// Generated by tsbindgen - Architecture
// Namespace: System.Security
// Assembly: System.Runtime.InteropServices, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, Hashtable, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { PermissionState } from "../../System.Security.Permissions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum PartialTrustVisibilityLevel {
    visibleToAllHosts = 0,
    notVisibleByDefault = 1
}


export enum SecurityCriticalScope {
    explicit = 0,
    everything = 1
}


export enum SecurityRuleSet {
    none = 0,
    level1 = 1,
    level2 = 2
}


export interface IPermission$instance {
    Copy(): IPermission;
    Demand(): void;
    FromXml(e: SecurityElement): void;
    Intersect(target: IPermission): IPermission;
    IsSubsetOf(target: IPermission): boolean;
    ToXml(): SecurityElement;
}


export type IPermission = IPermission$instance;

export interface ISecurityEncodable$instance {
    FromXml(e: SecurityElement): void;
    ToXml(): SecurityElement;
}


export type ISecurityEncodable = ISecurityEncodable$instance;

export interface IStackWalk$instance {
    Assert(): void;
}


export type IStackWalk = IStackWalk$instance;

export class AllowPartiallyTrustedCallersAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    partialTrustVisibilityLevel: PartialTrustVisibilityLevel;
}


export type AllowPartiallyTrustedCallersAttribute = AllowPartiallyTrustedCallersAttribute$instance;

export class PermissionSet$instance {
    constructor(state: PermissionState);
    constructor(permSet: PermissionSet);
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: any;
    addPermission(perm: IPermission): IPermission;
    assert(): void;
    containsNonCodeAccessPermissions(): boolean;
    copy(): PermissionSet;
    copyTo(array: ClrArray, index: int): void;
    demand(): void;
    deny(): void;
    equals(o: any): boolean;
    fromXml(et: SecurityElement): void;
    getEnumerator(): IEnumerator;
    getHashCode(): int;
    getPermission(permClass: Type): IPermission;
    intersect(other: PermissionSet): PermissionSet;
    isEmpty(): boolean;
    isSubsetOf(target: PermissionSet): boolean;
    isUnrestricted(): boolean;
    permitOnly(): void;
    removePermission(permClass: Type): IPermission;
    setPermission(perm: IPermission): IPermission;
    toString(): string;
    toXml(): SecurityElement;
    union(other: PermissionSet): PermissionSet;
    static ConvertPermissionSet(inFormat: string, inData: byte[], outFormat: string): byte[];
    static RevertAssert(): void;
}


export interface __PermissionSet$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISecurityEncodable: ISecurityEncodable$instance;
    readonly As_IStackWalk: IStackWalk$instance;
}

export type PermissionSet = PermissionSet$instance & __PermissionSet$views;


export class SecureString$instance {
    constructor();
    constructor(value: TSUnsafePointer<string>, length: int);
    readonly length: int;
    appendChar(c: string): void;
    clear(): void;
    copy(): SecureString;
    dispose(): void;
    insertAt(index: int, c: string): void;
    isReadOnly(): boolean;
    makeReadOnly(): void;
    removeAt(index: int): void;
    setAt(index: int, c: string): void;
}


export interface __SecureString$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SecureString = SecureString$instance & __SecureString$views;


export class SecurityCriticalAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(scope: SecurityCriticalScope);
    readonly scope: SecurityCriticalScope;
}


export type SecurityCriticalAttribute = SecurityCriticalAttribute$instance;

export class SecurityElement$instance {
    constructor(tag: string);
    constructor(tag: string, text: string);
    attributes: Hashtable;
    children: ArrayList;
    tag: string;
    text: string;
    addAttribute(name: string, value: string): void;
    addChild(child: SecurityElement): void;
    attribute(name: string): string;
    copy(): SecurityElement;
    equal(other: SecurityElement): boolean;
    searchForChildByTag(tag: string): SecurityElement;
    searchForTextOfTag(tag: string): string;
    toString(): string;
    static Escape(str: string): string;
    static FromString(xml: string): SecurityElement;
    static IsValidAttributeName(name: string): boolean;
    static IsValidAttributeValue(value: string): boolean;
    static IsValidTag(tag: string): boolean;
    static IsValidText(text: string): boolean;
}


export type SecurityElement = SecurityElement$instance;

export class SecurityException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, type_: Type);
    constructor(message: string, type_: Type, state: string);
    demanded: any;
    denySetInstance: any;
    failedAssemblyInfo: AssemblyName;
    grantedSet: string;
    method: MethodInfo;
    permissionState: string;
    permissionType: Type;
    permitOnlySetInstance: any;
    refusedSet: string;
    url: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __SecurityException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SecurityException = SecurityException$instance & __SecurityException$views;


export class SecurityRulesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(ruleSet: SecurityRuleSet);
    readonly ruleSet: SecurityRuleSet;
    skipVerificationInFullTrust: boolean;
}


export type SecurityRulesAttribute = SecurityRulesAttribute$instance;

export class SecuritySafeCriticalAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SecuritySafeCriticalAttribute = SecuritySafeCriticalAttribute$instance;

export class SecurityTransparentAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SecurityTransparentAttribute = SecurityTransparentAttribute$instance;

export class SecurityTreatAsSafeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SecurityTreatAsSafeAttribute = SecurityTreatAsSafeAttribute$instance;

export class SuppressUnmanagedCodeSecurityAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SuppressUnmanagedCodeSecurityAttribute = SuppressUnmanagedCodeSecurityAttribute$instance;

export class UnverifiableCodeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type UnverifiableCodeAttribute = UnverifiableCodeAttribute$instance;

export class VerificationException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __VerificationException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type VerificationException = VerificationException$instance & __VerificationException$views;


export abstract class SecureStringMarshal$instance {
    static SecureStringToCoTaskMemAnsi(s: SecureString): nint;
    static SecureStringToCoTaskMemUnicode(s: SecureString): nint;
    static SecureStringToGlobalAllocAnsi(s: SecureString): nint;
    static SecureStringToGlobalAllocUnicode(s: SecureString): nint;
}


export type SecureStringMarshal = SecureStringMarshal$instance;

