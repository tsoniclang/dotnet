// Generated by tsbindgen - Architecture
// Namespace: System.Security
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, Hashtable, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { PermissionState } from "../../System.Security.Permissions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum PartialTrustVisibilityLevel {
    VisibleToAllHosts = 0,
    NotVisibleByDefault = 1
}


export enum SecurityCriticalScope {
    Explicit = 0,
    Everything = 1
}


export enum SecurityRuleSet {
    None = 0,
    Level1 = 1,
    Level2 = 2
}


export interface IPermission$instance {
    Copy(): IPermission;
    Demand(): void;
    FromXml(e: SecurityElement): void;
    Intersect(target: IPermission): IPermission;
    IsSubsetOf(target: IPermission): boolean;
    ToXml(): SecurityElement;
}


export type IPermission = IPermission$instance;

export interface ISecurityEncodable$instance {
    FromXml(e: SecurityElement): void;
    ToXml(): SecurityElement;
}


export type ISecurityEncodable = ISecurityEncodable$instance;

export interface IStackWalk$instance {
    Assert(): void;
}


export type IStackWalk = IStackWalk$instance;

export class AllowPartiallyTrustedCallersAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    PartialTrustVisibilityLevel: PartialTrustVisibilityLevel;
}


export type AllowPartiallyTrustedCallersAttribute = AllowPartiallyTrustedCallersAttribute$instance;

export class PermissionSet$instance {
    constructor(state: PermissionState);
    constructor(permSet: PermissionSet);
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: any;
    AddPermission(perm: IPermission): IPermission;
    Assert(): void;
    ContainsNonCodeAccessPermissions(): boolean;
    Copy(): PermissionSet;
    CopyTo(array: ClrArray, index: int): void;
    Demand(): void;
    Deny(): void;
    Equals(o: any): boolean;
    FromXml(et: SecurityElement): void;
    GetEnumerator(): IEnumerator;
    GetHashCode(): int;
    GetPermission(permClass: Type): IPermission;
    Intersect(other: PermissionSet): PermissionSet;
    IsEmpty(): boolean;
    IsSubsetOf(target: PermissionSet): boolean;
    IsUnrestricted(): boolean;
    PermitOnly(): void;
    RemovePermission(permClass: Type): IPermission;
    SetPermission(perm: IPermission): IPermission;
    ToString(): string;
    ToXml(): SecurityElement;
    Union(other: PermissionSet): PermissionSet;
    static ConvertPermissionSet(inFormat: string, inData: byte[], outFormat: string): byte[];
    static RevertAssert(): void;
}


export interface __PermissionSet$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISecurityEncodable: ISecurityEncodable$instance;
    readonly As_IStackWalk: IStackWalk$instance;
}

export type PermissionSet = PermissionSet$instance & __PermissionSet$views;


export class SecureString$instance {
    constructor();
    constructor(value: TSUnsafePointer<string>, length: int);
    readonly Length: int;
    AppendChar(c: string): void;
    Clear(): void;
    Copy(): SecureString;
    Dispose(): void;
    InsertAt(index: int, c: string): void;
    IsReadOnly(): boolean;
    MakeReadOnly(): void;
    RemoveAt(index: int): void;
    SetAt(index: int, c: string): void;
}


export interface __SecureString$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SecureString = SecureString$instance & __SecureString$views;


export class SecurityCriticalAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(scope: SecurityCriticalScope);
    readonly Scope: SecurityCriticalScope;
}


export type SecurityCriticalAttribute = SecurityCriticalAttribute$instance;

export class SecurityElement$instance {
    constructor(tag: string);
    constructor(tag: string, text: string);
    Attributes: Hashtable;
    Children: ArrayList;
    Tag: string;
    Text: string;
    AddAttribute(name: string, value: string): void;
    AddChild(child: SecurityElement): void;
    Attribute(name: string): string;
    Copy(): SecurityElement;
    Equal(other: SecurityElement): boolean;
    SearchForChildByTag(tag: string): SecurityElement;
    SearchForTextOfTag(tag: string): string;
    ToString(): string;
    static Escape(str: string): string;
    static FromString(xml: string): SecurityElement;
    static IsValidAttributeName(name: string): boolean;
    static IsValidAttributeValue(value: string): boolean;
    static IsValidTag(tag: string): boolean;
    static IsValidText(text: string): boolean;
}


export type SecurityElement = SecurityElement$instance;

export class SecurityException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, type_: Type);
    constructor(message: string, type_: Type, state: string);
    Demanded: any;
    DenySetInstance: any;
    FailedAssemblyInfo: AssemblyName;
    GrantedSet: string;
    Method: MethodInfo;
    PermissionState: string;
    PermissionType: Type;
    PermitOnlySetInstance: any;
    RefusedSet: string;
    Url: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export interface __SecurityException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SecurityException = SecurityException$instance & __SecurityException$views;


export class SecurityRulesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(ruleSet: SecurityRuleSet);
    readonly RuleSet: SecurityRuleSet;
    SkipVerificationInFullTrust: boolean;
}


export type SecurityRulesAttribute = SecurityRulesAttribute$instance;

export class SecuritySafeCriticalAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SecuritySafeCriticalAttribute = SecuritySafeCriticalAttribute$instance;

export class SecurityTransparentAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SecurityTransparentAttribute = SecurityTransparentAttribute$instance;

export class SecurityTreatAsSafeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SecurityTreatAsSafeAttribute = SecurityTreatAsSafeAttribute$instance;

export class SuppressUnmanagedCodeSecurityAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SuppressUnmanagedCodeSecurityAttribute = SuppressUnmanagedCodeSecurityAttribute$instance;

export class UnverifiableCodeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type UnverifiableCodeAttribute = UnverifiableCodeAttribute$instance;

export class VerificationException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __VerificationException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type VerificationException = VerificationException$instance & __VerificationException$views;


export abstract class SecureStringMarshal$instance {
    static SecureStringToCoTaskMemAnsi(s: SecureString): nint;
    static SecureStringToCoTaskMemUnicode(s: SecureString): nint;
    static SecureStringToGlobalAllocAnsi(s: SecureString): nint;
    static SecureStringToGlobalAllocUnicode(s: SecureString): nint;
}


export type SecureStringMarshal = SecureStringMarshal$instance;

