// Generated by tsbindgen - Architecture
// Namespace: System.Text
// Assembly: System.Memory, System.Private.CoreLib, System.Text.Encoding.CodePages

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IBufferWriter_1, OperationStatus, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CultureInfo, UnicodeCategory } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, Decimal, Double, Enum, Exception, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, IUtf8SpanFormattable, IUtf8SpanParsable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum NormalizationForm {
    formC = 1,
    formD = 2,
    formKC = 5,
    formKD = 6
}


export class Rune$instance {
    constructor(ch: string);
    constructor(highSurrogate: string, lowSurrogate: string);
    constructor(value: int);
    constructor(value: uint);
    readonly isAscii: boolean;
    readonly isBmp: boolean;
    readonly plane: int;
    readonly utf16SequenceLength: int;
    readonly utf8SequenceLength: int;
    readonly value: int;
    compareTo(other: Rune): int;
    encodeToUtf16(destination: Span_1<CLROf<string>>): int;
    encodeToUtf8(destination: Span_1<CLROf<byte>>): int;
    equals(obj: any): boolean;
    equals(other: Rune): boolean;
    getHashCode(): int;
    toString(): string;
    tryEncodeToUtf16(destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    tryEncodeToUtf8(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static readonly ReplacementChar: Rune;
    static DecodeFromUtf16(source: ReadOnlySpan_1<CLROf<string>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    static DecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    static DecodeLastFromUtf16(source: ReadOnlySpan_1<CLROf<string>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    static DecodeLastFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    static GetNumericValue(value: Rune): double;
    static GetRuneAt(input: string, index: int): Rune;
    static GetUnicodeCategory(value: Rune): UnicodeCategory;
    static IsControl(value: Rune): boolean;
    static IsDigit(value: Rune): boolean;
    static IsLetter(value: Rune): boolean;
    static IsLetterOrDigit(value: Rune): boolean;
    static IsLower(value: Rune): boolean;
    static IsNumber(value: Rune): boolean;
    static IsPunctuation(value: Rune): boolean;
    static IsSeparator(value: Rune): boolean;
    static IsSymbol(value: Rune): boolean;
    static IsUpper(value: Rune): boolean;
    static IsValid(value: int): boolean;
    static IsValid(value: uint): boolean;
    static IsWhiteSpace(value: Rune): boolean;
    static ToLower(value: Rune, culture: CultureInfo): Rune;
    static ToLowerInvariant(value: Rune): Rune;
    static ToUpper(value: Rune, culture: CultureInfo): Rune;
    static ToUpperInvariant(value: Rune): Rune;
    static TryCreate(highSurrogate: string, lowSurrogate: string, result: { value: ref<Rune> }): boolean;
    static TryCreate(ch: string, result: { value: ref<Rune> }): boolean;
    static TryCreate(value: int, result: { value: ref<Rune> }): boolean;
    static TryCreate(value: uint, result: { value: ref<Rune> }): boolean;
    static TryGetRuneAt(input: string, index: int, value: { value: ref<Rune> }): boolean;
}


export interface __Rune$views {
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IComparable_1_of_Decimal: System_Internal.IComparable_1$instance<Rune>;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<Rune>;
    readonly As_IFormattable: System_Internal.IFormattable$instance;
    readonly As_ISpanFormattable: System_Internal.ISpanFormattable$instance;
    readonly As_IUtf8SpanFormattable: System_Internal.IUtf8SpanFormattable$instance;
    readonly As_IUtf8SpanParsable_1_of_Decimal: System_Internal.IUtf8SpanParsable_1$instance<any>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rune): boolean;
    CompareTo(obj: any): int;
}

export type Rune = Rune$instance & __Rune$views;


export class SpanLineEnumerator$instance {
    readonly current: ReadOnlySpan_1<CLROf<string>>;
    getEnumerator(): SpanLineEnumerator;
    moveNext(): boolean;
}


export interface __SpanLineEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<ReadOnlySpan_1<CLROf<string>>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SpanLineEnumerator = SpanLineEnumerator$instance & __SpanLineEnumerator$views;


export class SpanRuneEnumerator$instance {
    readonly current: Rune;
    getEnumerator(): SpanRuneEnumerator;
    moveNext(): boolean;
}


export interface __SpanRuneEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SpanRuneEnumerator = SpanRuneEnumerator$instance & __SpanRuneEnumerator$views;


export class StringBuilder_AppendInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, stringBuilder: StringBuilder);
    constructor(literalLength: int, formattedCount: int, stringBuilder: StringBuilder, provider: IFormatProvider);
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<string>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<string>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: any, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
}


export type StringBuilder_AppendInterpolatedStringHandler = StringBuilder_AppendInterpolatedStringHandler$instance;

export class StringBuilder_ChunkEnumerator$instance {
    readonly current: ReadOnlyMemory_1<CLROf<string>>;
    getEnumerator(): StringBuilder_ChunkEnumerator;
    moveNext(): boolean;
}


export type StringBuilder_ChunkEnumerator = StringBuilder_ChunkEnumerator$instance;

export class StringRuneEnumerator$instance {
    readonly current: Rune;
    getEnumerator(): StringRuneEnumerator;
    moveNext(): boolean;
}


export interface __StringRuneEnumerator$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<Rune>;
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type StringRuneEnumerator = StringRuneEnumerator$instance & __StringRuneEnumerator$views;


export class ASCIIEncoding$instance extends Encoding$instance {
    constructor();
    readonly isSingleByte: boolean;
    clone(): any;
    getByteCount(chars: string[], index: int, count: int): int;
    getByteCount(chars: string): int;
    getByteCount(chars: ptr<string>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getByteCount(chars: string[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getBytes(chars: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getBytes(chars: string[]): byte[];
    getBytes(chars: string[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getChars(bytes: byte[]): string[];
    getChars(bytes: byte[], index: int, count: int): string[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getString(bytes: byte[], byteIndex: int, byteCount: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
}


export interface __ASCIIEncoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ASCIIEncoding = ASCIIEncoding$instance & __ASCIIEncoding$views;


export class CodePagesEncodingProvider$instance extends EncodingProvider$instance {
    getEncoding(codepage: int): Encoding;
    getEncoding(name: string): Encoding;
    getEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncodings(): IEnumerable_1<EncodingInfo>;
    getEncodings(): IEnumerable_1<EncodingInfo>;
    static readonly Instance: EncodingProvider;
}


export type CodePagesEncodingProvider = CodePagesEncodingProvider$instance;

export class CompositeFormat$instance {
    readonly format: string;
    readonly minimumArgumentCount: int;
    static Parse(format: string): CompositeFormat;
}


export type CompositeFormat = CompositeFormat$instance;

export abstract class Decoder$instance {
    fallback: DecoderFallback;
    readonly fallbackBuffer: DecoderFallbackBuffer;
    convert(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: byte[], index: int, count: int, flush: boolean): int;
    getCharCount(bytes: ptr<byte>, count: int, flush: boolean): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>, flush: boolean): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int, flush: boolean): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int, flush: boolean): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, flush: boolean): int;
    reset(): void;
}


export type Decoder = Decoder$instance;

export class DecoderExceptionFallback$instance extends DecoderFallback$instance {
    constructor();
    readonly maxCharCount: int;
    createFallbackBuffer(): DecoderFallbackBuffer;
    equals(value: any): boolean;
    getHashCode(): int;
}


export type DecoderExceptionFallback = DecoderExceptionFallback$instance;

export class DecoderExceptionFallbackBuffer$instance extends DecoderFallbackBuffer$instance {
    constructor();
    readonly remaining: int;
    fallback(bytesUnknown: byte[], index: int): boolean;
    getNextChar(): string;
    movePrevious(): boolean;
}


export type DecoderExceptionFallbackBuffer = DecoderExceptionFallbackBuffer$instance;

export abstract class DecoderFallback$instance {
    readonly maxCharCount: int;
    abstract createFallbackBuffer(): DecoderFallbackBuffer;
    static readonly ReplacementFallback: DecoderFallback;
    static readonly ExceptionFallback: DecoderFallback;
}


export type DecoderFallback = DecoderFallback$instance;

export abstract class DecoderFallbackBuffer$instance {
    readonly remaining: int;
    abstract fallback(bytesUnknown: byte[], index: int): boolean;
    abstract getNextChar(): string;
    abstract movePrevious(): boolean;
    reset(): void;
}


export type DecoderFallbackBuffer = DecoderFallbackBuffer$instance;

export class DecoderFallbackException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, bytesUnknown: byte[], index: int);
    readonly bytesUnknown: byte[];
    readonly index: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DecoderFallbackException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DecoderFallbackException = DecoderFallbackException$instance & __DecoderFallbackException$views;


export class DecoderReplacementFallback$instance extends DecoderFallback$instance {
    constructor();
    constructor(replacement: string);
    readonly defaultString: string;
    readonly maxCharCount: int;
    createFallbackBuffer(): DecoderFallbackBuffer;
    equals(value: any): boolean;
    getHashCode(): int;
}


export type DecoderReplacementFallback = DecoderReplacementFallback$instance;

export class DecoderReplacementFallbackBuffer$instance extends DecoderFallbackBuffer$instance {
    constructor(fallback: DecoderReplacementFallback);
    readonly remaining: int;
    fallback(bytesUnknown: byte[], index: int): boolean;
    getNextChar(): string;
    movePrevious(): boolean;
    reset(): void;
}


export type DecoderReplacementFallbackBuffer = DecoderReplacementFallbackBuffer$instance;

export abstract class Encoder$instance {
    fallback: EncoderFallback;
    readonly fallbackBuffer: EncoderFallbackBuffer;
    convert(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    getByteCount(chars: string[], index: int, count: int, flush: boolean): int;
    getByteCount(chars: ptr<string>, count: int, flush: boolean): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>, flush: boolean): int;
    getBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, flush: boolean): int;
    getBytes(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, flush: boolean): int;
    reset(): void;
}


export type Encoder = Encoder$instance;

export class EncoderExceptionFallback$instance extends EncoderFallback$instance {
    constructor();
    readonly maxCharCount: int;
    createFallbackBuffer(): EncoderFallbackBuffer;
    equals(value: any): boolean;
    getHashCode(): int;
}


export type EncoderExceptionFallback = EncoderExceptionFallback$instance;

export class EncoderExceptionFallbackBuffer$instance extends EncoderFallbackBuffer$instance {
    constructor();
    readonly remaining: int;
    fallback(charUnknown: string, index: int): boolean;
    fallback(charUnknownHigh: string, charUnknownLow: string, index: int): boolean;
    getNextChar(): string;
    movePrevious(): boolean;
}


export type EncoderExceptionFallbackBuffer = EncoderExceptionFallbackBuffer$instance;

export abstract class EncoderFallback$instance {
    readonly maxCharCount: int;
    abstract createFallbackBuffer(): EncoderFallbackBuffer;
    static readonly ReplacementFallback: EncoderFallback;
    static readonly ExceptionFallback: EncoderFallback;
}


export type EncoderFallback = EncoderFallback$instance;

export abstract class EncoderFallbackBuffer$instance {
    readonly remaining: int;
    abstract fallback(charUnknown: string, index: int): boolean;
    abstract fallback(charUnknownHigh: string, charUnknownLow: string, index: int): boolean;
    abstract getNextChar(): string;
    abstract movePrevious(): boolean;
    reset(): void;
}


export type EncoderFallbackBuffer = EncoderFallbackBuffer$instance;

export class EncoderFallbackException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly charUnknown: string;
    readonly charUnknownHigh: string;
    readonly charUnknownLow: string;
    readonly index: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    isUnknownSurrogate(): boolean;
}


export interface __EncoderFallbackException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EncoderFallbackException = EncoderFallbackException$instance & __EncoderFallbackException$views;


export class EncoderReplacementFallback$instance extends EncoderFallback$instance {
    constructor();
    constructor(replacement: string);
    readonly defaultString: string;
    readonly maxCharCount: int;
    createFallbackBuffer(): EncoderFallbackBuffer;
    equals(value: any): boolean;
    getHashCode(): int;
}


export type EncoderReplacementFallback = EncoderReplacementFallback$instance;

export class EncoderReplacementFallbackBuffer$instance extends EncoderFallbackBuffer$instance {
    constructor(fallback: EncoderReplacementFallback);
    readonly remaining: int;
    fallback(charUnknown: string, index: int): boolean;
    fallback(charUnknownHigh: string, charUnknownLow: string, index: int): boolean;
    getNextChar(): string;
    movePrevious(): boolean;
    reset(): void;
}


export type EncoderReplacementFallbackBuffer = EncoderReplacementFallbackBuffer$instance;

export abstract class Encoding$instance {
    readonly bodyName: string;
    readonly codePage: int;
    decoderFallback: DecoderFallback;
    encoderFallback: EncoderFallback;
    readonly encodingName: string;
    readonly headerName: string;
    readonly isBrowserDisplay: boolean;
    readonly isBrowserSave: boolean;
    readonly isMailNewsDisplay: boolean;
    readonly isMailNewsSave: boolean;
    readonly isReadOnly: boolean;
    readonly isSingleByte: boolean;
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    readonly webName: string;
    readonly windowsCodePage: int;
    clone(): any;
    equals(value: any): boolean;
    getByteCount(chars: string[]): int;
    getByteCount(s: string): int;
    getByteCount(chars: string[], index: int, count: int): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ptr<string>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getBytes(chars: string[]): byte[];
    getBytes(chars: string[], index: int, count: int): byte[];
    getBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[]): string[];
    getChars(bytes: byte[], index: int, count: int): string[];
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    abstract getMaxByteCount(charCount: int): int;
    abstract getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    getString(bytes: byte[], index: int, count: int): string;
    isAlwaysNormalized(): boolean;
    isAlwaysNormalized(form: NormalizationForm): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    static readonly Default: Encoding;
    static readonly ASCII: Encoding;
    static readonly Latin1: Encoding;
    static readonly Unicode: Encoding;
    static readonly BigEndianUnicode: Encoding;
    static readonly UTF7: Encoding;
    static readonly UTF8: Encoding;
    static readonly UTF32: Encoding;
    static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[], index: int, count: int): byte[];
    static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[]): byte[];
    static CreateTranscodingStream(innerStream: Stream, innerStreamEncoding: Encoding, outerStreamEncoding: Encoding, leaveOpen?: boolean): Stream;
    static GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    static GetEncoding(codepage: int): Encoding;
    static GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    static GetEncoding(name: string): Encoding;
    static GetEncodings(): EncodingInfo[];
    static RegisterProvider(provider: EncodingProvider): void;
}


export interface __Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type Encoding = Encoding$instance & __Encoding$views;


export class EncodingInfo$instance {
    constructor(provider: EncodingProvider, codePage: int, name: string, displayName: string);
    readonly codePage: int;
    readonly displayName: string;
    readonly name: string;
    equals(value: any): boolean;
    getEncoding(): Encoding;
    getHashCode(): int;
}


export type EncodingInfo = EncodingInfo$instance;

export abstract class EncodingProvider$instance {
    constructor();
    getEncoding(name: string): Encoding;
    getEncoding(codepage: int): Encoding;
    getEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncodings(): IEnumerable_1<EncodingInfo>;
}


export type EncodingProvider = EncodingProvider$instance;

export class StringBuilder$instance {
    constructor();
    constructor(capacity: int);
    constructor(value: string);
    constructor(value: string, capacity: int);
    constructor(value: string, startIndex: int, length: int, capacity: int);
    constructor(capacity: int, maxCapacity: int);
    capacity: int;
    chars: string;
    length: int;
    readonly maxCapacity: int;
    append(value: string, repeatCount: int): StringBuilder;
    append(value: string[], startIndex: int, charCount: int): StringBuilder;
    append(value: string): StringBuilder;
    append(value: string, startIndex: int, count: int): StringBuilder;
    append(value: StringBuilder): StringBuilder;
    append(value: StringBuilder, startIndex: int, count: int): StringBuilder;
    append(value: boolean): StringBuilder;
    append(value: string): StringBuilder;
    append(value: sbyte): StringBuilder;
    append(value: byte): StringBuilder;
    append(value: short): StringBuilder;
    append(value: int): StringBuilder;
    append(value: long): StringBuilder;
    append(value: float): StringBuilder;
    append(value: double): StringBuilder;
    append(value: decimal): StringBuilder;
    append(value: ushort): StringBuilder;
    append(value: uint): StringBuilder;
    append(value: ulong): StringBuilder;
    append(value: any): StringBuilder;
    append(value: string[]): StringBuilder;
    append(value: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    append(value: ReadOnlyMemory_1<CLROf<string>>): StringBuilder;
    append(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    append(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    append(value: ptr<string>, valueCount: int): StringBuilder;
    appendFormat(format: string, arg0: any): StringBuilder;
    appendFormat(format: string, arg0: any, arg1: any): StringBuilder;
    appendFormat(format: string, arg0: any, arg1: any, arg2: any): StringBuilder;
    appendFormat(format: string, args: any[]): StringBuilder;
    appendFormat(format: string, args: ReadOnlySpan_1<any>): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: any): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: any, arg1: any): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: any, arg1: any, arg2: any): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, args: any[]): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, args: ReadOnlySpan_1<any>): StringBuilder;
    appendFormat<TArg0>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0): StringBuilder;
    appendFormat<TArg0, TArg1>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1): StringBuilder;
    appendFormat<TArg0, TArg1, TArg2>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): StringBuilder;
    appendFormat(provider: IFormatProvider, format: CompositeFormat, args: any[]): StringBuilder;
    appendFormat(provider: IFormatProvider, format: CompositeFormat, args: ReadOnlySpan_1<any>): StringBuilder;
    appendJoin(separator: string, values: any[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<any>): StringBuilder;
    appendJoin<T>(separator: string, values: IEnumerable_1<T>): StringBuilder;
    appendJoin(separator: string, values: string[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    appendJoin(separator: string, values: any[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<any>): StringBuilder;
    appendJoin<T>(separator: string, values: IEnumerable_1<T>): StringBuilder;
    appendJoin(separator: string, values: string[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    appendLine(): StringBuilder;
    appendLine(value: string): StringBuilder;
    appendLine(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    appendLine(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    clear(): StringBuilder;
    copyTo(sourceIndex: int, destination: string[], destinationIndex: int, count: int): void;
    copyTo(sourceIndex: int, destination: Span_1<CLROf<string>>, count: int): void;
    ensureCapacity(capacity: int): int;
    equals(sb: StringBuilder): boolean;
    equals(span: ReadOnlySpan_1<CLROf<string>>): boolean;
    getChunks(): StringBuilder_ChunkEnumerator;
    insert(index: int, value: string, count: int): StringBuilder;
    insert(index: int, value: string): StringBuilder;
    insert(index: int, value: boolean): StringBuilder;
    insert(index: int, value: sbyte): StringBuilder;
    insert(index: int, value: byte): StringBuilder;
    insert(index: int, value: short): StringBuilder;
    insert(index: int, value: string): StringBuilder;
    insert(index: int, value: string[]): StringBuilder;
    insert(index: int, value: string[], startIndex: int, charCount: int): StringBuilder;
    insert(index: int, value: int): StringBuilder;
    insert(index: int, value: long): StringBuilder;
    insert(index: int, value: float): StringBuilder;
    insert(index: int, value: double): StringBuilder;
    insert(index: int, value: decimal): StringBuilder;
    insert(index: int, value: ushort): StringBuilder;
    insert(index: int, value: uint): StringBuilder;
    insert(index: int, value: ulong): StringBuilder;
    insert(index: int, value: any): StringBuilder;
    insert(index: int, value: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    remove(startIndex: int, length: int): StringBuilder;
    replace(oldValue: string, newValue: string): StringBuilder;
    replace(oldValue: ReadOnlySpan_1<CLROf<string>>, newValue: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    replace(oldValue: string, newValue: string, startIndex: int, count: int): StringBuilder;
    replace(oldValue: ReadOnlySpan_1<CLROf<string>>, newValue: ReadOnlySpan_1<CLROf<string>>, startIndex: int, count: int): StringBuilder;
    replace(oldChar: string, newChar: string): StringBuilder;
    replace(oldChar: string, newChar: string, startIndex: int, count: int): StringBuilder;
    toString(): string;
    toString(startIndex: int, length: int): string;
}


export interface __StringBuilder$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StringBuilder = StringBuilder$instance & __StringBuilder$views;


export class UnicodeEncoding$instance extends Encoding$instance {
    constructor();
    constructor(bigEndian: boolean, byteOrderMark: boolean);
    constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidBytes: boolean);
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): any;
    equals(value: any): boolean;
    getByteCount(chars: string[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<string>, count: int): int;
    getByteCount(chars: string[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: string[]): byte[];
    getBytes(chars: string[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int): int;
    getChars(bytes: byte[]): string[];
    getChars(bytes: byte[], index: int, count: int): string[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    static readonly CharSize: int;
}


export interface __UnicodeEncoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UnicodeEncoding = UnicodeEncoding$instance & __UnicodeEncoding$views;


export class UTF32Encoding$instance extends Encoding$instance {
    constructor();
    constructor(bigEndian: boolean, byteOrderMark: boolean);
    constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidCharacters: boolean);
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): any;
    equals(value: any): boolean;
    getByteCount(chars: string[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<string>, count: int): int;
    getByteCount(chars: string[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: string[]): byte[];
    getBytes(chars: string[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int): int;
    getChars(bytes: byte[]): string[];
    getChars(bytes: byte[], index: int, count: int): string[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
}


export interface __UTF32Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UTF32Encoding = UTF32Encoding$instance & __UTF32Encoding$views;


export class UTF7Encoding$instance extends Encoding$instance {
    constructor();
    constructor(allowOptionals: boolean);
    clone(): any;
    equals(value: any): boolean;
    getByteCount(chars: string[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<string>, count: int): int;
    getByteCount(chars: string[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: string[]): byte[];
    getBytes(chars: string[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int): int;
    getChars(bytes: byte[]): string[];
    getChars(bytes: byte[], index: int, count: int): string[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
}


export interface __UTF7Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UTF7Encoding = UTF7Encoding$instance & __UTF7Encoding$views;


export class UTF8Encoding$instance extends Encoding$instance {
    constructor();
    constructor(encoderShouldEmitUTF8Identifier: boolean);
    constructor(encoderShouldEmitUTF8Identifier: boolean, throwOnInvalidBytes: boolean);
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): any;
    equals(value: any): boolean;
    getByteCount(chars: string[], index: int, count: int): int;
    getByteCount(chars: string): int;
    getByteCount(chars: ptr<string>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getByteCount(chars: string[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<string>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getBytes(chars: string[]): byte[];
    getBytes(chars: string[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<string>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getChars(bytes: byte[]): string[];
    getChars(bytes: byte[], index: int, count: int): string[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
}


export interface __UTF8Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UTF8Encoding = UTF8Encoding$instance & __UTF8Encoding$views;


export abstract class Ascii$instance {
    static Equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static FromUtf16(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static IsValid(value: byte): boolean;
    static IsValid(value: string): boolean;
    static IsValid(value: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static IsValid(value: ReadOnlySpan_1<CLROf<string>>): boolean;
    static ToLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToLowerInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToLowerInPlace(value: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUpperInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToUpperInPlace(value: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUtf16(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): OperationStatus;
    static Trim(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static Trim(value: ReadOnlySpan_1<CLROf<string>>): Range;
    static TrimEnd(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static TrimEnd(value: ReadOnlySpan_1<CLROf<string>>): Range;
    static TrimStart(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static TrimStart(value: ReadOnlySpan_1<CLROf<string>>): Range;
}


export type Ascii = Ascii$instance;

export abstract class EncodingExtensions$instance {
    static Convert(decoder: Decoder, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<string>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static Convert(decoder: Decoder, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<string>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static Convert(encoder: Encoder, chars: { value: ref<ReadOnlySequence_1<CLROf<string>>> }, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static Convert(encoder: Encoder, chars: ReadOnlySpan_1<CLROf<string>>, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static GetBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<string>>> }, writer: IBufferWriter_1<CLROf<byte>>): long;
    static GetBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<string>>> }, bytes: Span_1<CLROf<byte>>): int;
    static GetBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<string>>> }): byte[];
    static GetBytes(encoding: Encoding, chars: ReadOnlySpan_1<CLROf<string>>, writer: IBufferWriter_1<CLROf<byte>>): long;
    static GetChars(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<string>>): long;
    static GetChars(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, chars: Span_1<CLROf<string>>): int;
    static GetChars(encoding: Encoding, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<string>>): long;
    static GetString(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }): string;
}


export type EncodingExtensions = EncodingExtensions$instance;

