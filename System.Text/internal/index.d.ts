// Generated by tsbindgen - Architecture
// Namespace: System.Text
// Assembly: System.Memory, System.Private.CoreLib, System.Text.Encoding.CodePages

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IBufferWriter_1, OperationStatus, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CultureInfo, UnicodeCategory } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, Decimal, Double, Enum, Exception, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, IUtf8SpanFormattable, IUtf8SpanParsable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum NormalizationForm {
    formC = 1,
    formD = 2,
    formKC = 5,
    formKD = 6
}


export class Rune$instance {
    constructor(ch: char);
    constructor(highSurrogate: char, lowSurrogate: char);
    constructor(value: int);
    constructor(value: uint);
    readonly isAscii: boolean;
    readonly isBmp: boolean;
    readonly plane: int;
    readonly utf16SequenceLength: int;
    readonly utf8SequenceLength: int;
    readonly value: int;
    compareTo(other: Rune): int;
    encodeToUtf16(destination: Span_1<CLROf<char>>): int;
    encodeToUtf8(destination: Span_1<CLROf<byte>>): int;
    equals(obj: unknown): boolean;
    equals(other: Rune): boolean;
    getHashCode(): int;
    toString(): string;
    tryEncodeToUtf16(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryEncodeToUtf8(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static readonly replacementChar: Rune;
    static decodeFromUtf16(source: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    static decodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    static decodeLastFromUtf16(source: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    static decodeLastFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    static getNumericValue(value: Rune): double;
    static getRuneAt(input: string, index: int): Rune;
    static getUnicodeCategory(value: Rune): UnicodeCategory;
    static isControl(value: Rune): boolean;
    static isDigit(value: Rune): boolean;
    static isLetter(value: Rune): boolean;
    static isLetterOrDigit(value: Rune): boolean;
    static isLower(value: Rune): boolean;
    static isNumber(value: Rune): boolean;
    static isPunctuation(value: Rune): boolean;
    static isSeparator(value: Rune): boolean;
    static isSymbol(value: Rune): boolean;
    static isUpper(value: Rune): boolean;
    static isValid(value: int): boolean;
    static isValid(value: uint): boolean;
    static isWhiteSpace(value: Rune): boolean;
    static toLower(value: Rune, culture: CultureInfo): Rune;
    static toLowerInvariant(value: Rune): Rune;
    static toUpper(value: Rune, culture: CultureInfo): Rune;
    static toUpperInvariant(value: Rune): Rune;
    static tryCreate2(highSurrogate: char, lowSurrogate: char, result: { value: ref<Rune> }): boolean;
    static tryCreate2(ch: char, result: { value: ref<Rune> }): boolean;
    static tryCreate2(value: int, result: { value: ref<Rune> }): boolean;
    static tryCreate2(value: uint, result: { value: ref<Rune> }): boolean;
    static tryGetRuneAt(input: string, index: int, value: { value: ref<Rune> }): boolean;
}


export interface __Rune$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<Rune>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Rune>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<Rune>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rune): boolean;
    CompareTo(obj: unknown): int;
}

export interface Rune$instance extends System_Internal.IComparable_1$instance<Rune>, System_Internal.IUtf8SpanFormattable$instance, System_Internal.IUtf8SpanParsable_1$instance<Rune> {}

export type Rune = Rune$instance & __Rune$views;


export class SpanLineEnumerator$instance {
    readonly current: ReadOnlySpan_1<CLROf<char>>;
    getEnumerator(): SpanLineEnumerator;
    moveNext(): boolean;
}


export interface __SpanLineEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ReadOnlySpan_1<CLROf<char>>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SpanLineEnumerator = SpanLineEnumerator$instance & __SpanLineEnumerator$views;


export class SpanRuneEnumerator$instance {
    readonly current: Rune;
    getEnumerator(): SpanRuneEnumerator;
    moveNext(): boolean;
}


export interface __SpanRuneEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SpanRuneEnumerator = SpanRuneEnumerator$instance & __SpanRuneEnumerator$views;


export class StringBuilder_AppendInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, stringBuilder: StringBuilder);
    constructor(literalLength: int, formattedCount: int, stringBuilder: StringBuilder, provider: IFormatProvider);
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: unknown, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
}


export type StringBuilder_AppendInterpolatedStringHandler = StringBuilder_AppendInterpolatedStringHandler$instance;

export class StringBuilder_ChunkEnumerator$instance {
    readonly current: ReadOnlyMemory_1<CLROf<char>>;
    getEnumerator(): StringBuilder_ChunkEnumerator;
    moveNext(): boolean;
}


export type StringBuilder_ChunkEnumerator = StringBuilder_ChunkEnumerator$instance;

export class StringRuneEnumerator$instance {
    readonly current: Rune;
    getEnumerator(): StringRuneEnumerator;
    moveNext(): boolean;
}


export interface __StringRuneEnumerator$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Rune>;
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringRuneEnumerator = StringRuneEnumerator$instance & __StringRuneEnumerator$views;


export class ASCIIEncoding$instance extends Encoding$instance {
    constructor();
    readonly isSingleByte: boolean;
    clone(): unknown;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(chars: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(chars: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getString(bytes: byte[], byteIndex: int, byteCount: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export interface __ASCIIEncoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type ASCIIEncoding = ASCIIEncoding$instance & __ASCIIEncoding$views;


export class CodePagesEncodingProvider$instance extends EncodingProvider$instance {
    getEncoding(codepage: int): Encoding;
    getEncoding(name: string): Encoding;
    getEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncodings(): IEnumerable_1<EncodingInfo>;
    getEncodings(): IEnumerable_1<EncodingInfo>;
    static readonly instance: EncodingProvider;
}


export type CodePagesEncodingProvider = CodePagesEncodingProvider$instance;

export class CompositeFormat$instance {
    readonly format: string;
    readonly minimumArgumentCount: int;
    static parse(format: string): CompositeFormat;
}


export type CompositeFormat = CompositeFormat$instance;

export abstract class Decoder$instance {
    fallback: DecoderFallback;
    readonly fallbackBuffer: DecoderFallbackBuffer;
    convert(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: byte[], index: int, count: int, flush: boolean): int;
    getCharCount(bytes: ptr<byte>, count: int, flush: boolean): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>, flush: boolean): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int, flush: boolean): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int, flush: boolean): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, flush: boolean): int;
    reset(): void;
}


export type Decoder = Decoder$instance;

export class DecoderExceptionFallback$instance extends DecoderFallback$instance {
    constructor();
    readonly maxCharCount: int;
    createFallbackBuffer(): DecoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export type DecoderExceptionFallback = DecoderExceptionFallback$instance;

export class DecoderExceptionFallbackBuffer$instance extends DecoderFallbackBuffer$instance {
    constructor();
    readonly remaining: int;
    fallback(bytesUnknown: byte[], index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
}


export type DecoderExceptionFallbackBuffer = DecoderExceptionFallbackBuffer$instance;

export abstract class DecoderFallback$instance {
    readonly maxCharCount: int;
    abstract createFallbackBuffer(): DecoderFallbackBuffer;
    static readonly replacementFallback: DecoderFallback;
    static readonly exceptionFallback: DecoderFallback;
}


export type DecoderFallback = DecoderFallback$instance;

export abstract class DecoderFallbackBuffer$instance {
    readonly remaining: int;
    abstract fallback(bytesUnknown: byte[], index: int): boolean;
    abstract getNextChar(): char;
    abstract movePrevious(): boolean;
    reset(): void;
}


export type DecoderFallbackBuffer = DecoderFallbackBuffer$instance;

export class DecoderFallbackException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, bytesUnknown: byte[], index: int);
    readonly bytesUnknown: byte[];
    readonly index: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DecoderFallbackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DecoderFallbackException = DecoderFallbackException$instance & __DecoderFallbackException$views;


export class DecoderReplacementFallback$instance extends DecoderFallback$instance {
    constructor();
    constructor(replacement: string);
    readonly defaultString: string;
    readonly maxCharCount: int;
    createFallbackBuffer(): DecoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export type DecoderReplacementFallback = DecoderReplacementFallback$instance;

export class DecoderReplacementFallbackBuffer$instance extends DecoderFallbackBuffer$instance {
    constructor(fallback: DecoderReplacementFallback);
    readonly remaining: int;
    fallback(bytesUnknown: byte[], index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
    reset(): void;
}


export type DecoderReplacementFallbackBuffer = DecoderReplacementFallbackBuffer$instance;

export abstract class Encoder$instance {
    fallback: EncoderFallback;
    readonly fallbackBuffer: EncoderFallbackBuffer;
    convert(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    convert(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    getByteCount(chars: char[], index: int, count: int, flush: boolean): int;
    getByteCount(chars: ptr<char>, count: int, flush: boolean): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>, flush: boolean): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, flush: boolean): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, flush: boolean): int;
    reset(): void;
}


export type Encoder = Encoder$instance;

export class EncoderExceptionFallback$instance extends EncoderFallback$instance {
    constructor();
    readonly maxCharCount: int;
    createFallbackBuffer(): EncoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export type EncoderExceptionFallback = EncoderExceptionFallback$instance;

export class EncoderExceptionFallbackBuffer$instance extends EncoderFallbackBuffer$instance {
    constructor();
    readonly remaining: int;
    fallback(charUnknown: char, index: int): boolean;
    fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
}


export type EncoderExceptionFallbackBuffer = EncoderExceptionFallbackBuffer$instance;

export abstract class EncoderFallback$instance {
    readonly maxCharCount: int;
    abstract createFallbackBuffer(): EncoderFallbackBuffer;
    static readonly replacementFallback: EncoderFallback;
    static readonly exceptionFallback: EncoderFallback;
}


export type EncoderFallback = EncoderFallback$instance;

export abstract class EncoderFallbackBuffer$instance {
    readonly remaining: int;
    abstract fallback(charUnknown: char, index: int): boolean;
    abstract fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    abstract getNextChar(): char;
    abstract movePrevious(): boolean;
    reset(): void;
}


export type EncoderFallbackBuffer = EncoderFallbackBuffer$instance;

export class EncoderFallbackException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly charUnknown: char;
    readonly charUnknownHigh: char;
    readonly charUnknownLow: char;
    readonly index: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    isUnknownSurrogate(): boolean;
}


export interface __EncoderFallbackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EncoderFallbackException = EncoderFallbackException$instance & __EncoderFallbackException$views;


export class EncoderReplacementFallback$instance extends EncoderFallback$instance {
    constructor();
    constructor(replacement: string);
    readonly defaultString: string;
    readonly maxCharCount: int;
    createFallbackBuffer(): EncoderFallbackBuffer;
    equals(value: unknown): boolean;
    getHashCode(): int;
}


export type EncoderReplacementFallback = EncoderReplacementFallback$instance;

export class EncoderReplacementFallbackBuffer$instance extends EncoderFallbackBuffer$instance {
    constructor(fallback: EncoderReplacementFallback);
    readonly remaining: int;
    fallback(charUnknown: char, index: int): boolean;
    fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    getNextChar(): char;
    movePrevious(): boolean;
    reset(): void;
}


export type EncoderReplacementFallbackBuffer = EncoderReplacementFallbackBuffer$instance;

export abstract class Encoding$instance {
    readonly bodyName: string;
    readonly codePage: int;
    decoderFallback: DecoderFallback;
    encoderFallback: EncoderFallback;
    readonly encodingName: string;
    readonly headerName: string;
    readonly isBrowserDisplay: boolean;
    readonly isBrowserSave: boolean;
    readonly isMailNewsDisplay: boolean;
    readonly isMailNewsSave: boolean;
    readonly isReadOnly: boolean;
    readonly isSingleByte: boolean;
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    readonly webName: string;
    readonly windowsCodePage: int;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[]): int;
    getByteCount(s: string): int;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    abstract getMaxByteCount(charCount: int): int;
    abstract getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    getString(bytes: byte[], index: int, count: int): string;
    isAlwaysNormalized(): boolean;
    isAlwaysNormalized(form: NormalizationForm): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static readonly default_: Encoding;
    static readonly ASCII: Encoding;
    static readonly latin1: Encoding;
    static readonly unicode: Encoding;
    static readonly bigEndianUnicode: Encoding;
    static readonly UTF7: Encoding;
    static readonly UTF8: Encoding;
    static readonly UTF32: Encoding;
    static convert2(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[], index: int, count: int): byte[];
    static convert2(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[]): byte[];
    static createTranscodingStream(innerStream: Stream, innerStreamEncoding: Encoding, outerStreamEncoding: Encoding, leaveOpen?: boolean): Stream;
    static getEncoding2(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    static getEncoding2(codepage: int): Encoding;
    static getEncoding2(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    static getEncoding2(name: string): Encoding;
    static getEncodings(): EncodingInfo[];
    static registerProvider(provider: EncodingProvider): void;
}


export interface __Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Encoding$instance extends System_Internal.ICloneable$instance {}

export type Encoding = Encoding$instance & __Encoding$views;


export class EncodingInfo$instance {
    constructor(provider: EncodingProvider, codePage: int, name: string, displayName: string);
    readonly codePage: int;
    readonly displayName: string;
    readonly name: string;
    equals(value: unknown): boolean;
    getEncoding(): Encoding;
    getHashCode(): int;
}


export type EncodingInfo = EncodingInfo$instance;

export abstract class EncodingProvider$instance {
    constructor();
    getEncoding(name: string): Encoding;
    getEncoding(codepage: int): Encoding;
    getEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    getEncodings(): IEnumerable_1<EncodingInfo>;
}


export type EncodingProvider = EncodingProvider$instance;

export class StringBuilder$instance {
    constructor();
    constructor(capacity: int);
    constructor(value: string);
    constructor(value: string, capacity: int);
    constructor(value: string, startIndex: int, length: int, capacity: int);
    constructor(capacity: int, maxCapacity: int);
    capacity: int;
    chars: char;
    length: int;
    readonly maxCapacity: int;
    append(value: char, repeatCount: int): StringBuilder;
    append(value: char[], startIndex: int, charCount: int): StringBuilder;
    append(value: string): StringBuilder;
    append(value: string, startIndex: int, count: int): StringBuilder;
    append(value: StringBuilder): StringBuilder;
    append(value: StringBuilder, startIndex: int, count: int): StringBuilder;
    append(value: boolean): StringBuilder;
    append(value: char): StringBuilder;
    append(value: sbyte): StringBuilder;
    append(value: byte): StringBuilder;
    append(value: short): StringBuilder;
    append(value: int): StringBuilder;
    append(value: long): StringBuilder;
    append(value: float): StringBuilder;
    append(value: double): StringBuilder;
    append(value: decimal): StringBuilder;
    append(value: ushort): StringBuilder;
    append(value: uint): StringBuilder;
    append(value: ulong): StringBuilder;
    append(value: unknown): StringBuilder;
    append(value: char[]): StringBuilder;
    append(value: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    append(value: ReadOnlyMemory_1<CLROf<char>>): StringBuilder;
    append(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    append(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    append(value: ptr<char>, valueCount: int): StringBuilder;
    appendFormat(format: string, arg0: unknown): StringBuilder;
    appendFormat(format: string, arg0: unknown, arg1: unknown): StringBuilder;
    appendFormat(format: string, arg0: unknown, arg1: unknown, arg2: unknown): StringBuilder;
    appendFormat(format: string, args: unknown[]): StringBuilder;
    appendFormat(format: string, args: ReadOnlySpan_1<unknown>): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: unknown): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown, arg2: unknown): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, args: unknown[]): StringBuilder;
    appendFormat(provider: IFormatProvider, format: string, args: ReadOnlySpan_1<unknown>): StringBuilder;
    appendFormat<TArg0>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0): StringBuilder;
    appendFormat<TArg0, TArg1>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1): StringBuilder;
    appendFormat<TArg0, TArg1, TArg2>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): StringBuilder;
    appendFormat(provider: IFormatProvider, format: CompositeFormat, args: unknown[]): StringBuilder;
    appendFormat(provider: IFormatProvider, format: CompositeFormat, args: ReadOnlySpan_1<unknown>): StringBuilder;
    appendJoin(separator: string, values: unknown[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<unknown>): StringBuilder;
    appendJoin<T>(separator: string, values: IEnumerable_1<T>): StringBuilder;
    appendJoin(separator: string, values: string[]): StringBuilder;
    appendJoin(separator: string, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    appendJoin(separator: char, values: unknown[]): StringBuilder;
    appendJoin(separator: char, values: ReadOnlySpan_1<unknown>): StringBuilder;
    appendJoin<T>(separator: char, values: IEnumerable_1<T>): StringBuilder;
    appendJoin(separator: char, values: string[]): StringBuilder;
    appendJoin(separator: char, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    appendLine(): StringBuilder;
    appendLine(value: string): StringBuilder;
    appendLine(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    appendLine(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    clear(): StringBuilder;
    copyTo(sourceIndex: int, destination: char[], destinationIndex: int, count: int): void;
    copyTo(sourceIndex: int, destination: Span_1<CLROf<char>>, count: int): void;
    ensureCapacity(capacity: int): int;
    equals(sb: StringBuilder): boolean;
    equals(span: ReadOnlySpan_1<CLROf<char>>): boolean;
    getChunks(): StringBuilder_ChunkEnumerator;
    insert(index: int, value: string, count: int): StringBuilder;
    insert(index: int, value: string): StringBuilder;
    insert(index: int, value: boolean): StringBuilder;
    insert(index: int, value: sbyte): StringBuilder;
    insert(index: int, value: byte): StringBuilder;
    insert(index: int, value: short): StringBuilder;
    insert(index: int, value: char): StringBuilder;
    insert(index: int, value: char[]): StringBuilder;
    insert(index: int, value: char[], startIndex: int, charCount: int): StringBuilder;
    insert(index: int, value: int): StringBuilder;
    insert(index: int, value: long): StringBuilder;
    insert(index: int, value: float): StringBuilder;
    insert(index: int, value: double): StringBuilder;
    insert(index: int, value: decimal): StringBuilder;
    insert(index: int, value: ushort): StringBuilder;
    insert(index: int, value: uint): StringBuilder;
    insert(index: int, value: ulong): StringBuilder;
    insert(index: int, value: unknown): StringBuilder;
    insert(index: int, value: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    remove(startIndex: int, length: int): StringBuilder;
    replace(oldValue: string, newValue: string): StringBuilder;
    replace(oldValue: ReadOnlySpan_1<CLROf<char>>, newValue: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    replace(oldValue: string, newValue: string, startIndex: int, count: int): StringBuilder;
    replace(oldValue: ReadOnlySpan_1<CLROf<char>>, newValue: ReadOnlySpan_1<CLROf<char>>, startIndex: int, count: int): StringBuilder;
    replace(oldChar: char, newChar: char): StringBuilder;
    replace(oldChar: char, newChar: char, startIndex: int, count: int): StringBuilder;
    toString(): string;
    toString(startIndex: int, length: int): string;
}


export interface __StringBuilder$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface StringBuilder$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type StringBuilder = StringBuilder$instance & __StringBuilder$views;


export class UnicodeEncoding$instance extends Encoding$instance {
    constructor();
    constructor(bigEndian: boolean, byteOrderMark: boolean);
    constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidBytes: boolean);
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    static readonly charSize: int;
}


export interface __UnicodeEncoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UnicodeEncoding = UnicodeEncoding$instance & __UnicodeEncoding$views;


export class UTF32Encoding$instance extends Encoding$instance {
    constructor();
    constructor(bigEndian: boolean, byteOrderMark: boolean);
    constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidCharacters: boolean);
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
}


export interface __UTF32Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF32Encoding = UTF32Encoding$instance & __UTF32Encoding$views;


export class UTF7Encoding$instance extends Encoding$instance {
    constructor();
    constructor(allowOptionals: boolean);
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(s: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
}


export interface __UTF7Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF7Encoding = UTF7Encoding$instance & __UTF7Encoding$views;


export class UTF8Encoding$instance extends Encoding$instance {
    constructor();
    constructor(encoderShouldEmitUTF8Identifier: boolean);
    constructor(encoderShouldEmitUTF8Identifier: boolean, throwOnInvalidBytes: boolean);
    readonly preamble: ReadOnlySpan_1<CLROf<byte>>;
    clone(): unknown;
    equals(value: unknown): boolean;
    getByteCount(chars: char[], index: int, count: int): int;
    getByteCount(chars: string): int;
    getByteCount(chars: ptr<char>, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getByteCount(chars: char[]): int;
    getByteCount(s: string, index: int, count: int): int;
    getByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    getBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    getBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getBytes(chars: char[]): byte[];
    getBytes(chars: char[], index: int, count: int): byte[];
    getBytes(s: string): byte[];
    getBytes(s: string, index: int, count: int): byte[];
    getBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[], index: int, count: int): int;
    getCharCount(bytes: ptr<byte>, count: int): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getCharCount(bytes: byte[]): int;
    getCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    getChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    getChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getChars(bytes: byte[]): char[];
    getChars(bytes: byte[], index: int, count: int): char[];
    getChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    getDecoder(): Decoder;
    getEncoder(): Encoder;
    getHashCode(): int;
    getMaxByteCount(charCount: int): int;
    getMaxCharCount(byteCount: int): int;
    getPreamble(): byte[];
    getString(bytes: byte[], index: int, count: int): string;
    getString(bytes: ptr<byte>, byteCount: int): string;
    getString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    getString(bytes: byte[]): string;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export interface __UTF8Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF8Encoding = UTF8Encoding$instance & __UTF8Encoding$views;


export abstract class Ascii$instance {
    static equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static equals(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equals(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static equalsIgnoreCase(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static fromUtf16(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static isValid3(value: byte): boolean;
    static isValid3(value: char): boolean;
    static isValid3(value: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static isValid3(value: ReadOnlySpan_1<CLROf<char>>): boolean;
    static toLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toLower(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toLower(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toLowerInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toLowerInPlace(value: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toUpper(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUpperInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static toUpperInPlace(value: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static toUtf16(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static trim(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static trim(value: ReadOnlySpan_1<CLROf<char>>): Range;
    static trimEnd(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static trimEnd(value: ReadOnlySpan_1<CLROf<char>>): Range;
    static trimStart(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static trimStart(value: ReadOnlySpan_1<CLROf<char>>): Range;
}


export type Ascii = Ascii$instance;

export abstract class EncodingExtensions$instance {
    static convert4(decoder: Decoder, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<char>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static convert4(decoder: Decoder, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<char>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static convert4(encoder: Encoder, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static convert4(encoder: Encoder, chars: ReadOnlySpan_1<CLROf<char>>, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static getBytes2(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, writer: IBufferWriter_1<CLROf<byte>>): long;
    static getBytes2(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, bytes: Span_1<CLROf<byte>>): int;
    static getBytes2(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }): byte[];
    static getBytes2(encoding: Encoding, chars: ReadOnlySpan_1<CLROf<char>>, writer: IBufferWriter_1<CLROf<byte>>): long;
    static getChars2(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<char>>): long;
    static getChars2(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, chars: Span_1<CLROf<char>>): int;
    static getChars2(encoding: Encoding, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<char>>): long;
    static getString(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }): string;
}


export type EncodingExtensions = EncodingExtensions$instance;

