// Generated by tsbindgen - Architecture
// Namespace: System.Text
// Assembly: System.Private.CoreLib, System.Text.Encoding.CodePages, System.Memory

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IBufferWriter_1, OperationStatus, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CultureInfo, UnicodeCategory } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, Decimal, Double, Enum, Exception, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, IUtf8SpanFormattable, IUtf8SpanParsable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum NormalizationForm {
    FormC = 1,
    FormD = 2,
    FormKC = 5,
    FormKD = 6
}


export class Rune$instance {
    constructor(ch: string);
    constructor(highSurrogate: string, lowSurrogate: string);
    constructor(value: int);
    constructor(value: uint);
    readonly IsAscii: boolean;
    readonly IsBmp: boolean;
    readonly Plane: int;
    readonly Utf16SequenceLength: int;
    readonly Utf8SequenceLength: int;
    readonly Value: int;
    CompareTo(other: Rune): int;
    EncodeToUtf16(destination: Span_1<CLROf<string>>): int;
    EncodeToUtf8(destination: Span_1<CLROf<byte>>): int;
    Equals(obj: any): boolean;
    Equals(other: Rune): boolean;
    GetHashCode(): int;
    ToString(): string;
    TryEncodeToUtf16(destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    TryEncodeToUtf8(destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static readonly ReplacementChar: Rune;
    static DecodeFromUtf16(source: ReadOnlySpan_1<CLROf<string>>, result: { value: TSByRef<Rune> }, charsConsumed: { value: TSByRef<int> }): OperationStatus;
    static DecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, result: { value: TSByRef<Rune> }, bytesConsumed: { value: TSByRef<int> }): OperationStatus;
    static DecodeLastFromUtf16(source: ReadOnlySpan_1<CLROf<string>>, result: { value: TSByRef<Rune> }, charsConsumed: { value: TSByRef<int> }): OperationStatus;
    static DecodeLastFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<Rune> }, bytesConsumed: { value: TSByRef<int> }): OperationStatus;
    static GetNumericValue(value: Rune): double;
    static GetRuneAt(input: string, index: int): Rune;
    static GetUnicodeCategory(value: Rune): UnicodeCategory;
    static IsControl(value: Rune): boolean;
    static IsDigit(value: Rune): boolean;
    static IsLetter(value: Rune): boolean;
    static IsLetterOrDigit(value: Rune): boolean;
    static IsLower(value: Rune): boolean;
    static IsNumber(value: Rune): boolean;
    static IsPunctuation(value: Rune): boolean;
    static IsSeparator(value: Rune): boolean;
    static IsSymbol(value: Rune): boolean;
    static IsUpper(value: Rune): boolean;
    static IsValid(value: int): boolean;
    static IsValid(value: uint): boolean;
    static IsWhiteSpace(value: Rune): boolean;
    static ToLower(value: Rune, culture: CultureInfo): Rune;
    static ToLowerInvariant(value: Rune): Rune;
    static ToUpper(value: Rune, culture: CultureInfo): Rune;
    static ToUpperInvariant(value: Rune): Rune;
    static TryCreate(highSurrogate: string, lowSurrogate: string, result: { value: TSByRef<Rune> }): boolean;
    static TryCreate(ch: string, result: { value: TSByRef<Rune> }): boolean;
    static TryCreate(value: int, result: { value: TSByRef<Rune> }): boolean;
    static TryCreate(value: uint, result: { value: TSByRef<Rune> }): boolean;
    static TryGetRuneAt(input: string, index: int, value: { value: TSByRef<Rune> }): boolean;
}


export interface __Rune$views {
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IComparable_1_of_Decimal: System_Internal.IComparable_1$instance<Rune>;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<Rune>;
    readonly As_IFormattable: System_Internal.IFormattable$instance;
    readonly As_ISpanFormattable: System_Internal.ISpanFormattable$instance;
    readonly As_IUtf8SpanFormattable: System_Internal.IUtf8SpanFormattable$instance;
    readonly As_IUtf8SpanParsable_1_of_Decimal: System_Internal.IUtf8SpanParsable_1$instance<any>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rune): boolean;
    CompareTo(obj: any): int;
}

export type Rune = Rune$instance & __Rune$views;


export class SpanLineEnumerator$instance {
    readonly Current: ReadOnlySpan_1<CLROf<string>>;
    GetEnumerator(): SpanLineEnumerator;
    MoveNext(): boolean;
}


export interface __SpanLineEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<ReadOnlySpan_1<CLROf<string>>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SpanLineEnumerator = SpanLineEnumerator$instance & __SpanLineEnumerator$views;


export class SpanRuneEnumerator$instance {
    readonly Current: Rune;
    GetEnumerator(): SpanRuneEnumerator;
    MoveNext(): boolean;
}


export interface __SpanRuneEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SpanRuneEnumerator = SpanRuneEnumerator$instance & __SpanRuneEnumerator$views;


export class StringBuilder_AppendInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, stringBuilder: StringBuilder);
    constructor(literalLength: int, formattedCount: int, stringBuilder: StringBuilder, provider: IFormatProvider);
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<string>>): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<string>>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: any, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
}


export type StringBuilder_AppendInterpolatedStringHandler = StringBuilder_AppendInterpolatedStringHandler$instance;

export class StringBuilder_ChunkEnumerator$instance {
    readonly Current: ReadOnlyMemory_1<CLROf<string>>;
    GetEnumerator(): StringBuilder_ChunkEnumerator;
    MoveNext(): boolean;
}


export type StringBuilder_ChunkEnumerator = StringBuilder_ChunkEnumerator$instance;

export class StringRuneEnumerator$instance {
    readonly Current: Rune;
    GetEnumerator(): StringRuneEnumerator;
    MoveNext(): boolean;
}


export interface __StringRuneEnumerator$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<Rune>;
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type StringRuneEnumerator = StringRuneEnumerator$instance & __StringRuneEnumerator$views;


export class ASCIIEncoding$instance extends Encoding$instance {
    constructor();
    readonly IsSingleByte: boolean;
    Clone(): any;
    GetByteCount(chars: string[], index: int, count: int): int;
    GetByteCount(chars: string): int;
    GetByteCount(chars: TSUnsafePointer<string>, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetByteCount(chars: string[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetBytes(chars: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetBytes(chars: string[]): byte[];
    GetBytes(chars: string[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: TSUnsafePointer<byte>, count: int): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    GetChars(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetChars(bytes: byte[]): string[];
    GetChars(bytes: byte[], index: int, count: int): string[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetString(bytes: byte[], byteIndex: int, byteCount: int): string;
    GetString(bytes: TSUnsafePointer<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
}


export interface __ASCIIEncoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ASCIIEncoding = ASCIIEncoding$instance & __ASCIIEncoding$views;


export class CodePagesEncodingProvider$instance extends EncodingProvider$instance {
    GetEncoding(codepage: int): Encoding;
    GetEncoding(name: string): Encoding;
    GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncodings(): IEnumerable_1<EncodingInfo>;
    GetEncodings(): IEnumerable_1<EncodingInfo>;
    static readonly Instance: EncodingProvider;
}


export type CodePagesEncodingProvider = CodePagesEncodingProvider$instance;

export class CompositeFormat$instance {
    readonly Format: string;
    readonly MinimumArgumentCount: int;
    static Parse(format: string): CompositeFormat;
}


export type CompositeFormat = CompositeFormat$instance;

export abstract class Decoder$instance {
    Fallback: DecoderFallback;
    readonly FallbackBuffer: DecoderFallbackBuffer;
    Convert(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int, charCount: int, flush: boolean, bytesUsed: { value: TSByRef<int> }, charsUsed: { value: TSByRef<int> }, completed: { value: TSByRef<boolean> }): void;
    Convert(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int, flush: boolean, bytesUsed: { value: TSByRef<int> }, charsUsed: { value: TSByRef<int> }, completed: { value: TSByRef<boolean> }): void;
    Convert(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, flush: boolean, bytesUsed: { value: TSByRef<int> }, charsUsed: { value: TSByRef<int> }, completed: { value: TSByRef<boolean> }): void;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: byte[], index: int, count: int, flush: boolean): int;
    GetCharCount(bytes: TSUnsafePointer<byte>, count: int, flush: boolean): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>, flush: boolean): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int, flush: boolean): int;
    GetChars(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int, flush: boolean): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, flush: boolean): int;
    Reset(): void;
}


export type Decoder = Decoder$instance;

export class DecoderExceptionFallback$instance extends DecoderFallback$instance {
    constructor();
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): DecoderFallbackBuffer;
    Equals(value: any): boolean;
    GetHashCode(): int;
}


export type DecoderExceptionFallback = DecoderExceptionFallback$instance;

export class DecoderExceptionFallbackBuffer$instance extends DecoderFallbackBuffer$instance {
    constructor();
    readonly Remaining: int;
    Fallback(bytesUnknown: byte[], index: int): boolean;
    GetNextChar(): string;
    MovePrevious(): boolean;
}


export type DecoderExceptionFallbackBuffer = DecoderExceptionFallbackBuffer$instance;

export abstract class DecoderFallback$instance {
    readonly MaxCharCount: int;
    abstract CreateFallbackBuffer(): DecoderFallbackBuffer;
    static readonly ReplacementFallback: DecoderFallback;
    static readonly ExceptionFallback: DecoderFallback;
}


export type DecoderFallback = DecoderFallback$instance;

export abstract class DecoderFallbackBuffer$instance {
    readonly Remaining: int;
    abstract Fallback(bytesUnknown: byte[], index: int): boolean;
    abstract GetNextChar(): string;
    abstract MovePrevious(): boolean;
    Reset(): void;
}


export type DecoderFallbackBuffer = DecoderFallbackBuffer$instance;

export class DecoderFallbackException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, bytesUnknown: byte[], index: int);
    readonly BytesUnknown: byte[];
    readonly Index: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DecoderFallbackException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DecoderFallbackException = DecoderFallbackException$instance & __DecoderFallbackException$views;


export class DecoderReplacementFallback$instance extends DecoderFallback$instance {
    constructor();
    constructor(replacement: string);
    readonly DefaultString: string;
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): DecoderFallbackBuffer;
    Equals(value: any): boolean;
    GetHashCode(): int;
}


export type DecoderReplacementFallback = DecoderReplacementFallback$instance;

export class DecoderReplacementFallbackBuffer$instance extends DecoderFallbackBuffer$instance {
    constructor(fallback: DecoderReplacementFallback);
    readonly Remaining: int;
    Fallback(bytesUnknown: byte[], index: int): boolean;
    GetNextChar(): string;
    MovePrevious(): boolean;
    Reset(): void;
}


export type DecoderReplacementFallbackBuffer = DecoderReplacementFallbackBuffer$instance;

export abstract class Encoder$instance {
    Fallback: EncoderFallback;
    readonly FallbackBuffer: EncoderFallbackBuffer;
    Convert(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, byteCount: int, flush: boolean, charsUsed: { value: TSByRef<int> }, bytesUsed: { value: TSByRef<int> }, completed: { value: TSByRef<boolean> }): void;
    Convert(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int, flush: boolean, charsUsed: { value: TSByRef<int> }, bytesUsed: { value: TSByRef<int> }, completed: { value: TSByRef<boolean> }): void;
    Convert(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, flush: boolean, charsUsed: { value: TSByRef<int> }, bytesUsed: { value: TSByRef<int> }, completed: { value: TSByRef<boolean> }): void;
    GetByteCount(chars: string[], index: int, count: int, flush: boolean): int;
    GetByteCount(chars: TSUnsafePointer<string>, count: int, flush: boolean): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>, flush: boolean): int;
    GetBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, flush: boolean): int;
    GetBytes(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int, flush: boolean): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, flush: boolean): int;
    Reset(): void;
}


export type Encoder = Encoder$instance;

export class EncoderExceptionFallback$instance extends EncoderFallback$instance {
    constructor();
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): EncoderFallbackBuffer;
    Equals(value: any): boolean;
    GetHashCode(): int;
}


export type EncoderExceptionFallback = EncoderExceptionFallback$instance;

export class EncoderExceptionFallbackBuffer$instance extends EncoderFallbackBuffer$instance {
    constructor();
    readonly Remaining: int;
    Fallback(charUnknown: string, index: int): boolean;
    Fallback(charUnknownHigh: string, charUnknownLow: string, index: int): boolean;
    GetNextChar(): string;
    MovePrevious(): boolean;
}


export type EncoderExceptionFallbackBuffer = EncoderExceptionFallbackBuffer$instance;

export abstract class EncoderFallback$instance {
    readonly MaxCharCount: int;
    abstract CreateFallbackBuffer(): EncoderFallbackBuffer;
    static readonly ReplacementFallback: EncoderFallback;
    static readonly ExceptionFallback: EncoderFallback;
}


export type EncoderFallback = EncoderFallback$instance;

export abstract class EncoderFallbackBuffer$instance {
    readonly Remaining: int;
    abstract Fallback(charUnknown: string, index: int): boolean;
    abstract Fallback(charUnknownHigh: string, charUnknownLow: string, index: int): boolean;
    abstract GetNextChar(): string;
    abstract MovePrevious(): boolean;
    Reset(): void;
}


export type EncoderFallbackBuffer = EncoderFallbackBuffer$instance;

export class EncoderFallbackException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly CharUnknown: string;
    readonly CharUnknownHigh: string;
    readonly CharUnknownLow: string;
    readonly Index: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    IsUnknownSurrogate(): boolean;
}


export interface __EncoderFallbackException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EncoderFallbackException = EncoderFallbackException$instance & __EncoderFallbackException$views;


export class EncoderReplacementFallback$instance extends EncoderFallback$instance {
    constructor();
    constructor(replacement: string);
    readonly DefaultString: string;
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): EncoderFallbackBuffer;
    Equals(value: any): boolean;
    GetHashCode(): int;
}


export type EncoderReplacementFallback = EncoderReplacementFallback$instance;

export class EncoderReplacementFallbackBuffer$instance extends EncoderFallbackBuffer$instance {
    constructor(fallback: EncoderReplacementFallback);
    readonly Remaining: int;
    Fallback(charUnknown: string, index: int): boolean;
    Fallback(charUnknownHigh: string, charUnknownLow: string, index: int): boolean;
    GetNextChar(): string;
    MovePrevious(): boolean;
    Reset(): void;
}


export type EncoderReplacementFallbackBuffer = EncoderReplacementFallbackBuffer$instance;

export abstract class Encoding$instance {
    readonly BodyName: string;
    readonly CodePage: int;
    DecoderFallback: DecoderFallback;
    EncoderFallback: EncoderFallback;
    readonly EncodingName: string;
    readonly HeaderName: string;
    readonly IsBrowserDisplay: boolean;
    readonly IsBrowserSave: boolean;
    readonly IsMailNewsDisplay: boolean;
    readonly IsMailNewsSave: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSingleByte: boolean;
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    readonly WebName: string;
    readonly WindowsCodePage: int;
    Clone(): any;
    Equals(value: any): boolean;
    GetByteCount(chars: string[]): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: string[], index: int, count: int): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: TSUnsafePointer<string>, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetBytes(chars: string[]): byte[];
    GetBytes(chars: string[], index: int, count: int): byte[];
    GetBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: TSUnsafePointer<byte>, count: int): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[]): string[];
    GetChars(bytes: byte[], index: int, count: int): string[];
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    GetChars(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    abstract GetMaxByteCount(charCount: int): int;
    abstract GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: TSUnsafePointer<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
    GetString(bytes: byte[], index: int, count: int): string;
    IsAlwaysNormalized(): boolean;
    IsAlwaysNormalized(form: NormalizationForm): boolean;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    static readonly Default: Encoding;
    static readonly ASCII: Encoding;
    static readonly Latin1: Encoding;
    static readonly Unicode: Encoding;
    static readonly BigEndianUnicode: Encoding;
    static readonly UTF7: Encoding;
    static readonly UTF8: Encoding;
    static readonly UTF32: Encoding;
    static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[], index: int, count: int): byte[];
    static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[]): byte[];
    static CreateTranscodingStream(innerStream: Stream, innerStreamEncoding: Encoding, outerStreamEncoding: Encoding, leaveOpen?: boolean): Stream;
    static GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    static GetEncoding(codepage: int): Encoding;
    static GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    static GetEncoding(name: string): Encoding;
    static GetEncodings(): EncodingInfo[];
    static RegisterProvider(provider: EncodingProvider): void;
}


export interface __Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type Encoding = Encoding$instance & __Encoding$views;


export class EncodingInfo$instance {
    constructor(provider: EncodingProvider, codePage: int, name: string, displayName: string);
    readonly CodePage: int;
    readonly DisplayName: string;
    readonly Name: string;
    Equals(value: any): boolean;
    GetEncoding(): Encoding;
    GetHashCode(): int;
}


export type EncodingInfo = EncodingInfo$instance;

export abstract class EncodingProvider$instance {
    constructor();
    GetEncoding(name: string): Encoding;
    GetEncoding(codepage: int): Encoding;
    GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncodings(): IEnumerable_1<EncodingInfo>;
}


export type EncodingProvider = EncodingProvider$instance;

export class StringBuilder$instance {
    constructor();
    constructor(capacity: int);
    constructor(value: string);
    constructor(value: string, capacity: int);
    constructor(value: string, startIndex: int, length: int, capacity: int);
    constructor(capacity: int, maxCapacity: int);
    Capacity: int;
    Chars: string;
    Length: int;
    readonly MaxCapacity: int;
    Append(value: string, repeatCount: int): StringBuilder;
    Append(value: string[], startIndex: int, charCount: int): StringBuilder;
    Append(value: string): StringBuilder;
    Append(value: string, startIndex: int, count: int): StringBuilder;
    Append(value: StringBuilder): StringBuilder;
    Append(value: StringBuilder, startIndex: int, count: int): StringBuilder;
    Append(value: boolean): StringBuilder;
    Append(value: string): StringBuilder;
    Append(value: sbyte): StringBuilder;
    Append(value: byte): StringBuilder;
    Append(value: short): StringBuilder;
    Append(value: int): StringBuilder;
    Append(value: long): StringBuilder;
    Append(value: float): StringBuilder;
    Append(value: double): StringBuilder;
    Append(value: decimal): StringBuilder;
    Append(value: ushort): StringBuilder;
    Append(value: uint): StringBuilder;
    Append(value: ulong): StringBuilder;
    Append(value: any): StringBuilder;
    Append(value: string[]): StringBuilder;
    Append(value: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    Append(value: ReadOnlyMemory_1<CLROf<string>>): StringBuilder;
    Append(handler: { value: TSByRef<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    Append(provider: IFormatProvider, handler: { value: TSByRef<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    Append(value: TSUnsafePointer<string>, valueCount: int): StringBuilder;
    AppendFormat(format: string, arg0: any): StringBuilder;
    AppendFormat(format: string, arg0: any, arg1: any): StringBuilder;
    AppendFormat(format: string, arg0: any, arg1: any, arg2: any): StringBuilder;
    AppendFormat(format: string, args: any[]): StringBuilder;
    AppendFormat(format: string, args: ReadOnlySpan_1<any>): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, arg0: any): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, arg0: any, arg1: any): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, arg0: any, arg1: any, arg2: any): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, args: any[]): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, args: ReadOnlySpan_1<any>): StringBuilder;
    AppendFormat<TArg0>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0): StringBuilder;
    AppendFormat<TArg0, TArg1>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1): StringBuilder;
    AppendFormat<TArg0, TArg1, TArg2>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: CompositeFormat, args: any[]): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: CompositeFormat, args: ReadOnlySpan_1<any>): StringBuilder;
    AppendJoin(separator: string, values: any[]): StringBuilder;
    AppendJoin(separator: string, values: ReadOnlySpan_1<any>): StringBuilder;
    AppendJoin<T>(separator: string, values: IEnumerable_1<T>): StringBuilder;
    AppendJoin(separator: string, values: string[]): StringBuilder;
    AppendJoin(separator: string, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    AppendJoin(separator: string, values: any[]): StringBuilder;
    AppendJoin(separator: string, values: ReadOnlySpan_1<any>): StringBuilder;
    AppendJoin<T>(separator: string, values: IEnumerable_1<T>): StringBuilder;
    AppendJoin(separator: string, values: string[]): StringBuilder;
    AppendJoin(separator: string, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    AppendLine(): StringBuilder;
    AppendLine(value: string): StringBuilder;
    AppendLine(handler: { value: TSByRef<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    AppendLine(provider: IFormatProvider, handler: { value: TSByRef<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    Clear(): StringBuilder;
    CopyTo(sourceIndex: int, destination: string[], destinationIndex: int, count: int): void;
    CopyTo(sourceIndex: int, destination: Span_1<CLROf<string>>, count: int): void;
    EnsureCapacity(capacity: int): int;
    Equals(sb: StringBuilder): boolean;
    Equals(span: ReadOnlySpan_1<CLROf<string>>): boolean;
    GetChunks(): StringBuilder_ChunkEnumerator;
    Insert(index: int, value: string, count: int): StringBuilder;
    Insert(index: int, value: string): StringBuilder;
    Insert(index: int, value: boolean): StringBuilder;
    Insert(index: int, value: sbyte): StringBuilder;
    Insert(index: int, value: byte): StringBuilder;
    Insert(index: int, value: short): StringBuilder;
    Insert(index: int, value: string): StringBuilder;
    Insert(index: int, value: string[]): StringBuilder;
    Insert(index: int, value: string[], startIndex: int, charCount: int): StringBuilder;
    Insert(index: int, value: int): StringBuilder;
    Insert(index: int, value: long): StringBuilder;
    Insert(index: int, value: float): StringBuilder;
    Insert(index: int, value: double): StringBuilder;
    Insert(index: int, value: decimal): StringBuilder;
    Insert(index: int, value: ushort): StringBuilder;
    Insert(index: int, value: uint): StringBuilder;
    Insert(index: int, value: ulong): StringBuilder;
    Insert(index: int, value: any): StringBuilder;
    Insert(index: int, value: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    Remove(startIndex: int, length: int): StringBuilder;
    Replace(oldValue: string, newValue: string): StringBuilder;
    Replace(oldValue: ReadOnlySpan_1<CLROf<string>>, newValue: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    Replace(oldValue: string, newValue: string, startIndex: int, count: int): StringBuilder;
    Replace(oldValue: ReadOnlySpan_1<CLROf<string>>, newValue: ReadOnlySpan_1<CLROf<string>>, startIndex: int, count: int): StringBuilder;
    Replace(oldChar: string, newChar: string): StringBuilder;
    Replace(oldChar: string, newChar: string, startIndex: int, count: int): StringBuilder;
    ToString(): string;
    ToString(startIndex: int, length: int): string;
}


export interface __StringBuilder$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StringBuilder = StringBuilder$instance & __StringBuilder$views;


export class UnicodeEncoding$instance extends Encoding$instance {
    constructor();
    constructor(bigEndian: boolean, byteOrderMark: boolean);
    constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidBytes: boolean);
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    Clone(): any;
    Equals(value: any): boolean;
    GetByteCount(chars: string[], index: int, count: int): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: TSUnsafePointer<string>, count: int): int;
    GetByteCount(chars: string[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int): int;
    GetBytes(chars: string[]): byte[];
    GetBytes(chars: string[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: TSUnsafePointer<byte>, count: int): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    GetChars(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int): int;
    GetChars(bytes: byte[]): string[];
    GetChars(bytes: byte[], index: int, count: int): string[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: TSUnsafePointer<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
    static readonly CharSize: int;
}


export interface __UnicodeEncoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UnicodeEncoding = UnicodeEncoding$instance & __UnicodeEncoding$views;


export class UTF32Encoding$instance extends Encoding$instance {
    constructor();
    constructor(bigEndian: boolean, byteOrderMark: boolean);
    constructor(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidCharacters: boolean);
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    Clone(): any;
    Equals(value: any): boolean;
    GetByteCount(chars: string[], index: int, count: int): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: TSUnsafePointer<string>, count: int): int;
    GetByteCount(chars: string[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int): int;
    GetBytes(chars: string[]): byte[];
    GetBytes(chars: string[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: TSUnsafePointer<byte>, count: int): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    GetChars(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int): int;
    GetChars(bytes: byte[]): string[];
    GetChars(bytes: byte[], index: int, count: int): string[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: TSUnsafePointer<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
}


export interface __UTF32Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UTF32Encoding = UTF32Encoding$instance & __UTF32Encoding$views;


export class UTF7Encoding$instance extends Encoding$instance {
    constructor();
    constructor(allowOptionals: boolean);
    Clone(): any;
    Equals(value: any): boolean;
    GetByteCount(chars: string[], index: int, count: int): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: TSUnsafePointer<string>, count: int): int;
    GetByteCount(chars: string[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int): int;
    GetBytes(chars: string[]): byte[];
    GetBytes(chars: string[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: TSUnsafePointer<byte>, count: int): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    GetChars(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int): int;
    GetChars(bytes: byte[]): string[];
    GetChars(bytes: byte[], index: int, count: int): string[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: TSUnsafePointer<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
}


export interface __UTF7Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UTF7Encoding = UTF7Encoding$instance & __UTF7Encoding$views;


export class UTF8Encoding$instance extends Encoding$instance {
    constructor();
    constructor(encoderShouldEmitUTF8Identifier: boolean);
    constructor(encoderShouldEmitUTF8Identifier: boolean, throwOnInvalidBytes: boolean);
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    Clone(): any;
    Equals(value: any): boolean;
    GetByteCount(chars: string[], index: int, count: int): int;
    GetByteCount(chars: string): int;
    GetByteCount(chars: TSUnsafePointer<string>, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetByteCount(chars: string[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<string>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: string[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: TSUnsafePointer<string>, charCount: int, bytes: TSUnsafePointer<byte>, byteCount: int): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetBytes(chars: string[]): byte[];
    GetBytes(chars: string[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: TSUnsafePointer<byte>, count: int): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: string[], charIndex: int): int;
    GetChars(bytes: TSUnsafePointer<byte>, byteCount: int, chars: TSUnsafePointer<string>, charCount: int): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetChars(bytes: byte[]): string[];
    GetChars(bytes: byte[], index: int, count: int): string[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: TSUnsafePointer<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<string>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
}


export interface __UTF8Encoding$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UTF8Encoding = UTF8Encoding$instance & __UTF8Encoding$views;


export abstract class Ascii$instance {
    static Equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<string>>, right: ReadOnlySpan_1<CLROf<string>>): boolean;
    static FromUtf16(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static IsValid(value: byte): boolean;
    static IsValid(value: string): boolean;
    static IsValid(value: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static IsValid(value: ReadOnlySpan_1<CLROf<string>>): boolean;
    static ToLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): OperationStatus;
    static ToLowerInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static ToLowerInPlace(value: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): OperationStatus;
    static ToUpperInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static ToUpperInPlace(value: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): OperationStatus;
    static ToUtf16(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): OperationStatus;
    static Trim(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static Trim(value: ReadOnlySpan_1<CLROf<string>>): Range;
    static TrimEnd(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static TrimEnd(value: ReadOnlySpan_1<CLROf<string>>): Range;
    static TrimStart(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static TrimStart(value: ReadOnlySpan_1<CLROf<string>>): Range;
}


export type Ascii = Ascii$instance;

export abstract class EncodingExtensions$instance {
    static Convert(decoder: Decoder, bytes: { value: TSByRef<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<string>>, flush: boolean, charsUsed: { value: TSByRef<long> }, completed: { value: TSByRef<boolean> }): void;
    static Convert(decoder: Decoder, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<string>>, flush: boolean, charsUsed: { value: TSByRef<long> }, completed: { value: TSByRef<boolean> }): void;
    static Convert(encoder: Encoder, chars: { value: TSByRef<ReadOnlySequence_1<CLROf<string>>> }, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: TSByRef<long> }, completed: { value: TSByRef<boolean> }): void;
    static Convert(encoder: Encoder, chars: ReadOnlySpan_1<CLROf<string>>, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: TSByRef<long> }, completed: { value: TSByRef<boolean> }): void;
    static GetBytes(encoding: Encoding, chars: { value: TSByRef<ReadOnlySequence_1<CLROf<string>>> }, writer: IBufferWriter_1<CLROf<byte>>): long;
    static GetBytes(encoding: Encoding, chars: { value: TSByRef<ReadOnlySequence_1<CLROf<string>>> }, bytes: Span_1<CLROf<byte>>): int;
    static GetBytes(encoding: Encoding, chars: { value: TSByRef<ReadOnlySequence_1<CLROf<string>>> }): byte[];
    static GetBytes(encoding: Encoding, chars: ReadOnlySpan_1<CLROf<string>>, writer: IBufferWriter_1<CLROf<byte>>): long;
    static GetChars(encoding: Encoding, bytes: { value: TSByRef<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<string>>): long;
    static GetChars(encoding: Encoding, bytes: { value: TSByRef<ReadOnlySequence_1<CLROf<byte>>> }, chars: Span_1<CLROf<string>>): int;
    static GetChars(encoding: Encoding, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<string>>): long;
    static GetString(encoding: Encoding, bytes: { value: TSByRef<ReadOnlySequence_1<CLROf<byte>>> }): string;
}


export type EncodingExtensions = EncodingExtensions$instance;

