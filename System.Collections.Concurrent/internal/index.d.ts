// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Concurrent
// Assembly: System.Collections.Concurrent, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Enum, Func_2, Func_3, Func_4, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, String as ClrString, TimeSpan, Tuple_2, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum EnumerablePartitionerOptions {
    none = 0,
    noBuffering = 1
}


export interface IProducerConsumerCollection_1$instance<T> {
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    ToArray(): T[];
    TryAdd(item: T): boolean;
    TryTake(item: { value: TSByRef<T> }): boolean;
}


export type IProducerConsumerCollection_1<T> = IProducerConsumerCollection_1$instance<T>;

export class ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly dictionary: ConcurrentDictionary_2<TKey, TValue>;
    item: TValue;
    containsKey(key: TAlternateKey): boolean;
    tryAdd(key: TAlternateKey, value: TValue): boolean;
    tryGetValue(key: TAlternateKey, value: { value: TSByRef<TValue> }): boolean;
    tryGetValue(key: TAlternateKey, actualKey: { value: TSByRef<TKey> }, value: { value: TSByRef<TValue> }): boolean;
    tryRemove(key: TAlternateKey, value: { value: TSByRef<TValue> }): boolean;
    tryRemove(key: TAlternateKey, actualKey: { value: TSByRef<TKey> }, value: { value: TSByRef<TValue> }): boolean;
}


export type ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export class BlockingCollection_1$instance<T> {
    constructor();
    constructor(boundedCapacity: int);
    constructor(collection: IProducerConsumerCollection_1<T>, boundedCapacity: int);
    constructor(collection: IProducerConsumerCollection_1<T>);
    readonly boundedCapacity: int;
    readonly count: int;
    readonly isAddingCompleted: boolean;
    readonly isCompleted: boolean;
    add(item: T): void;
    add(item: T, cancellationToken: CancellationToken): void;
    completeAdding(): void;
    copyTo(array: T[], index: int): void;
    dispose(): void;
    getConsumingEnumerable(): IEnumerable_1<T>;
    getConsumingEnumerable(cancellationToken: CancellationToken): IEnumerable_1<T>;
    take(): T;
    take(cancellationToken: CancellationToken): T;
    toArray(): T[];
    tryAdd(item: T): boolean;
    tryAdd(item: T, timeout: TimeSpan): boolean;
    tryAdd(item: T, millisecondsTimeout: int): boolean;
    tryAdd(item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    tryTake(item: { value: TSByRef<T> }): boolean;
    tryTake(item: { value: TSByRef<T> }, timeout: TimeSpan): boolean;
    tryTake(item: { value: TSByRef<T> }, millisecondsTimeout: int): boolean;
    tryTake(item: { value: TSByRef<T> }, millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    static AddToAny<T>(collections: BlockingCollection_1<T>[], item: T, cancellationToken: CancellationToken): int;
    static AddToAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
    static TakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: TSByRef<T> }, cancellationToken: CancellationToken): int;
    static TakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: TSByRef<T> }): int;
    static TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    static TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int): int;
    static TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, timeout: TimeSpan): int;
    static TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
    static TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: TSByRef<T> }, millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    static TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: TSByRef<T> }, millisecondsTimeout: int): int;
    static TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: TSByRef<T> }, timeout: TimeSpan): int;
    static TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: { value: TSByRef<T> }): int;
}


export interface __BlockingCollection_1$views<T> {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type BlockingCollection_1<T> = BlockingCollection_1$instance<T> & __BlockingCollection_1$views<T>;


export class ConcurrentBag_1$instance<T> {
    constructor();
    constructor(collection: IEnumerable_1<T>);
    readonly count: int;
    readonly isEmpty: boolean;
    add(item: T): void;
    clear(): void;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    toArray(): T[];
    tryPeek(result: { value: TSByRef<T> }): boolean;
    tryTake(result: { value: TSByRef<T> }): boolean;
}


export interface __ConcurrentBag_1$views<T> {
    readonly As_IProducerConsumerCollection_1: IProducerConsumerCollection_1$instance<T>;
    readonly As_IEnumerable_1: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentBag_1<T> = ConcurrentBag_1$instance<T> & __ConcurrentBag_1$views<T>;


export class ConcurrentDictionary_2$instance<TKey, TValue> {
    constructor();
    constructor(concurrencyLevel: int, capacity: int);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>);
    constructor(comparer: IEqualityComparer_1<TKey>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>);
    constructor(concurrencyLevel: int, collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>);
    constructor(concurrencyLevel: int, capacity: int, comparer: IEqualityComparer_1<TKey>);
    readonly comparer: IEqualityComparer_1<TKey>;
    readonly count: int;
    readonly isEmpty: boolean;
    item: TValue;
    readonly keys: ICollection_1<TKey>;
    readonly values: ICollection_1<TValue>;
    addOrUpdate<TArg>(key: TKey, addValueFactory: Func_3<TKey, TArg, TValue>, updateValueFactory: Func_4<TKey, TValue, TArg, TValue>, factoryArgument: TArg): TValue;
    addOrUpdate(key: TKey, addValueFactory: Func_2<TKey, TValue>, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    addOrUpdate(key: TKey, addValue: TValue, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    clear(): void;
    containsKey(key: TKey): boolean;
    getAlternateLookup<TAlternateKey>(): ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    getOrAdd(key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    getOrAdd<TArg>(key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    getOrAdd(key: TKey, value: TValue): TValue;
    toArray(): KeyValuePair_2<TKey, TValue>[];
    tryAdd(key: TKey, value: TValue): boolean;
    tryGetAlternateLookup<TAlternateKey>(lookup: { value: TSByRef<ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>> }): boolean;
    tryGetValue(key: TKey, value: { value: TSByRef<TValue> }): boolean;
    tryRemove(key: TKey, value: { value: TSByRef<TValue> }): boolean;
    tryRemove(item: KeyValuePair_2<TKey, TValue>): boolean;
    tryUpdate(key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
}


export interface __ConcurrentDictionary_2$views<TKey, TValue> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentDictionary_2<TKey, TValue> = ConcurrentDictionary_2$instance<TKey, TValue> & __ConcurrentDictionary_2$views<TKey, TValue>;


export class ConcurrentQueue_1$instance<T> {
    constructor();
    constructor(collection: IEnumerable_1<T>);
    readonly count: int;
    readonly isEmpty: boolean;
    clear(): void;
    copyTo(array: T[], index: int): void;
    enqueue(item: T): void;
    getEnumerator(): IEnumerator_1<T>;
    toArray(): T[];
    tryDequeue(result: { value: TSByRef<T> }): boolean;
    tryPeek(result: { value: TSByRef<T> }): boolean;
}


export interface __ConcurrentQueue_1$views<T> {
    readonly As_IProducerConsumerCollection_1: IProducerConsumerCollection_1$instance<T>;
    readonly As_IEnumerable_1: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentQueue_1<T> = ConcurrentQueue_1$instance<T> & __ConcurrentQueue_1$views<T>;


export class ConcurrentStack_1$instance<T> {
    constructor();
    constructor(collection: IEnumerable_1<T>);
    readonly count: int;
    readonly isEmpty: boolean;
    clear(): void;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    push(item: T): void;
    pushRange(items: T[]): void;
    pushRange(items: T[], startIndex: int, count: int): void;
    toArray(): T[];
    tryPeek(result: { value: TSByRef<T> }): boolean;
    tryPop(result: { value: TSByRef<T> }): boolean;
    tryPopRange(items: T[]): int;
    tryPopRange(items: T[], startIndex: int, count: int): int;
}


export interface __ConcurrentStack_1$views<T> {
    readonly As_IProducerConsumerCollection_1: IProducerConsumerCollection_1$instance<T>;
    readonly As_IEnumerable_1: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentStack_1<T> = ConcurrentStack_1$instance<T> & __ConcurrentStack_1$views<T>;


export abstract class OrderablePartitioner_1$instance<TSource> extends Partitioner_1$instance<TSource> {
    readonly keysNormalized: boolean;
    readonly keysOrderedAcrossPartitions: boolean;
    readonly keysOrderedInEachPartition: boolean;
    getDynamicPartitions(): IEnumerable_1<TSource>;
    getDynamicPartitions(): IEnumerable_1<TSource>;
    getOrderableDynamicPartitions(): IEnumerable_1<KeyValuePair_2<CLROf<long>, TSource>>;
    abstract getOrderablePartitions(partitionCount: int): IList_1<IEnumerator_1<KeyValuePair_2<CLROf<long>, TSource>>>;
    getPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
    getPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
}


export type OrderablePartitioner_1<TSource> = OrderablePartitioner_1$instance<TSource>;

export abstract class Partitioner_1$instance<TSource> {
    readonly supportsDynamicPartitions: boolean;
    getDynamicPartitions(): IEnumerable_1<TSource>;
    abstract getPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
}


export type Partitioner_1<TSource> = Partitioner_1$instance<TSource>;

export abstract class Partitioner$instance {
    static Create<TSource>(source: IEnumerable_1<TSource>, partitionerOptions: EnumerablePartitionerOptions): OrderablePartitioner_1<TSource>;
    static Create<TSource>(source: IEnumerable_1<TSource>): OrderablePartitioner_1<TSource>;
    static Create<TSource>(list: IList_1<TSource>, loadBalance: boolean): OrderablePartitioner_1<TSource>;
    static Create(fromInclusive: int, toExclusive: int, rangeSize: int): OrderablePartitioner_1<Tuple_2<CLROf<int>, CLROf<int>>>;
    static Create(fromInclusive: int, toExclusive: int): OrderablePartitioner_1<Tuple_2<CLROf<int>, CLROf<int>>>;
    static Create(fromInclusive: long, toExclusive: long, rangeSize: long): OrderablePartitioner_1<Tuple_2<CLROf<long>, CLROf<long>>>;
    static Create(fromInclusive: long, toExclusive: long): OrderablePartitioner_1<Tuple_2<CLROf<long>, CLROf<long>>>;
    static Create<TSource>(array: TSource[], loadBalance: boolean): OrderablePartitioner_1<TSource>;
}


export type Partitioner = Partitioner$instance;

