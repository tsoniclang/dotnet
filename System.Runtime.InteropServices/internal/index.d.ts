// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices
// Assembly: System.Collections.Immutable, System.Private.CoreLib, System.Runtime.InteropServices, System.Memory, System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as Microsoft_Win32_SafeHandles_Internal from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { SafeHandleZeroOrMinusOneIsInvalid } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { MemoryManager_1, ReadOnlySequence_1, ReadOnlySequenceSegment_1, SequenceReader_1 } from "../../System.Buffers/internal/index.js";
import type { Dictionary_2, Dictionary_2_AlternateLookup_1, IEnumerable_1, IList_1, IReadOnlyDictionary_2, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1, ImmutableArray_1_Builder } from "../../System.Collections.Immutable/internal/index.js";
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { NumberStyles } from "../../System.Globalization/internal/index.js";
import * as System_Numerics_Internal from "../../System.Numerics/internal/index.js";
import type { IAdditionOperators_3, IAdditiveIdentity_2, IBinaryFloatingPointIeee754_1, IBinaryInteger_1, IBinaryNumber_1, IBitwiseOperators_3, IComparisonOperators_3, IDecrementOperators_1, IDivisionOperators_3, IEqualityOperators_3, IExponentialFunctions_1, IFloatingPoint_1, IFloatingPointConstants_1, IFloatingPointIeee754_1, IHyperbolicFunctions_1, IIncrementOperators_1, ILogarithmicFunctions_1, IMinMaxValue_1, IModulusOperators_3, IMultiplicativeIdentity_2, IMultiplyOperators_3, INumber_1, INumberBase_1, IPowerFunctions_1, IRootFunctions_1, ISignedNumber_1, ISubtractionOperators_3, ITrigonometricFunctions_1, IUnaryNegationOperators_2, IUnaryPlusOperators_2 } from "../../System.Numerics/internal/index.js";
import { EventInfo } from "../../System.Reflection/internal/index.js";
import * as System_Reflection_Internal from "../../System.Reflection/internal/index.js";
import type { Assembly, CustomAttributeData, EventAttributes, ICustomAttributeProvider, MemberInfo, MemberTypes, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { ITypeInfo } from "../../System.Runtime.InteropServices.ComTypes/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { JsonElement, JsonProperty } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, ArraySegment_1, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Double, Enum, Exception, Guid, IAsyncResult, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MidpointRounding, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, RuntimeTypeHandle, Single, Span_1, String as ClrString, SystemException, Type, TypeCode, UInt32, UInt64, UIntPtr, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum Architecture {
    X86 = 0,
    X64 = 1,
    Arm = 2,
    Arm64 = 3,
    Wasm = 4,
    S390x = 5,
    LoongArch64 = 6,
    Armv6 = 7,
    Ppc64le = 8,
    RiscV64 = 9
}


export enum AssemblyRegistrationFlags {
    None = 0,
    SetCodeBase = 1
}


export enum CallingConvention {
    Winapi = 1,
    Cdecl = 2,
    StdCall = 3,
    ThisCall = 4,
    FastCall = 5
}


export enum CharSet {
    None = 1,
    Ansi = 2,
    Unicode = 3,
    Auto = 4
}


export enum ClassInterfaceType {
    None = 0,
    AutoDispatch = 1,
    AutoDual = 2
}


export enum ComInterfaceType {
    InterfaceIsDual = 0,
    InterfaceIsIUnknown = 1,
    InterfaceIsIDispatch = 2,
    InterfaceIsIInspectable = 3
}


export enum ComMemberType {
    Method = 0,
    PropGet = 1,
    PropSet = 2
}


export enum CreateComInterfaceFlags {
    None = 0,
    CallerDefinedIUnknown = 1,
    TrackerSupport = 2
}


export enum CreatedWrapperFlags {
    None = 0,
    TrackerObject = 1,
    NonWrapping = 2
}


export enum CreateObjectFlags {
    None = 0,
    TrackerObject = 1,
    UniqueInstance = 2,
    Aggregation = 4,
    Unwrap = 8
}


export enum CustomQueryInterfaceMode {
    Ignore = 0,
    Allow = 1
}


export enum CustomQueryInterfaceResult {
    Handled = 0,
    NotHandled = 1,
    Failed = 2
}


export enum DllImportSearchPath {
    UseDllDirectoryForDependencies = 256,
    ApplicationDirectory = 512,
    UserDirectories = 1024,
    System32 = 2048,
    SafeDirectories = 4096,
    AssemblyDirectory = 2,
    LegacyBehavior = 0
}


export enum ExporterEventKind {
    NOTIF_TYPECONVERTED = 0,
    NOTIF_CONVERTWARNING = 1,
    ERROR_REFTOINVALIDASSEMBLY = 2
}


export enum GCHandleType {
    Weak = 0,
    WeakTrackResurrection = 1,
    Normal = 2,
    Pinned = 3
}


export enum LayoutKind {
    Sequential = 0,
    Explicit = 2,
    Auto = 3
}


export enum PosixSignal {
    SIGHUP = -1,
    SIGINT = -2,
    SIGQUIT = -3,
    SIGTERM = -4,
    SIGCHLD = -5,
    SIGCONT = -6,
    SIGWINCH = -7,
    SIGTTIN = -8,
    SIGTTOU = -9,
    SIGTSTP = -10
}


export enum RegistrationClassContext {
    InProcessServer = 1,
    InProcessHandler = 2,
    LocalServer = 4,
    InProcessServer16 = 8,
    RemoteServer = 16,
    InProcessHandler16 = 32,
    Reserved1 = 64,
    Reserved2 = 128,
    Reserved3 = 256,
    Reserved4 = 512,
    NoCodeDownload = 1024,
    Reserved5 = 2048,
    NoCustomMarshal = 4096,
    EnableCodeDownload = 8192,
    NoFailureLog = 16384,
    DisableActivateAsActivator = 32768,
    EnableActivateAsActivator = 65536,
    FromDefaultContext = 131072
}


export enum RegistrationConnectionType {
    SingleUse = 0,
    MultipleUse = 1,
    MultiSeparate = 2,
    Suspended = 4,
    Surrogate = 8
}


export enum StringMarshalling {
    Custom = 0,
    Utf8 = 1,
    Utf16 = 2
}


export enum TypeLibFuncFlags {
    FRestricted = 1,
    FSource = 2,
    FBindable = 4,
    FRequestEdit = 8,
    FDisplayBind = 16,
    FDefaultBind = 32,
    FHidden = 64,
    FUsesGetLastError = 128,
    FDefaultCollelem = 256,
    FUiDefault = 512,
    FNonBrowsable = 1024,
    FReplaceable = 2048,
    FImmediateBind = 4096
}


export enum TypeLibTypeFlags {
    FAppObject = 1,
    FCanCreate = 2,
    FLicensed = 4,
    FPreDeclId = 8,
    FHidden = 16,
    FControl = 32,
    FDual = 64,
    FNonExtensible = 128,
    FOleAutomation = 256,
    FRestricted = 512,
    FAggregatable = 1024,
    FReplaceable = 2048,
    FDispatchable = 4096,
    FReverseBind = 8192
}


export enum TypeLibVarFlags {
    FReadOnly = 1,
    FSource = 2,
    FBindable = 4,
    FRequestEdit = 8,
    FDisplayBind = 16,
    FDefaultBind = 32,
    FHidden = 64,
    FRestricted = 128,
    FDefaultCollelem = 256,
    FUiDefault = 512,
    FNonBrowsable = 1024,
    FReplaceable = 2048,
    FImmediateBind = 4096
}


export enum UnmanagedType {
    Bool = 2,
    I1 = 3,
    U1 = 4,
    I2 = 5,
    U2 = 6,
    I4 = 7,
    U4 = 8,
    I8 = 9,
    U8 = 10,
    R4 = 11,
    R8 = 12,
    Currency = 15,
    BStr = 19,
    LPStr = 20,
    LPWStr = 21,
    LPTStr = 22,
    ByValTStr = 23,
    IUnknown = 25,
    IDispatch = 26,
    Struct = 27,
    Interface = 28,
    SafeArray = 29,
    ByValArray = 30,
    SysInt = 31,
    SysUInt = 32,
    VBByRefStr = 34,
    AnsiBStr = 35,
    TBStr = 36,
    VariantBool = 37,
    FunctionPtr = 38,
    AsAny = 40,
    LPArray = 42,
    LPStruct = 43,
    CustomMarshaler = 44,
    Error = 45,
    IInspectable = 46,
    HString = 47,
    LPUTF8Str = 48
}


export enum VarEnum {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VECTOR = 4096,
    VT_ARRAY = 8192,
    VT_BYREF = 16384
}


export interface ICustomAdapter$instance {
    GetUnderlyingObject(): any;
}


export type ICustomAdapter = ICustomAdapter$instance;

export interface ICustomFactory$instance {
    CreateInstance(serverType: Type): MarshalByRefObject;
}


export type ICustomFactory = ICustomFactory$instance;

export interface ICustomMarshaler$instance {
    CleanUpManagedData(ManagedObj: any): void;
    CleanUpNativeData(pNativeData: nint): void;
    GetNativeDataSize(): int;
    MarshalManagedToNative(ManagedObj: any): nint;
    MarshalNativeToManaged(pNativeData: nint): any;
}


export type ICustomMarshaler = ICustomMarshaler$instance;

export interface ICustomQueryInterface$instance {
    GetInterface(iid: { value: TSByRef<Guid> }, ppv: { value: TSByRef<nint> }): CustomQueryInterfaceResult;
}


export type ICustomQueryInterface = ICustomQueryInterface$instance;

export interface IDynamicInterfaceCastable$instance {
    GetInterfaceImplementation(interfaceType: RuntimeTypeHandle): RuntimeTypeHandle;
    IsInterfaceImplemented(interfaceType: RuntimeTypeHandle, throwIfNotImplemented: boolean): boolean;
}


export type IDynamicInterfaceCastable = IDynamicInterfaceCastable$instance;

export class ArrayWithOffset$instance {
    constructor(array: any, offset: int);
    Equals(obj: any): boolean;
    Equals(obj: ArrayWithOffset): boolean;
    GetArray(): any;
    GetHashCode(): int;
    GetOffset(): int;
}


export interface __ArrayWithOffset$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ArrayWithOffset>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ArrayWithOffset): boolean;
}

export type ArrayWithOffset = ArrayWithOffset$instance & __ArrayWithOffset$views;


export class CLong$instance {
    constructor(value: int);
    constructor(value: nint);
    readonly Value: nint;
    Equals(o: any): boolean;
    Equals(other: CLong): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export interface __CLong$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CLong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CLong): boolean;
}

export type CLong = CLong$instance & __CLong$views;


export class ComWrappers_ComInterfaceDispatch$instance {
    Vtable: nint;
    static GetInstance<T>(dispatchPtr: TSUnsafePointer<ComWrappers_ComInterfaceDispatch>): T;
}


export type ComWrappers_ComInterfaceDispatch = ComWrappers_ComInterfaceDispatch$instance;

export class ComWrappers_ComInterfaceEntry$instance {
    IID: Guid;
    Vtable: nint;
}


export type ComWrappers_ComInterfaceEntry = ComWrappers_ComInterfaceEntry$instance;

export class CULong$instance {
    constructor(value: uint);
    constructor(value: nuint);
    readonly Value: nuint;
    Equals(o: any): boolean;
    Equals(other: CULong): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export interface __CULong$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CULong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CULong): boolean;
}

export type CULong = CULong$instance & __CULong$views;


export class GCHandle$instance {
    readonly IsAllocated: boolean;
    Target: any;
    AddrOfPinnedObject(): nint;
    Equals(o: any): boolean;
    Equals(other: GCHandle): boolean;
    Free(): void;
    GetHashCode(): int;
    static Alloc(value: any, type_: GCHandleType): GCHandle;
    static Alloc(value: any): GCHandle;
    static FromIntPtr(value: nint): GCHandle;
    static ToIntPtr(value: GCHandle): nint;
}


export interface __GCHandle$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<GCHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle): boolean;
}

export type GCHandle = GCHandle$instance & __GCHandle$views;


export class GCHandle_1$instance<T> {
    constructor(target: T);
    readonly IsAllocated: boolean;
    Target: T;
    Dispose(): void;
    Equals(obj: any): boolean;
    Equals(other: GCHandle_1<T>): boolean;
    GetHashCode(): int;
    static FromIntPtr<T>(value: nint): GCHandle_1<T>;
    static ToIntPtr<T>(value: GCHandle_1<T>): nint;
}


export interface __GCHandle_1$views<T> {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<GCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle_1<T>): boolean;
}

export type GCHandle_1<T> = GCHandle_1$instance<T> & __GCHandle_1$views<T>;


export class HandleRef$instance {
    constructor(wrapper: any, handle: nint);
    readonly Handle: nint;
    readonly Wrapper: any;
    static ToIntPtr(value: HandleRef): nint;
}


export type HandleRef = HandleRef$instance;

export class NFloat$instance {
    constructor(value: float);
    constructor(value: double);
    readonly Value: double;
    CompareTo(obj: any): int;
    CompareTo(other: NFloat): int;
    Equals(obj: any): boolean;
    Equals(other: NFloat): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(format: string): string;
    ToString(provider: IFormatProvider): string;
    ToString(format: string, provider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }, format?: ReadOnlySpan_1<CLROf<string>>, provider?: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: ReadOnlySpan_1<CLROf<string>>, provider?: IFormatProvider): boolean;
    static readonly Epsilon: NFloat;
    static readonly MaxValue: NFloat;
    static readonly MinValue: NFloat;
    static readonly NaN: NFloat;
    static readonly NegativeInfinity: NFloat;
    static readonly PositiveInfinity: NFloat;
    static readonly Size: int;
    static readonly E: NFloat;
    static readonly Pi: NFloat;
    static readonly Tau: NFloat;
    static readonly NegativeZero: NFloat;
    static Abs(value: NFloat): NFloat;
    static Acos(x: NFloat): NFloat;
    static Acosh(x: NFloat): NFloat;
    static AcosPi(x: NFloat): NFloat;
    static Asin(x: NFloat): NFloat;
    static Asinh(x: NFloat): NFloat;
    static AsinPi(x: NFloat): NFloat;
    static Atan(x: NFloat): NFloat;
    static Atan2(y: NFloat, x: NFloat): NFloat;
    static Atan2Pi(y: NFloat, x: NFloat): NFloat;
    static Atanh(x: NFloat): NFloat;
    static AtanPi(x: NFloat): NFloat;
    static BitDecrement(x: NFloat): NFloat;
    static BitIncrement(x: NFloat): NFloat;
    static Cbrt(x: NFloat): NFloat;
    static Ceiling(x: NFloat): NFloat;
    static Clamp(value: NFloat, min: NFloat, max: NFloat): NFloat;
    static ClampNative(value: NFloat, min: NFloat, max: NFloat): NFloat;
    static ConvertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    static ConvertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    static CopySign(value: NFloat, sign: NFloat): NFloat;
    static Cos(x: NFloat): NFloat;
    static Cosh(x: NFloat): NFloat;
    static CosPi(x: NFloat): NFloat;
    static CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static DegreesToRadians(degrees: NFloat): NFloat;
    static Exp(x: NFloat): NFloat;
    static Exp10(x: NFloat): NFloat;
    static Exp10M1(x: NFloat): NFloat;
    static Exp2(x: NFloat): NFloat;
    static Exp2M1(x: NFloat): NFloat;
    static ExpM1(x: NFloat): NFloat;
    static Floor(x: NFloat): NFloat;
    static FusedMultiplyAdd(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    static Hypot(x: NFloat, y: NFloat): NFloat;
    static Ieee754Remainder(left: NFloat, right: NFloat): NFloat;
    static ILogB(x: NFloat): int;
    static IsEvenInteger(value: NFloat): boolean;
    static IsFinite(value: NFloat): boolean;
    static IsInfinity(value: NFloat): boolean;
    static IsInteger(value: NFloat): boolean;
    static IsNaN(value: NFloat): boolean;
    static IsNegative(value: NFloat): boolean;
    static IsNegativeInfinity(value: NFloat): boolean;
    static IsNormal(value: NFloat): boolean;
    static IsOddInteger(value: NFloat): boolean;
    static IsPositive(value: NFloat): boolean;
    static IsPositiveInfinity(value: NFloat): boolean;
    static IsPow2(value: NFloat): boolean;
    static IsRealNumber(value: NFloat): boolean;
    static IsSubnormal(value: NFloat): boolean;
    static Lerp(value1: NFloat, value2: NFloat, amount: NFloat): NFloat;
    static Log(x: NFloat, newBase: NFloat): NFloat;
    static Log(x: NFloat): NFloat;
    static Log10(x: NFloat): NFloat;
    static Log10P1(x: NFloat): NFloat;
    static Log2(value: NFloat): NFloat;
    static Log2P1(x: NFloat): NFloat;
    static LogP1(x: NFloat): NFloat;
    static Max(x: NFloat, y: NFloat): NFloat;
    static MaxMagnitude(x: NFloat, y: NFloat): NFloat;
    static MaxMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    static MaxNative(x: NFloat, y: NFloat): NFloat;
    static MaxNumber(x: NFloat, y: NFloat): NFloat;
    static Min(x: NFloat, y: NFloat): NFloat;
    static MinMagnitude(x: NFloat, y: NFloat): NFloat;
    static MinMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    static MinNative(x: NFloat, y: NFloat): NFloat;
    static MinNumber(x: NFloat, y: NFloat): NFloat;
    static MultiplyAddEstimate(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    static Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    static Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): NFloat;
    static Parse(s: ReadOnlySpan_1<CLROf<string>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    static Parse(s: ReadOnlySpan_1<CLROf<string>>, provider: IFormatProvider): NFloat;
    static Parse(s: string, style: NumberStyles, provider: IFormatProvider): NFloat;
    static Parse(s: string, style: NumberStyles): NFloat;
    static Parse(s: string, provider: IFormatProvider): NFloat;
    static Parse(s: string): NFloat;
    static Pow(x: NFloat, y: NFloat): NFloat;
    static RadiansToDegrees(radians: NFloat): NFloat;
    static ReciprocalEstimate(x: NFloat): NFloat;
    static ReciprocalSqrtEstimate(x: NFloat): NFloat;
    static RootN(x: NFloat, n: int): NFloat;
    static Round(x: NFloat, digits: int, mode: MidpointRounding): NFloat;
    static Round(x: NFloat, digits: int): NFloat;
    static Round(x: NFloat, mode: MidpointRounding): NFloat;
    static Round(x: NFloat): NFloat;
    static ScaleB(x: NFloat, n: int): NFloat;
    static Sign(value: NFloat): int;
    static Sin(x: NFloat): NFloat;
    static SinCos(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    static SinCosPi(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    static Sinh(x: NFloat): NFloat;
    static SinPi(x: NFloat): NFloat;
    static Sqrt(x: NFloat): NFloat;
    static Tan(x: NFloat): NFloat;
    static Tanh(x: NFloat): NFloat;
    static TanPi(x: NFloat): NFloat;
    static Truncate(x: NFloat): NFloat;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(s: ReadOnlySpan_1<CLROf<string>>, style: NumberStyles, provider: IFormatProvider, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(s: ReadOnlySpan_1<CLROf<string>>, provider: IFormatProvider, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(s: ReadOnlySpan_1<CLROf<string>>, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(s: string, provider: IFormatProvider, result: { value: TSByRef<NFloat> }): boolean;
    static TryParse(s: string, result: { value: TSByRef<NFloat> }): boolean;
}


export interface __NFloat$views {
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IComparable_1_of_Decimal: System_Internal.IComparable_1$instance<NFloat>;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<NFloat>;
    readonly As_IFormattable: System_Internal.IFormattable$instance;
    readonly As_IParsable_1_of_Decimal: System_Internal.IParsable_1$instance<any>;
    readonly As_ISpanParsable_1_of_Decimal: System_Internal.ISpanParsable_1$instance<any>;
    readonly As_IUtf8SpanFormattable: System_Internal.IUtf8SpanFormattable$instance;
    readonly As_IUtf8SpanParsable_1_of_Decimal: System_Internal.IUtf8SpanParsable_1$instance<any>;
    readonly As_IAdditiveIdentity_2: System_Numerics_Internal.IAdditiveIdentity_2$instance<any, any>;
    readonly As_IFloatingPoint_1: System_Numerics_Internal.IFloatingPoint_1$instance<any>;
    readonly As_IMinMaxValue_1: System_Numerics_Internal.IMinMaxValue_1$instance<any>;
    readonly As_INumber_1: System_Numerics_Internal.INumber_1$instance<any>;
    readonly As_INumberBase_1: System_Numerics_Internal.INumberBase_1$instance<any>;
    readonly As_IRootFunctions_1: System_Numerics_Internal.IRootFunctions_1$instance<NFloat>;
    readonly As_ITrigonometricFunctions_1_of_Double: System_Numerics_Internal.ITrigonometricFunctions_1$instance<NFloat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: NFloat): boolean;
    CompareTo(obj: any): int;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<string>>, charsWritten: { value: TSByRef<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<string>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
}

export type NFloat = NFloat$instance & __NFloat$views;


export class OSPlatform$instance {
    Equals(other: OSPlatform): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly FreeBSD: OSPlatform;
    static readonly Linux: OSPlatform;
    static readonly OSX: OSPlatform;
    static readonly Windows: OSPlatform;
    static Create(osPlatform: string): OSPlatform;
}


export interface __OSPlatform$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<OSPlatform>;

    // Structural method bridges for numeric interface constraints
    Equals(other: OSPlatform): boolean;
}

export type OSPlatform = OSPlatform$instance & __OSPlatform$views;


export class PinnedGCHandle_1$instance<T> {
    constructor(target: T);
    readonly IsAllocated: boolean;
    Target: T;
    Dispose(): void;
    Equals(obj: any): boolean;
    Equals(other: PinnedGCHandle_1<T>): boolean;
    GetAddressOfObjectData(): TSUnsafePointer<void>;
    GetHashCode(): int;
    static FromIntPtr<T>(value: nint): PinnedGCHandle_1<T>;
    static ToIntPtr<T>(value: PinnedGCHandle_1<T>): nint;
}


export interface __PinnedGCHandle_1$views<T> {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<PinnedGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PinnedGCHandle_1<T>): boolean;
}

export type PinnedGCHandle_1<T> = PinnedGCHandle_1$instance<T> & __PinnedGCHandle_1$views<T>;


export class WeakGCHandle_1$instance<T> {
    constructor(target: T, trackResurrection: boolean);
    readonly IsAllocated: boolean;
    Dispose(): void;
    Equals(obj: any): boolean;
    Equals(other: WeakGCHandle_1<T>): boolean;
    GetHashCode(): int;
    SetTarget(target: T): void;
    TryGetTarget(target: { value: TSByRef<T> }): boolean;
    static FromIntPtr<T>(value: nint): WeakGCHandle_1<T>;
    static ToIntPtr<T>(value: WeakGCHandle_1<T>): nint;
}


export interface __WeakGCHandle_1$views<T> {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<WeakGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: WeakGCHandle_1<T>): boolean;
}

export type WeakGCHandle_1<T> = WeakGCHandle_1$instance<T> & __WeakGCHandle_1$views<T>;


export class AllowReversePInvokeCallsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type AllowReversePInvokeCallsAttribute = AllowReversePInvokeCallsAttribute$instance;

export class AutomationProxyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(val: boolean);
    readonly Value: boolean;
}


export type AutomationProxyAttribute = AutomationProxyAttribute$instance;

export class BestFitMappingAttribute$instance extends System_Internal.Attribute$instance {
    constructor(BestFitMapping: boolean);
    ThrowOnUnmappableChar: boolean;
    readonly BestFitMapping: boolean;
}


export type BestFitMappingAttribute = BestFitMappingAttribute$instance;

export class BStrWrapper$instance {
    constructor(value: string);
    constructor(value: any);
    readonly WrappedObject: string;
}


export type BStrWrapper = BStrWrapper$instance;

export class ClassInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(classInterfaceType: ClassInterfaceType);
    constructor(classInterfaceType: short);
    readonly Value: ClassInterfaceType;
}


export type ClassInterfaceAttribute = ClassInterfaceAttribute$instance;

export class CoClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor(coClass: Type);
    readonly CoClass: Type;
}


export type CoClassAttribute = CoClassAttribute$instance;

export class ComAliasNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(alias: string);
    readonly Value: string;
}


export type ComAliasNameAttribute = ComAliasNameAttribute$instance;

export class ComAwareEventInfo$instance extends System_Reflection_Internal.EventInfo$instance {
    constructor(type_: Type, eventName: string);
    readonly Attributes: EventAttributes;
    readonly DeclaringType: Type;
    readonly MetadataToken: int;
    readonly Module: Module;
    readonly Name: string;
    readonly ReflectedType: Type;
    AddEventHandler(target: any, handler: Function): void;
    GetAddMethod(nonPublic: boolean): MethodInfo;
    GetAddMethod(): MethodInfo;
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetOtherMethods(nonPublic: boolean): MethodInfo[];
    GetOtherMethods(): MethodInfo[];
    GetRaiseMethod(nonPublic: boolean): MethodInfo;
    GetRaiseMethod(): MethodInfo;
    GetRemoveMethod(nonPublic: boolean): MethodInfo;
    GetRemoveMethod(): MethodInfo;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    RemoveEventHandler(target: any, handler: Function): void;
}


export interface __ComAwareEventInfo$views {
    readonly As_ICustomAttributeProvider: System_Reflection_Internal.ICustomAttributeProvider$instance;
}

export type ComAwareEventInfo = ComAwareEventInfo$instance & __ComAwareEventInfo$views;


export class ComCompatibleVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int, build: int, revision: int);
    readonly BuildNumber: int;
    readonly MajorVersion: int;
    readonly MinorVersion: int;
    readonly RevisionNumber: int;
}


export type ComCompatibleVersionAttribute = ComCompatibleVersionAttribute$instance;

export class ComConversionLossAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComConversionLossAttribute = ComConversionLossAttribute$instance;

export class ComDefaultInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(defaultInterface: Type);
    readonly Value: Type;
}


export type ComDefaultInterfaceAttribute = ComDefaultInterfaceAttribute$instance;

export class ComEventInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(SourceInterface: Type, EventProvider: Type);
    readonly EventProvider: Type;
    readonly SourceInterface: Type;
}


export type ComEventInterfaceAttribute = ComEventInterfaceAttribute$instance;

export class COMException$instance extends ExternalException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, errorCode: int);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export interface __COMException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type COMException = COMException$instance & __COMException$views;


export class ComImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComImportAttribute = ComImportAttribute$instance;

export class ComRegisterFunctionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComRegisterFunctionAttribute = ComRegisterFunctionAttribute$instance;

export class ComSourceInterfacesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(sourceInterfaces: string);
    constructor(sourceInterface: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type, sourceInterface4: Type);
    readonly Value: string;
}


export type ComSourceInterfacesAttribute = ComSourceInterfacesAttribute$instance;

export class ComUnregisterFunctionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComUnregisterFunctionAttribute = ComUnregisterFunctionAttribute$instance;

export class ComVisibleAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visibility: boolean);
    readonly Value: boolean;
}


export type ComVisibleAttribute = ComVisibleAttribute$instance;

export abstract class ComWrappers$instance {
    GetOrCreateComInterfaceForObject(instance: any, flags: CreateComInterfaceFlags): nint;
    GetOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags): any;
    GetOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, userState: any): any;
    GetOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: any): any;
    GetOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: any, inner: nint): any;
    static GetIUnknownImpl(fpQueryInterface: { value: TSByRef<nint> }, fpAddRef: { value: TSByRef<nint> }, fpRelease: { value: TSByRef<nint> }): void;
    static RegisterForMarshalling(instance: ComWrappers): void;
    static RegisterForTrackerSupport(instance: ComWrappers): void;
    static TryGetComInstance(obj: any, unknown_: { value: TSByRef<nint> }): boolean;
    static TryGetObject(unknown_: nint, obj: { value: TSByRef<any> }): boolean;
}


export type ComWrappers = ComWrappers$instance;

export abstract class CriticalHandle$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    readonly IsClosed: boolean;
    readonly IsInvalid: boolean;
    Close(): void;
    Dispose(): void;
    SetHandleAsInvalid(): void;
}


export interface __CriticalHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type CriticalHandle = CriticalHandle$instance & __CriticalHandle$views;


export class CurrencyWrapper$instance {
    constructor(obj: decimal);
    constructor(obj: any);
    readonly WrappedObject: decimal;
}


export type CurrencyWrapper = CurrencyWrapper$instance;

export class DefaultCharSetAttribute$instance extends System_Internal.Attribute$instance {
    constructor(charSet: CharSet);
    readonly CharSet: CharSet;
}


export type DefaultCharSetAttribute = DefaultCharSetAttribute$instance;

export class DefaultDllImportSearchPathsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(paths: DllImportSearchPath);
    readonly Paths: DllImportSearchPath;
}


export type DefaultDllImportSearchPathsAttribute = DefaultDllImportSearchPathsAttribute$instance;

export class DefaultParameterValueAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: any);
    readonly Value: any;
}


export type DefaultParameterValueAttribute = DefaultParameterValueAttribute$instance;

export class DispatchWrapper$instance {
    constructor(obj: any);
    readonly WrappedObject: any;
}


export type DispatchWrapper = DispatchWrapper$instance;

export class DispIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dispId: int);
    readonly Value: int;
}


export type DispIdAttribute = DispIdAttribute$instance;

export class DllImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dllName: string);
    EntryPoint: string;
    CharSet: CharSet;
    SetLastError: boolean;
    ExactSpelling: boolean;
    CallingConvention: CallingConvention;
    BestFitMapping: boolean;
    PreserveSig: boolean;
    ThrowOnUnmappableChar: boolean;
    readonly Value: string;
}


export type DllImportAttribute = DllImportAttribute$instance;

export class DllImportResolver$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): nint;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
}


export interface __DllImportResolver$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DllImportResolver = DllImportResolver$instance & __DllImportResolver$views;


export class DynamicInterfaceCastableImplementationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DynamicInterfaceCastableImplementationAttribute = DynamicInterfaceCastableImplementationAttribute$instance;

export class ErrorWrapper$instance {
    constructor(errorCode: int);
    constructor(errorCode: any);
    constructor(e: Exception);
    readonly ErrorCode: int;
}


export type ErrorWrapper = ErrorWrapper$instance;

export class ExternalException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, errorCode: int);
    readonly ErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export interface __ExternalException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExternalException = ExternalException$instance & __ExternalException$views;


export class FieldOffsetAttribute$instance extends System_Internal.Attribute$instance {
    constructor(offset: int);
    readonly Value: int;
}


export type FieldOffsetAttribute = FieldOffsetAttribute$instance;

export class GuidAttribute$instance extends System_Internal.Attribute$instance {
    constructor(guid: string);
    readonly Value: string;
}


export type GuidAttribute = GuidAttribute$instance;

export class HandleCollector$instance {
    constructor(name: string, initialThreshold: int);
    constructor(name: string, initialThreshold: int, maximumThreshold: int);
    readonly Count: int;
    readonly InitialThreshold: int;
    readonly MaximumThreshold: int;
    readonly Name: string;
    Add(): void;
    Remove(): void;
}


export type HandleCollector = HandleCollector$instance;

export class ImportedFromTypeLibAttribute$instance extends System_Internal.Attribute$instance {
    constructor(tlbFile: string);
    readonly Value: string;
}


export type ImportedFromTypeLibAttribute = ImportedFromTypeLibAttribute$instance;

export class InAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type InAttribute = InAttribute$instance;

export class InterfaceTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(interfaceType: ComInterfaceType);
    constructor(interfaceType: short);
    readonly Value: ComInterfaceType;
}


export type InterfaceTypeAttribute = InterfaceTypeAttribute$instance;

export class InvalidComObjectException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidComObjectException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidComObjectException = InvalidComObjectException$instance & __InvalidComObjectException$views;


export class InvalidOleVariantTypeException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidOleVariantTypeException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidOleVariantTypeException = InvalidOleVariantTypeException$instance & __InvalidOleVariantTypeException$views;


export class LCIDConversionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(lcid: int);
    readonly Value: int;
}


export type LCIDConversionAttribute = LCIDConversionAttribute$instance;

export class LibraryImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor(libraryName: string);
    EntryPoint: string;
    readonly LibraryName: string;
    SetLastError: boolean;
    StringMarshalling: StringMarshalling;
    StringMarshallingCustomType: Type;
}


export type LibraryImportAttribute = LibraryImportAttribute$instance;

export class ManagedToNativeComInteropStubAttribute$instance extends System_Internal.Attribute$instance {
    constructor(classType: Type, methodName: string);
    readonly ClassType: Type;
    readonly MethodName: string;
}


export type ManagedToNativeComInteropStubAttribute = ManagedToNativeComInteropStubAttribute$instance;

export class MarshalAsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(unmanagedType: UnmanagedType);
    constructor(unmanagedType: short);
    SafeArraySubType: VarEnum;
    SafeArrayUserDefinedSubType: Type;
    IidParameterIndex: int;
    ArraySubType: UnmanagedType;
    SizeParamIndex: short;
    SizeConst: int;
    MarshalType: string;
    MarshalTypeRef: Type;
    MarshalCookie: string;
    readonly Value: UnmanagedType;
}


export type MarshalAsAttribute = MarshalAsAttribute$instance;

export class MarshalDirectiveException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MarshalDirectiveException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MarshalDirectiveException = MarshalDirectiveException$instance & __MarshalDirectiveException$views;


export class OptionalAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OptionalAttribute = OptionalAttribute$instance;

export class OutAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OutAttribute = OutAttribute$instance;

export class PosixSignalContext$instance {
    constructor(signal: PosixSignal);
    Cancel: boolean;
    readonly Signal: PosixSignal;
}


export type PosixSignalContext = PosixSignalContext$instance;

export class PosixSignalRegistration$instance {
    Dispose(): void;
    static Create(signal: PosixSignal, handler: Action_1<PosixSignalContext>): PosixSignalRegistration;
}


export interface __PosixSignalRegistration$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type PosixSignalRegistration = PosixSignalRegistration$instance & __PosixSignalRegistration$views;


export class PreserveSigAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type PreserveSigAttribute = PreserveSigAttribute$instance;

export class PrimaryInteropAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int);
    readonly MajorVersion: int;
    readonly MinorVersion: int;
}


export type PrimaryInteropAssemblyAttribute = PrimaryInteropAssemblyAttribute$instance;

export class ProgIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(progId: string);
    readonly Value: string;
}


export type ProgIdAttribute = ProgIdAttribute$instance;

export class SafeArrayRankMismatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SafeArrayRankMismatchException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayRankMismatchException = SafeArrayRankMismatchException$instance & __SafeArrayRankMismatchException$views;


export class SafeArrayTypeMismatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SafeArrayTypeMismatchException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayTypeMismatchException = SafeArrayTypeMismatchException$instance & __SafeArrayTypeMismatchException$views;


export abstract class SafeBuffer$instance extends Microsoft_Win32_SafeHandles_Internal.SafeHandleZeroOrMinusOneIsInvalid$instance {
    readonly ByteLength: ulong;
    AcquirePointer(pointer: { value: TSByRef<TSUnsafePointer<byte>> }): void;
    Dispose(): void;
    Initialize(numBytes: ulong): void;
    Initialize(numElements: uint, sizeOfEachElement: uint): void;
    Initialize<T extends any>(numElements: uint): void;
    Read<T extends any>(byteOffset: ulong): T;
    ReadArray<T extends any>(byteOffset: ulong, array: T[], index: int, count: int): void;
    ReadSpan<T extends any>(byteOffset: ulong, buffer: Span_1<T>): void;
    ReleasePointer(): void;
    Write<T extends any>(byteOffset: ulong, value: T): void;
    WriteArray<T extends any>(byteOffset: ulong, array: T[], index: int, count: int): void;
    WriteSpan<T extends any>(byteOffset: ulong, data: ReadOnlySpan_1<T>): void;
}


export interface __SafeBuffer$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SafeBuffer = SafeBuffer$instance & __SafeBuffer$views;


export abstract class SafeHandle$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    readonly IsClosed: boolean;
    readonly IsInvalid: boolean;
    Close(): void;
    DangerousAddRef(success: { value: TSByRef<boolean> }): void;
    DangerousGetHandle(): nint;
    DangerousRelease(): void;
    Dispose(): void;
    SetHandleAsInvalid(): void;
}


export interface __SafeHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SafeHandle = SafeHandle$instance & __SafeHandle$views;


export class SEHException$instance extends ExternalException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    CanResume(): boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SEHException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SEHException = SEHException$instance & __SEHException$views;


export class StandardOleMarshalObject$instance extends System_Internal.MarshalByRefObject$instance {
}


export type StandardOleMarshalObject = StandardOleMarshalObject$instance;

export class StructLayoutAttribute$instance extends System_Internal.Attribute$instance {
    constructor(layoutKind: LayoutKind);
    constructor(layoutKind: short);
    Pack: int;
    Size: int;
    CharSet: CharSet;
    readonly Value: LayoutKind;
}


export type StructLayoutAttribute = StructLayoutAttribute$instance;

export class SuppressGCTransitionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SuppressGCTransitionAttribute = SuppressGCTransitionAttribute$instance;

export class TypeIdentifierAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(scope: string, identifier: string);
    readonly Identifier: string;
    readonly Scope: string;
}


export type TypeIdentifierAttribute = TypeIdentifierAttribute$instance;

export class TypeLibFuncAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibFuncFlags);
    constructor(flags: short);
    readonly Value: TypeLibFuncFlags;
}


export type TypeLibFuncAttribute = TypeLibFuncAttribute$instance;

export class TypeLibImportClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor(importClass: Type);
    readonly Value: string;
}


export type TypeLibImportClassAttribute = TypeLibImportClassAttribute$instance;

export class TypeLibTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibTypeFlags);
    constructor(flags: short);
    readonly Value: TypeLibTypeFlags;
}


export type TypeLibTypeAttribute = TypeLibTypeAttribute$instance;

export class TypeLibVarAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibVarFlags);
    constructor(flags: short);
    readonly Value: TypeLibVarFlags;
}


export type TypeLibVarAttribute = TypeLibVarAttribute$instance;

export class TypeLibVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int);
    readonly MajorVersion: int;
    readonly MinorVersion: int;
}


export type TypeLibVersionAttribute = TypeLibVersionAttribute$instance;

export class TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(assemblyName: string);
}


export type TypeMapAssemblyTargetAttribute_1<TTypeMapGroup> = TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup>;

export class TypeMapAssociationAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(source: Type, proxy: Type);
}


export type TypeMapAssociationAttribute_1<TTypeMapGroup> = TypeMapAssociationAttribute_1$instance<TTypeMapGroup>;

export class TypeMapAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(value: string, target: Type);
    constructor(value: string, target: Type, trimTarget: Type);
}


export type TypeMapAttribute_1<TTypeMapGroup> = TypeMapAttribute_1$instance<TTypeMapGroup>;

export class UnknownWrapper$instance {
    constructor(obj: any);
    readonly WrappedObject: any;
}


export type UnknownWrapper = UnknownWrapper$instance;

export class UnmanagedCallConvAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    CallConvs: Type[];
}


export type UnmanagedCallConvAttribute = UnmanagedCallConvAttribute$instance;

export class UnmanagedCallersOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    CallConvs: Type[];
    EntryPoint: string;
}


export type UnmanagedCallersOnlyAttribute = UnmanagedCallersOnlyAttribute$instance;

export class UnmanagedFunctionPointerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(callingConvention: CallingConvention);
    BestFitMapping: boolean;
    SetLastError: boolean;
    ThrowOnUnmappableChar: boolean;
    CharSet: CharSet;
    readonly CallingConvention: CallingConvention;
}


export type UnmanagedFunctionPointerAttribute = UnmanagedFunctionPointerAttribute$instance;

export class VariantWrapper$instance {
    constructor(obj: any);
    readonly WrappedObject: any;
}


export type VariantWrapper = VariantWrapper$instance;

export class WasmImportLinkageAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type WasmImportLinkageAttribute = WasmImportLinkageAttribute$instance;

export abstract class CollectionsMarshal$instance {
    static AsBytes(array: BitArray): Span_1<CLROf<byte>>;
    static AsSpan<T>(list: List_1<T>): Span_1<T>;
    static GetValueRefOrAddDefault<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey, exists: { value: TSByRef<boolean> }): TSByRef<TValue>;
    static GetValueRefOrAddDefault<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey, exists: { value: TSByRef<boolean> }): TSByRef<TValue>;
    static GetValueRefOrNullRef<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey): TSByRef<TValue>;
    static GetValueRefOrNullRef<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey): TSByRef<TValue>;
    static SetCount<T>(list: List_1<T>, count: int): void;
}


export type CollectionsMarshal = CollectionsMarshal$instance;

export abstract class ComEventsHelper$instance {
    static Combine(rcw: any, iid: Guid, dispid: int, d: Function): void;
    static Remove(rcw: any, iid: Guid, dispid: int, d: Function): Function;
}


export type ComEventsHelper = ComEventsHelper$instance;

export abstract class GCHandleExtensions$instance {
    static GetAddressOfArrayData<T>(handle: PinnedGCHandle_1<T[]>): TSUnsafePointer<T>;
    static GetAddressOfStringData(handle: PinnedGCHandle_1<CLROf<string>>): TSUnsafePointer<string>;
}


export type GCHandleExtensions = GCHandleExtensions$instance;

export abstract class ImmutableCollectionsMarshal$instance {
    static AsArray<T>(array: ImmutableArray_1<T>): T[];
    static AsImmutableArray<T>(array: T[]): ImmutableArray_1<T>;
    static AsMemory<T>(builder: ImmutableArray_1_Builder<T>): Memory_1<T>;
}


export type ImmutableCollectionsMarshal = ImmutableCollectionsMarshal$instance;

export abstract class JsonMarshal$instance {
    static GetRawUtf8PropertyName(property: JsonProperty): ReadOnlySpan_1<CLROf<byte>>;
    static GetRawUtf8Value(element: JsonElement): ReadOnlySpan_1<CLROf<byte>>;
}


export type JsonMarshal = JsonMarshal$instance;

export abstract class Marshal$instance {
    static readonly SystemDefaultCharSize: int;
    static readonly SystemMaxDBCSCharSize: int;
    static AddRef(pUnk: nint): int;
    static AllocCoTaskMem(cb: int): nint;
    static AllocHGlobal(cb: int): nint;
    static AllocHGlobal(cb: nint): nint;
    static AreComObjectsAvailableForCleanup(): boolean;
    static BindToMoniker(monikerName: string): any;
    static ChangeWrapperHandleStrength(otp: any, fIsWeak: boolean): void;
    static CleanupUnusedObjectsInCurrentContext(): void;
    static Copy(source: byte[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: string[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: double[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: short[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: int[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: long[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: nint, destination: byte[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: string[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: double[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: short[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: int[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: long[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: nint[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: float[], startIndex: int, length: int): void;
    static Copy(source: nint[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: float[], startIndex: int, destination: nint, length: int): void;
    static CreateAggregatedObject(pOuter: nint, o: any): nint;
    static CreateAggregatedObject<T>(pOuter: nint, o: T): nint;
    static CreateWrapperOfType(o: any, t: Type): any;
    static CreateWrapperOfType<T, TWrapper>(o: T): TWrapper;
    static DestroyStructure(ptr: nint, structuretype: Type): void;
    static DestroyStructure<T>(ptr: nint): void;
    static FinalReleaseComObject(o: any): int;
    static FreeBSTR(ptr: nint): void;
    static FreeCoTaskMem(ptr: nint): void;
    static FreeHGlobal(hglobal: nint): void;
    static GenerateGuidForType(type_: Type): Guid;
    static GenerateProgIdForType(type_: Type): string;
    static GetComInterfaceForObject(o: any, T: Type, mode: CustomQueryInterfaceMode): nint;
    static GetComInterfaceForObject(o: any, T: Type): nint;
    static GetComInterfaceForObject<T, TInterface>(o: T): nint;
    static GetComObjectData(obj: any, key: any): any;
    static GetDelegateForFunctionPointer(ptr: nint, t: Type): Function;
    static GetDelegateForFunctionPointer<TDelegate>(ptr: nint): TDelegate;
    static GetEndComSlot(t: Type): int;
    static GetExceptionCode(): int;
    static GetExceptionForHR(errorCode: int, iid: { value: TSByRef<Guid> }, pUnk: nint): Exception;
    static GetExceptionForHR(errorCode: int, errorInfo: nint): Exception;
    static GetExceptionForHR(errorCode: int): Exception;
    static GetExceptionPointers(): nint;
    static GetFunctionPointerForDelegate(d: Function): nint;
    static GetFunctionPointerForDelegate<TDelegate>(d: TDelegate): nint;
    static GetHINSTANCE(m: Module): nint;
    static GetHRForException(e: Exception): int;
    static GetHRForLastWin32Error(): int;
    static GetIDispatchForObject(o: any): nint;
    static GetIUnknownForObject(o: any): nint;
    static GetLastPInvokeError(): int;
    static GetLastPInvokeErrorMessage(): string;
    static GetLastSystemError(): int;
    static GetLastWin32Error(): int;
    static GetNativeVariantForObject(obj: any, pDstNativeVariant: nint): void;
    static GetNativeVariantForObject<T>(obj: T, pDstNativeVariant: nint): void;
    static GetObjectForIUnknown(pUnk: nint): any;
    static GetObjectForNativeVariant(pSrcNativeVariant: nint): any;
    static GetObjectForNativeVariant<T>(pSrcNativeVariant: nint): T;
    static GetObjectsForNativeVariants(aSrcNativeVariant: nint, cVars: int): any[];
    static GetObjectsForNativeVariants<T>(aSrcNativeVariant: nint, cVars: int): T[];
    static GetPInvokeErrorMessage(error: int): string;
    static GetStartComSlot(t: Type): int;
    static GetTypedObjectForIUnknown(pUnk: nint, t: Type): any;
    static GetTypeFromCLSID(clsid: Guid): Type;
    static GetTypeInfoName(typeInfo: ITypeInfo): string;
    static GetUniqueObjectForIUnknown(unknown_: nint): any;
    static InitHandle(safeHandle: SafeHandle, handle: nint): void;
    static IsComObject(o: any): boolean;
    static IsTypeVisibleFromCom(t: Type): boolean;
    static OffsetOf<T>(fieldName: string): nint;
    static OffsetOf(t: Type, fieldName: string): nint;
    static Prelink(m: MethodInfo): void;
    static PrelinkAll(c: Type): void;
    static PtrToStringAnsi(ptr: nint, len: int): string;
    static PtrToStringAnsi(ptr: nint): string;
    static PtrToStringAuto(ptr: nint, len: int): string;
    static PtrToStringAuto(ptr: nint): string;
    static PtrToStringBSTR(ptr: nint): string;
    static PtrToStringUni(ptr: nint, len: int): string;
    static PtrToStringUni(ptr: nint): string;
    static PtrToStringUTF8(ptr: nint, byteLen: int): string;
    static PtrToStringUTF8(ptr: nint): string;
    static PtrToStructure(ptr: nint, structure: any): void;
    static PtrToStructure(ptr: nint, structureType: Type): any;
    static PtrToStructure<T>(ptr: nint, structure: T): void;
    static PtrToStructure<T>(ptr: nint): T;
    static QueryInterface(pUnk: nint, iid: { value: TSByRef<Guid> }, ppv: { value: TSByRef<nint> }): int;
    static ReadByte(ptr: nint, ofs: int): byte;
    static ReadByte(ptr: nint): byte;
    static ReadByte(ptr: any, ofs: int): byte;
    static ReadInt16(ptr: nint, ofs: int): short;
    static ReadInt16(ptr: nint): short;
    static ReadInt16(ptr: any, ofs: int): short;
    static ReadInt32(ptr: nint, ofs: int): int;
    static ReadInt32(ptr: nint): int;
    static ReadInt32(ptr: any, ofs: int): int;
    static ReadInt64(ptr: nint, ofs: int): long;
    static ReadInt64(ptr: nint): long;
    static ReadInt64(ptr: any, ofs: int): long;
    static ReadIntPtr(ptr: nint, ofs: int): nint;
    static ReadIntPtr(ptr: nint): nint;
    static ReadIntPtr(ptr: any, ofs: int): nint;
    static ReAllocCoTaskMem(pv: nint, cb: int): nint;
    static ReAllocHGlobal(pv: nint, cb: nint): nint;
    static Release(pUnk: nint): int;
    static ReleaseComObject(o: any): int;
    static SecureStringToBSTR(s: SecureString): nint;
    static SecureStringToCoTaskMemAnsi(s: SecureString): nint;
    static SecureStringToCoTaskMemUnicode(s: SecureString): nint;
    static SecureStringToGlobalAllocAnsi(s: SecureString): nint;
    static SecureStringToGlobalAllocUnicode(s: SecureString): nint;
    static SetComObjectData(obj: any, key: any, data: any): boolean;
    static SetLastPInvokeError(error: int): void;
    static SetLastSystemError(error: int): void;
    static SizeOf<T>(): int;
    static SizeOf(structure: any): int;
    static SizeOf(t: Type): int;
    static SizeOf<T>(structure: T): int;
    static StringToBSTR(s: string): nint;
    static StringToCoTaskMemAnsi(s: string): nint;
    static StringToCoTaskMemAuto(s: string): nint;
    static StringToCoTaskMemUni(s: string): nint;
    static StringToCoTaskMemUTF8(s: string): nint;
    static StringToHGlobalAnsi(s: string): nint;
    static StringToHGlobalAuto(s: string): nint;
    static StringToHGlobalUni(s: string): nint;
    static StructureToPtr(structure: any, ptr: nint, fDeleteOld: boolean): void;
    static StructureToPtr<T>(structure: T, ptr: nint, fDeleteOld: boolean): void;
    static ThrowExceptionForHR(errorCode: int, iid: { value: TSByRef<Guid> }, pUnk: nint): void;
    static ThrowExceptionForHR(errorCode: int, errorInfo: nint): void;
    static ThrowExceptionForHR(errorCode: int): void;
    static UnsafeAddrOfPinnedArrayElement(arr: ClrArray, index: int): nint;
    static UnsafeAddrOfPinnedArrayElement<T>(arr: T[], index: int): nint;
    static WriteByte(ptr: nint, val: byte): void;
    static WriteByte(ptr: nint, ofs: int, val: byte): void;
    static WriteByte(ptr: any, ofs: int, val: byte): void;
    static WriteInt16(ptr: nint, val: string): void;
    static WriteInt16(ptr: nint, val: short): void;
    static WriteInt16(ptr: nint, ofs: int, val: string): void;
    static WriteInt16(ptr: nint, ofs: int, val: short): void;
    static WriteInt16(ptr: { value: any }, ofs: int, val: string): void;
    static WriteInt16(ptr: any, ofs: int, val: short): void;
    static WriteInt32(ptr: nint, ofs: int, val: int): void;
    static WriteInt32(ptr: nint, val: int): void;
    static WriteInt32(ptr: any, ofs: int, val: int): void;
    static WriteInt64(ptr: nint, ofs: int, val: long): void;
    static WriteInt64(ptr: nint, val: long): void;
    static WriteInt64(ptr: any, ofs: int, val: long): void;
    static WriteIntPtr(ptr: nint, ofs: int, val: nint): void;
    static WriteIntPtr(ptr: nint, val: nint): void;
    static WriteIntPtr(ptr: any, ofs: int, val: nint): void;
    static ZeroFreeBSTR(s: nint): void;
    static ZeroFreeCoTaskMemAnsi(s: nint): void;
    static ZeroFreeCoTaskMemUnicode(s: nint): void;
    static ZeroFreeCoTaskMemUTF8(s: nint): void;
    static ZeroFreeGlobalAllocAnsi(s: nint): void;
    static ZeroFreeGlobalAllocUnicode(s: nint): void;
}


export type Marshal = Marshal$instance;

export abstract class MemoryMarshal$instance {
    static AsBytes<T extends any>(span: ReadOnlySpan_1<T>): ReadOnlySpan_1<CLROf<byte>>;
    static AsBytes<T extends any>(span: Span_1<T>): Span_1<CLROf<byte>>;
    static AsMemory<T>(memory: ReadOnlyMemory_1<T>): Memory_1<T>;
    static AsRef<T extends any>(span: ReadOnlySpan_1<CLROf<byte>>): TSByRef<T>;
    static AsRef<T extends any>(span: Span_1<CLROf<byte>>): TSByRef<T>;
    static Cast<TFrom extends any, TTo extends any>(span: ReadOnlySpan_1<TFrom>): ReadOnlySpan_1<TTo>;
    static Cast<TFrom extends any, TTo extends any>(span: Span_1<TFrom>): Span_1<TTo>;
    static CreateFromPinnedArray<T>(array: T[], start: int, length: int): Memory_1<T>;
    static CreateReadOnlySpan<T>(reference: { value: TSByRef<T> }, length: int): ReadOnlySpan_1<T>;
    static CreateReadOnlySpanFromNullTerminated(value: TSUnsafePointer<byte>): ReadOnlySpan_1<CLROf<byte>>;
    static CreateReadOnlySpanFromNullTerminated(value: TSUnsafePointer<string>): ReadOnlySpan_1<CLROf<string>>;
    static CreateSpan<T>(reference: { value: TSByRef<T> }, length: int): Span_1<T>;
    static GetArrayDataReference(array: ClrArray): TSByRef<byte>;
    static GetArrayDataReference<T>(array: T[]): TSByRef<T>;
    static GetReference<T>(span: ReadOnlySpan_1<T>): TSByRef<T>;
    static GetReference<T>(span: Span_1<T>): TSByRef<T>;
    static Read<T extends any>(source: ReadOnlySpan_1<CLROf<byte>>): T;
    static ToEnumerable<T>(memory: ReadOnlyMemory_1<T>): IEnumerable_1<T>;
    static TryGetArray<T>(memory: ReadOnlyMemory_1<T>, segment: { value: TSByRef<ArraySegment_1<T>> }): boolean;
    static TryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: TSByRef<TManager> }, start: { value: TSByRef<int> }, length: { value: TSByRef<int> }): boolean;
    static TryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: TSByRef<TManager> }): boolean;
    static TryGetString(memory: ReadOnlyMemory_1<CLROf<string>>, text: { value: TSByRef<string> }, start: { value: TSByRef<int> }, length: { value: TSByRef<int> }): boolean;
    static TryRead<T extends any>(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<T> }): boolean;
    static TryWrite<T extends any>(destination: Span_1<CLROf<byte>>, value: { value: TSByRef<T> }): boolean;
    static Write<T extends any>(destination: Span_1<CLROf<byte>>, value: { value: TSByRef<T> }): void;
}


export type MemoryMarshal = MemoryMarshal$instance;

export abstract class NativeLibrary$instance {
    static Free(handle: nint): void;
    static GetExport(handle: nint, name: string): nint;
    static GetMainProgramHandle(): nint;
    static Load(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
    static Load(libraryPath: string): nint;
    static SetDllImportResolver(assembly: Assembly, resolver: DllImportResolver): void;
    static TryGetExport(handle: nint, name: string, address: { value: TSByRef<nint> }): boolean;
    static TryLoad(libraryPath: string, handle: { value: TSByRef<nint> }): boolean;
    static TryLoad(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, handle: { value: TSByRef<nint> }): boolean;
}


export type NativeLibrary = NativeLibrary$instance;

export abstract class NativeMemory$instance {
    static AlignedAlloc(byteCount: nuint, alignment: nuint): TSUnsafePointer<void>;
    static AlignedFree(ptr: TSUnsafePointer<void>): void;
    static AlignedRealloc(ptr: TSUnsafePointer<void>, byteCount: nuint, alignment: nuint): TSUnsafePointer<void>;
    static Alloc(elementCount: nuint, elementSize: nuint): TSUnsafePointer<void>;
    static Alloc(byteCount: nuint): TSUnsafePointer<void>;
    static AllocZeroed(elementCount: nuint, elementSize: nuint): TSUnsafePointer<void>;
    static AllocZeroed(byteCount: nuint): TSUnsafePointer<void>;
    static Clear(ptr: TSUnsafePointer<void>, byteCount: nuint): void;
    static Copy(source: TSUnsafePointer<void>, destination: TSUnsafePointer<void>, byteCount: nuint): void;
    static Fill(ptr: TSUnsafePointer<void>, byteCount: nuint, value: byte): void;
    static Free(ptr: TSUnsafePointer<void>): void;
    static Realloc(ptr: TSUnsafePointer<void>, byteCount: nuint): TSUnsafePointer<void>;
}


export type NativeMemory = NativeMemory$instance;

export abstract class RuntimeEnvironment$instance {
    static readonly SystemConfigurationFile: string;
    static FromGlobalAccessCache(a: Assembly): boolean;
    static GetRuntimeDirectory(): string;
    static GetRuntimeInterfaceAsIntPtr(clsid: Guid, riid: Guid): nint;
    static GetRuntimeInterfaceAsObject(clsid: Guid, riid: Guid): any;
    static GetSystemVersion(): string;
}


export type RuntimeEnvironment = RuntimeEnvironment$instance;

export abstract class RuntimeInformation$instance {
    static readonly RuntimeIdentifier: string;
    static readonly ProcessArchitecture: Architecture;
    static readonly OSDescription: string;
    static readonly OSArchitecture: Architecture;
    static readonly FrameworkDescription: string;
    static IsOSPlatform(osPlatform: OSPlatform): boolean;
}


export type RuntimeInformation = RuntimeInformation$instance;

export abstract class SequenceMarshal$instance {
    static TryGetArray<T>(sequence: ReadOnlySequence_1<T>, segment: { value: TSByRef<ArraySegment_1<T>> }): boolean;
    static TryGetReadOnlyMemory<T>(sequence: ReadOnlySequence_1<T>, memory: { value: TSByRef<ReadOnlyMemory_1<T>> }): boolean;
    static TryGetReadOnlySequenceSegment<T>(sequence: ReadOnlySequence_1<T>, startSegment: { value: TSByRef<ReadOnlySequenceSegment_1<T>> }, startIndex: { value: TSByRef<int> }, endSegment: { value: TSByRef<ReadOnlySequenceSegment_1<T>> }, endIndex: { value: TSByRef<int> }): boolean;
    static TryRead<T extends any>(reader: { value: TSByRef<SequenceReader_1<CLROf<byte>>> }, value: { value: TSByRef<T> }): boolean;
}


export type SequenceMarshal = SequenceMarshal$instance;

export abstract class TypeMapping$instance {
    static GetOrCreateExternalTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<CLROf<string>, Type>;
    static GetOrCreateProxyTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<Type, Type>;
}


export type TypeMapping = TypeMapping$instance;

