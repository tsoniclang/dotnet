// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices
// Assembly: System.Collections.Immutable, System.Memory, System.Private.CoreLib, System.Runtime.InteropServices, System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as Microsoft_Win32_SafeHandles_Internal from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { SafeHandleZeroOrMinusOneIsInvalid } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { MemoryManager_1, ReadOnlySequence_1, ReadOnlySequenceSegment_1, SequenceReader_1 } from "../../System.Buffers/internal/index.js";
import type { Dictionary_2, Dictionary_2_AlternateLookup_1, IEnumerable_1, IList_1, IReadOnlyDictionary_2, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1, ImmutableArray_1_Builder } from "../../System.Collections.Immutable/internal/index.js";
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { NumberStyles } from "../../System.Globalization/internal/index.js";
import * as System_Numerics_Internal from "../../System.Numerics/internal/index.js";
import type { IAdditionOperators_3, IAdditiveIdentity_2, IBinaryFloatingPointIeee754_1, IBinaryInteger_1, IBinaryNumber_1, IBitwiseOperators_3, IComparisonOperators_3, IDecrementOperators_1, IDivisionOperators_3, IEqualityOperators_3, IExponentialFunctions_1, IFloatingPoint_1, IFloatingPointConstants_1, IFloatingPointIeee754_1, IHyperbolicFunctions_1, IIncrementOperators_1, ILogarithmicFunctions_1, IMinMaxValue_1, IModulusOperators_3, IMultiplicativeIdentity_2, IMultiplyOperators_3, INumber_1, INumberBase_1, IPowerFunctions_1, IRootFunctions_1, ISignedNumber_1, ISubtractionOperators_3, ITrigonometricFunctions_1, IUnaryNegationOperators_2, IUnaryPlusOperators_2 } from "../../System.Numerics/internal/index.js";
import { EventInfo } from "../../System.Reflection/internal/index.js";
import * as System_Reflection_Internal from "../../System.Reflection/internal/index.js";
import type { Assembly, CustomAttributeData, EventAttributes, ICustomAttributeProvider, MemberInfo, MemberTypes, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { ITypeInfo } from "../../System.Runtime.InteropServices.ComTypes/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { JsonElement, JsonProperty } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, ArraySegment_1, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Double, Enum, Exception, Guid, IAsyncResult, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MidpointRounding, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, RuntimeTypeHandle, Single, Span_1, String as ClrString, SystemException, Type, TypeCode, UInt32, UInt64, UIntPtr, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum Architecture {
    x86 = 0,
    x64 = 1,
    arm = 2,
    arm64 = 3,
    wasm = 4,
    s390x = 5,
    loongArch64 = 6,
    armv6 = 7,
    ppc64le = 8,
    riscV64 = 9
}


export enum AssemblyRegistrationFlags {
    none = 0,
    setCodeBase = 1
}


export enum CallingConvention {
    winapi = 1,
    cdecl = 2,
    stdCall = 3,
    thisCall = 4,
    fastCall = 5
}


export enum CharSet {
    none = 1,
    ansi = 2,
    unicode = 3,
    auto = 4
}


export enum ClassInterfaceType {
    none = 0,
    autoDispatch = 1,
    autoDual = 2
}


export enum ComInterfaceType {
    interfaceIsDual = 0,
    interfaceIsIUnknown = 1,
    interfaceIsIDispatch = 2,
    interfaceIsIInspectable = 3
}


export enum ComMemberType {
    method = 0,
    propGet = 1,
    propSet = 2
}


export enum CreateComInterfaceFlags {
    none = 0,
    callerDefinedIUnknown = 1,
    trackerSupport = 2
}


export enum CreatedWrapperFlags {
    none = 0,
    trackerObject = 1,
    nonWrapping = 2
}


export enum CreateObjectFlags {
    none = 0,
    trackerObject = 1,
    uniqueInstance = 2,
    aggregation = 4,
    unwrap = 8
}


export enum CustomQueryInterfaceMode {
    ignore = 0,
    allow = 1
}


export enum CustomQueryInterfaceResult {
    handled = 0,
    notHandled = 1,
    failed = 2
}


export enum DllImportSearchPath {
    useDllDirectoryForDependencies = 256,
    applicationDirectory = 512,
    userDirectories = 1024,
    system32 = 2048,
    safeDirectories = 4096,
    assemblyDirectory = 2,
    legacyBehavior = 0
}


export enum ExporterEventKind {
    notif_typeconverted = 0,
    notif_convertwarning = 1,
    error_reftoinvalidassembly = 2
}


export enum GCHandleType {
    weak = 0,
    weakTrackResurrection = 1,
    normal = 2,
    pinned = 3
}


export enum LayoutKind {
    sequential = 0,
    explicit = 2,
    auto = 3
}


export enum PosixSignal {
    sighup = -1,
    sigint = -2,
    sigquit = -3,
    sigterm = -4,
    sigchld = -5,
    sigcont = -6,
    sigwinch = -7,
    sigttin = -8,
    sigttou = -9,
    sigtstp = -10
}


export enum RegistrationClassContext {
    inProcessServer = 1,
    inProcessHandler = 2,
    localServer = 4,
    inProcessServer16 = 8,
    remoteServer = 16,
    inProcessHandler16 = 32,
    reserved1 = 64,
    reserved2 = 128,
    reserved3 = 256,
    reserved4 = 512,
    noCodeDownload = 1024,
    reserved5 = 2048,
    noCustomMarshal = 4096,
    enableCodeDownload = 8192,
    noFailureLog = 16384,
    disableActivateAsActivator = 32768,
    enableActivateAsActivator = 65536,
    fromDefaultContext = 131072
}


export enum RegistrationConnectionType {
    singleUse = 0,
    multipleUse = 1,
    multiSeparate = 2,
    suspended = 4,
    surrogate = 8
}


export enum StringMarshalling {
    custom = 0,
    utf8 = 1,
    utf16 = 2
}


export enum TypeLibFuncFlags {
    fRestricted = 1,
    fSource = 2,
    fBindable = 4,
    fRequestEdit = 8,
    fDisplayBind = 16,
    fDefaultBind = 32,
    fHidden = 64,
    fUsesGetLastError = 128,
    fDefaultCollelem = 256,
    fUiDefault = 512,
    fNonBrowsable = 1024,
    fReplaceable = 2048,
    fImmediateBind = 4096
}


export enum TypeLibTypeFlags {
    fAppObject = 1,
    fCanCreate = 2,
    fLicensed = 4,
    fPreDeclId = 8,
    fHidden = 16,
    fControl = 32,
    fDual = 64,
    fNonExtensible = 128,
    fOleAutomation = 256,
    fRestricted = 512,
    fAggregatable = 1024,
    fReplaceable = 2048,
    fDispatchable = 4096,
    fReverseBind = 8192
}


export enum TypeLibVarFlags {
    fReadOnly = 1,
    fSource = 2,
    fBindable = 4,
    fRequestEdit = 8,
    fDisplayBind = 16,
    fDefaultBind = 32,
    fHidden = 64,
    fRestricted = 128,
    fDefaultCollelem = 256,
    fUiDefault = 512,
    fNonBrowsable = 1024,
    fReplaceable = 2048,
    fImmediateBind = 4096
}


export enum UnmanagedType {
    bool = 2,
    i1 = 3,
    u1 = 4,
    i2 = 5,
    u2 = 6,
    i4 = 7,
    u4 = 8,
    i8 = 9,
    u8 = 10,
    r4 = 11,
    r8 = 12,
    currency = 15,
    bStr = 19,
    lpStr = 20,
    lpwStr = 21,
    lptStr = 22,
    byValTStr = 23,
    iUnknown = 25,
    iDispatch = 26,
    struct = 27,
    interface_ = 28,
    safeArray = 29,
    byValArray = 30,
    sysInt = 31,
    sysUInt = 32,
    vbByRefStr = 34,
    ansiBStr = 35,
    tbStr = 36,
    variantBool = 37,
    functionPtr = 38,
    asAny = 40,
    lpArray = 42,
    lpStruct = 43,
    customMarshaler = 44,
    error = 45,
    iInspectable = 46,
    hString = 47,
    lputf8Str = 48
}


export enum VarEnum {
    vt_empty = 0,
    vt_null = 1,
    vt_i2 = 2,
    vt_i4 = 3,
    vt_r4 = 4,
    vt_r8 = 5,
    vt_cy = 6,
    vt_date = 7,
    vt_bstr = 8,
    vt_dispatch = 9,
    vt_error = 10,
    vt_bool = 11,
    vt_variant = 12,
    vt_unknown = 13,
    vt_decimal = 14,
    vt_i1 = 16,
    vt_ui1 = 17,
    vt_ui2 = 18,
    vt_ui4 = 19,
    vt_i8 = 20,
    vt_ui8 = 21,
    vt_int = 22,
    vt_uint = 23,
    vt_void = 24,
    vt_hresult = 25,
    vt_ptr = 26,
    vt_safearray = 27,
    vt_carray = 28,
    vt_userdefined = 29,
    vt_lpstr = 30,
    vt_lpwstr = 31,
    vt_record = 36,
    vt_filetime = 64,
    vt_blob = 65,
    vt_stream = 66,
    vt_storage = 67,
    vt_streamed_object = 68,
    vt_stored_object = 69,
    vt_blob_object = 70,
    vt_cf = 71,
    vt_clsid = 72,
    vt_vector = 4096,
    vt_array = 8192,
    vt_byref = 16384
}


export interface ICustomAdapter$instance {
    getUnderlyingObject(): unknown;
}


export type ICustomAdapter = ICustomAdapter$instance;

export interface ICustomFactory$instance {
    createInstance(serverType: Type): MarshalByRefObject;
}


export type ICustomFactory = ICustomFactory$instance;

export interface ICustomMarshaler$instance {
    cleanUpManagedData(ManagedObj: unknown): void;
    cleanUpNativeData(pNativeData: nint): void;
    getNativeDataSize(): int;
    marshalManagedToNative(ManagedObj: unknown): nint;
    marshalNativeToManaged(pNativeData: nint): unknown;
}


export type ICustomMarshaler = ICustomMarshaler$instance;

export interface ICustomQueryInterface$instance {
    getInterface(iid: { value: ref<Guid> }, ppv: { value: ref<nint> }): CustomQueryInterfaceResult;
}


export type ICustomQueryInterface = ICustomQueryInterface$instance;

export interface IDynamicInterfaceCastable$instance {
    getInterfaceImplementation(interfaceType: RuntimeTypeHandle): RuntimeTypeHandle;
    isInterfaceImplemented(interfaceType: RuntimeTypeHandle, throwIfNotImplemented: boolean): boolean;
}


export type IDynamicInterfaceCastable = IDynamicInterfaceCastable$instance;

export class ArrayWithOffset$instance {
    constructor(array: unknown, offset: int);
    equals(obj: unknown): boolean;
    equals(obj: ArrayWithOffset): boolean;
    getArray(): unknown;
    getHashCode(): int;
    getOffset(): int;
}


export interface __ArrayWithOffset$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ArrayWithOffset>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ArrayWithOffset): boolean;
}

export type ArrayWithOffset = ArrayWithOffset$instance & __ArrayWithOffset$views;


export class CLong$instance {
    constructor(value: int);
    constructor(value: nint);
    readonly value: nint;
    equals(o: unknown): boolean;
    equals(other: CLong): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __CLong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CLong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CLong): boolean;
}

export type CLong = CLong$instance & __CLong$views;


export class ComWrappers_ComInterfaceDispatch$instance {
    vtable: nint;
    static getInstance<T>(dispatchPtr: ptr<ComWrappers_ComInterfaceDispatch>): T;
}


export type ComWrappers_ComInterfaceDispatch = ComWrappers_ComInterfaceDispatch$instance;

export class ComWrappers_ComInterfaceEntry$instance {
    iid: Guid;
    vtable: nint;
}


export type ComWrappers_ComInterfaceEntry = ComWrappers_ComInterfaceEntry$instance;

export class CULong$instance {
    constructor(value: uint);
    constructor(value: nuint);
    readonly value: nuint;
    equals(o: unknown): boolean;
    equals(other: CULong): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __CULong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CULong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CULong): boolean;
}

export type CULong = CULong$instance & __CULong$views;


export class GCHandle$instance {
    readonly isAllocated: boolean;
    target: unknown;
    addrOfPinnedObject(): nint;
    equals(o: unknown): boolean;
    equals(other: GCHandle): boolean;
    free(): void;
    getHashCode(): int;
    static alloc(value: unknown, type_: GCHandleType): GCHandle;
    static alloc(value: unknown): GCHandle;
    static fromIntPtr(value: nint): GCHandle;
    static toIntPtr(value: GCHandle): nint;
}


export interface __GCHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle): boolean;
}

export type GCHandle = GCHandle$instance & __GCHandle$views;


export class GCHandle_1$instance<T> {
    constructor(target: T);
    readonly isAllocated: boolean;
    target: T;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: GCHandle_1<T>): boolean;
    getHashCode(): int;
    static fromIntPtr<T>(value: nint): GCHandle_1<T>;
    static toIntPtr<T>(value: GCHandle_1<T>): nint;
}


export interface __GCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle_1<T>): boolean;
}

export interface GCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type GCHandle_1<T> = GCHandle_1$instance<T> & __GCHandle_1$views<T>;


export class HandleRef$instance {
    constructor(wrapper: unknown, handle: nint);
    readonly handle: nint;
    readonly wrapper: unknown;
    static toIntPtr(value: HandleRef): nint;
}


export type HandleRef = HandleRef$instance;

export class NFloat$instance implements IBitwiseOperators_3<NFloat, NFloat, NFloat>, IComparisonOperators_3<NFloat, NFloat, CLROf<boolean>>, IEqualityOperators_3<NFloat, NFloat, CLROf<boolean>>, IModulusOperators_3<NFloat, NFloat, NFloat>, IAdditionOperators_3<NFloat, NFloat, NFloat>, IDecrementOperators_1<NFloat>, IDivisionOperators_3<NFloat, NFloat, NFloat>, IIncrementOperators_1<NFloat>, IMultiplyOperators_3<NFloat, NFloat, NFloat>, ISubtractionOperators_3<NFloat, NFloat, NFloat>, IUnaryPlusOperators_2<NFloat, NFloat>, IUnaryNegationOperators_2<NFloat, NFloat> {
    constructor(value: float);
    constructor(value: double);
    readonly value: double;
    compareTo(obj: unknown): int;
    compareTo(other: NFloat): int;
    equals(obj: unknown): boolean;
    equals(other: NFloat): boolean;
    getHashCode(): int;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly epsilon: NFloat;
    static readonly maxValue: NFloat;
    static readonly minValue: NFloat;
    static readonly naN: NFloat;
    static readonly negativeInfinity: NFloat;
    static readonly positiveInfinity: NFloat;
    static readonly size: int;
    static readonly e: NFloat;
    static readonly pi: NFloat;
    static readonly tau: NFloat;
    static readonly negativeZero: NFloat;
    static abs(value: NFloat): NFloat;
    static acos(x: NFloat): NFloat;
    static acosh(x: NFloat): NFloat;
    static acosPi(x: NFloat): NFloat;
    static asin(x: NFloat): NFloat;
    static asinh(x: NFloat): NFloat;
    static asinPi(x: NFloat): NFloat;
    static atan(x: NFloat): NFloat;
    static atan2(y: NFloat, x: NFloat): NFloat;
    static atan2Pi(y: NFloat, x: NFloat): NFloat;
    static atanh(x: NFloat): NFloat;
    static atanPi(x: NFloat): NFloat;
    static bitDecrement(x: NFloat): NFloat;
    static bitIncrement(x: NFloat): NFloat;
    static cbrt(x: NFloat): NFloat;
    static ceiling(x: NFloat): NFloat;
    static clamp(value: NFloat, min: NFloat, max: NFloat): NFloat;
    static clampNative(value: NFloat, min: NFloat, max: NFloat): NFloat;
    static convertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    static convertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    static copySign(value: NFloat, sign: NFloat): NFloat;
    static cos(x: NFloat): NFloat;
    static cosh(x: NFloat): NFloat;
    static cosPi(x: NFloat): NFloat;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static degreesToRadians(degrees: NFloat): NFloat;
    static exp(x: NFloat): NFloat;
    static exp10(x: NFloat): NFloat;
    static exp10M1(x: NFloat): NFloat;
    static exp2(x: NFloat): NFloat;
    static exp2M1(x: NFloat): NFloat;
    static expM1(x: NFloat): NFloat;
    static floor(x: NFloat): NFloat;
    static fusedMultiplyAdd(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    static hypot(x: NFloat, y: NFloat): NFloat;
    static ieee754Remainder(left: NFloat, right: NFloat): NFloat;
    static iLogB(x: NFloat): int;
    static isEvenInteger(value: NFloat): boolean;
    static isFinite(value: NFloat): boolean;
    static isInfinity(value: NFloat): boolean;
    static isInteger(value: NFloat): boolean;
    static isNaN(value: NFloat): boolean;
    static isNegative(value: NFloat): boolean;
    static isNegativeInfinity(value: NFloat): boolean;
    static isNormal(value: NFloat): boolean;
    static isOddInteger(value: NFloat): boolean;
    static isPositive(value: NFloat): boolean;
    static isPositiveInfinity(value: NFloat): boolean;
    static isPow2(value: NFloat): boolean;
    static isRealNumber(value: NFloat): boolean;
    static isSubnormal(value: NFloat): boolean;
    static lerp(value1: NFloat, value2: NFloat, amount: NFloat): NFloat;
    static log(x: NFloat, newBase: NFloat): NFloat;
    static log(x: NFloat): NFloat;
    static log10(x: NFloat): NFloat;
    static log10P1(x: NFloat): NFloat;
    static log2(value: NFloat): NFloat;
    static log2P1(x: NFloat): NFloat;
    static logP1(x: NFloat): NFloat;
    static max(x: NFloat, y: NFloat): NFloat;
    static maxMagnitude(x: NFloat, y: NFloat): NFloat;
    static maxMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    static maxNative(x: NFloat, y: NFloat): NFloat;
    static maxNumber(x: NFloat, y: NFloat): NFloat;
    static min(x: NFloat, y: NFloat): NFloat;
    static minMagnitude(x: NFloat, y: NFloat): NFloat;
    static minMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    static minNative(x: NFloat, y: NFloat): NFloat;
    static minNumber(x: NFloat, y: NFloat): NFloat;
    static multiplyAddEstimate(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    static parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    static parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): NFloat;
    static parse(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    static parse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): NFloat;
    static parse(s: string, style: NumberStyles, provider: IFormatProvider): NFloat;
    static parse(s: string, style: NumberStyles): NFloat;
    static parse(s: string, provider: IFormatProvider): NFloat;
    static parse(s: string): NFloat;
    static pow(x: NFloat, y: NFloat): NFloat;
    static radiansToDegrees(radians: NFloat): NFloat;
    static reciprocalEstimate(x: NFloat): NFloat;
    static reciprocalSqrtEstimate(x: NFloat): NFloat;
    static rootN(x: NFloat, n: int): NFloat;
    static round(x: NFloat, digits: int, mode: MidpointRounding): NFloat;
    static round(x: NFloat, digits: int): NFloat;
    static round(x: NFloat, mode: MidpointRounding): NFloat;
    static round(x: NFloat): NFloat;
    static scaleB(x: NFloat, n: int): NFloat;
    static sign(value: NFloat): int;
    static sin(x: NFloat): NFloat;
    static sinCos(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    static sinCosPi(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    static sinh(x: NFloat): NFloat;
    static sinPi(x: NFloat): NFloat;
    static sqrt(x: NFloat): NFloat;
    static tan(x: NFloat): NFloat;
    static tanh(x: NFloat): NFloat;
    static tanPi(x: NFloat): NFloat;
    static truncate(x: NFloat): NFloat;
    static tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<NFloat> }): boolean;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<NFloat> }): boolean;
    static tryParse(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static tryParse(s: string, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static tryParse(s: string, result: { value: ref<NFloat> }): boolean;
}


export interface __NFloat$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<NFloat>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<NFloat>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<NFloat>;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<NFloat>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<NFloat>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<NFloat, NFloat>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<NFloat>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<NFloat>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<NFloat>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<NFloat>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<NFloat>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<NFloat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: NFloat): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<char>>, charsWritten: { value: ref<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<char>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>): int;
}

export interface NFloat$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<NFloat> {}

export type NFloat = NFloat$instance & __NFloat$views;


export class OSPlatform$instance {
    equals(other: OSPlatform): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly freeBSD: OSPlatform;
    static readonly linux: OSPlatform;
    static readonly osx: OSPlatform;
    static readonly windows: OSPlatform;
    static create(osPlatform: string): OSPlatform;
}


export interface __OSPlatform$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<OSPlatform>;

    // Structural method bridges for numeric interface constraints
    Equals(other: OSPlatform): boolean;
}

export type OSPlatform = OSPlatform$instance & __OSPlatform$views;


export class PinnedGCHandle_1$instance<T> {
    constructor(target: T);
    readonly isAllocated: boolean;
    target: T;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: PinnedGCHandle_1<T>): boolean;
    getAddressOfObjectData(): ptr<void>;
    getHashCode(): int;
    static fromIntPtr<T>(value: nint): PinnedGCHandle_1<T>;
    static toIntPtr<T>(value: PinnedGCHandle_1<T>): nint;
}


export interface __PinnedGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PinnedGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PinnedGCHandle_1<T>): boolean;
}

export interface PinnedGCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type PinnedGCHandle_1<T> = PinnedGCHandle_1$instance<T> & __PinnedGCHandle_1$views<T>;


export class WeakGCHandle_1$instance<T> {
    constructor(target: T, trackResurrection: boolean);
    readonly isAllocated: boolean;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: WeakGCHandle_1<T>): boolean;
    getHashCode(): int;
    setTarget(target: T): void;
    tryGetTarget(target: { value: ref<T> }): boolean;
    static fromIntPtr<T>(value: nint): WeakGCHandle_1<T>;
    static toIntPtr<T>(value: WeakGCHandle_1<T>): nint;
}


export interface __WeakGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<WeakGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: WeakGCHandle_1<T>): boolean;
}

export interface WeakGCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type WeakGCHandle_1<T> = WeakGCHandle_1$instance<T> & __WeakGCHandle_1$views<T>;


export class AllowReversePInvokeCallsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type AllowReversePInvokeCallsAttribute = AllowReversePInvokeCallsAttribute$instance;

export class AutomationProxyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(val: boolean);
    readonly value: boolean;
}


export type AutomationProxyAttribute = AutomationProxyAttribute$instance;

export class BestFitMappingAttribute$instance extends System_Internal.Attribute$instance {
    constructor(BestFitMapping: boolean);
    throwOnUnmappableChar: boolean;
    readonly bestFitMapping: boolean;
}


export type BestFitMappingAttribute = BestFitMappingAttribute$instance;

export class BStrWrapper$instance {
    constructor(value: string);
    constructor(value: unknown);
    readonly wrappedObject: string;
}


export type BStrWrapper = BStrWrapper$instance;

export class ClassInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(classInterfaceType: ClassInterfaceType);
    constructor(classInterfaceType: short);
    readonly value: ClassInterfaceType;
}


export type ClassInterfaceAttribute = ClassInterfaceAttribute$instance;

export class CoClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor(coClass: Type);
    readonly coClass: Type;
}


export type CoClassAttribute = CoClassAttribute$instance;

export class ComAliasNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(alias: string);
    readonly value: string;
}


export type ComAliasNameAttribute = ComAliasNameAttribute$instance;

export class ComAwareEventInfo$instance extends System_Reflection_Internal.EventInfo$instance {
    constructor(type_: Type, eventName: string);
    readonly attributes: EventAttributes;
    readonly declaringType: Type;
    readonly metadataToken: int;
    readonly module_: Module;
    readonly name: string;
    readonly reflectedType: Type;
    addEventHandler(target: unknown, handler: Function): void;
    GetAddMethod(nonPublic: boolean): MethodInfo;
    GetAddMethod(): MethodInfo;
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getOtherMethods(nonPublic: boolean): MethodInfo[];
    getOtherMethods(): MethodInfo[];
    GetRaiseMethod(nonPublic: boolean): MethodInfo;
    GetRaiseMethod(): MethodInfo;
    GetRemoveMethod(nonPublic: boolean): MethodInfo;
    GetRemoveMethod(): MethodInfo;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    removeEventHandler(target: unknown, handler: Function): void;
}


export interface __ComAwareEventInfo$views {
    As_ICustomAttributeProvider(): System_Reflection_Internal.ICustomAttributeProvider$instance;
}

export type ComAwareEventInfo = ComAwareEventInfo$instance & __ComAwareEventInfo$views;


export class ComCompatibleVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int, build: int, revision: int);
    readonly buildNumber: int;
    readonly majorVersion: int;
    readonly minorVersion: int;
    readonly revisionNumber: int;
}


export type ComCompatibleVersionAttribute = ComCompatibleVersionAttribute$instance;

export class ComConversionLossAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComConversionLossAttribute = ComConversionLossAttribute$instance;

export class ComDefaultInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(defaultInterface: Type);
    readonly value: Type;
}


export type ComDefaultInterfaceAttribute = ComDefaultInterfaceAttribute$instance;

export class ComEventInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(SourceInterface: Type, EventProvider: Type);
    readonly eventProvider: Type;
    readonly sourceInterface: Type;
}


export type ComEventInterfaceAttribute = ComEventInterfaceAttribute$instance;

export class COMException$instance extends ExternalException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, errorCode: int);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __COMException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface COMException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type COMException = COMException$instance & __COMException$views;


export class ComImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComImportAttribute = ComImportAttribute$instance;

export class ComRegisterFunctionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComRegisterFunctionAttribute = ComRegisterFunctionAttribute$instance;

export class ComSourceInterfacesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(sourceInterfaces: string);
    constructor(sourceInterface: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type, sourceInterface4: Type);
    readonly value: string;
}


export type ComSourceInterfacesAttribute = ComSourceInterfacesAttribute$instance;

export class ComUnregisterFunctionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComUnregisterFunctionAttribute = ComUnregisterFunctionAttribute$instance;

export class ComVisibleAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visibility: boolean);
    readonly value: boolean;
}


export type ComVisibleAttribute = ComVisibleAttribute$instance;

export abstract class ComWrappers$instance {
    getOrCreateComInterfaceForObject(instance: unknown, flags: CreateComInterfaceFlags): nint;
    getOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags): unknown;
    getOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, userState: unknown): unknown;
    getOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown): unknown;
    getOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown, inner: nint): unknown;
    static getIUnknownImpl(fpQueryInterface: { value: ref<nint> }, fpAddRef: { value: ref<nint> }, fpRelease: { value: ref<nint> }): void;
    static registerForMarshalling(instance: ComWrappers): void;
    static registerForTrackerSupport(instance: ComWrappers): void;
    static tryGetComInstance(obj: unknown, unknown_: { value: ref<nint> }): boolean;
    static tryGetObject(unknown_: nint, obj: { value: ref<unknown> }): boolean;
}


export type ComWrappers = ComWrappers$instance;

export abstract class CriticalHandle$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    readonly isClosed: boolean;
    readonly isInvalid: boolean;
    close(): void;
    dispose(): void;
    setHandleAsInvalid(): void;
}


export interface __CriticalHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CriticalHandle$instance extends System_Internal.IDisposable$instance {}

export type CriticalHandle = CriticalHandle$instance & __CriticalHandle$views;


export class CurrencyWrapper$instance {
    constructor(obj: decimal);
    constructor(obj: unknown);
    readonly wrappedObject: decimal;
}


export type CurrencyWrapper = CurrencyWrapper$instance;

export class DefaultCharSetAttribute$instance extends System_Internal.Attribute$instance {
    constructor(charSet: CharSet);
    readonly charSet: CharSet;
}


export type DefaultCharSetAttribute = DefaultCharSetAttribute$instance;

export class DefaultDllImportSearchPathsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(paths: DllImportSearchPath);
    readonly paths: DllImportSearchPath;
}


export type DefaultDllImportSearchPathsAttribute = DefaultDllImportSearchPathsAttribute$instance;

export class DefaultParameterValueAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: unknown);
    readonly value: unknown;
}


export type DefaultParameterValueAttribute = DefaultParameterValueAttribute$instance;

export class DispatchWrapper$instance {
    constructor(obj: unknown);
    readonly wrappedObject: unknown;
}


export type DispatchWrapper = DispatchWrapper$instance;

export class DispIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dispId: int);
    readonly value: int;
}


export type DispIdAttribute = DispIdAttribute$instance;

export class DllImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dllName: string);
    entryPoint: string;
    charSet: CharSet;
    setLastError: boolean;
    exactSpelling: boolean;
    callingConvention: CallingConvention;
    bestFitMapping: boolean;
    preserveSig: boolean;
    throwOnUnmappableChar: boolean;
    readonly value: string;
}


export type DllImportAttribute = DllImportAttribute$instance;

export class DllImportResolver$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    endInvoke(result: IAsyncResult): nint;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
}


export interface __DllImportResolver$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DllImportResolver$instance extends System_Internal.ICloneable$instance {}

export type DllImportResolver = DllImportResolver$instance & __DllImportResolver$views;


export class DynamicInterfaceCastableImplementationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DynamicInterfaceCastableImplementationAttribute = DynamicInterfaceCastableImplementationAttribute$instance;

export class ErrorWrapper$instance {
    constructor(errorCode: int);
    constructor(errorCode: unknown);
    constructor(e: Exception);
    readonly errorCode: int;
}


export type ErrorWrapper = ErrorWrapper$instance;

export class ExternalException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, errorCode: int);
    readonly errorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __ExternalException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface ExternalException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type ExternalException = ExternalException$instance & __ExternalException$views;


export class FieldOffsetAttribute$instance extends System_Internal.Attribute$instance {
    constructor(offset: int);
    readonly value: int;
}


export type FieldOffsetAttribute = FieldOffsetAttribute$instance;

export class GuidAttribute$instance extends System_Internal.Attribute$instance {
    constructor(guid: string);
    readonly value: string;
}


export type GuidAttribute = GuidAttribute$instance;

export class HandleCollector$instance {
    constructor(name: string, initialThreshold: int);
    constructor(name: string, initialThreshold: int, maximumThreshold: int);
    readonly count: int;
    readonly initialThreshold: int;
    readonly maximumThreshold: int;
    readonly name: string;
    add(): void;
    remove(): void;
}


export type HandleCollector = HandleCollector$instance;

export class ImportedFromTypeLibAttribute$instance extends System_Internal.Attribute$instance {
    constructor(tlbFile: string);
    readonly value: string;
}


export type ImportedFromTypeLibAttribute = ImportedFromTypeLibAttribute$instance;

export class InAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type InAttribute = InAttribute$instance;

export class InterfaceTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(interfaceType: ComInterfaceType);
    constructor(interfaceType: short);
    readonly value: ComInterfaceType;
}


export type InterfaceTypeAttribute = InterfaceTypeAttribute$instance;

export class InvalidComObjectException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidComObjectException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface InvalidComObjectException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type InvalidComObjectException = InvalidComObjectException$instance & __InvalidComObjectException$views;


export class InvalidOleVariantTypeException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidOleVariantTypeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface InvalidOleVariantTypeException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type InvalidOleVariantTypeException = InvalidOleVariantTypeException$instance & __InvalidOleVariantTypeException$views;


export class LCIDConversionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(lcid: int);
    readonly value: int;
}


export type LCIDConversionAttribute = LCIDConversionAttribute$instance;

export class LibraryImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor(libraryName: string);
    entryPoint: string;
    readonly libraryName: string;
    setLastError: boolean;
    stringMarshalling: StringMarshalling;
    stringMarshallingCustomType: Type;
}


export type LibraryImportAttribute = LibraryImportAttribute$instance;

export class ManagedToNativeComInteropStubAttribute$instance extends System_Internal.Attribute$instance {
    constructor(classType: Type, methodName: string);
    readonly classType: Type;
    readonly methodName: string;
}


export type ManagedToNativeComInteropStubAttribute = ManagedToNativeComInteropStubAttribute$instance;

export class MarshalAsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(unmanagedType: UnmanagedType);
    constructor(unmanagedType: short);
    safeArraySubType: VarEnum;
    safeArrayUserDefinedSubType: Type;
    iidParameterIndex: int;
    arraySubType: UnmanagedType;
    sizeParamIndex: short;
    sizeConst: int;
    marshalType: string;
    marshalTypeRef: Type;
    marshalCookie: string;
    readonly value: UnmanagedType;
}


export type MarshalAsAttribute = MarshalAsAttribute$instance;

export class MarshalDirectiveException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MarshalDirectiveException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface MarshalDirectiveException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type MarshalDirectiveException = MarshalDirectiveException$instance & __MarshalDirectiveException$views;


export class OptionalAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OptionalAttribute = OptionalAttribute$instance;

export class OutAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OutAttribute = OutAttribute$instance;

export class PosixSignalContext$instance {
    constructor(signal: PosixSignal);
    cancel: boolean;
    readonly signal: PosixSignal;
}


export type PosixSignalContext = PosixSignalContext$instance;

export class PosixSignalRegistration$instance {
    dispose(): void;
    static create(signal: PosixSignal, handler: Action_1<PosixSignalContext>): PosixSignalRegistration;
}


export interface __PosixSignalRegistration$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PosixSignalRegistration$instance extends System_Internal.IDisposable$instance {}

export type PosixSignalRegistration = PosixSignalRegistration$instance & __PosixSignalRegistration$views;


export class PreserveSigAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type PreserveSigAttribute = PreserveSigAttribute$instance;

export class PrimaryInteropAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int);
    readonly majorVersion: int;
    readonly minorVersion: int;
}


export type PrimaryInteropAssemblyAttribute = PrimaryInteropAssemblyAttribute$instance;

export class ProgIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(progId: string);
    readonly value: string;
}


export type ProgIdAttribute = ProgIdAttribute$instance;

export class SafeArrayRankMismatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SafeArrayRankMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SafeArrayRankMismatchException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SafeArrayRankMismatchException = SafeArrayRankMismatchException$instance & __SafeArrayRankMismatchException$views;


export class SafeArrayTypeMismatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SafeArrayTypeMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SafeArrayTypeMismatchException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SafeArrayTypeMismatchException = SafeArrayTypeMismatchException$instance & __SafeArrayTypeMismatchException$views;


export abstract class SafeBuffer$instance extends Microsoft_Win32_SafeHandles_Internal.SafeHandleZeroOrMinusOneIsInvalid$instance {
    readonly byteLength: ulong;
    acquirePointer(pointer: { value: ref<ptr<byte>> }): void;
    Dispose(): void;
    initialize(numBytes: ulong): void;
    initialize(numElements: uint, sizeOfEachElement: uint): void;
    initialize<T extends unknown>(numElements: uint): void;
    read<T extends unknown>(byteOffset: ulong): T;
    readArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    readSpan<T extends unknown>(byteOffset: ulong, buffer: Span_1<T>): void;
    releasePointer(): void;
    write<T extends unknown>(byteOffset: ulong, value: T): void;
    writeArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    writeSpan<T extends unknown>(byteOffset: ulong, data: ReadOnlySpan_1<T>): void;
}


export interface __SafeBuffer$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SafeBuffer$instance extends System_Internal.IDisposable$instance {}

export type SafeBuffer = SafeBuffer$instance & __SafeBuffer$views;


export abstract class SafeHandle$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    readonly isClosed: boolean;
    readonly isInvalid: boolean;
    close(): void;
    dangerousAddRef(success: { value: ref<boolean> }): void;
    dangerousGetHandle(): nint;
    dangerousRelease(): void;
    dispose(): void;
    setHandleAsInvalid(): void;
}


export interface __SafeHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SafeHandle$instance extends System_Internal.IDisposable$instance {}

export type SafeHandle = SafeHandle$instance & __SafeHandle$views;


export class SEHException$instance extends ExternalException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    canResume(): boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SEHException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SEHException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SEHException = SEHException$instance & __SEHException$views;


export class StandardOleMarshalObject$instance extends System_Internal.MarshalByRefObject$instance {
}


export type StandardOleMarshalObject = StandardOleMarshalObject$instance;

export class StructLayoutAttribute$instance extends System_Internal.Attribute$instance {
    constructor(layoutKind: LayoutKind);
    constructor(layoutKind: short);
    pack: int;
    size: int;
    charSet: CharSet;
    readonly value: LayoutKind;
}


export type StructLayoutAttribute = StructLayoutAttribute$instance;

export class SuppressGCTransitionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SuppressGCTransitionAttribute = SuppressGCTransitionAttribute$instance;

export class TypeIdentifierAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(scope: string, identifier: string);
    readonly identifier: string;
    readonly scope: string;
}


export type TypeIdentifierAttribute = TypeIdentifierAttribute$instance;

export class TypeLibFuncAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibFuncFlags);
    constructor(flags: short);
    readonly value: TypeLibFuncFlags;
}


export type TypeLibFuncAttribute = TypeLibFuncAttribute$instance;

export class TypeLibImportClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor(importClass: Type);
    readonly value: string;
}


export type TypeLibImportClassAttribute = TypeLibImportClassAttribute$instance;

export class TypeLibTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibTypeFlags);
    constructor(flags: short);
    readonly value: TypeLibTypeFlags;
}


export type TypeLibTypeAttribute = TypeLibTypeAttribute$instance;

export class TypeLibVarAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibVarFlags);
    constructor(flags: short);
    readonly value: TypeLibVarFlags;
}


export type TypeLibVarAttribute = TypeLibVarAttribute$instance;

export class TypeLibVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int);
    readonly majorVersion: int;
    readonly minorVersion: int;
}


export type TypeLibVersionAttribute = TypeLibVersionAttribute$instance;

export class TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(assemblyName: string);
}


export type TypeMapAssemblyTargetAttribute_1<TTypeMapGroup> = TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup>;

export class TypeMapAssociationAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(source: Type, proxy: Type);
}


export type TypeMapAssociationAttribute_1<TTypeMapGroup> = TypeMapAssociationAttribute_1$instance<TTypeMapGroup>;

export class TypeMapAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(value: string, target: Type);
    constructor(value: string, target: Type, trimTarget: Type);
}


export type TypeMapAttribute_1<TTypeMapGroup> = TypeMapAttribute_1$instance<TTypeMapGroup>;

export class UnknownWrapper$instance {
    constructor(obj: unknown);
    readonly wrappedObject: unknown;
}


export type UnknownWrapper = UnknownWrapper$instance;

export class UnmanagedCallConvAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    callConvs: Type[];
}


export type UnmanagedCallConvAttribute = UnmanagedCallConvAttribute$instance;

export class UnmanagedCallersOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    callConvs: Type[];
    entryPoint: string;
}


export type UnmanagedCallersOnlyAttribute = UnmanagedCallersOnlyAttribute$instance;

export class UnmanagedFunctionPointerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(callingConvention: CallingConvention);
    bestFitMapping: boolean;
    setLastError: boolean;
    throwOnUnmappableChar: boolean;
    charSet: CharSet;
    readonly callingConvention: CallingConvention;
}


export type UnmanagedFunctionPointerAttribute = UnmanagedFunctionPointerAttribute$instance;

export class VariantWrapper$instance {
    constructor(obj: unknown);
    readonly wrappedObject: unknown;
}


export type VariantWrapper = VariantWrapper$instance;

export class WasmImportLinkageAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type WasmImportLinkageAttribute = WasmImportLinkageAttribute$instance;

export abstract class CollectionsMarshal$instance {
    static asBytes(array: BitArray): Span_1<CLROf<byte>>;
    static asSpan<T>(list: List_1<T>): Span_1<T>;
    static getValueRefOrAddDefault<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey, exists: { value: ref<boolean> }): ref<TValue>;
    static getValueRefOrAddDefault<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey, exists: { value: ref<boolean> }): ref<TValue>;
    static getValueRefOrNullRef<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey): ref<TValue>;
    static getValueRefOrNullRef<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey): ref<TValue>;
    static setCount<T>(list: List_1<T>, count: int): void;
}


export type CollectionsMarshal = CollectionsMarshal$instance;

export abstract class ComEventsHelper$instance {
    static combine(rcw: unknown, iid: Guid, dispid: int, d: Function): void;
    static remove(rcw: unknown, iid: Guid, dispid: int, d: Function): Function;
}


export type ComEventsHelper = ComEventsHelper$instance;

export abstract class GCHandleExtensions$instance {
    static getAddressOfArrayData<T>(handle: PinnedGCHandle_1<T[]>): ptr<T>;
    static getAddressOfStringData(handle: PinnedGCHandle_1<CLROf<string>>): ptr<char>;
}


export type GCHandleExtensions = GCHandleExtensions$instance;

export abstract class ImmutableCollectionsMarshal$instance {
    static asArray<T>(array: ImmutableArray_1<T>): T[];
    static asImmutableArray<T>(array: T[]): ImmutableArray_1<T>;
    static asMemory<T>(builder: ImmutableArray_1_Builder<T>): Memory_1<T>;
}


export type ImmutableCollectionsMarshal = ImmutableCollectionsMarshal$instance;

export abstract class JsonMarshal$instance {
    static getRawUtf8PropertyName(property: JsonProperty): ReadOnlySpan_1<CLROf<byte>>;
    static getRawUtf8Value(element: JsonElement): ReadOnlySpan_1<CLROf<byte>>;
}


export type JsonMarshal = JsonMarshal$instance;

export abstract class Marshal$instance {
    static readonly systemDefaultCharSize: int;
    static readonly systemMaxDBCSCharSize: int;
    static addRef(pUnk: nint): int;
    static allocCoTaskMem(cb: int): nint;
    static allocHGlobal(cb: int): nint;
    static allocHGlobal(cb: nint): nint;
    static areComObjectsAvailableForCleanup(): boolean;
    static bindToMoniker(monikerName: string): unknown;
    static changeWrapperHandleStrength(otp: unknown, fIsWeak: boolean): void;
    static cleanupUnusedObjectsInCurrentContext(): void;
    static copy(source: byte[], startIndex: int, destination: nint, length: int): void;
    static copy(source: char[], startIndex: int, destination: nint, length: int): void;
    static copy(source: double[], startIndex: int, destination: nint, length: int): void;
    static copy(source: short[], startIndex: int, destination: nint, length: int): void;
    static copy(source: int[], startIndex: int, destination: nint, length: int): void;
    static copy(source: long[], startIndex: int, destination: nint, length: int): void;
    static copy(source: nint, destination: byte[], startIndex: int, length: int): void;
    static copy(source: nint, destination: char[], startIndex: int, length: int): void;
    static copy(source: nint, destination: double[], startIndex: int, length: int): void;
    static copy(source: nint, destination: short[], startIndex: int, length: int): void;
    static copy(source: nint, destination: int[], startIndex: int, length: int): void;
    static copy(source: nint, destination: long[], startIndex: int, length: int): void;
    static copy(source: nint, destination: nint[], startIndex: int, length: int): void;
    static copy(source: nint, destination: float[], startIndex: int, length: int): void;
    static copy(source: nint[], startIndex: int, destination: nint, length: int): void;
    static copy(source: float[], startIndex: int, destination: nint, length: int): void;
    static createAggregatedObject(pOuter: nint, o: unknown): nint;
    static createAggregatedObject<T>(pOuter: nint, o: T): nint;
    static createWrapperOfType(o: unknown, t: Type): unknown;
    static createWrapperOfType<T, TWrapper>(o: T): TWrapper;
    static destroyStructure(ptr: nint, structuretype: Type): void;
    static destroyStructure<T>(ptr: nint): void;
    static finalReleaseComObject(o: unknown): int;
    static freeBSTR(ptr: nint): void;
    static freeCoTaskMem(ptr: nint): void;
    static freeHGlobal(hglobal: nint): void;
    static generateGuidForType(type_: Type): Guid;
    static generateProgIdForType(type_: Type): string;
    static getComInterfaceForObject(o: unknown, T: Type, mode: CustomQueryInterfaceMode): nint;
    static getComInterfaceForObject(o: unknown, T: Type): nint;
    static getComInterfaceForObject<T, TInterface>(o: T): nint;
    static getComObjectData(obj: unknown, key: unknown): unknown;
    static getDelegateForFunctionPointer(ptr: nint, t: Type): Function;
    static getDelegateForFunctionPointer<TDelegate>(ptr: nint): TDelegate;
    static getEndComSlot(t: Type): int;
    static getExceptionCode(): int;
    static getExceptionForHR(errorCode: int, iid: { value: ref<Guid> }, pUnk: nint): Exception;
    static getExceptionForHR(errorCode: int, errorInfo: nint): Exception;
    static getExceptionForHR(errorCode: int): Exception;
    static getExceptionPointers(): nint;
    static getFunctionPointerForDelegate(d: Function): nint;
    static getFunctionPointerForDelegate<TDelegate>(d: TDelegate): nint;
    static getHINSTANCE(m: Module): nint;
    static getHRForException(e: Exception): int;
    static getHRForLastWin32Error(): int;
    static getIDispatchForObject(o: unknown): nint;
    static getIUnknownForObject(o: unknown): nint;
    static getLastPInvokeError(): int;
    static getLastPInvokeErrorMessage(): string;
    static getLastSystemError(): int;
    static getLastWin32Error(): int;
    static getNativeVariantForObject(obj: unknown, pDstNativeVariant: nint): void;
    static getNativeVariantForObject<T>(obj: T, pDstNativeVariant: nint): void;
    static getObjectForIUnknown(pUnk: nint): unknown;
    static getObjectForNativeVariant(pSrcNativeVariant: nint): unknown;
    static getObjectForNativeVariant<T>(pSrcNativeVariant: nint): T;
    static getObjectsForNativeVariants(aSrcNativeVariant: nint, cVars: int): unknown[];
    static getObjectsForNativeVariants<T>(aSrcNativeVariant: nint, cVars: int): T[];
    static getPInvokeErrorMessage(error: int): string;
    static getStartComSlot(t: Type): int;
    static getTypedObjectForIUnknown(pUnk: nint, t: Type): unknown;
    static getTypeFromCLSID(clsid: Guid): Type;
    static getTypeInfoName(typeInfo: ITypeInfo): string;
    static getUniqueObjectForIUnknown(unknown_: nint): unknown;
    static initHandle(safeHandle: SafeHandle, handle: nint): void;
    static isComObject(o: unknown): boolean;
    static isTypeVisibleFromCom(t: Type): boolean;
    static offsetOf<T>(fieldName: string): nint;
    static offsetOf(t: Type, fieldName: string): nint;
    static prelink(m: MethodInfo): void;
    static prelinkAll(c: Type): void;
    static ptrToStringAnsi(ptr: nint, len: int): string;
    static ptrToStringAnsi(ptr: nint): string;
    static ptrToStringAuto(ptr: nint, len: int): string;
    static ptrToStringAuto(ptr: nint): string;
    static ptrToStringBSTR(ptr: nint): string;
    static ptrToStringUni(ptr: nint, len: int): string;
    static ptrToStringUni(ptr: nint): string;
    static ptrToStringUTF8(ptr: nint, byteLen: int): string;
    static ptrToStringUTF8(ptr: nint): string;
    static ptrToStructure(ptr: nint, structure: unknown): void;
    static ptrToStructure(ptr: nint, structureType: Type): unknown;
    static ptrToStructure<T>(ptr: nint, structure: T): void;
    static ptrToStructure<T>(ptr: nint): T;
    static queryInterface(pUnk: nint, iid: { value: ref<Guid> }, ppv: { value: ref<nint> }): int;
    static readByte(ptr: nint, ofs: int): byte;
    static readByte(ptr: nint): byte;
    static readByte(ptr: unknown, ofs: int): byte;
    static readInt16(ptr: nint, ofs: int): short;
    static readInt16(ptr: nint): short;
    static readInt16(ptr: unknown, ofs: int): short;
    static readInt32(ptr: nint, ofs: int): int;
    static readInt32(ptr: nint): int;
    static readInt32(ptr: unknown, ofs: int): int;
    static readInt64(ptr: nint, ofs: int): long;
    static readInt64(ptr: nint): long;
    static readInt64(ptr: unknown, ofs: int): long;
    static readIntPtr(ptr: nint, ofs: int): nint;
    static readIntPtr(ptr: nint): nint;
    static readIntPtr(ptr: unknown, ofs: int): nint;
    static reAllocCoTaskMem(pv: nint, cb: int): nint;
    static reAllocHGlobal(pv: nint, cb: nint): nint;
    static release(pUnk: nint): int;
    static releaseComObject(o: unknown): int;
    static secureStringToBSTR(s: SecureString): nint;
    static secureStringToCoTaskMemAnsi(s: SecureString): nint;
    static secureStringToCoTaskMemUnicode(s: SecureString): nint;
    static secureStringToGlobalAllocAnsi(s: SecureString): nint;
    static secureStringToGlobalAllocUnicode(s: SecureString): nint;
    static setComObjectData(obj: unknown, key: unknown, data: unknown): boolean;
    static setLastPInvokeError(error: int): void;
    static setLastSystemError(error: int): void;
    static sizeOf<T>(): int;
    static sizeOf(structure: unknown): int;
    static sizeOf(t: Type): int;
    static sizeOf<T>(structure: T): int;
    static stringToBSTR(s: string): nint;
    static stringToCoTaskMemAnsi(s: string): nint;
    static stringToCoTaskMemAuto(s: string): nint;
    static stringToCoTaskMemUni(s: string): nint;
    static stringToCoTaskMemUTF8(s: string): nint;
    static stringToHGlobalAnsi(s: string): nint;
    static stringToHGlobalAuto(s: string): nint;
    static stringToHGlobalUni(s: string): nint;
    static structureToPtr(structure: unknown, ptr: nint, fDeleteOld: boolean): void;
    static structureToPtr<T>(structure: T, ptr: nint, fDeleteOld: boolean): void;
    static throwExceptionForHR(errorCode: int, iid: { value: ref<Guid> }, pUnk: nint): void;
    static throwExceptionForHR(errorCode: int, errorInfo: nint): void;
    static throwExceptionForHR(errorCode: int): void;
    static unsafeAddrOfPinnedArrayElement(arr: ClrArray, index: int): nint;
    static unsafeAddrOfPinnedArrayElement<T>(arr: T[], index: int): nint;
    static writeByte(ptr: nint, val: byte): void;
    static writeByte(ptr: nint, ofs: int, val: byte): void;
    static writeByte(ptr: unknown, ofs: int, val: byte): void;
    static writeInt16(ptr: nint, val: char): void;
    static writeInt16(ptr: nint, val: short): void;
    static writeInt16(ptr: nint, ofs: int, val: char): void;
    static writeInt16(ptr: nint, ofs: int, val: short): void;
    static writeInt16(ptr: { value: unknown }, ofs: int, val: char): void;
    static writeInt16(ptr: unknown, ofs: int, val: short): void;
    static writeInt32(ptr: nint, ofs: int, val: int): void;
    static writeInt32(ptr: nint, val: int): void;
    static writeInt32(ptr: unknown, ofs: int, val: int): void;
    static writeInt64(ptr: nint, ofs: int, val: long): void;
    static writeInt64(ptr: nint, val: long): void;
    static writeInt64(ptr: unknown, ofs: int, val: long): void;
    static writeIntPtr(ptr: nint, ofs: int, val: nint): void;
    static writeIntPtr(ptr: nint, val: nint): void;
    static writeIntPtr(ptr: unknown, ofs: int, val: nint): void;
    static zeroFreeBSTR(s: nint): void;
    static zeroFreeCoTaskMemAnsi(s: nint): void;
    static zeroFreeCoTaskMemUnicode(s: nint): void;
    static zeroFreeCoTaskMemUTF8(s: nint): void;
    static zeroFreeGlobalAllocAnsi(s: nint): void;
    static zeroFreeGlobalAllocUnicode(s: nint): void;
}


export type Marshal = Marshal$instance;

export abstract class MemoryMarshal$instance {
    static asBytes<T extends unknown>(span: ReadOnlySpan_1<T>): ReadOnlySpan_1<CLROf<byte>>;
    static asBytes<T extends unknown>(span: Span_1<T>): Span_1<CLROf<byte>>;
    static asMemory<T>(memory: ReadOnlyMemory_1<T>): Memory_1<T>;
    static asRef<T extends unknown>(span: ReadOnlySpan_1<CLROf<byte>>): ref<T>;
    static asRef<T extends unknown>(span: Span_1<CLROf<byte>>): ref<T>;
    static cast<TFrom extends unknown, TTo extends unknown>(span: ReadOnlySpan_1<TFrom>): ReadOnlySpan_1<TTo>;
    static cast<TFrom extends unknown, TTo extends unknown>(span: Span_1<TFrom>): Span_1<TTo>;
    static createFromPinnedArray<T>(array: T[], start: int, length: int): Memory_1<T>;
    static createReadOnlySpan<T>(reference: { value: ref<T> }, length: int): ReadOnlySpan_1<T>;
    static createReadOnlySpanFromNullTerminated(value: ptr<byte>): ReadOnlySpan_1<CLROf<byte>>;
    static createReadOnlySpanFromNullTerminated(value: ptr<char>): ReadOnlySpan_1<CLROf<char>>;
    static createSpan<T>(reference: { value: ref<T> }, length: int): Span_1<T>;
    static getArrayDataReference(array: ClrArray): ref<byte>;
    static getArrayDataReference<T>(array: T[]): ref<T>;
    static getReference<T>(span: ReadOnlySpan_1<T>): ref<T>;
    static getReference<T>(span: Span_1<T>): ref<T>;
    static read<T extends unknown>(source: ReadOnlySpan_1<CLROf<byte>>): T;
    static toEnumerable<T>(memory: ReadOnlyMemory_1<T>): IEnumerable_1<T>;
    static tryGetArray<T>(memory: ReadOnlyMemory_1<T>, segment: { value: ref<ArraySegment_1<T>> }): boolean;
    static tryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: ref<TManager> }, start: { value: ref<int> }, length: { value: ref<int> }): boolean;
    static tryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: ref<TManager> }): boolean;
    static tryGetString(memory: ReadOnlyMemory_1<CLROf<char>>, text: { value: ref<string> }, start: { value: ref<int> }, length: { value: ref<int> }): boolean;
    static tryRead<T extends unknown>(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<T> }): boolean;
    static tryWrite<T extends unknown>(destination: Span_1<CLROf<byte>>, value: { value: ref<T> }): boolean;
    static write<T extends unknown>(destination: Span_1<CLROf<byte>>, value: { value: ref<T> }): void;
}


export type MemoryMarshal = MemoryMarshal$instance;

export abstract class NativeLibrary$instance {
    static free(handle: nint): void;
    static getExport(handle: nint, name: string): nint;
    static getMainProgramHandle(): nint;
    static load(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
    static load(libraryPath: string): nint;
    static setDllImportResolver(assembly: Assembly, resolver: DllImportResolver): void;
    static tryGetExport(handle: nint, name: string, address: { value: ref<nint> }): boolean;
    static tryLoad(libraryPath: string, handle: { value: ref<nint> }): boolean;
    static tryLoad(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, handle: { value: ref<nint> }): boolean;
}


export type NativeLibrary = NativeLibrary$instance;

export abstract class NativeMemory$instance {
    static alignedAlloc(byteCount: nuint, alignment: nuint): ptr<void>;
    static alignedFree(ptr: ptr<void>): void;
    static alignedRealloc(ptr: ptr<void>, byteCount: nuint, alignment: nuint): ptr<void>;
    static alloc(elementCount: nuint, elementSize: nuint): ptr<void>;
    static alloc(byteCount: nuint): ptr<void>;
    static allocZeroed(elementCount: nuint, elementSize: nuint): ptr<void>;
    static allocZeroed(byteCount: nuint): ptr<void>;
    static clear(ptr: ptr<void>, byteCount: nuint): void;
    static copy(source: ptr<void>, destination: ptr<void>, byteCount: nuint): void;
    static fill(ptr: ptr<void>, byteCount: nuint, value: byte): void;
    static free(ptr: ptr<void>): void;
    static realloc(ptr: ptr<void>, byteCount: nuint): ptr<void>;
}


export type NativeMemory = NativeMemory$instance;

export abstract class RuntimeEnvironment$instance {
    static readonly systemConfigurationFile: string;
    static fromGlobalAccessCache(a: Assembly): boolean;
    static getRuntimeDirectory(): string;
    static getRuntimeInterfaceAsIntPtr(clsid: Guid, riid: Guid): nint;
    static getRuntimeInterfaceAsObject(clsid: Guid, riid: Guid): unknown;
    static getSystemVersion(): string;
}


export type RuntimeEnvironment = RuntimeEnvironment$instance;

export abstract class RuntimeInformation$instance {
    static readonly runtimeIdentifier: string;
    static readonly processArchitecture: Architecture;
    static readonly osDescription: string;
    static readonly osArchitecture: Architecture;
    static readonly frameworkDescription: string;
    static isOSPlatform(osPlatform: OSPlatform): boolean;
}


export type RuntimeInformation = RuntimeInformation$instance;

export abstract class SequenceMarshal$instance {
    static tryGetArray<T>(sequence: ReadOnlySequence_1<T>, segment: { value: ref<ArraySegment_1<T>> }): boolean;
    static tryGetReadOnlyMemory<T>(sequence: ReadOnlySequence_1<T>, memory: { value: ref<ReadOnlyMemory_1<T>> }): boolean;
    static tryGetReadOnlySequenceSegment<T>(sequence: ReadOnlySequence_1<T>, startSegment: { value: ref<ReadOnlySequenceSegment_1<T>> }, startIndex: { value: ref<int> }, endSegment: { value: ref<ReadOnlySequenceSegment_1<T>> }, endIndex: { value: ref<int> }): boolean;
    static tryRead<T extends unknown>(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<T> }): boolean;
}


export type SequenceMarshal = SequenceMarshal$instance;

export abstract class TypeMapping$instance {
    static getOrCreateExternalTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<CLROf<string>, Type>;
    static getOrCreateProxyTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<Type, Type>;
}


export type TypeMapping = TypeMapping$instance;

