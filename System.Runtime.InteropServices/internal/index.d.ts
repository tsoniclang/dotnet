// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices
// Assembly: System.Collections.Immutable, System.Memory, System.Private.CoreLib, System.Runtime.InteropServices, System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as Microsoft_Win32_SafeHandles_Internal from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { SafeHandleZeroOrMinusOneIsInvalid } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { MemoryManager_1, ReadOnlySequence_1, ReadOnlySequenceSegment_1, SequenceReader_1 } from "../../System.Buffers/internal/index.js";
import type { Dictionary_2, Dictionary_2_AlternateLookup_1, IEnumerable_1, IList_1, IReadOnlyDictionary_2, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1, ImmutableArray_1_Builder } from "../../System.Collections.Immutable/internal/index.js";
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { NumberStyles } from "../../System.Globalization/internal/index.js";
import * as System_Numerics_Internal from "../../System.Numerics/internal/index.js";
import type { IAdditionOperators_3, IAdditiveIdentity_2, IBinaryFloatingPointIeee754_1, IBinaryInteger_1, IBinaryNumber_1, IBitwiseOperators_3, IComparisonOperators_3, IDecrementOperators_1, IDivisionOperators_3, IEqualityOperators_3, IExponentialFunctions_1, IFloatingPoint_1, IFloatingPointConstants_1, IFloatingPointIeee754_1, IHyperbolicFunctions_1, IIncrementOperators_1, ILogarithmicFunctions_1, IMinMaxValue_1, IModulusOperators_3, IMultiplicativeIdentity_2, IMultiplyOperators_3, INumber_1, INumberBase_1, IPowerFunctions_1, IRootFunctions_1, ISignedNumber_1, ISubtractionOperators_3, ITrigonometricFunctions_1, IUnaryNegationOperators_2, IUnaryPlusOperators_2 } from "../../System.Numerics/internal/index.js";
import { EventInfo } from "../../System.Reflection/internal/index.js";
import * as System_Reflection_Internal from "../../System.Reflection/internal/index.js";
import type { Assembly, CustomAttributeData, EventAttributes, ICustomAttributeProvider, MemberInfo, MemberTypes, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { ITypeInfo } from "../../System.Runtime.InteropServices.ComTypes/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { JsonElement, JsonProperty } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, ArraySegment_1, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Double, Enum, Exception, Guid, IAsyncResult, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MidpointRounding, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, RuntimeTypeHandle, Single, Span_1, String as ClrString, SystemException, Type, TypeCode, UInt32, UInt64, UIntPtr, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum Architecture {
    x86 = 0,
    x64 = 1,
    arm = 2,
    arm64 = 3,
    wasm = 4,
    s390x = 5,
    loongArch64 = 6,
    armv6 = 7,
    ppc64le = 8,
    riscV64 = 9
}


export enum AssemblyRegistrationFlags {
    none = 0,
    setCodeBase = 1
}


export enum CallingConvention {
    winapi = 1,
    cdecl = 2,
    stdCall = 3,
    thisCall = 4,
    fastCall = 5
}


export enum CharSet {
    none = 1,
    ansi = 2,
    unicode = 3,
    auto = 4
}


export enum ClassInterfaceType {
    none = 0,
    autoDispatch = 1,
    autoDual = 2
}


export enum ComInterfaceType {
    interfaceIsDual = 0,
    interfaceIsIUnknown = 1,
    interfaceIsIDispatch = 2,
    interfaceIsIInspectable = 3
}


export enum ComMemberType {
    method = 0,
    propGet = 1,
    propSet = 2
}


export enum CreateComInterfaceFlags {
    none = 0,
    callerDefinedIUnknown = 1,
    trackerSupport = 2
}


export enum CreatedWrapperFlags {
    none = 0,
    trackerObject = 1,
    nonWrapping = 2
}


export enum CreateObjectFlags {
    none = 0,
    trackerObject = 1,
    uniqueInstance = 2,
    aggregation = 4,
    unwrap = 8
}


export enum CustomQueryInterfaceMode {
    ignore = 0,
    allow = 1
}


export enum CustomQueryInterfaceResult {
    handled = 0,
    notHandled = 1,
    failed = 2
}


export enum DllImportSearchPath {
    useDllDirectoryForDependencies = 256,
    applicationDirectory = 512,
    userDirectories = 1024,
    system32 = 2048,
    safeDirectories = 4096,
    assemblyDirectory = 2,
    legacyBehavior = 0
}


export enum ExporterEventKind {
    notif_typeconverted = 0,
    notif_convertwarning = 1,
    error_reftoinvalidassembly = 2
}


export enum GCHandleType {
    weak = 0,
    weakTrackResurrection = 1,
    normal = 2,
    pinned = 3
}


export enum LayoutKind {
    sequential = 0,
    explicit = 2,
    auto = 3
}


export enum PosixSignal {
    sighup = -1,
    sigint = -2,
    sigquit = -3,
    sigterm = -4,
    sigchld = -5,
    sigcont = -6,
    sigwinch = -7,
    sigttin = -8,
    sigttou = -9,
    sigtstp = -10
}


export enum RegistrationClassContext {
    inProcessServer = 1,
    inProcessHandler = 2,
    localServer = 4,
    inProcessServer16 = 8,
    remoteServer = 16,
    inProcessHandler16 = 32,
    reserved1 = 64,
    reserved2 = 128,
    reserved3 = 256,
    reserved4 = 512,
    noCodeDownload = 1024,
    reserved5 = 2048,
    noCustomMarshal = 4096,
    enableCodeDownload = 8192,
    noFailureLog = 16384,
    disableActivateAsActivator = 32768,
    enableActivateAsActivator = 65536,
    fromDefaultContext = 131072
}


export enum RegistrationConnectionType {
    singleUse = 0,
    multipleUse = 1,
    multiSeparate = 2,
    suspended = 4,
    surrogate = 8
}


export enum StringMarshalling {
    custom = 0,
    utf8 = 1,
    utf16 = 2
}


export enum TypeLibFuncFlags {
    fRestricted = 1,
    fSource = 2,
    fBindable = 4,
    fRequestEdit = 8,
    fDisplayBind = 16,
    fDefaultBind = 32,
    fHidden = 64,
    fUsesGetLastError = 128,
    fDefaultCollelem = 256,
    fUiDefault = 512,
    fNonBrowsable = 1024,
    fReplaceable = 2048,
    fImmediateBind = 4096
}


export enum TypeLibTypeFlags {
    fAppObject = 1,
    fCanCreate = 2,
    fLicensed = 4,
    fPreDeclId = 8,
    fHidden = 16,
    fControl = 32,
    fDual = 64,
    fNonExtensible = 128,
    fOleAutomation = 256,
    fRestricted = 512,
    fAggregatable = 1024,
    fReplaceable = 2048,
    fDispatchable = 4096,
    fReverseBind = 8192
}


export enum TypeLibVarFlags {
    fReadOnly = 1,
    fSource = 2,
    fBindable = 4,
    fRequestEdit = 8,
    fDisplayBind = 16,
    fDefaultBind = 32,
    fHidden = 64,
    fRestricted = 128,
    fDefaultCollelem = 256,
    fUiDefault = 512,
    fNonBrowsable = 1024,
    fReplaceable = 2048,
    fImmediateBind = 4096
}


export enum UnmanagedType {
    bool = 2,
    i1 = 3,
    u1 = 4,
    i2 = 5,
    u2 = 6,
    i4 = 7,
    u4 = 8,
    i8 = 9,
    u8 = 10,
    r4 = 11,
    r8 = 12,
    currency = 15,
    bStr = 19,
    lpStr = 20,
    lpwStr = 21,
    lptStr = 22,
    byValTStr = 23,
    iUnknown = 25,
    iDispatch = 26,
    struct = 27,
    interface_ = 28,
    safeArray = 29,
    byValArray = 30,
    sysInt = 31,
    sysUInt = 32,
    vbByRefStr = 34,
    ansiBStr = 35,
    tbStr = 36,
    variantBool = 37,
    functionPtr = 38,
    asAny = 40,
    lpArray = 42,
    lpStruct = 43,
    customMarshaler = 44,
    error = 45,
    iInspectable = 46,
    hString = 47,
    lputf8Str = 48
}


export enum VarEnum {
    vt_empty = 0,
    vt_null = 1,
    vt_i2 = 2,
    vt_i4 = 3,
    vt_r4 = 4,
    vt_r8 = 5,
    vt_cy = 6,
    vt_date = 7,
    vt_bstr = 8,
    vt_dispatch = 9,
    vt_error = 10,
    vt_bool = 11,
    vt_variant = 12,
    vt_unknown = 13,
    vt_decimal = 14,
    vt_i1 = 16,
    vt_ui1 = 17,
    vt_ui2 = 18,
    vt_ui4 = 19,
    vt_i8 = 20,
    vt_ui8 = 21,
    vt_int = 22,
    vt_uint = 23,
    vt_void = 24,
    vt_hresult = 25,
    vt_ptr = 26,
    vt_safearray = 27,
    vt_carray = 28,
    vt_userdefined = 29,
    vt_lpstr = 30,
    vt_lpwstr = 31,
    vt_record = 36,
    vt_filetime = 64,
    vt_blob = 65,
    vt_stream = 66,
    vt_storage = 67,
    vt_streamed_object = 68,
    vt_stored_object = 69,
    vt_blob_object = 70,
    vt_cf = 71,
    vt_clsid = 72,
    vt_vector = 4096,
    vt_array = 8192,
    vt_byref = 16384
}


export interface ICustomAdapter$instance {
    GetUnderlyingObject(): unknown;
}


export type ICustomAdapter = ICustomAdapter$instance;

export interface ICustomFactory$instance {
    CreateInstance(serverType: Type): MarshalByRefObject;
}


export type ICustomFactory = ICustomFactory$instance;

export interface ICustomMarshaler$instance {
    CleanUpManagedData(ManagedObj: unknown): void;
    CleanUpNativeData(pNativeData: nint): void;
    GetNativeDataSize(): int;
    MarshalManagedToNative(ManagedObj: unknown): nint;
    MarshalNativeToManaged(pNativeData: nint): unknown;
}


export type ICustomMarshaler = ICustomMarshaler$instance;

export interface ICustomQueryInterface$instance {
    GetInterface(iid: { value: ref<Guid> }, ppv: { value: ref<nint> }): CustomQueryInterfaceResult;
}


export type ICustomQueryInterface = ICustomQueryInterface$instance;

export interface IDynamicInterfaceCastable$instance {
    GetInterfaceImplementation(interfaceType: RuntimeTypeHandle): RuntimeTypeHandle;
    IsInterfaceImplemented(interfaceType: RuntimeTypeHandle, throwIfNotImplemented: boolean): boolean;
}


export type IDynamicInterfaceCastable = IDynamicInterfaceCastable$instance;

export class ArrayWithOffset$instance {
    constructor(array: unknown, offset: int);
    equals(obj: unknown): boolean;
    equals(obj: ArrayWithOffset): boolean;
    getArray(): unknown;
    getHashCode(): int;
    getOffset(): int;
}


export interface __ArrayWithOffset$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ArrayWithOffset>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ArrayWithOffset): boolean;
}

export type ArrayWithOffset = ArrayWithOffset$instance & __ArrayWithOffset$views;


export class CLong$instance {
    constructor(value: int);
    constructor(value: nint);
    readonly value: nint;
    equals(o: unknown): boolean;
    equals(other: CLong): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __CLong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CLong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CLong): boolean;
}

export type CLong = CLong$instance & __CLong$views;


export class ComWrappers_ComInterfaceDispatch$instance {
    Vtable: nint;
    static GetInstance<T>(dispatchPtr: ptr<ComWrappers_ComInterfaceDispatch>): T;
}


export type ComWrappers_ComInterfaceDispatch = ComWrappers_ComInterfaceDispatch$instance;

export class ComWrappers_ComInterfaceEntry$instance {
    IID: Guid;
    Vtable: nint;
}


export type ComWrappers_ComInterfaceEntry = ComWrappers_ComInterfaceEntry$instance;

export class CULong$instance {
    constructor(value: uint);
    constructor(value: nuint);
    readonly value: nuint;
    equals(o: unknown): boolean;
    equals(other: CULong): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __CULong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CULong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CULong): boolean;
}

export type CULong = CULong$instance & __CULong$views;


export class GCHandle$instance {
    readonly isAllocated: boolean;
    target: unknown;
    addrOfPinnedObject(): nint;
    equals(o: unknown): boolean;
    equals(other: GCHandle): boolean;
    free(): void;
    getHashCode(): int;
    static Alloc(value: unknown, type_: GCHandleType): GCHandle;
    static Alloc(value: unknown): GCHandle;
    static FromIntPtr(value: nint): GCHandle;
    static ToIntPtr(value: GCHandle): nint;
}


export interface __GCHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle): boolean;
}

export type GCHandle = GCHandle$instance & __GCHandle$views;


export class GCHandle_1$instance<T> {
    constructor(target: T);
    readonly isAllocated: boolean;
    target: T;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: GCHandle_1<T>): boolean;
    getHashCode(): int;
    static FromIntPtr<T>(value: nint): GCHandle_1<T>;
    static ToIntPtr<T>(value: GCHandle_1<T>): nint;
}


export interface __GCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle_1<T>): boolean;
}

export type GCHandle_1<T> = GCHandle_1$instance<T> & __GCHandle_1$views<T>;


export class HandleRef$instance {
    constructor(wrapper: unknown, handle: nint);
    readonly handle: nint;
    readonly wrapper: unknown;
    static ToIntPtr(value: HandleRef): nint;
}


export type HandleRef = HandleRef$instance;

export class NFloat$instance implements IBitwiseOperators_3<NFloat, NFloat, NFloat>, IComparisonOperators_3<NFloat, NFloat, CLROf<boolean>>, IEqualityOperators_3<NFloat, NFloat, CLROf<boolean>>, IModulusOperators_3<NFloat, NFloat, NFloat>, IAdditionOperators_3<NFloat, NFloat, NFloat>, IDecrementOperators_1<NFloat>, IDivisionOperators_3<NFloat, NFloat, NFloat>, IIncrementOperators_1<NFloat>, IMultiplyOperators_3<NFloat, NFloat, NFloat>, ISubtractionOperators_3<NFloat, NFloat, NFloat>, IUnaryPlusOperators_2<NFloat, NFloat>, IUnaryNegationOperators_2<NFloat, NFloat> {
    constructor(value: float);
    constructor(value: double);
    readonly value: double;
    compareTo(obj: unknown): int;
    compareTo(other: NFloat): int;
    equals(obj: unknown): boolean;
    equals(other: NFloat): boolean;
    getHashCode(): int;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly Epsilon: NFloat;
    static readonly MaxValue: NFloat;
    static readonly MinValue: NFloat;
    static readonly NaN: NFloat;
    static readonly NegativeInfinity: NFloat;
    static readonly PositiveInfinity: NFloat;
    static readonly Size: int;
    static readonly E: NFloat;
    static readonly Pi: NFloat;
    static readonly Tau: NFloat;
    static readonly NegativeZero: NFloat;
    static Abs(value: NFloat): NFloat;
    static Acos(x: NFloat): NFloat;
    static Acosh(x: NFloat): NFloat;
    static AcosPi(x: NFloat): NFloat;
    static Asin(x: NFloat): NFloat;
    static Asinh(x: NFloat): NFloat;
    static AsinPi(x: NFloat): NFloat;
    static Atan(x: NFloat): NFloat;
    static Atan2(y: NFloat, x: NFloat): NFloat;
    static Atan2Pi(y: NFloat, x: NFloat): NFloat;
    static Atanh(x: NFloat): NFloat;
    static AtanPi(x: NFloat): NFloat;
    static BitDecrement(x: NFloat): NFloat;
    static BitIncrement(x: NFloat): NFloat;
    static Cbrt(x: NFloat): NFloat;
    static Ceiling(x: NFloat): NFloat;
    static Clamp(value: NFloat, min: NFloat, max: NFloat): NFloat;
    static ClampNative(value: NFloat, min: NFloat, max: NFloat): NFloat;
    static ConvertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    static ConvertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    static CopySign(value: NFloat, sign: NFloat): NFloat;
    static Cos(x: NFloat): NFloat;
    static Cosh(x: NFloat): NFloat;
    static CosPi(x: NFloat): NFloat;
    static CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    static DegreesToRadians(degrees: NFloat): NFloat;
    static Exp(x: NFloat): NFloat;
    static Exp10(x: NFloat): NFloat;
    static Exp10M1(x: NFloat): NFloat;
    static Exp2(x: NFloat): NFloat;
    static Exp2M1(x: NFloat): NFloat;
    static ExpM1(x: NFloat): NFloat;
    static Floor(x: NFloat): NFloat;
    static FusedMultiplyAdd(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    static Hypot(x: NFloat, y: NFloat): NFloat;
    static Ieee754Remainder(left: NFloat, right: NFloat): NFloat;
    static ILogB(x: NFloat): int;
    static IsEvenInteger(value: NFloat): boolean;
    static IsFinite(value: NFloat): boolean;
    static IsInfinity(value: NFloat): boolean;
    static IsInteger(value: NFloat): boolean;
    static IsNaN(value: NFloat): boolean;
    static IsNegative(value: NFloat): boolean;
    static IsNegativeInfinity(value: NFloat): boolean;
    static IsNormal(value: NFloat): boolean;
    static IsOddInteger(value: NFloat): boolean;
    static IsPositive(value: NFloat): boolean;
    static IsPositiveInfinity(value: NFloat): boolean;
    static IsPow2(value: NFloat): boolean;
    static IsRealNumber(value: NFloat): boolean;
    static IsSubnormal(value: NFloat): boolean;
    static Lerp(value1: NFloat, value2: NFloat, amount: NFloat): NFloat;
    static Log(x: NFloat, newBase: NFloat): NFloat;
    static Log(x: NFloat): NFloat;
    static Log10(x: NFloat): NFloat;
    static Log10P1(x: NFloat): NFloat;
    static Log2(value: NFloat): NFloat;
    static Log2P1(x: NFloat): NFloat;
    static LogP1(x: NFloat): NFloat;
    static Max(x: NFloat, y: NFloat): NFloat;
    static MaxMagnitude(x: NFloat, y: NFloat): NFloat;
    static MaxMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    static MaxNative(x: NFloat, y: NFloat): NFloat;
    static MaxNumber(x: NFloat, y: NFloat): NFloat;
    static Min(x: NFloat, y: NFloat): NFloat;
    static MinMagnitude(x: NFloat, y: NFloat): NFloat;
    static MinMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    static MinNative(x: NFloat, y: NFloat): NFloat;
    static MinNumber(x: NFloat, y: NFloat): NFloat;
    static MultiplyAddEstimate(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    static Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    static Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): NFloat;
    static Parse(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    static Parse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): NFloat;
    static Parse(s: string, style: NumberStyles, provider: IFormatProvider): NFloat;
    static Parse(s: string, style: NumberStyles): NFloat;
    static Parse(s: string, provider: IFormatProvider): NFloat;
    static Parse(s: string): NFloat;
    static Pow(x: NFloat, y: NFloat): NFloat;
    static RadiansToDegrees(radians: NFloat): NFloat;
    static ReciprocalEstimate(x: NFloat): NFloat;
    static ReciprocalSqrtEstimate(x: NFloat): NFloat;
    static RootN(x: NFloat, n: int): NFloat;
    static Round(x: NFloat, digits: int, mode: MidpointRounding): NFloat;
    static Round(x: NFloat, digits: int): NFloat;
    static Round(x: NFloat, mode: MidpointRounding): NFloat;
    static Round(x: NFloat): NFloat;
    static ScaleB(x: NFloat, n: int): NFloat;
    static Sign(value: NFloat): int;
    static Sin(x: NFloat): NFloat;
    static SinCos(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    static SinCosPi(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    static Sinh(x: NFloat): NFloat;
    static SinPi(x: NFloat): NFloat;
    static Sqrt(x: NFloat): NFloat;
    static Tan(x: NFloat): NFloat;
    static Tanh(x: NFloat): NFloat;
    static TanPi(x: NFloat): NFloat;
    static Truncate(x: NFloat): NFloat;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<NFloat> }): boolean;
    static TryParse(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static TryParse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static TryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<NFloat> }): boolean;
    static TryParse(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static TryParse(s: string, provider: IFormatProvider, result: { value: ref<NFloat> }): boolean;
    static TryParse(s: string, result: { value: ref<NFloat> }): boolean;
}


export interface __NFloat$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<NFloat>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<NFloat>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<NFloat>;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<NFloat>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<NFloat>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<NFloat, NFloat>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<NFloat>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<NFloat>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<NFloat>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<NFloat>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<NFloat>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<NFloat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: NFloat): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<char>>, charsWritten: { value: ref<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<char>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>): int;
}

export type NFloat = NFloat$instance & __NFloat$views;


export class OSPlatform$instance {
    equals(other: OSPlatform): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly FreeBSD: OSPlatform;
    static readonly Linux: OSPlatform;
    static readonly OSX: OSPlatform;
    static readonly Windows: OSPlatform;
    static Create(osPlatform: string): OSPlatform;
}


export interface __OSPlatform$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<OSPlatform>;

    // Structural method bridges for numeric interface constraints
    Equals(other: OSPlatform): boolean;
}

export type OSPlatform = OSPlatform$instance & __OSPlatform$views;


export class PinnedGCHandle_1$instance<T> {
    constructor(target: T);
    readonly isAllocated: boolean;
    target: T;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: PinnedGCHandle_1<T>): boolean;
    getAddressOfObjectData(): ptr<void>;
    getHashCode(): int;
    static FromIntPtr<T>(value: nint): PinnedGCHandle_1<T>;
    static ToIntPtr<T>(value: PinnedGCHandle_1<T>): nint;
}


export interface __PinnedGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PinnedGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PinnedGCHandle_1<T>): boolean;
}

export type PinnedGCHandle_1<T> = PinnedGCHandle_1$instance<T> & __PinnedGCHandle_1$views<T>;


export class WeakGCHandle_1$instance<T> {
    constructor(target: T, trackResurrection: boolean);
    readonly isAllocated: boolean;
    dispose(): void;
    equals(obj: unknown): boolean;
    equals(other: WeakGCHandle_1<T>): boolean;
    getHashCode(): int;
    setTarget(target: T): void;
    tryGetTarget(target: { value: ref<T> }): boolean;
    static FromIntPtr<T>(value: nint): WeakGCHandle_1<T>;
    static ToIntPtr<T>(value: WeakGCHandle_1<T>): nint;
}


export interface __WeakGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<WeakGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: WeakGCHandle_1<T>): boolean;
}

export type WeakGCHandle_1<T> = WeakGCHandle_1$instance<T> & __WeakGCHandle_1$views<T>;


export class AllowReversePInvokeCallsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type AllowReversePInvokeCallsAttribute = AllowReversePInvokeCallsAttribute$instance;

export class AutomationProxyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(val: boolean);
    readonly value: boolean;
}


export type AutomationProxyAttribute = AutomationProxyAttribute$instance;

export class BestFitMappingAttribute$instance extends System_Internal.Attribute$instance {
    constructor(BestFitMapping: boolean);
    ThrowOnUnmappableChar: boolean;
    readonly bestFitMapping: boolean;
}


export type BestFitMappingAttribute = BestFitMappingAttribute$instance;

export class BStrWrapper$instance {
    constructor(value: string);
    constructor(value: unknown);
    readonly wrappedObject: string;
}


export type BStrWrapper = BStrWrapper$instance;

export class ClassInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(classInterfaceType: ClassInterfaceType);
    constructor(classInterfaceType: short);
    readonly value: ClassInterfaceType;
}


export type ClassInterfaceAttribute = ClassInterfaceAttribute$instance;

export class CoClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor(coClass: Type);
    readonly coClass: Type;
}


export type CoClassAttribute = CoClassAttribute$instance;

export class ComAliasNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(alias: string);
    readonly value: string;
}


export type ComAliasNameAttribute = ComAliasNameAttribute$instance;

export class ComAwareEventInfo$instance extends System_Reflection_Internal.EventInfo$instance {
    constructor(type_: Type, eventName: string);
    readonly attributes: EventAttributes;
    readonly declaringType: Type;
    readonly metadataToken: int;
    readonly module_: Module;
    readonly name: string;
    readonly reflectedType: Type;
    addEventHandler(target: unknown, handler: Function): void;
    getAddMethod(nonPublic: boolean): MethodInfo;
    getAddMethod(): MethodInfo;
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getOtherMethods(nonPublic: boolean): MethodInfo[];
    getOtherMethods(): MethodInfo[];
    getRaiseMethod(nonPublic: boolean): MethodInfo;
    getRaiseMethod(): MethodInfo;
    getRemoveMethod(nonPublic: boolean): MethodInfo;
    getRemoveMethod(): MethodInfo;
    isDefined(attributeType: Type, inherit: boolean): boolean;
    removeEventHandler(target: unknown, handler: Function): void;
}


export interface __ComAwareEventInfo$views {
    As_ICustomAttributeProvider(): System_Reflection_Internal.ICustomAttributeProvider$instance;
}

export type ComAwareEventInfo = ComAwareEventInfo$instance & __ComAwareEventInfo$views;


export class ComCompatibleVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int, build: int, revision: int);
    readonly buildNumber: int;
    readonly majorVersion: int;
    readonly minorVersion: int;
    readonly revisionNumber: int;
}


export type ComCompatibleVersionAttribute = ComCompatibleVersionAttribute$instance;

export class ComConversionLossAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComConversionLossAttribute = ComConversionLossAttribute$instance;

export class ComDefaultInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(defaultInterface: Type);
    readonly value: Type;
}


export type ComDefaultInterfaceAttribute = ComDefaultInterfaceAttribute$instance;

export class ComEventInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(SourceInterface: Type, EventProvider: Type);
    readonly eventProvider: Type;
    readonly sourceInterface: Type;
}


export type ComEventInterfaceAttribute = ComEventInterfaceAttribute$instance;

export class COMException$instance extends ExternalException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, errorCode: int);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __COMException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type COMException = COMException$instance & __COMException$views;


export class ComImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComImportAttribute = ComImportAttribute$instance;

export class ComRegisterFunctionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComRegisterFunctionAttribute = ComRegisterFunctionAttribute$instance;

export class ComSourceInterfacesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(sourceInterfaces: string);
    constructor(sourceInterface: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type);
    constructor(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type, sourceInterface4: Type);
    readonly value: string;
}


export type ComSourceInterfacesAttribute = ComSourceInterfacesAttribute$instance;

export class ComUnregisterFunctionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ComUnregisterFunctionAttribute = ComUnregisterFunctionAttribute$instance;

export class ComVisibleAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visibility: boolean);
    readonly value: boolean;
}


export type ComVisibleAttribute = ComVisibleAttribute$instance;

export abstract class ComWrappers$instance {
    getOrCreateComInterfaceForObject(instance: unknown, flags: CreateComInterfaceFlags): nint;
    getOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags): unknown;
    getOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, userState: unknown): unknown;
    getOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown): unknown;
    getOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown, inner: nint): unknown;
    static GetIUnknownImpl(fpQueryInterface: { value: ref<nint> }, fpAddRef: { value: ref<nint> }, fpRelease: { value: ref<nint> }): void;
    static RegisterForMarshalling(instance: ComWrappers): void;
    static RegisterForTrackerSupport(instance: ComWrappers): void;
    static TryGetComInstance(obj: unknown, unknown_: { value: ref<nint> }): boolean;
    static TryGetObject(unknown_: nint, obj: { value: ref<unknown> }): boolean;
}


export type ComWrappers = ComWrappers$instance;

export abstract class CriticalHandle$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    readonly isClosed: boolean;
    readonly isInvalid: boolean;
    close(): void;
    dispose(): void;
    setHandleAsInvalid(): void;
}


export interface __CriticalHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type CriticalHandle = CriticalHandle$instance & __CriticalHandle$views;


export class CurrencyWrapper$instance {
    constructor(obj: decimal);
    constructor(obj: unknown);
    readonly wrappedObject: decimal;
}


export type CurrencyWrapper = CurrencyWrapper$instance;

export class DefaultCharSetAttribute$instance extends System_Internal.Attribute$instance {
    constructor(charSet: CharSet);
    readonly charSet: CharSet;
}


export type DefaultCharSetAttribute = DefaultCharSetAttribute$instance;

export class DefaultDllImportSearchPathsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(paths: DllImportSearchPath);
    readonly paths: DllImportSearchPath;
}


export type DefaultDllImportSearchPathsAttribute = DefaultDllImportSearchPathsAttribute$instance;

export class DefaultParameterValueAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: unknown);
    readonly value: unknown;
}


export type DefaultParameterValueAttribute = DefaultParameterValueAttribute$instance;

export class DispatchWrapper$instance {
    constructor(obj: unknown);
    readonly wrappedObject: unknown;
}


export type DispatchWrapper = DispatchWrapper$instance;

export class DispIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dispId: int);
    readonly value: int;
}


export type DispIdAttribute = DispIdAttribute$instance;

export class DllImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dllName: string);
    EntryPoint: string;
    CharSet: CharSet;
    SetLastError: boolean;
    ExactSpelling: boolean;
    CallingConvention: CallingConvention;
    BestFitMapping: boolean;
    PreserveSig: boolean;
    ThrowOnUnmappableChar: boolean;
    readonly value: string;
}


export type DllImportAttribute = DllImportAttribute$instance;

export class DllImportResolver$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): nint;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
}


export interface __DllImportResolver$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DllImportResolver = DllImportResolver$instance & __DllImportResolver$views;


export class DynamicInterfaceCastableImplementationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DynamicInterfaceCastableImplementationAttribute = DynamicInterfaceCastableImplementationAttribute$instance;

export class ErrorWrapper$instance {
    constructor(errorCode: int);
    constructor(errorCode: unknown);
    constructor(e: Exception);
    readonly errorCode: int;
}


export type ErrorWrapper = ErrorWrapper$instance;

export class ExternalException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, errorCode: int);
    readonly errorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __ExternalException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExternalException = ExternalException$instance & __ExternalException$views;


export class FieldOffsetAttribute$instance extends System_Internal.Attribute$instance {
    constructor(offset: int);
    readonly value: int;
}


export type FieldOffsetAttribute = FieldOffsetAttribute$instance;

export class GuidAttribute$instance extends System_Internal.Attribute$instance {
    constructor(guid: string);
    readonly value: string;
}


export type GuidAttribute = GuidAttribute$instance;

export class HandleCollector$instance {
    constructor(name: string, initialThreshold: int);
    constructor(name: string, initialThreshold: int, maximumThreshold: int);
    readonly count: int;
    readonly initialThreshold: int;
    readonly maximumThreshold: int;
    readonly name: string;
    add(): void;
    remove(): void;
}


export type HandleCollector = HandleCollector$instance;

export class ImportedFromTypeLibAttribute$instance extends System_Internal.Attribute$instance {
    constructor(tlbFile: string);
    readonly value: string;
}


export type ImportedFromTypeLibAttribute = ImportedFromTypeLibAttribute$instance;

export class InAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type InAttribute = InAttribute$instance;

export class InterfaceTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(interfaceType: ComInterfaceType);
    constructor(interfaceType: short);
    readonly value: ComInterfaceType;
}


export type InterfaceTypeAttribute = InterfaceTypeAttribute$instance;

export class InvalidComObjectException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidComObjectException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidComObjectException = InvalidComObjectException$instance & __InvalidComObjectException$views;


export class InvalidOleVariantTypeException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidOleVariantTypeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidOleVariantTypeException = InvalidOleVariantTypeException$instance & __InvalidOleVariantTypeException$views;


export class LCIDConversionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(lcid: int);
    readonly value: int;
}


export type LCIDConversionAttribute = LCIDConversionAttribute$instance;

export class LibraryImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor(libraryName: string);
    entryPoint: string;
    readonly libraryName: string;
    setLastError: boolean;
    stringMarshalling: StringMarshalling;
    stringMarshallingCustomType: Type;
}


export type LibraryImportAttribute = LibraryImportAttribute$instance;

export class ManagedToNativeComInteropStubAttribute$instance extends System_Internal.Attribute$instance {
    constructor(classType: Type, methodName: string);
    readonly classType: Type;
    readonly methodName: string;
}


export type ManagedToNativeComInteropStubAttribute = ManagedToNativeComInteropStubAttribute$instance;

export class MarshalAsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(unmanagedType: UnmanagedType);
    constructor(unmanagedType: short);
    SafeArraySubType: VarEnum;
    SafeArrayUserDefinedSubType: Type;
    IidParameterIndex: int;
    ArraySubType: UnmanagedType;
    SizeParamIndex: short;
    SizeConst: int;
    MarshalType: string;
    MarshalTypeRef: Type;
    MarshalCookie: string;
    readonly value: UnmanagedType;
}


export type MarshalAsAttribute = MarshalAsAttribute$instance;

export class MarshalDirectiveException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MarshalDirectiveException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MarshalDirectiveException = MarshalDirectiveException$instance & __MarshalDirectiveException$views;


export class OptionalAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OptionalAttribute = OptionalAttribute$instance;

export class OutAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OutAttribute = OutAttribute$instance;

export class PosixSignalContext$instance {
    constructor(signal: PosixSignal);
    cancel: boolean;
    readonly signal: PosixSignal;
}


export type PosixSignalContext = PosixSignalContext$instance;

export class PosixSignalRegistration$instance {
    dispose(): void;
    static Create(signal: PosixSignal, handler: Action_1<PosixSignalContext>): PosixSignalRegistration;
}


export interface __PosixSignalRegistration$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type PosixSignalRegistration = PosixSignalRegistration$instance & __PosixSignalRegistration$views;


export class PreserveSigAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type PreserveSigAttribute = PreserveSigAttribute$instance;

export class PrimaryInteropAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int);
    readonly majorVersion: int;
    readonly minorVersion: int;
}


export type PrimaryInteropAssemblyAttribute = PrimaryInteropAssemblyAttribute$instance;

export class ProgIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(progId: string);
    readonly value: string;
}


export type ProgIdAttribute = ProgIdAttribute$instance;

export class SafeArrayRankMismatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SafeArrayRankMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayRankMismatchException = SafeArrayRankMismatchException$instance & __SafeArrayRankMismatchException$views;


export class SafeArrayTypeMismatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SafeArrayTypeMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayTypeMismatchException = SafeArrayTypeMismatchException$instance & __SafeArrayTypeMismatchException$views;


export abstract class SafeBuffer$instance extends Microsoft_Win32_SafeHandles_Internal.SafeHandleZeroOrMinusOneIsInvalid$instance {
    readonly byteLength: ulong;
    acquirePointer(pointer: { value: ref<ptr<byte>> }): void;
    dispose(): void;
    initialize(numBytes: ulong): void;
    initialize(numElements: uint, sizeOfEachElement: uint): void;
    initialize<T extends unknown>(numElements: uint): void;
    read<T extends unknown>(byteOffset: ulong): T;
    readArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    readSpan<T extends unknown>(byteOffset: ulong, buffer: Span_1<T>): void;
    releasePointer(): void;
    write<T extends unknown>(byteOffset: ulong, value: T): void;
    writeArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    writeSpan<T extends unknown>(byteOffset: ulong, data: ReadOnlySpan_1<T>): void;
}


export interface __SafeBuffer$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeBuffer = SafeBuffer$instance & __SafeBuffer$views;


export abstract class SafeHandle$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    readonly isClosed: boolean;
    readonly isInvalid: boolean;
    close(): void;
    dangerousAddRef(success: { value: ref<boolean> }): void;
    dangerousGetHandle(): nint;
    dangerousRelease(): void;
    dispose(): void;
    setHandleAsInvalid(): void;
}


export interface __SafeHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeHandle = SafeHandle$instance & __SafeHandle$views;


export class SEHException$instance extends ExternalException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    canResume(): boolean;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SEHException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SEHException = SEHException$instance & __SEHException$views;


export class StandardOleMarshalObject$instance extends System_Internal.MarshalByRefObject$instance {
}


export type StandardOleMarshalObject = StandardOleMarshalObject$instance;

export class StructLayoutAttribute$instance extends System_Internal.Attribute$instance {
    constructor(layoutKind: LayoutKind);
    constructor(layoutKind: short);
    Pack: int;
    Size: int;
    CharSet: CharSet;
    readonly value: LayoutKind;
}


export type StructLayoutAttribute = StructLayoutAttribute$instance;

export class SuppressGCTransitionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SuppressGCTransitionAttribute = SuppressGCTransitionAttribute$instance;

export class TypeIdentifierAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(scope: string, identifier: string);
    readonly identifier: string;
    readonly scope: string;
}


export type TypeIdentifierAttribute = TypeIdentifierAttribute$instance;

export class TypeLibFuncAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibFuncFlags);
    constructor(flags: short);
    readonly value: TypeLibFuncFlags;
}


export type TypeLibFuncAttribute = TypeLibFuncAttribute$instance;

export class TypeLibImportClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor(importClass: Type);
    readonly value: string;
}


export type TypeLibImportClassAttribute = TypeLibImportClassAttribute$instance;

export class TypeLibTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibTypeFlags);
    constructor(flags: short);
    readonly value: TypeLibTypeFlags;
}


export type TypeLibTypeAttribute = TypeLibTypeAttribute$instance;

export class TypeLibVarAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: TypeLibVarFlags);
    constructor(flags: short);
    readonly value: TypeLibVarFlags;
}


export type TypeLibVarAttribute = TypeLibVarAttribute$instance;

export class TypeLibVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(major: int, minor: int);
    readonly majorVersion: int;
    readonly minorVersion: int;
}


export type TypeLibVersionAttribute = TypeLibVersionAttribute$instance;

export class TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(assemblyName: string);
}


export type TypeMapAssemblyTargetAttribute_1<TTypeMapGroup> = TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup>;

export class TypeMapAssociationAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(source: Type, proxy: Type);
}


export type TypeMapAssociationAttribute_1<TTypeMapGroup> = TypeMapAssociationAttribute_1$instance<TTypeMapGroup>;

export class TypeMapAttribute_1$instance<TTypeMapGroup> extends System_Internal.Attribute$instance {
    constructor(value: string, target: Type);
    constructor(value: string, target: Type, trimTarget: Type);
}


export type TypeMapAttribute_1<TTypeMapGroup> = TypeMapAttribute_1$instance<TTypeMapGroup>;

export class UnknownWrapper$instance {
    constructor(obj: unknown);
    readonly wrappedObject: unknown;
}


export type UnknownWrapper = UnknownWrapper$instance;

export class UnmanagedCallConvAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    CallConvs: Type[];
}


export type UnmanagedCallConvAttribute = UnmanagedCallConvAttribute$instance;

export class UnmanagedCallersOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    CallConvs: Type[];
    EntryPoint: string;
}


export type UnmanagedCallersOnlyAttribute = UnmanagedCallersOnlyAttribute$instance;

export class UnmanagedFunctionPointerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(callingConvention: CallingConvention);
    BestFitMapping: boolean;
    SetLastError: boolean;
    ThrowOnUnmappableChar: boolean;
    CharSet: CharSet;
    readonly callingConvention: CallingConvention;
}


export type UnmanagedFunctionPointerAttribute = UnmanagedFunctionPointerAttribute$instance;

export class VariantWrapper$instance {
    constructor(obj: unknown);
    readonly wrappedObject: unknown;
}


export type VariantWrapper = VariantWrapper$instance;

export class WasmImportLinkageAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type WasmImportLinkageAttribute = WasmImportLinkageAttribute$instance;

export abstract class CollectionsMarshal$instance {
    static AsBytes(array: BitArray): Span_1<CLROf<byte>>;
    static AsSpan<T>(list: List_1<T>): Span_1<T>;
    static GetValueRefOrAddDefault<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey, exists: { value: ref<boolean> }): ref<TValue>;
    static GetValueRefOrAddDefault<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey, exists: { value: ref<boolean> }): ref<TValue>;
    static GetValueRefOrNullRef<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey): ref<TValue>;
    static GetValueRefOrNullRef<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey): ref<TValue>;
    static SetCount<T>(list: List_1<T>, count: int): void;
}


export type CollectionsMarshal = CollectionsMarshal$instance;

export abstract class ComEventsHelper$instance {
    static Combine(rcw: unknown, iid: Guid, dispid: int, d: Function): void;
    static Remove(rcw: unknown, iid: Guid, dispid: int, d: Function): Function;
}


export type ComEventsHelper = ComEventsHelper$instance;

export abstract class GCHandleExtensions$instance {
    static GetAddressOfArrayData<T>(handle: PinnedGCHandle_1<T[]>): ptr<T>;
    static GetAddressOfStringData(handle: PinnedGCHandle_1<CLROf<string>>): ptr<char>;
}


export type GCHandleExtensions = GCHandleExtensions$instance;

export abstract class ImmutableCollectionsMarshal$instance {
    static AsArray<T>(array: ImmutableArray_1<T>): T[];
    static AsImmutableArray<T>(array: T[]): ImmutableArray_1<T>;
    static AsMemory<T>(builder: ImmutableArray_1_Builder<T>): Memory_1<T>;
}


export type ImmutableCollectionsMarshal = ImmutableCollectionsMarshal$instance;

export abstract class JsonMarshal$instance {
    static GetRawUtf8PropertyName(property: JsonProperty): ReadOnlySpan_1<CLROf<byte>>;
    static GetRawUtf8Value(element: JsonElement): ReadOnlySpan_1<CLROf<byte>>;
}


export type JsonMarshal = JsonMarshal$instance;

export abstract class Marshal$instance {
    static readonly systemDefaultCharSize: int;
    static readonly systemMaxDBCSCharSize: int;
    static AddRef(pUnk: nint): int;
    static AllocCoTaskMem(cb: int): nint;
    static AllocHGlobal(cb: int): nint;
    static AllocHGlobal(cb: nint): nint;
    static AreComObjectsAvailableForCleanup(): boolean;
    static BindToMoniker(monikerName: string): unknown;
    static ChangeWrapperHandleStrength(otp: unknown, fIsWeak: boolean): void;
    static CleanupUnusedObjectsInCurrentContext(): void;
    static Copy(source: byte[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: char[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: double[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: short[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: int[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: long[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: nint, destination: byte[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: char[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: double[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: short[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: int[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: long[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: nint[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: float[], startIndex: int, length: int): void;
    static Copy(source: nint[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: float[], startIndex: int, destination: nint, length: int): void;
    static CreateAggregatedObject(pOuter: nint, o: unknown): nint;
    static CreateAggregatedObject<T>(pOuter: nint, o: T): nint;
    static CreateWrapperOfType(o: unknown, t: Type): unknown;
    static CreateWrapperOfType<T, TWrapper>(o: T): TWrapper;
    static DestroyStructure(ptr: nint, structuretype: Type): void;
    static DestroyStructure<T>(ptr: nint): void;
    static FinalReleaseComObject(o: unknown): int;
    static FreeBSTR(ptr: nint): void;
    static FreeCoTaskMem(ptr: nint): void;
    static FreeHGlobal(hglobal: nint): void;
    static GenerateGuidForType(type_: Type): Guid;
    static GenerateProgIdForType(type_: Type): string;
    static GetComInterfaceForObject(o: unknown, T: Type, mode: CustomQueryInterfaceMode): nint;
    static GetComInterfaceForObject(o: unknown, T: Type): nint;
    static GetComInterfaceForObject<T, TInterface>(o: T): nint;
    static GetComObjectData(obj: unknown, key: unknown): unknown;
    static GetDelegateForFunctionPointer(ptr: nint, t: Type): Function;
    static GetDelegateForFunctionPointer<TDelegate>(ptr: nint): TDelegate;
    static GetEndComSlot(t: Type): int;
    static GetExceptionCode(): int;
    static GetExceptionForHR(errorCode: int, iid: { value: ref<Guid> }, pUnk: nint): Exception;
    static GetExceptionForHR(errorCode: int, errorInfo: nint): Exception;
    static GetExceptionForHR(errorCode: int): Exception;
    static GetExceptionPointers(): nint;
    static GetFunctionPointerForDelegate(d: Function): nint;
    static GetFunctionPointerForDelegate<TDelegate>(d: TDelegate): nint;
    static GetHINSTANCE(m: Module): nint;
    static GetHRForException(e: Exception): int;
    static GetHRForLastWin32Error(): int;
    static GetIDispatchForObject(o: unknown): nint;
    static GetIUnknownForObject(o: unknown): nint;
    static GetLastPInvokeError(): int;
    static GetLastPInvokeErrorMessage(): string;
    static GetLastSystemError(): int;
    static GetLastWin32Error(): int;
    static GetNativeVariantForObject(obj: unknown, pDstNativeVariant: nint): void;
    static GetNativeVariantForObject<T>(obj: T, pDstNativeVariant: nint): void;
    static GetObjectForIUnknown(pUnk: nint): unknown;
    static GetObjectForNativeVariant(pSrcNativeVariant: nint): unknown;
    static GetObjectForNativeVariant<T>(pSrcNativeVariant: nint): T;
    static GetObjectsForNativeVariants(aSrcNativeVariant: nint, cVars: int): unknown[];
    static GetObjectsForNativeVariants<T>(aSrcNativeVariant: nint, cVars: int): T[];
    static GetPInvokeErrorMessage(error: int): string;
    static GetStartComSlot(t: Type): int;
    static GetTypedObjectForIUnknown(pUnk: nint, t: Type): unknown;
    static GetTypeFromCLSID(clsid: Guid): Type;
    static GetTypeInfoName(typeInfo: ITypeInfo): string;
    static GetUniqueObjectForIUnknown(unknown_: nint): unknown;
    static InitHandle(safeHandle: SafeHandle, handle: nint): void;
    static IsComObject(o: unknown): boolean;
    static IsTypeVisibleFromCom(t: Type): boolean;
    static OffsetOf<T>(fieldName: string): nint;
    static OffsetOf(t: Type, fieldName: string): nint;
    static Prelink(m: MethodInfo): void;
    static PrelinkAll(c: Type): void;
    static PtrToStringAnsi(ptr: nint, len: int): string;
    static PtrToStringAnsi(ptr: nint): string;
    static PtrToStringAuto(ptr: nint, len: int): string;
    static PtrToStringAuto(ptr: nint): string;
    static PtrToStringBSTR(ptr: nint): string;
    static PtrToStringUni(ptr: nint, len: int): string;
    static PtrToStringUni(ptr: nint): string;
    static PtrToStringUTF8(ptr: nint, byteLen: int): string;
    static PtrToStringUTF8(ptr: nint): string;
    static PtrToStructure(ptr: nint, structure: unknown): void;
    static PtrToStructure(ptr: nint, structureType: Type): unknown;
    static PtrToStructure<T>(ptr: nint, structure: T): void;
    static PtrToStructure<T>(ptr: nint): T;
    static QueryInterface(pUnk: nint, iid: { value: ref<Guid> }, ppv: { value: ref<nint> }): int;
    static ReadByte(ptr: nint, ofs: int): byte;
    static ReadByte(ptr: nint): byte;
    static ReadByte(ptr: unknown, ofs: int): byte;
    static ReadInt16(ptr: nint, ofs: int): short;
    static ReadInt16(ptr: nint): short;
    static ReadInt16(ptr: unknown, ofs: int): short;
    static ReadInt32(ptr: nint, ofs: int): int;
    static ReadInt32(ptr: nint): int;
    static ReadInt32(ptr: unknown, ofs: int): int;
    static ReadInt64(ptr: nint, ofs: int): long;
    static ReadInt64(ptr: nint): long;
    static ReadInt64(ptr: unknown, ofs: int): long;
    static ReadIntPtr(ptr: nint, ofs: int): nint;
    static ReadIntPtr(ptr: nint): nint;
    static ReadIntPtr(ptr: unknown, ofs: int): nint;
    static ReAllocCoTaskMem(pv: nint, cb: int): nint;
    static ReAllocHGlobal(pv: nint, cb: nint): nint;
    static Release(pUnk: nint): int;
    static ReleaseComObject(o: unknown): int;
    static SecureStringToBSTR(s: SecureString): nint;
    static SecureStringToCoTaskMemAnsi(s: SecureString): nint;
    static SecureStringToCoTaskMemUnicode(s: SecureString): nint;
    static SecureStringToGlobalAllocAnsi(s: SecureString): nint;
    static SecureStringToGlobalAllocUnicode(s: SecureString): nint;
    static SetComObjectData(obj: unknown, key: unknown, data: unknown): boolean;
    static SetLastPInvokeError(error: int): void;
    static SetLastSystemError(error: int): void;
    static SizeOf<T>(): int;
    static SizeOf(structure: unknown): int;
    static SizeOf(t: Type): int;
    static SizeOf<T>(structure: T): int;
    static StringToBSTR(s: string): nint;
    static StringToCoTaskMemAnsi(s: string): nint;
    static StringToCoTaskMemAuto(s: string): nint;
    static StringToCoTaskMemUni(s: string): nint;
    static StringToCoTaskMemUTF8(s: string): nint;
    static StringToHGlobalAnsi(s: string): nint;
    static StringToHGlobalAuto(s: string): nint;
    static StringToHGlobalUni(s: string): nint;
    static StructureToPtr(structure: unknown, ptr: nint, fDeleteOld: boolean): void;
    static StructureToPtr<T>(structure: T, ptr: nint, fDeleteOld: boolean): void;
    static ThrowExceptionForHR(errorCode: int, iid: { value: ref<Guid> }, pUnk: nint): void;
    static ThrowExceptionForHR(errorCode: int, errorInfo: nint): void;
    static ThrowExceptionForHR(errorCode: int): void;
    static UnsafeAddrOfPinnedArrayElement(arr: ClrArray, index: int): nint;
    static UnsafeAddrOfPinnedArrayElement<T>(arr: T[], index: int): nint;
    static WriteByte(ptr: nint, val: byte): void;
    static WriteByte(ptr: nint, ofs: int, val: byte): void;
    static WriteByte(ptr: unknown, ofs: int, val: byte): void;
    static WriteInt16(ptr: nint, val: char): void;
    static WriteInt16(ptr: nint, val: short): void;
    static WriteInt16(ptr: nint, ofs: int, val: char): void;
    static WriteInt16(ptr: nint, ofs: int, val: short): void;
    static WriteInt16(ptr: { value: unknown }, ofs: int, val: char): void;
    static WriteInt16(ptr: unknown, ofs: int, val: short): void;
    static WriteInt32(ptr: nint, ofs: int, val: int): void;
    static WriteInt32(ptr: nint, val: int): void;
    static WriteInt32(ptr: unknown, ofs: int, val: int): void;
    static WriteInt64(ptr: nint, ofs: int, val: long): void;
    static WriteInt64(ptr: nint, val: long): void;
    static WriteInt64(ptr: unknown, ofs: int, val: long): void;
    static WriteIntPtr(ptr: nint, ofs: int, val: nint): void;
    static WriteIntPtr(ptr: nint, val: nint): void;
    static WriteIntPtr(ptr: unknown, ofs: int, val: nint): void;
    static ZeroFreeBSTR(s: nint): void;
    static ZeroFreeCoTaskMemAnsi(s: nint): void;
    static ZeroFreeCoTaskMemUnicode(s: nint): void;
    static ZeroFreeCoTaskMemUTF8(s: nint): void;
    static ZeroFreeGlobalAllocAnsi(s: nint): void;
    static ZeroFreeGlobalAllocUnicode(s: nint): void;
}


export type Marshal = Marshal$instance;

export abstract class MemoryMarshal$instance {
    static AsBytes<T extends unknown>(span: ReadOnlySpan_1<T>): ReadOnlySpan_1<CLROf<byte>>;
    static AsBytes<T extends unknown>(span: Span_1<T>): Span_1<CLROf<byte>>;
    static AsMemory<T>(memory: ReadOnlyMemory_1<T>): Memory_1<T>;
    static AsRef<T extends unknown>(span: ReadOnlySpan_1<CLROf<byte>>): ref<T>;
    static AsRef<T extends unknown>(span: Span_1<CLROf<byte>>): ref<T>;
    static Cast<TFrom extends unknown, TTo extends unknown>(span: ReadOnlySpan_1<TFrom>): ReadOnlySpan_1<TTo>;
    static Cast<TFrom extends unknown, TTo extends unknown>(span: Span_1<TFrom>): Span_1<TTo>;
    static CreateFromPinnedArray<T>(array: T[], start: int, length: int): Memory_1<T>;
    static CreateReadOnlySpan<T>(reference: { value: ref<T> }, length: int): ReadOnlySpan_1<T>;
    static CreateReadOnlySpanFromNullTerminated(value: ptr<byte>): ReadOnlySpan_1<CLROf<byte>>;
    static CreateReadOnlySpanFromNullTerminated(value: ptr<char>): ReadOnlySpan_1<CLROf<char>>;
    static CreateSpan<T>(reference: { value: ref<T> }, length: int): Span_1<T>;
    static GetArrayDataReference(array: ClrArray): ref<byte>;
    static GetArrayDataReference<T>(array: T[]): ref<T>;
    static GetReference<T>(span: ReadOnlySpan_1<T>): ref<T>;
    static GetReference<T>(span: Span_1<T>): ref<T>;
    static Read<T extends unknown>(source: ReadOnlySpan_1<CLROf<byte>>): T;
    static ToEnumerable<T>(memory: ReadOnlyMemory_1<T>): IEnumerable_1<T>;
    static TryGetArray<T>(memory: ReadOnlyMemory_1<T>, segment: { value: ref<ArraySegment_1<T>> }): boolean;
    static TryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: ref<TManager> }, start: { value: ref<int> }, length: { value: ref<int> }): boolean;
    static TryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: { value: ref<TManager> }): boolean;
    static TryGetString(memory: ReadOnlyMemory_1<CLROf<char>>, text: { value: ref<string> }, start: { value: ref<int> }, length: { value: ref<int> }): boolean;
    static TryRead<T extends unknown>(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<T> }): boolean;
    static TryWrite<T extends unknown>(destination: Span_1<CLROf<byte>>, value: { value: ref<T> }): boolean;
    static Write<T extends unknown>(destination: Span_1<CLROf<byte>>, value: { value: ref<T> }): void;
}


export type MemoryMarshal = MemoryMarshal$instance;

export abstract class NativeLibrary$instance {
    static Free(handle: nint): void;
    static GetExport(handle: nint, name: string): nint;
    static GetMainProgramHandle(): nint;
    static Load(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
    static Load(libraryPath: string): nint;
    static SetDllImportResolver(assembly: Assembly, resolver: DllImportResolver): void;
    static TryGetExport(handle: nint, name: string, address: { value: ref<nint> }): boolean;
    static TryLoad(libraryPath: string, handle: { value: ref<nint> }): boolean;
    static TryLoad(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, handle: { value: ref<nint> }): boolean;
}


export type NativeLibrary = NativeLibrary$instance;

export abstract class NativeMemory$instance {
    static AlignedAlloc(byteCount: nuint, alignment: nuint): ptr<void>;
    static AlignedFree(ptr: ptr<void>): void;
    static AlignedRealloc(ptr: ptr<void>, byteCount: nuint, alignment: nuint): ptr<void>;
    static Alloc(elementCount: nuint, elementSize: nuint): ptr<void>;
    static Alloc(byteCount: nuint): ptr<void>;
    static AllocZeroed(elementCount: nuint, elementSize: nuint): ptr<void>;
    static AllocZeroed(byteCount: nuint): ptr<void>;
    static Clear(ptr: ptr<void>, byteCount: nuint): void;
    static Copy(source: ptr<void>, destination: ptr<void>, byteCount: nuint): void;
    static Fill(ptr: ptr<void>, byteCount: nuint, value: byte): void;
    static Free(ptr: ptr<void>): void;
    static Realloc(ptr: ptr<void>, byteCount: nuint): ptr<void>;
}


export type NativeMemory = NativeMemory$instance;

export abstract class RuntimeEnvironment$instance {
    static readonly SystemConfigurationFile: string;
    static FromGlobalAccessCache(a: Assembly): boolean;
    static GetRuntimeDirectory(): string;
    static GetRuntimeInterfaceAsIntPtr(clsid: Guid, riid: Guid): nint;
    static GetRuntimeInterfaceAsObject(clsid: Guid, riid: Guid): unknown;
    static GetSystemVersion(): string;
}


export type RuntimeEnvironment = RuntimeEnvironment$instance;

export abstract class RuntimeInformation$instance {
    static readonly RuntimeIdentifier: string;
    static readonly ProcessArchitecture: Architecture;
    static readonly OSDescription: string;
    static readonly OSArchitecture: Architecture;
    static readonly FrameworkDescription: string;
    static IsOSPlatform(osPlatform: OSPlatform): boolean;
}


export type RuntimeInformation = RuntimeInformation$instance;

export abstract class SequenceMarshal$instance {
    static TryGetArray<T>(sequence: ReadOnlySequence_1<T>, segment: { value: ref<ArraySegment_1<T>> }): boolean;
    static TryGetReadOnlyMemory<T>(sequence: ReadOnlySequence_1<T>, memory: { value: ref<ReadOnlyMemory_1<T>> }): boolean;
    static TryGetReadOnlySequenceSegment<T>(sequence: ReadOnlySequence_1<T>, startSegment: { value: ref<ReadOnlySequenceSegment_1<T>> }, startIndex: { value: ref<int> }, endSegment: { value: ref<ReadOnlySequenceSegment_1<T>> }, endIndex: { value: ref<int> }): boolean;
    static TryRead<T extends unknown>(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<T> }): boolean;
}


export type SequenceMarshal = SequenceMarshal$instance;

export abstract class TypeMapping$instance {
    static GetOrCreateExternalTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<CLROf<string>, Type>;
    static GetOrCreateProxyTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<Type, Type>;
}


export type TypeMapping = TypeMapping$instance;

