// Generated by tsbindgen - Architecture
// Namespace: System.Xml
// Assembly: System.Data.Common, System.Private.DataContractSerialization, System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IDictionary_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { DataRow, DataSet } from "../../System.Data/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { RequestCachePolicy } from "../../System.Net.Cache/internal/index.js";
import type { ICredentials, IWebProxy } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Encoding, StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { IXmlSchemaInfo, ValidationEventHandler, XmlSchemaCollection, XmlSchemaSet, XmlSchemaValidationFlags } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { IXPathNavigable, XPathNavigator } from "../../System.Xml.XPath/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Delegate, Double, Enum, EventArgs, Exception, Guid, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, SByte, Single, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, Uri, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ConformanceLevel {
    auto = 0,
    fragment = 1,
    document = 2
}


export enum DtdProcessing {
    prohibit = 0,
    ignore = 1,
    parse = 2
}


export enum EntityHandling {
    expandEntities = 1,
    expandCharEntities = 2
}


export enum Formatting {
    none = 0,
    indented = 1
}


export enum NamespaceHandling {
    default_ = 0,
    omitDuplicates = 1
}


export enum NewLineHandling {
    replace = 0,
    entitize = 1,
    none = 2
}


export enum ReadState {
    initial = 0,
    interactive = 1,
    error = 2,
    endOfFile = 3,
    closed = 4
}


export enum ValidationType {
    none = 0,
    auto = 1,
    dtd = 2,
    xdr = 3,
    schema = 4
}


export enum WhitespaceHandling {
    all = 0,
    significant = 1,
    none = 2
}


export enum WriteState {
    start = 0,
    prolog = 1,
    element = 2,
    attribute = 3,
    content = 4,
    closed = 5,
    error = 6
}


export enum XmlDateTimeSerializationMode {
    local = 0,
    utc = 1,
    unspecified = 2,
    roundtripKind = 3
}


export enum XmlDictionaryReaderQuotaTypes {
    maxDepth = 1,
    maxStringContentLength = 2,
    maxArrayLength = 4,
    maxBytesPerRead = 8,
    maxNameTableCharCount = 16
}


export enum XmlNamespaceScope {
    all = 0,
    excludeXml = 1,
    local = 2
}


export enum XmlNodeChangedAction {
    insert = 0,
    remove = 1,
    change = 2
}


export enum XmlNodeOrder {
    before = 0,
    after = 1,
    same = 2,
    unknown_ = 3
}


export enum XmlNodeType {
    none = 0,
    element = 1,
    attribute = 2,
    text = 3,
    cdata = 4,
    entityReference = 5,
    entity = 6,
    processingInstruction = 7,
    comment = 8,
    document = 9,
    documentType = 10,
    documentFragment = 11,
    notation = 12,
    whitespace = 13,
    significantWhitespace = 14,
    endElement = 15,
    endEntity = 16,
    xmlDeclaration = 17
}


export enum XmlOutputMethod {
    xml = 0,
    html = 1,
    text = 2,
    autoDetect = 3
}


export enum XmlSpace {
    none = 0,
    default_ = 1,
    preserve = 2
}


export enum XmlTokenizedType {
    cdata = 0,
    id = 1,
    idref = 2,
    idrefs = 3,
    entity = 4,
    entities = 5,
    nmtoken = 6,
    nmtokens = 7,
    notation = 8,
    enumeration = 9,
    qName = 10,
    ncName = 11,
    none = 12
}


export interface IApplicationResourceStreamResolver$instance {
    GetApplicationResourceStream(relativeUri: Uri): Stream;
}


export type IApplicationResourceStreamResolver = IApplicationResourceStreamResolver$instance;

export interface IFragmentCapableXmlDictionaryWriter$instance {
    readonly CanFragment: boolean;
    EndFragment(): void;
    StartFragment(stream: Stream, generateSelfContainedTextFragment: boolean): void;
    WriteFragment(buffer: byte[], offset: int, count: int): void;
}


export type IFragmentCapableXmlDictionaryWriter = IFragmentCapableXmlDictionaryWriter$instance;

export interface IHasXmlNode$instance {
    GetNode(): XmlNode;
}


export type IHasXmlNode = IHasXmlNode$instance;

export interface IStreamProvider$instance {
    GetStream(): Stream;
    ReleaseStream(stream: Stream): void;
}


export type IStreamProvider = IStreamProvider$instance;

export interface IXmlBinaryReaderInitializer$instance {
    SetInput(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): void;
    SetInput(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): void;
}


export type IXmlBinaryReaderInitializer = IXmlBinaryReaderInitializer$instance;

export interface IXmlBinaryWriterInitializer$instance {
    SetOutput(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession, ownsStream: boolean): void;
}


export type IXmlBinaryWriterInitializer = IXmlBinaryWriterInitializer$instance;

export interface IXmlDictionary$instance {
    TryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    TryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    TryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
}


export type IXmlDictionary = IXmlDictionary$instance;

export interface IXmlLineInfo$instance {
    readonly LineNumber: int;
    readonly LinePosition: int;
    HasLineInfo(): boolean;
}


export type IXmlLineInfo = IXmlLineInfo$instance;

export interface IXmlNamespaceResolver$instance {
    GetNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    LookupNamespace(prefix: string): string;
}


export type IXmlNamespaceResolver = IXmlNamespaceResolver$instance;

export interface IXmlTextReaderInitializer$instance {
    SetInput(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): void;
    SetInput(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): void;
}


export type IXmlTextReaderInitializer = IXmlTextReaderInitializer$instance;

export interface IXmlTextWriterInitializer$instance {
    SetOutput(stream: Stream, encoding: Encoding, ownsStream: boolean): void;
}


export type IXmlTextWriterInitializer = IXmlTextWriterInitializer$instance;

export class NameTable$instance extends XmlNameTable$instance {
    constructor();
    add(key: string): string;
    add(key: string[], start: int, len: int): string;
    get_(value: string): string;
    get_(key: string[], start: int, len: int): string;
}


export type NameTable = NameTable$instance;

export class OnXmlDictionaryReaderClose$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(reader: XmlDictionaryReader, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(reader: XmlDictionaryReader): void;
}


export interface __OnXmlDictionaryReaderClose$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OnXmlDictionaryReaderClose = OnXmlDictionaryReaderClose$instance & __OnXmlDictionaryReaderClose$views;


export class UniqueId$instance {
    constructor();
    constructor(guid: Guid);
    constructor(guid: byte[]);
    constructor(guid: byte[], offset: int);
    constructor(value: string);
    constructor(chars: string[], offset: int, count: int);
    readonly charArrayLength: int;
    readonly isGuid: boolean;
    equals(obj: any): boolean;
    getHashCode(): int;
    toCharArray(chars: string[], offset: int): int;
    toString(): string;
    tryGetGuid(guid: { value: ref<Guid> }): boolean;
    tryGetGuid(buffer: byte[], offset: int): boolean;
}


export type UniqueId = UniqueId$instance;

export class XmlAttribute$instance extends XmlNode$instance {
    readonly baseURI: string;
    innerText: string;
    innerXml: string;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly ownerElement: XmlElement;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly specified: boolean;
    value: string;
    appendChild(newChild: XmlNode): XmlNode;
    clone(): XmlNode;
    clone(): any;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    insertAfter(newChild: XmlNode, refChild: XmlNode): XmlNode;
    insertBefore(newChild: XmlNode, refChild: XmlNode): XmlNode;
    prependChild(newChild: XmlNode): XmlNode;
    removeChild(oldChild: XmlNode): XmlNode;
    replaceChild(newChild: XmlNode, oldChild: XmlNode): XmlNode;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlAttribute$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlAttribute = XmlAttribute$instance & __XmlAttribute$views;


export class XmlAttributeCollection$instance extends XmlNamedNodeMap$instance {
    append(node: XmlAttribute): XmlAttribute;
    copyTo(array: XmlAttribute[], index: int): void;
    get_Item(i: int): XmlAttribute;
    get_Item(name: string): XmlAttribute;
    get_Item(localName: string, namespaceURI: string): XmlAttribute;
    getEnumerator(): IEnumerator;
    insertAfter(newNode: XmlAttribute, refNode: XmlAttribute): XmlAttribute;
    insertBefore(newNode: XmlAttribute, refNode: XmlAttribute): XmlAttribute;
    prepend(node: XmlAttribute): XmlAttribute;
    remove(node: XmlAttribute): XmlAttribute;
    removeAll(): void;
    removeAt(i: int): XmlAttribute;
    setNamedItem(node: XmlNode): XmlNode;
}


export interface __XmlAttributeCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type XmlAttributeCollection = XmlAttributeCollection$instance & __XmlAttributeCollection$views;


export class XmlBinaryReaderSession$instance {
    constructor();
    add(id: int, value: string): XmlDictionaryString;
    clear(): void;
    tryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
}


export interface __XmlBinaryReaderSession$views {
    readonly As_IXmlDictionary: IXmlDictionary$instance;
}

export type XmlBinaryReaderSession = XmlBinaryReaderSession$instance & __XmlBinaryReaderSession$views;


export class XmlBinaryWriterSession$instance {
    constructor();
    reset(): void;
    tryAdd(value: XmlDictionaryString, key: { value: ref<int> }): boolean;
}


export type XmlBinaryWriterSession = XmlBinaryWriterSession$instance;

export class XmlCDataSection$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlCDataSection$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlCDataSection = XmlCDataSection$instance & __XmlCDataSection$views;


export abstract class XmlCharacterData$instance extends XmlLinkedNode$instance {
    data: string;
    innerText: string;
    readonly length: int;
    value: string;
    appendData(strData: string): void;
    clone(): any;
    clone(): XmlNode;
    createNavigator(): XPathNavigator;
    deleteData(offset: int, count: int): void;
    getEnumerator(): IEnumerator;
    insertData(offset: int, strData: string): void;
    replaceData(offset: int, count: int, strData: string): void;
    substring(offset: int, count: int): string;
}


export interface __XmlCharacterData$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlCharacterData = XmlCharacterData$instance & __XmlCharacterData$views;


export class XmlComment$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlComment$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlComment = XmlComment$instance & __XmlComment$views;


export class XmlConvert$instance {
    constructor();
    static DecodeName(name: string): string;
    static EncodeLocalName(name: string): string;
    static EncodeName(name: string): string;
    static EncodeNmToken(name: string): string;
    static IsNCNameChar(ch: string): boolean;
    static IsPublicIdChar(ch: string): boolean;
    static IsStartNCNameChar(ch: string): boolean;
    static IsWhitespaceChar(ch: string): boolean;
    static IsXmlChar(ch: string): boolean;
    static IsXmlSurrogatePair(lowChar: string, highChar: string): boolean;
    static ToBoolean(s: string): boolean;
    static ToByte(s: string): byte;
    static ToChar(s: string): string;
    static ToDateTime(s: string, format: string): DateTime;
    static ToDateTime(s: string, formats: string[]): DateTime;
    static ToDateTime(s: string, dateTimeOption: XmlDateTimeSerializationMode): DateTime;
    static ToDateTime(s: string): DateTime;
    static ToDateTimeOffset(s: string, format: string): DateTimeOffset;
    static ToDateTimeOffset(s: string, formats: string[]): DateTimeOffset;
    static ToDateTimeOffset(s: string): DateTimeOffset;
    static ToDecimal(s: string): decimal;
    static ToDouble(s: string): double;
    static ToGuid(s: string): Guid;
    static ToInt16(s: string): short;
    static ToInt32(s: string): int;
    static ToInt64(s: string): long;
    static ToSByte(s: string): sbyte;
    static ToSingle(s: string): float;
    static ToString(value: boolean): string;
    static ToString(value: byte): string;
    static ToString(value: string): string;
    static ToString(value: DateTime, format: string): string;
    static ToString(value: DateTime, dateTimeOption: XmlDateTimeSerializationMode): string;
    static ToString(value: DateTime): string;
    static ToString(value: DateTimeOffset, format: string): string;
    static ToString(value: DateTimeOffset): string;
    static ToString(value: decimal): string;
    static ToString(value: double): string;
    static ToString(value: Guid): string;
    static ToString(value: short): string;
    static ToString(value: int): string;
    static ToString(value: long): string;
    static ToString(value: sbyte): string;
    static ToString(value: float): string;
    static ToString(value: TimeSpan): string;
    static ToString(value: ushort): string;
    static ToString(value: uint): string;
    static ToString(value: ulong): string;
    static ToTimeSpan(s: string): TimeSpan;
    static ToUInt16(s: string): ushort;
    static ToUInt32(s: string): uint;
    static ToUInt64(s: string): ulong;
    static VerifyName(name: string): string;
    static VerifyNCName(name: string): string;
    static VerifyNMTOKEN(name: string): string;
    static VerifyPublicId(publicId: string): string;
    static VerifyTOKEN(token: string): string;
    static VerifyWhitespace(content: string): string;
    static VerifyXmlChars(content: string): string;
}


export type XmlConvert = XmlConvert$instance;

export class XmlDataDocument$instance extends XmlDocument$instance {
    constructor();
    constructor(dataset: DataSet);
    readonly dataSet: DataSet;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createElement(prefix: string, localName: string, namespaceURI: string): XmlElement;
    createElement(name: string): XmlElement;
    createElement(qualifiedName: string, namespaceURI: string): XmlElement;
    createEntityReference(name: string): XmlEntityReference;
    createNavigator(): XPathNavigator;
    getElementById(elemId: string): XmlElement;
    getElementFromRow(r: DataRow): XmlElement;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    getRowFromElement(e: XmlElement): DataRow;
    load(filename: string): void;
    load(inStream: Stream): void;
    load(txtReader: TextReader): void;
    load(reader: XmlReader): void;
}


export interface __XmlDataDocument$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDataDocument = XmlDataDocument$instance & __XmlDataDocument$views;


export class XmlDeclaration$instance extends XmlLinkedNode$instance {
    encoding: string;
    innerText: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    standalone: string;
    value: string;
    readonly version: string;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDeclaration$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDeclaration = XmlDeclaration$instance & __XmlDeclaration$views;


export class XmlDictionary$instance {
    constructor();
    constructor(capacity: int);
    add(value: string): XmlDictionaryString;
    tryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
    static readonly Empty: IXmlDictionary;
}


export interface __XmlDictionary$views {
    readonly As_IXmlDictionary: IXmlDictionary$instance;
}

export type XmlDictionary = XmlDictionary$instance & __XmlDictionary$views;


export abstract class XmlDictionaryReader$instance extends XmlReader$instance {
    readonly canCanonicalize: boolean;
    readonly quotas: XmlDictionaryReaderQuotas;
    dispose(): void;
    endCanonicalization(): void;
    getAttribute(name: string): string;
    getAttribute(name: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    getNonAtomizedNames(localName: { value: ref<string> }, namespaceUri: { value: ref<string> }): void;
    indexOfLocalName(localNames: string[], namespaceUri: string): int;
    indexOfLocalName(localNames: XmlDictionaryString[], namespaceUri: XmlDictionaryString): int;
    isLocalName(localName: string): boolean;
    isLocalName(localName: XmlDictionaryString): boolean;
    isNamespaceUri(namespaceUri: string): boolean;
    isNamespaceUri(namespaceUri: XmlDictionaryString): boolean;
    isStartArray(type_: { value: ref<Type> }): boolean;
    isStartElement(): boolean;
    isStartElement(name: string): boolean;
    isStartElement(localname: string, ns: string): boolean;
    moveToStartElement(): void;
    moveToStartElement(name: string): void;
    moveToStartElement(localName: string, namespaceUri: string): void;
    moveToStartElement(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): void;
    readArray(localName: string, namespaceUri: string, array: boolean[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: boolean[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: short[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: short[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: int[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: int[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: long[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: long[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: float[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: float[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: double[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: double[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: decimal[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: decimal[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: DateTime[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: DateTime[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: Guid[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: Guid[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: TimeSpan[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: TimeSpan[], offset: int, count: int): int;
    readBooleanArray(localName: string, namespaceUri: string): boolean[];
    readBooleanArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): boolean[];
    readContentAs(type_: Type, namespaceResolver: IXmlNamespaceResolver): any;
    readContentAsBase642(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readContentAsChars(chars: string[], offset: int, count: int): int;
    readContentAsDecimal(): decimal;
    readContentAsFloat(): float;
    readContentAsGuid(): Guid;
    readContentAsQualifiedName(localName: { value: ref<string> }, namespaceUri: { value: ref<string> }): void;
    readContentAsString(): string;
    readContentAsTimeSpan(): TimeSpan;
    readContentAsUniqueId(): UniqueId;
    readDateTimeArray(localName: string, namespaceUri: string): DateTime[];
    readDateTimeArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): DateTime[];
    readDecimalArray(localName: string, namespaceUri: string): decimal[];
    readDecimalArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): decimal[];
    readDoubleArray(localName: string, namespaceUri: string): double[];
    readDoubleArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): double[];
    readElementContentAsBase642(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBoolean(): boolean;
    readElementContentAsBoolean(localName: string, namespaceURI: string): boolean;
    readElementContentAsDateTime(): DateTime;
    readElementContentAsDateTime(localName: string, namespaceURI: string): DateTime;
    readElementContentAsDecimal(): decimal;
    readElementContentAsDecimal(localName: string, namespaceURI: string): decimal;
    readElementContentAsDouble(): double;
    readElementContentAsDouble(localName: string, namespaceURI: string): double;
    readElementContentAsFloat(): float;
    readElementContentAsFloat(localName: string, namespaceURI: string): float;
    readElementContentAsGuid(): Guid;
    readElementContentAsInt(): int;
    readElementContentAsInt(localName: string, namespaceURI: string): int;
    readElementContentAsLong(): long;
    readElementContentAsLong(localName: string, namespaceURI: string): long;
    readElementContentAsString(): string;
    readElementContentAsString(localName: string, namespaceURI: string): string;
    readElementContentAsTimeSpan(): TimeSpan;
    readElementContentAsUniqueId(): UniqueId;
    readFullStartElement(): void;
    readFullStartElement(name: string): void;
    readFullStartElement(localName: string, namespaceUri: string): void;
    readFullStartElement(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): void;
    readGuidArray(localName: string, namespaceUri: string): Guid[];
    readGuidArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): Guid[];
    readInt16Array(localName: string, namespaceUri: string): short[];
    readInt16Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): short[];
    readInt32Array(localName: string, namespaceUri: string): int[];
    readInt32Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): int[];
    readInt64Array(localName: string, namespaceUri: string): long[];
    readInt64Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): long[];
    readSingleArray(localName: string, namespaceUri: string): float[];
    readSingleArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): float[];
    readStartElement(): void;
    readStartElement(name: string): void;
    readStartElement(localname: string, ns: string): void;
    readString(): string;
    readTimeSpanArray(localName: string, namespaceUri: string): TimeSpan[];
    readTimeSpanArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): TimeSpan[];
    readValueAsBase64(buffer: byte[], offset: int, count: int): int;
    startCanonicalization(stream: Stream, includeComments: boolean, inclusivePrefixes: string[]): void;
    tryGetArrayLength(count: { value: ref<int> }): boolean;
    tryGetBase64ContentLength(length: { value: ref<int> }): boolean;
    tryGetLocalNameAsDictionaryString(localName: { value: ref<XmlDictionaryString> }): boolean;
    tryGetNamespaceUriAsDictionaryString(namespaceUri: { value: ref<XmlDictionaryString> }): boolean;
    tryGetValueAsDictionaryString(value: { value: ref<XmlDictionaryString> }): boolean;
    static CreateBinaryReader(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static CreateBinaryReader(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession): XmlDictionaryReader;
    static CreateBinaryReader(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateBinaryReader(buffer: byte[], offset: int, count: int, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateBinaryReader(buffer: byte[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateBinaryReader(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static CreateBinaryReader(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession): XmlDictionaryReader;
    static CreateBinaryReader(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateBinaryReader(stream: Stream, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateDictionaryReader(reader: XmlReader): XmlDictionaryReader;
    static CreateMtomReader(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateMtomReader(buffer: byte[], offset: int, count: int, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas, maxBufferSize: int, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static CreateMtomReader(buffer: byte[], offset: int, count: int, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateMtomReader(buffer: byte[], offset: int, count: int, encodings: Encoding[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateMtomReader(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateMtomReader(stream: Stream, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas, maxBufferSize: int, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static CreateMtomReader(stream: Stream, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateMtomReader(stream: Stream, encodings: Encoding[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateTextReader(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static CreateTextReader(buffer: byte[], offset: int, count: int, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateTextReader(buffer: byte[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static CreateTextReader(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static CreateTextReader(stream: Stream, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
}


export interface __XmlDictionaryReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlDictionaryReader = XmlDictionaryReader$instance & __XmlDictionaryReader$views;


export class XmlDictionaryReaderQuotas$instance {
    constructor();
    maxArrayLength: int;
    maxBytesPerRead: int;
    maxDepth: int;
    maxNameTableCharCount: int;
    maxStringContentLength: int;
    readonly modifiedQuotas: XmlDictionaryReaderQuotaTypes;
    copyTo(quotas: XmlDictionaryReaderQuotas): void;
    static readonly Max: XmlDictionaryReaderQuotas;
}


export type XmlDictionaryReaderQuotas = XmlDictionaryReaderQuotas$instance;

export class XmlDictionaryString$instance {
    constructor(dictionary: IXmlDictionary, value: string, key: int);
    readonly dictionary: IXmlDictionary;
    readonly key: int;
    readonly value: string;
    toString(): string;
    static readonly Empty: XmlDictionaryString;
}


export type XmlDictionaryString = XmlDictionaryString$instance;

export abstract class XmlDictionaryWriter$instance extends XmlWriter$instance {
    readonly canCanonicalize: boolean;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    endCanonicalization(): void;
    startCanonicalization(stream: Stream, includeComments: boolean, inclusivePrefixes: string[]): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: boolean[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: boolean[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: short[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: short[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: int[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: int[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: long[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: long[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: float[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: float[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: double[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: double[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: decimal[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: decimal[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: DateTime[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: DateTime[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: Guid[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: Guid[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: TimeSpan[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: TimeSpan[], offset: int, count: int): void;
    writeAttributeString(localName: string, ns: string, value: string): void;
    writeAttributeString(localName: string, value: string): void;
    writeAttributeString(prefix: string, localName: string, ns: string, value: string): void;
    writeBase64Async(buffer: byte[], index: int, count: int): Task;
    writeElementString(localName: string, value: string): void;
    writeElementString(localName: string, ns: string, value: string): void;
    writeElementString(prefix: string, localName: string, ns: string, value: string): void;
    writeNode(reader: XmlReader, defattr: boolean): void;
    writeNode(navigator: XPathNavigator, defattr: boolean): void;
    writeQualifiedName(localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeString(text: string): void;
    writeValue(value: any): void;
    writeValue(value: string): void;
    writeValue(value: boolean): void;
    writeValue(value: DateTime): void;
    writeValue(value: DateTimeOffset): void;
    writeValue(value: double): void;
    writeValue(value: float): void;
    writeValue(value: decimal): void;
    writeValue(value: int): void;
    writeValue(value: long): void;
    writeValueAsync(value: IStreamProvider): Task;
    writeXmlAttribute(localName: string, value: string): void;
    writeXmlAttribute(localName: XmlDictionaryString, value: XmlDictionaryString): void;
    writeXmlnsAttribute(prefix: string, namespaceUri: string): void;
    writeXmlnsAttribute(prefix: string, namespaceUri: XmlDictionaryString): void;
    static CreateBinaryWriter(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession, ownsStream: boolean): XmlDictionaryWriter;
    static CreateBinaryWriter(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession): XmlDictionaryWriter;
    static CreateBinaryWriter(stream: Stream, dictionary: IXmlDictionary): XmlDictionaryWriter;
    static CreateBinaryWriter(stream: Stream): XmlDictionaryWriter;
    static CreateDictionaryWriter(writer: XmlWriter): XmlDictionaryWriter;
    static CreateMtomWriter(stream: Stream, encoding: Encoding, maxSizeInBytes: int, startInfo: string, boundary: string, startUri: string, writeMessageHeaders: boolean, ownsStream: boolean): XmlDictionaryWriter;
    static CreateMtomWriter(stream: Stream, encoding: Encoding, maxSizeInBytes: int, startInfo: string): XmlDictionaryWriter;
    static CreateTextWriter(stream: Stream, encoding: Encoding, ownsStream: boolean): XmlDictionaryWriter;
    static CreateTextWriter(stream: Stream, encoding: Encoding): XmlDictionaryWriter;
    static CreateTextWriter(stream: Stream): XmlDictionaryWriter;
}


export interface __XmlDictionaryWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlDictionaryWriter = XmlDictionaryWriter$instance & __XmlDictionaryWriter$views;


export class XmlDocument$instance extends XmlNode$instance {
    constructor();
    constructor(nt: XmlNameTable);
    readonly baseURI: string;
    readonly documentElement: XmlElement;
    readonly documentType: XmlDocumentType;
    readonly implementation: XmlImplementation;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    preserveWhitespace: boolean;
    readonly schemaInfo: IXmlSchemaInfo;
    schemas: XmlSchemaSet;
    xmlResolver: XmlResolver;
    clone(): XmlNode;
    clone(): any;
    cloneNode(deep: boolean): XmlNode;
    createAttribute(name: string): XmlAttribute;
    createAttribute(qualifiedName: string, namespaceURI: string): XmlAttribute;
    createAttribute(prefix: string, localName: string, namespaceURI: string): XmlAttribute;
    createCDataSection(data: string): XmlCDataSection;
    createComment(data: string): XmlComment;
    createDocumentFragment(): XmlDocumentFragment;
    createDocumentType(name: string, publicId: string, systemId: string, internalSubset: string): XmlDocumentType;
    createElement(name: string): XmlElement;
    createElement(qualifiedName: string, namespaceURI: string): XmlElement;
    createElement(prefix: string, localName: string, namespaceURI: string): XmlElement;
    createEntityReference(name: string): XmlEntityReference;
    createNavigator(): XPathNavigator;
    createNode(type_: XmlNodeType, prefix: string, name: string, namespaceURI: string): XmlNode;
    createNode(nodeTypeString: string, name: string, namespaceURI: string): XmlNode;
    createNode(type_: XmlNodeType, name: string, namespaceURI: string): XmlNode;
    createProcessingInstruction(target: string, data: string): XmlProcessingInstruction;
    createSignificantWhitespace(text: string): XmlSignificantWhitespace;
    createTextNode(text: string): XmlText;
    createWhitespace(text: string): XmlWhitespace;
    createXmlDeclaration(version: string, encoding: string, standalone: string): XmlDeclaration;
    getElementById(elementId: string): XmlElement;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    importNode(node: XmlNode, deep: boolean): XmlNode;
    load(filename: string): void;
    load(inStream: Stream): void;
    load(txtReader: TextReader): void;
    load(reader: XmlReader): void;
    loadXml(xml: string): void;
    readNode(reader: XmlReader): XmlNode;
    save(filename: string): void;
    save(outStream: Stream): void;
    save(writer: TextWriter): void;
    save(w: XmlWriter): void;
    validate(validationEventHandler: ValidationEventHandler): void;
    validate(validationEventHandler: ValidationEventHandler, nodeToValidate: XmlNode): void;
    writeContentTo(xw: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDocument$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocument = XmlDocument$instance & __XmlDocument$views;


export class XmlDocumentFragment$instance extends XmlNode$instance {
    innerXml: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    clone(): XmlNode;
    clone(): any;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDocumentFragment$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocumentFragment = XmlDocumentFragment$instance & __XmlDocumentFragment$views;


export class XmlDocumentType$instance extends XmlLinkedNode$instance {
    readonly entities: XmlNamedNodeMap;
    readonly internalSubset: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly notations: XmlNamedNodeMap;
    readonly publicId: string;
    readonly systemId: string;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDocumentType$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocumentType = XmlDocumentType$instance & __XmlDocumentType$views;


export class XmlElement$instance extends XmlLinkedNode$instance {
    readonly attributes: XmlAttributeCollection;
    readonly hasAttributes: boolean;
    innerText: string;
    innerXml: string;
    isEmpty: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nextSibling: XmlNode;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly schemaInfo: IXmlSchemaInfo;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttributeNode(name: string): XmlAttribute;
    getAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    hasAttribute(name: string): boolean;
    hasAttribute(localName: string, namespaceURI: string): boolean;
    removeAll(): void;
    removeAllAttributes(): void;
    removeAttribute(name: string): void;
    removeAttribute(localName: string, namespaceURI: string): void;
    removeAttributeAt(i: int): XmlNode;
    removeAttributeNode(oldAttr: XmlAttribute): XmlAttribute;
    removeAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    setAttribute(name: string, value: string): void;
    setAttribute(localName: string, namespaceURI: string, value: string): string;
    setAttributeNode(newAttr: XmlAttribute): XmlAttribute;
    setAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlElement$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlElement = XmlElement$instance & __XmlElement$views;


export class XmlEntity$instance extends XmlNode$instance {
    readonly baseURI: string;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly notationName: string;
    readonly outerXml: string;
    readonly publicId: string;
    readonly systemId: string;
    clone(): XmlNode;
    clone(): any;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlEntity$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlEntity = XmlEntity$instance & __XmlEntity$views;


export class XmlEntityReference$instance extends XmlLinkedNode$instance {
    readonly baseURI: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    value: string;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlEntityReference$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlEntityReference = XmlEntityReference$instance & __XmlEntityReference$views;


export class XmlException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerException: Exception, lineNumber: int, linePosition: int);
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly message: string;
    readonly sourceUri: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XmlException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlException = XmlException$instance & __XmlException$views;


export class XmlImplementation$instance {
    constructor();
    constructor(nt: XmlNameTable);
    createDocument(): XmlDocument;
    hasFeature(strFeature: string, strVersion: string): boolean;
}


export type XmlImplementation = XmlImplementation$instance;

export abstract class XmlLinkedNode$instance extends XmlNode$instance {
    readonly nextSibling: XmlNode;
    readonly previousSibling: XmlNode;
    clone(): XmlNode;
    clone(): any;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
}


export interface __XmlLinkedNode$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlLinkedNode = XmlLinkedNode$instance & __XmlLinkedNode$views;


export class XmlNamedNodeMap$instance {
    readonly count: int;
    getEnumerator(): IEnumerator;
    getNamedItem(name: string): XmlNode;
    getNamedItem(localName: string, namespaceURI: string): XmlNode;
    item(index: int): XmlNode;
    removeNamedItem(name: string): XmlNode;
    removeNamedItem(localName: string, namespaceURI: string): XmlNode;
    setNamedItem(node: XmlNode): XmlNode;
}


export interface __XmlNamedNodeMap$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type XmlNamedNodeMap = XmlNamedNodeMap$instance & __XmlNamedNodeMap$views;


export class XmlNamespaceManager$instance {
    constructor(nameTable: XmlNameTable);
    readonly defaultNamespace: string;
    readonly nameTable: XmlNameTable;
    addNamespace(prefix: string, uri: string): void;
    getEnumerator(): IEnumerator;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    hasNamespace(prefix: string): boolean;
    lookupNamespace(prefix: string): string;
    lookupPrefix(uri: string): string;
    popScope(): boolean;
    pushScope(): void;
    removeNamespace(prefix: string, uri: string): void;
}


export interface __XmlNamespaceManager$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IXmlNamespaceResolver: IXmlNamespaceResolver$instance;
}

export type XmlNamespaceManager = XmlNamespaceManager$instance & __XmlNamespaceManager$views;


export abstract class XmlNameTable$instance {
    abstract add(array: string[], offset: int, length: int): string;
    abstract add(array: string): string;
    abstract get_(array: string[], offset: int, length: int): string;
    abstract get_(array: string): string;
}


export type XmlNameTable = XmlNameTable$instance;

export abstract class XmlNode$instance {
    readonly attributes: XmlAttributeCollection;
    readonly baseURI: string;
    readonly childNodes: XmlNodeList;
    readonly firstChild: XmlNode;
    readonly hasChildNodes: boolean;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly lastChild: XmlNode;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nextSibling: XmlNode;
    readonly nodeType: XmlNodeType;
    readonly outerXml: string;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly previousSibling: XmlNode;
    readonly previousText: XmlNode;
    readonly schemaInfo: IXmlSchemaInfo;
    value: string;
    appendChild(newChild: XmlNode): XmlNode;
    clone(): XmlNode;
    abstract cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    get_Item(name: string): XmlElement;
    get_Item(localname: string, ns: string): XmlElement;
    getEnumerator(): IEnumerator;
    getNamespaceOfPrefix(prefix: string): string;
    getPrefixOfNamespace(namespaceURI: string): string;
    insertAfter(newChild: XmlNode, refChild: XmlNode): XmlNode;
    insertBefore(newChild: XmlNode, refChild: XmlNode): XmlNode;
    normalize(): void;
    prependChild(newChild: XmlNode): XmlNode;
    removeAll(): void;
    removeChild(oldChild: XmlNode): XmlNode;
    replaceChild(newChild: XmlNode, oldChild: XmlNode): XmlNode;
    selectNodes(xpath: string): XmlNodeList;
    selectNodes(xpath: string, nsmgr: XmlNamespaceManager): XmlNodeList;
    selectSingleNode(xpath: string): XmlNode;
    selectSingleNode(xpath: string, nsmgr: XmlNamespaceManager): XmlNode;
    supports(feature: string, version: string): boolean;
    abstract writeContentTo(w: XmlWriter): void;
    abstract writeTo(w: XmlWriter): void;
}


export interface __XmlNode$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlNode = XmlNode$instance & __XmlNode$views;


export class XmlNodeChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(node: XmlNode, oldParent: XmlNode, newParent: XmlNode, oldValue: string, newValue: string, action: XmlNodeChangedAction);
    readonly action: XmlNodeChangedAction;
    readonly newParent: XmlNode;
    readonly newValue: string;
    readonly node: XmlNode;
    readonly oldParent: XmlNode;
    readonly oldValue: string;
}


export type XmlNodeChangedEventArgs = XmlNodeChangedEventArgs$instance;

export class XmlNodeChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: XmlNodeChangedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: XmlNodeChangedEventArgs): void;
}


export interface __XmlNodeChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlNodeChangedEventHandler = XmlNodeChangedEventHandler$instance & __XmlNodeChangedEventHandler$views;


export abstract class XmlNodeList$instance {
    readonly count: int;
    readonly itemOf: XmlNode;
    abstract getEnumerator(): IEnumerator;
    abstract item(index: int): XmlNode;
}


export interface __XmlNodeList$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlNodeList = XmlNodeList$instance & __XmlNodeList$views;


export class XmlNodeReader$instance extends XmlReader$instance {
    constructor(node: XmlNode);
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly eof: boolean;
    readonly hasAttributes: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly readState: ReadState;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly value: string;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(name: string, namespaceURI: string): string;
    getAttribute(attributeIndex: int): string;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(name: string, namespaceURI: string): boolean;
    moveToAttribute(attributeIndex: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    resolveEntity(): void;
    skip(): void;
}


export interface __XmlNodeReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IXmlNamespaceResolver: IXmlNamespaceResolver$instance;
}

export type XmlNodeReader = XmlNodeReader$instance & __XmlNodeReader$views;


export class XmlNotation$instance extends XmlNode$instance {
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly outerXml: string;
    readonly publicId: string;
    readonly systemId: string;
    clone(): XmlNode;
    clone(): any;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlNotation$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlNotation = XmlNotation$instance & __XmlNotation$views;


export class XmlParserContext$instance {
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, xmlLang: string, xmlSpace: XmlSpace);
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, xmlLang: string, xmlSpace: XmlSpace, enc: Encoding);
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, docTypeName: string, pubId: string, sysId: string, internalSubset: string, baseURI: string, xmlLang: string, xmlSpace: XmlSpace);
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, docTypeName: string, pubId: string, sysId: string, internalSubset: string, baseURI: string, xmlLang: string, xmlSpace: XmlSpace, enc: Encoding);
    baseURI: string;
    docTypeName: string;
    encoding: Encoding;
    internalSubset: string;
    namespaceManager: XmlNamespaceManager;
    nameTable: XmlNameTable;
    publicId: string;
    systemId: string;
    xmlLang: string;
    xmlSpace: XmlSpace;
}


export type XmlParserContext = XmlParserContext$instance;

export class XmlProcessingInstruction$instance extends XmlLinkedNode$instance {
    data: string;
    innerText: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly target: string;
    value: string;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlProcessingInstruction$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlProcessingInstruction = XmlProcessingInstruction$instance & __XmlProcessingInstruction$views;


export class XmlQualifiedName$instance {
    constructor();
    constructor(name: string);
    constructor(name: string, ns: string);
    readonly isEmpty: boolean;
    readonly name: string;
    readonly namespace_: string;
    equals(other: any): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly empty: XmlQualifiedName;
    static ToString(name: string, ns: string): string;
}


export type XmlQualifiedName = XmlQualifiedName$instance;

export abstract class XmlReader$instance {
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canReadValueChunk: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly eof: boolean;
    readonly hasAttributes: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly quoteChar: string;
    readonly readState: ReadState;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly settings: XmlReaderSettings;
    readonly value: string;
    readonly valueType: Type;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    get_Item(i: int): string;
    get_Item(name: string): string;
    get_Item(name: string, namespaceURI: string): string;
    abstract getAttribute(name: string): string;
    abstract getAttribute(name: string, namespaceURI: string): string;
    abstract getAttribute(i: int): string;
    getValueAsync(): Task_1<CLROf<string>>;
    isStartElement(): boolean;
    isStartElement(name: string): boolean;
    isStartElement(localname: string, ns: string): boolean;
    abstract lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(name: string, ns: string): boolean;
    moveToAttribute(i: int): void;
    moveToContent(): XmlNodeType;
    moveToContentAsync(): Task_1<XmlNodeType>;
    abstract moveToElement(): boolean;
    abstract moveToFirstAttribute(): boolean;
    abstract moveToNextAttribute(): boolean;
    abstract read(): boolean;
    readAsync(): Task_1<CLROf<boolean>>;
    abstract readAttributeValue(): boolean;
    readContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver): any;
    readContentAsAsync(returnType: Type, namespaceResolver: IXmlNamespaceResolver): Task_1<any>;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBase64Async(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readContentAsBinHexAsync(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readContentAsBoolean(): boolean;
    readContentAsDateTime(): DateTime;
    readContentAsDateTimeOffset(): DateTimeOffset;
    readContentAsDecimal(): decimal;
    readContentAsDouble(): double;
    readContentAsFloat(): float;
    readContentAsInt(): int;
    readContentAsLong(): long;
    readContentAsObject(): any;
    readContentAsObjectAsync(): Task_1<any>;
    readContentAsString(): string;
    readContentAsStringAsync(): Task_1<CLROf<string>>;
    readElementContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver): any;
    readElementContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver, localName: string, namespaceURI: string): any;
    readElementContentAsAsync(returnType: Type, namespaceResolver: IXmlNamespaceResolver): Task_1<any>;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64Async(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHexAsync(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readElementContentAsBoolean(): boolean;
    readElementContentAsBoolean(localName: string, namespaceURI: string): boolean;
    readElementContentAsDateTime(): DateTime;
    readElementContentAsDateTime(localName: string, namespaceURI: string): DateTime;
    readElementContentAsDecimal(): decimal;
    readElementContentAsDecimal(localName: string, namespaceURI: string): decimal;
    readElementContentAsDouble(): double;
    readElementContentAsDouble(localName: string, namespaceURI: string): double;
    readElementContentAsFloat(): float;
    readElementContentAsFloat(localName: string, namespaceURI: string): float;
    readElementContentAsInt(): int;
    readElementContentAsInt(localName: string, namespaceURI: string): int;
    readElementContentAsLong(): long;
    readElementContentAsLong(localName: string, namespaceURI: string): long;
    readElementContentAsObject(): any;
    readElementContentAsObject(localName: string, namespaceURI: string): any;
    readElementContentAsObjectAsync(): Task_1<any>;
    readElementContentAsString(): string;
    readElementContentAsString(localName: string, namespaceURI: string): string;
    readElementContentAsStringAsync(): Task_1<CLROf<string>>;
    readElementString(): string;
    readElementString(name: string): string;
    readElementString(localname: string, ns: string): string;
    readEndElement(): void;
    readInnerXml(): string;
    readInnerXmlAsync(): Task_1<CLROf<string>>;
    readOuterXml(): string;
    readOuterXmlAsync(): Task_1<CLROf<string>>;
    readStartElement(): void;
    readStartElement(name: string): void;
    readStartElement(localname: string, ns: string): void;
    readString(): string;
    readSubtree(): XmlReader;
    readToDescendant(name: string): boolean;
    readToDescendant(localName: string, namespaceURI: string): boolean;
    readToFollowing(name: string): boolean;
    readToFollowing(localName: string, namespaceURI: string): boolean;
    readToNextSibling(name: string): boolean;
    readToNextSibling(localName: string, namespaceURI: string): boolean;
    readValueChunk(buffer: string[], index: int, count: int): int;
    readValueChunkAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    abstract resolveEntity(): void;
    skip(): void;
    skipAsync(): Task;
    static Create(input: Stream, settings: XmlReaderSettings, baseUri: string): XmlReader;
    static Create(input: Stream, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    static Create(input: Stream, settings: XmlReaderSettings): XmlReader;
    static Create(input: Stream): XmlReader;
    static Create(input: TextReader, settings: XmlReaderSettings, baseUri: string): XmlReader;
    static Create(input: TextReader, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    static Create(input: TextReader, settings: XmlReaderSettings): XmlReader;
    static Create(input: TextReader): XmlReader;
    static Create(inputUri: string, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    static Create(inputUri: string, settings: XmlReaderSettings): XmlReader;
    static Create(inputUri: string): XmlReader;
    static Create(reader: XmlReader, settings: XmlReaderSettings): XmlReader;
    static IsName(str: string): boolean;
    static IsNameToken(str: string): boolean;
}


export interface __XmlReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlReader = XmlReader$instance & __XmlReader$views;


export class XmlReaderSettings$instance {
    constructor();
    async_: boolean;
    checkCharacters: boolean;
    closeInput: boolean;
    conformanceLevel: ConformanceLevel;
    dtdProcessing: DtdProcessing;
    ignoreComments: boolean;
    ignoreProcessingInstructions: boolean;
    ignoreWhitespace: boolean;
    lineNumberOffset: int;
    linePositionOffset: int;
    maxCharactersFromEntities: long;
    maxCharactersInDocument: long;
    nameTable: XmlNameTable;
    prohibitDtd: boolean;
    schemas: XmlSchemaSet;
    validationFlags: XmlSchemaValidationFlags;
    validationType: ValidationType;
    xmlResolver: XmlResolver;
    clone(): XmlReaderSettings;
    reset(): void;
}


export type XmlReaderSettings = XmlReaderSettings$instance;

export abstract class XmlResolver$instance {
    credentials: ICredentials;
    abstract getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): any;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<any>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
    supportsType(absoluteUri: Uri, type_: Type): boolean;
    static readonly FileSystemResolver: XmlResolver;
    static readonly ThrowingResolver: XmlResolver;
}


export type XmlResolver = XmlResolver$instance;

export class XmlSecureResolver$instance extends XmlResolver$instance {
    constructor(resolver: XmlResolver, securityUrl: string);
    credentials: ICredentials;
    getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): any;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<any>;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<any>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
}


export type XmlSecureResolver = XmlSecureResolver$instance;

export class XmlSignificantWhitespace$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlSignificantWhitespace$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlSignificantWhitespace = XmlSignificantWhitespace$instance & __XmlSignificantWhitespace$views;


export class XmlText$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    splitText(offset: int): XmlText;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlText$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlText = XmlText$instance & __XmlText$views;


export class XmlTextReader$instance extends XmlReader$instance {
    constructor(input: Stream);
    constructor(url: string, input: Stream);
    constructor(input: Stream, nt: XmlNameTable);
    constructor(url: string, input: Stream, nt: XmlNameTable);
    constructor(input: TextReader);
    constructor(url: string, input: TextReader);
    constructor(input: TextReader, nt: XmlNameTable);
    constructor(url: string, input: TextReader, nt: XmlNameTable);
    constructor(xmlFragment: Stream, fragType: XmlNodeType, context: XmlParserContext);
    constructor(xmlFragment: string, fragType: XmlNodeType, context: XmlParserContext);
    constructor(url: string);
    constructor(url: string, nt: XmlNameTable);
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canReadValueChunk: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    dtdProcessing: DtdProcessing;
    readonly encoding: Encoding;
    entityHandling: EntityHandling;
    readonly eof: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly localName: string;
    readonly name: string;
    namespaces: boolean;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    normalization: boolean;
    readonly prefix: string;
    prohibitDtd: boolean;
    readonly quoteChar: string;
    readonly readState: ReadState;
    readonly value: string;
    whitespaceHandling: WhitespaceHandling;
    readonly xmlLang: string;
    xmlResolver: XmlResolver;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    getRemainder(): TextReader;
    hasLineInfo(): boolean;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(localName: string, namespaceURI: string): boolean;
    moveToAttribute(i: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readBase64(array: byte[], offset: int, len: int): int;
    readBinHex(array: byte[], offset: int, len: int): int;
    readChars(buffer: string[], index: int, count: int): int;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    resetState(): void;
    resolveEntity(): void;
    skip(): void;
}


export interface __XmlTextReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IXmlLineInfo: IXmlLineInfo$instance;
    readonly As_IXmlNamespaceResolver: IXmlNamespaceResolver$instance;
}

export type XmlTextReader = XmlTextReader$instance & __XmlTextReader$views;


export class XmlTextWriter$instance extends XmlWriter$instance {
    constructor(w: Stream, encoding: Encoding);
    constructor(filename: string, encoding: Encoding);
    constructor(w: TextWriter);
    readonly baseStream: Stream;
    formatting: Formatting;
    indentation: int;
    indentChar: string;
    namespaces: boolean;
    quoteChar: string;
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    lookupPrefix(ns: string): string;
    writeBase64(buffer: byte[], index: int, count: int): void;
    writeBinHex(buffer: byte[], index: int, count: int): void;
    writeCData(text: string): void;
    writeCharEntity(ch: string): void;
    writeChars(buffer: string[], index: int, count: int): void;
    writeComment(text: string): void;
    writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeEndAttribute(): void;
    writeEndDocument(): void;
    writeEndElement(): void;
    writeEntityRef(name: string): void;
    writeFullEndElement(): void;
    writeName(name: string): void;
    writeNmToken(name: string): void;
    writeProcessingInstruction(name: string, text: string): void;
    writeQualifiedName(localName: string, ns: string): void;
    writeRaw(buffer: string[], index: int, count: int): void;
    writeRaw(data: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartDocument(): void;
    writeStartDocument(standalone: boolean): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeString(text: string): void;
    writeSurrogateCharEntity(lowChar: string, highChar: string): void;
    writeWhitespace(ws: string): void;
}


export interface __XmlTextWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlTextWriter = XmlTextWriter$instance & __XmlTextWriter$views;


export class XmlUrlResolver$instance extends XmlResolver$instance {
    constructor();
    cachePolicy: RequestCachePolicy;
    credentials: ICredentials;
    proxy: IWebProxy;
    getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): any;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<any>;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<any>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
}


export type XmlUrlResolver = XmlUrlResolver$instance;

export class XmlValidatingReader$instance extends XmlReader$instance {
    constructor(reader: XmlReader);
    constructor(xmlFragment: string, fragType: XmlNodeType, context: XmlParserContext);
    constructor(xmlFragment: Stream, fragType: XmlNodeType, context: XmlParserContext);
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly encoding: Encoding;
    entityHandling: EntityHandling;
    readonly eof: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly localName: string;
    readonly name: string;
    namespaces: boolean;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly quoteChar: string;
    readonly reader: XmlReader;
    readonly readState: ReadState;
    readonly schemas: XmlSchemaCollection;
    readonly schemaType: any;
    validationType: ValidationType;
    readonly value: string;
    readonly xmlLang: string;
    xmlResolver: XmlResolver;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    hasLineInfo(): boolean;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(localName: string, namespaceURI: string): boolean;
    moveToAttribute(i: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    readTypedValue(): any;
    resolveEntity(): void;
}


export interface __XmlValidatingReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IXmlLineInfo: IXmlLineInfo$instance;
    readonly As_IXmlNamespaceResolver: IXmlNamespaceResolver$instance;
}

export type XmlValidatingReader = XmlValidatingReader$instance & __XmlValidatingReader$views;


export class XmlWhitespace$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): any;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlWhitespace$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IXPathNavigable: System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlWhitespace = XmlWhitespace$instance & __XmlWhitespace$views;


export abstract class XmlWriter$instance {
    readonly settings: XmlWriterSettings;
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    abstract flush(): void;
    flushAsync(): Task;
    abstract lookupPrefix(ns: string): string;
    writeAttributes(reader: XmlReader, defattr: boolean): void;
    writeAttributesAsync(reader: XmlReader, defattr: boolean): Task;
    writeAttributeString(localName: string, ns: string, value: string): void;
    writeAttributeString(localName: string, value: string): void;
    writeAttributeString(prefix: string, localName: string, ns: string, value: string): void;
    writeAttributeStringAsync(prefix: string, localName: string, ns: string, value: string): Task;
    abstract writeBase64(buffer: byte[], index: int, count: int): void;
    writeBase64Async(buffer: byte[], index: int, count: int): Task;
    writeBinHex(buffer: byte[], index: int, count: int): void;
    writeBinHexAsync(buffer: byte[], index: int, count: int): Task;
    abstract writeCData(text: string): void;
    writeCDataAsync(text: string): Task;
    abstract writeCharEntity(ch: string): void;
    writeCharEntityAsync(ch: string): Task;
    abstract writeChars(buffer: string[], index: int, count: int): void;
    writeCharsAsync(buffer: string[], index: int, count: int): Task;
    abstract writeComment(text: string): void;
    writeCommentAsync(text: string): Task;
    abstract writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeDocTypeAsync(name: string, pubid: string, sysid: string, subset: string): Task;
    writeElementString(localName: string, value: string): void;
    writeElementString(localName: string, ns: string, value: string): void;
    writeElementString(prefix: string, localName: string, ns: string, value: string): void;
    writeElementStringAsync(prefix: string, localName: string, ns: string, value: string): Task;
    abstract writeEndAttribute(): void;
    abstract writeEndDocument(): void;
    writeEndDocumentAsync(): Task;
    abstract writeEndElement(): void;
    writeEndElementAsync(): Task;
    abstract writeEntityRef(name: string): void;
    writeEntityRefAsync(name: string): Task;
    abstract writeFullEndElement(): void;
    writeFullEndElementAsync(): Task;
    writeName(name: string): void;
    writeNameAsync(name: string): Task;
    writeNmToken(name: string): void;
    writeNmTokenAsync(name: string): Task;
    writeNode(reader: XmlReader, defattr: boolean): void;
    writeNode(navigator: XPathNavigator, defattr: boolean): void;
    writeNodeAsync(reader: XmlReader, defattr: boolean): Task;
    writeNodeAsync(navigator: XPathNavigator, defattr: boolean): Task;
    abstract writeProcessingInstruction(name: string, text: string): void;
    writeProcessingInstructionAsync(name: string, text: string): Task;
    writeQualifiedName(localName: string, ns: string): void;
    writeQualifiedNameAsync(localName: string, ns: string): Task;
    abstract writeRaw(buffer: string[], index: int, count: int): void;
    abstract writeRaw(data: string): void;
    writeRawAsync(buffer: string[], index: int, count: int): Task;
    writeRawAsync(data: string): Task;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    abstract writeStartDocument(): void;
    abstract writeStartDocument(standalone: boolean): void;
    writeStartDocumentAsync(): Task;
    writeStartDocumentAsync(standalone: boolean): Task;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeStartElementAsync(prefix: string, localName: string, ns: string): Task;
    abstract writeString(text: string): void;
    writeStringAsync(text: string): Task;
    abstract writeSurrogateCharEntity(lowChar: string, highChar: string): void;
    writeSurrogateCharEntityAsync(lowChar: string, highChar: string): Task;
    writeValue(value: any): void;
    writeValue(value: string): void;
    writeValue(value: boolean): void;
    writeValue(value: DateTime): void;
    writeValue(value: DateTimeOffset): void;
    writeValue(value: double): void;
    writeValue(value: float): void;
    writeValue(value: decimal): void;
    writeValue(value: int): void;
    writeValue(value: long): void;
    abstract writeWhitespace(ws: string): void;
    writeWhitespaceAsync(ws: string): Task;
    static Create(output: Stream, settings: XmlWriterSettings): XmlWriter;
    static Create(output: Stream): XmlWriter;
    static Create(output: TextWriter, settings: XmlWriterSettings): XmlWriter;
    static Create(output: TextWriter): XmlWriter;
    static Create(outputFileName: string, settings: XmlWriterSettings): XmlWriter;
    static Create(outputFileName: string): XmlWriter;
    static Create(output: StringBuilder, settings: XmlWriterSettings): XmlWriter;
    static Create(output: StringBuilder): XmlWriter;
    static Create(output: XmlWriter, settings: XmlWriterSettings): XmlWriter;
    static Create(output: XmlWriter): XmlWriter;
}


export interface __XmlWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlWriter = XmlWriter$instance & __XmlWriter$views;


export class XmlWriterSettings$instance {
    constructor();
    async_: boolean;
    checkCharacters: boolean;
    closeOutput: boolean;
    conformanceLevel: ConformanceLevel;
    doNotEscapeUriAttributes: boolean;
    encoding: Encoding;
    indent: boolean;
    indentChars: string;
    namespaceHandling: NamespaceHandling;
    newLineChars: string;
    newLineHandling: NewLineHandling;
    newLineOnAttributes: boolean;
    omitXmlDeclaration: boolean;
    readonly outputMethod: XmlOutputMethod;
    writeEndDocumentOnClose: boolean;
    clone(): XmlWriterSettings;
    reset(): void;
}


export type XmlWriterSettings = XmlWriterSettings$instance;

