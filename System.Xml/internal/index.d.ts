// Generated by tsbindgen - Architecture
// Namespace: System.Xml
// Assembly: System.Data.Common, System.Private.DataContractSerialization, System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IDictionary_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { DataRow, DataSet } from "../../System.Data/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { RequestCachePolicy } from "../../System.Net.Cache/internal/index.js";
import type { ICredentials, IWebProxy } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Encoding, StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { IXmlSchemaInfo, ValidationEventHandler, XmlSchemaCollection, XmlSchemaSet, XmlSchemaValidationFlags } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { IXPathNavigable, XPathNavigator } from "../../System.Xml.XPath/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Delegate, Double, Enum, EventArgs, Exception, Guid, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, SByte, Single, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, Uri, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ConformanceLevel {
    auto = 0,
    fragment = 1,
    document = 2
}


export enum DtdProcessing {
    prohibit = 0,
    ignore = 1,
    parse = 2
}


export enum EntityHandling {
    expandEntities = 1,
    expandCharEntities = 2
}


export enum Formatting {
    none = 0,
    indented = 1
}


export enum NamespaceHandling {
    default_ = 0,
    omitDuplicates = 1
}


export enum NewLineHandling {
    replace = 0,
    entitize = 1,
    none = 2
}


export enum ReadState {
    initial = 0,
    interactive = 1,
    error = 2,
    endOfFile = 3,
    closed = 4
}


export enum ValidationType {
    none = 0,
    auto = 1,
    DTD = 2,
    XDR = 3,
    schema = 4
}


export enum WhitespaceHandling {
    all = 0,
    significant = 1,
    none = 2
}


export enum WriteState {
    start = 0,
    prolog = 1,
    element = 2,
    attribute = 3,
    content = 4,
    closed = 5,
    error = 6
}


export enum XmlDateTimeSerializationMode {
    local = 0,
    utc = 1,
    unspecified = 2,
    roundtripKind = 3
}


export enum XmlDictionaryReaderQuotaTypes {
    maxDepth = 1,
    maxStringContentLength = 2,
    maxArrayLength = 4,
    maxBytesPerRead = 8,
    maxNameTableCharCount = 16
}


export enum XmlNamespaceScope {
    all = 0,
    excludeXml = 1,
    local = 2
}


export enum XmlNodeChangedAction {
    insert = 0,
    remove = 1,
    change = 2
}


export enum XmlNodeOrder {
    before = 0,
    after = 1,
    same = 2,
    unknown_ = 3
}


export enum XmlNodeType {
    none = 0,
    element = 1,
    attribute = 2,
    text = 3,
    CDATA = 4,
    entityReference = 5,
    entity = 6,
    processingInstruction = 7,
    comment = 8,
    document = 9,
    documentType = 10,
    documentFragment = 11,
    notation = 12,
    whitespace = 13,
    significantWhitespace = 14,
    endElement = 15,
    endEntity = 16,
    xmlDeclaration = 17
}


export enum XmlOutputMethod {
    xml = 0,
    html = 1,
    text = 2,
    autoDetect = 3
}


export enum XmlSpace {
    none = 0,
    default_ = 1,
    preserve = 2
}


export enum XmlTokenizedType {
    CDATA = 0,
    ID = 1,
    IDREF = 2,
    IDREFS = 3,
    ENTITY = 4,
    ENTITIES = 5,
    NMTOKEN = 6,
    NMTOKENS = 7,
    NOTATION = 8,
    ENUMERATION = 9,
    qName = 10,
    ncName = 11,
    none = 12
}


export interface IApplicationResourceStreamResolver$instance {
    getApplicationResourceStream(relativeUri: Uri): Stream;
}


export type IApplicationResourceStreamResolver = IApplicationResourceStreamResolver$instance;

export interface IFragmentCapableXmlDictionaryWriter$instance {
    readonly canFragment: boolean;
    endFragment(): void;
    startFragment(stream: Stream, generateSelfContainedTextFragment: boolean): void;
    writeFragment(buffer: byte[], offset: int, count: int): void;
}


export type IFragmentCapableXmlDictionaryWriter = IFragmentCapableXmlDictionaryWriter$instance;

export interface IHasXmlNode$instance {
    getNode(): XmlNode;
}


export type IHasXmlNode = IHasXmlNode$instance;

export interface IStreamProvider$instance {
    getStream(): Stream;
    releaseStream(stream: Stream): void;
}


export type IStreamProvider = IStreamProvider$instance;

export interface IXmlBinaryReaderInitializer$instance {
    setInput(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): void;
    setInput(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): void;
}


export type IXmlBinaryReaderInitializer = IXmlBinaryReaderInitializer$instance;

export interface IXmlBinaryWriterInitializer$instance {
    setOutput(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession, ownsStream: boolean): void;
}


export type IXmlBinaryWriterInitializer = IXmlBinaryWriterInitializer$instance;

export interface IXmlDictionary$instance {
    tryLookup2(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup2(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup2(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
}


export type IXmlDictionary = IXmlDictionary$instance;

export interface IXmlLineInfo$instance {
    readonly lineNumber: int;
    readonly linePosition: int;
    hasLineInfo(): boolean;
}


export type IXmlLineInfo = IXmlLineInfo$instance;

export interface IXmlNamespaceResolver$instance {
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    lookupNamespace(prefix: string): string;
}


export type IXmlNamespaceResolver = IXmlNamespaceResolver$instance;

export interface IXmlTextReaderInitializer$instance {
    setInput(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): void;
    setInput(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): void;
}


export type IXmlTextReaderInitializer = IXmlTextReaderInitializer$instance;

export interface IXmlTextWriterInitializer$instance {
    setOutput(stream: Stream, encoding: Encoding, ownsStream: boolean): void;
}


export type IXmlTextWriterInitializer = IXmlTextWriterInitializer$instance;

export class NameTable$instance extends XmlNameTable$instance {
    constructor();
    add(key: string): string;
    add(key: char[], start: int, len: int): string;
    get_(value: string): string;
    get_(key: char[], start: int, len: int): string;
}


export type NameTable = NameTable$instance;

export class OnXmlDictionaryReaderClose$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(reader: XmlDictionaryReader, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(reader: XmlDictionaryReader): void;
}


export interface __OnXmlDictionaryReaderClose$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OnXmlDictionaryReaderClose = OnXmlDictionaryReaderClose$instance & __OnXmlDictionaryReaderClose$views;


export class UniqueId$instance {
    constructor();
    constructor(guid: Guid);
    constructor(guid: byte[]);
    constructor(guid: byte[], offset: int);
    constructor(value: string);
    constructor(chars: char[], offset: int, count: int);
    readonly charArrayLength: int;
    readonly isGuid: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toCharArray(chars: char[], offset: int): int;
    toString(): string;
    tryGetGuid(guid: { value: ref<Guid> }): boolean;
    tryGetGuid(buffer: byte[], offset: int): boolean;
}


export type UniqueId = UniqueId$instance;

export class XmlAttribute$instance extends XmlNode$instance {
    readonly baseURI: string;
    innerText: string;
    innerXml: string;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly ownerElement: XmlElement;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly specified: boolean;
    value: string;
    appendChild(newChild: XmlNode): XmlNode;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    insertAfter(newChild: XmlNode, refChild: XmlNode): XmlNode;
    insertBefore(newChild: XmlNode, refChild: XmlNode): XmlNode;
    prependChild(newChild: XmlNode): XmlNode;
    removeChild(oldChild: XmlNode): XmlNode;
    replaceChild(newChild: XmlNode, oldChild: XmlNode): XmlNode;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlAttribute$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlAttribute = XmlAttribute$instance & __XmlAttribute$views;


export class XmlAttributeCollection$instance extends XmlNamedNodeMap$instance {
    append(node: XmlAttribute): XmlAttribute;
    copyTo(array: XmlAttribute[], index: int): void;
    get_Item(i: int): XmlAttribute;
    get_Item(name: string): XmlAttribute;
    get_Item(localName: string, namespaceURI: string): XmlAttribute;
    getEnumerator(): IEnumerator;
    insertAfter(newNode: XmlAttribute, refNode: XmlAttribute): XmlAttribute;
    insertBefore(newNode: XmlAttribute, refNode: XmlAttribute): XmlAttribute;
    prepend(node: XmlAttribute): XmlAttribute;
    remove(node: XmlAttribute): XmlAttribute;
    removeAll(): void;
    removeAt(i: int): XmlAttribute;
    setNamedItem(node: XmlNode): XmlNode;
}


export interface __XmlAttributeCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type XmlAttributeCollection = XmlAttributeCollection$instance & __XmlAttributeCollection$views;


export class XmlBinaryReaderSession$instance {
    constructor();
    add(id: int, value: string): XmlDictionaryString;
    clear(): void;
    tryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
}


export interface __XmlBinaryReaderSession$views {
    As_IXmlDictionary(): IXmlDictionary$instance;
}

export type XmlBinaryReaderSession = XmlBinaryReaderSession$instance & __XmlBinaryReaderSession$views;


export class XmlBinaryWriterSession$instance {
    constructor();
    reset(): void;
    tryAdd(value: XmlDictionaryString, key: { value: ref<int> }): boolean;
}


export type XmlBinaryWriterSession = XmlBinaryWriterSession$instance;

export class XmlCDataSection$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlCDataSection$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlCDataSection = XmlCDataSection$instance & __XmlCDataSection$views;


export abstract class XmlCharacterData$instance extends XmlLinkedNode$instance {
    data: string;
    innerText: string;
    readonly length: int;
    value: string;
    appendData(strData: string): void;
    clone(): unknown;
    clone(): XmlNode;
    createNavigator(): XPathNavigator;
    deleteData(offset: int, count: int): void;
    getEnumerator(): IEnumerator;
    insertData(offset: int, strData: string): void;
    replaceData(offset: int, count: int, strData: string): void;
    substring(offset: int, count: int): string;
}


export interface __XmlCharacterData$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlCharacterData = XmlCharacterData$instance & __XmlCharacterData$views;


export class XmlComment$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlComment$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlComment = XmlComment$instance & __XmlComment$views;


export class XmlConvert$instance {
    constructor();
    static decodeName(name: string): string;
    static encodeLocalName(name: string): string;
    static encodeName(name: string): string;
    static encodeNmToken(name: string): string;
    static isNCNameChar(ch: char): boolean;
    static isPublicIdChar(ch: char): boolean;
    static isStartNCNameChar(ch: char): boolean;
    static isWhitespaceChar(ch: char): boolean;
    static isXmlChar(ch: char): boolean;
    static isXmlSurrogatePair(lowChar: char, highChar: char): boolean;
    static toBoolean(s: string): boolean;
    static toByte(s: string): byte;
    static toChar(s: string): char;
    static toDateTime2(s: string, format: string): DateTime;
    static toDateTime2(s: string, formats: string[]): DateTime;
    static toDateTime2(s: string, dateTimeOption: XmlDateTimeSerializationMode): DateTime;
    static toDateTime2(s: string): DateTime;
    static toDateTimeOffset2(s: string, format: string): DateTimeOffset;
    static toDateTimeOffset2(s: string, formats: string[]): DateTimeOffset;
    static toDateTimeOffset2(s: string): DateTimeOffset;
    static toDecimal(s: string): decimal;
    static toDouble(s: string): double;
    static toGuid(s: string): Guid;
    static toInt16(s: string): short;
    static toInt32(s: string): int;
    static toInt64(s: string): long;
    static toSByte(s: string): sbyte;
    static toSingle(s: string): float;
    static toString(value: boolean): string;
    static toString(value: byte): string;
    static toString(value: char): string;
    static toString(value: DateTime, format: string): string;
    static toString(value: DateTime, dateTimeOption: XmlDateTimeSerializationMode): string;
    static toString(value: DateTime): string;
    static toString(value: DateTimeOffset, format: string): string;
    static toString(value: DateTimeOffset): string;
    static toString(value: decimal): string;
    static toString(value: double): string;
    static toString(value: Guid): string;
    static toString(value: short): string;
    static toString(value: int): string;
    static toString(value: long): string;
    static toString(value: sbyte): string;
    static toString(value: float): string;
    static toString(value: TimeSpan): string;
    static toString(value: ushort): string;
    static toString(value: uint): string;
    static toString(value: ulong): string;
    static toTimeSpan(s: string): TimeSpan;
    static toUInt16(s: string): ushort;
    static toUInt32(s: string): uint;
    static toUInt64(s: string): ulong;
    static verifyName(name: string): string;
    static verifyNCName(name: string): string;
    static verifyNMTOKEN(name: string): string;
    static verifyPublicId(publicId: string): string;
    static verifyTOKEN(token: string): string;
    static verifyWhitespace(content: string): string;
    static verifyXmlChars(content: string): string;
}


export type XmlConvert = XmlConvert$instance;

export class XmlDataDocument$instance extends XmlDocument$instance {
    constructor();
    constructor(dataset: DataSet);
    readonly dataSet: DataSet;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createElement(prefix: string, localName: string, namespaceURI: string): XmlElement;
    createElement(name: string): XmlElement;
    createElement(qualifiedName: string, namespaceURI: string): XmlElement;
    createEntityReference(name: string): XmlEntityReference;
    createNavigator(): XPathNavigator;
    getElementById(elemId: string): XmlElement;
    getElementFromRow(r: DataRow): XmlElement;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    getRowFromElement(e: XmlElement): DataRow;
    load(filename: string): void;
    load(inStream: Stream): void;
    load(txtReader: TextReader): void;
    load(reader: XmlReader): void;
}


export interface __XmlDataDocument$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDataDocument = XmlDataDocument$instance & __XmlDataDocument$views;


export class XmlDeclaration$instance extends XmlLinkedNode$instance {
    encoding: string;
    innerText: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    standalone: string;
    value: string;
    readonly version: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDeclaration$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDeclaration = XmlDeclaration$instance & __XmlDeclaration$views;


export class XmlDictionary$instance {
    constructor();
    constructor(capacity: int);
    add(value: string): XmlDictionaryString;
    tryLookup(value: string, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(key: int, result: { value: ref<XmlDictionaryString> }): boolean;
    tryLookup(value: XmlDictionaryString, result: { value: ref<XmlDictionaryString> }): boolean;
    static readonly empty: IXmlDictionary;
}


export interface __XmlDictionary$views {
    As_IXmlDictionary(): IXmlDictionary$instance;
}

export interface XmlDictionary$instance extends IXmlDictionary$instance {}

export type XmlDictionary = XmlDictionary$instance & __XmlDictionary$views;


export abstract class XmlDictionaryReader$instance extends XmlReader$instance {
    readonly canCanonicalize: boolean;
    readonly quotas: XmlDictionaryReaderQuotas;
    dispose(): void;
    endCanonicalization(): void;
    getAttribute(name: string): string;
    getAttribute(name: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    getNonAtomizedNames(localName: { value: ref<string> }, namespaceUri: { value: ref<string> }): void;
    indexOfLocalName(localNames: string[], namespaceUri: string): int;
    indexOfLocalName(localNames: XmlDictionaryString[], namespaceUri: XmlDictionaryString): int;
    isLocalName(localName: string): boolean;
    isLocalName(localName: XmlDictionaryString): boolean;
    isNamespaceUri(namespaceUri: string): boolean;
    isNamespaceUri(namespaceUri: XmlDictionaryString): boolean;
    isStartArray(type_: { value: ref<Type> }): boolean;
    isStartElement(): boolean;
    isStartElement(name: string): boolean;
    isStartElement(localname: string, ns: string): boolean;
    moveToStartElement(): void;
    moveToStartElement(name: string): void;
    moveToStartElement(localName: string, namespaceUri: string): void;
    moveToStartElement(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): void;
    readArray(localName: string, namespaceUri: string, array: boolean[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: boolean[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: short[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: short[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: int[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: int[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: long[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: long[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: float[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: float[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: double[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: double[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: decimal[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: decimal[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: DateTime[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: DateTime[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: Guid[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: Guid[], offset: int, count: int): int;
    readArray(localName: string, namespaceUri: string, array: TimeSpan[], offset: int, count: int): int;
    readArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: TimeSpan[], offset: int, count: int): int;
    readBooleanArray(localName: string, namespaceUri: string): boolean[];
    readBooleanArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): boolean[];
    readContentAs(type_: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    readContentAsBase642(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readContentAsChars(chars: char[], offset: int, count: int): int;
    readContentAsDecimal(): decimal;
    readContentAsFloat(): float;
    readContentAsGuid(): Guid;
    readContentAsQualifiedName(localName: { value: ref<string> }, namespaceUri: { value: ref<string> }): void;
    readContentAsString(): string;
    readContentAsTimeSpan(): TimeSpan;
    readContentAsUniqueId(): UniqueId;
    readDateTimeArray(localName: string, namespaceUri: string): DateTime[];
    readDateTimeArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): DateTime[];
    readDecimalArray(localName: string, namespaceUri: string): decimal[];
    readDecimalArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): decimal[];
    readDoubleArray(localName: string, namespaceUri: string): double[];
    readDoubleArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): double[];
    readElementContentAsBase642(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBoolean(): boolean;
    readElementContentAsBoolean(localName: string, namespaceURI: string): boolean;
    readElementContentAsDateTime(): DateTime;
    readElementContentAsDateTime(localName: string, namespaceURI: string): DateTime;
    readElementContentAsDecimal(): decimal;
    readElementContentAsDecimal(localName: string, namespaceURI: string): decimal;
    readElementContentAsDouble(): double;
    readElementContentAsDouble(localName: string, namespaceURI: string): double;
    readElementContentAsFloat(): float;
    readElementContentAsFloat(localName: string, namespaceURI: string): float;
    readElementContentAsGuid(): Guid;
    readElementContentAsInt(): int;
    readElementContentAsInt(localName: string, namespaceURI: string): int;
    readElementContentAsLong(): long;
    readElementContentAsLong(localName: string, namespaceURI: string): long;
    readElementContentAsString(): string;
    readElementContentAsString(localName: string, namespaceURI: string): string;
    readElementContentAsTimeSpan(): TimeSpan;
    readElementContentAsUniqueId(): UniqueId;
    readFullStartElement(): void;
    readFullStartElement(name: string): void;
    readFullStartElement(localName: string, namespaceUri: string): void;
    readFullStartElement(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): void;
    readGuidArray(localName: string, namespaceUri: string): Guid[];
    readGuidArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): Guid[];
    readInt16Array(localName: string, namespaceUri: string): short[];
    readInt16Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): short[];
    readInt32Array(localName: string, namespaceUri: string): int[];
    readInt32Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): int[];
    readInt64Array(localName: string, namespaceUri: string): long[];
    readInt64Array(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): long[];
    readSingleArray(localName: string, namespaceUri: string): float[];
    readSingleArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): float[];
    readStartElement(): void;
    readStartElement(name: string): void;
    readStartElement(localname: string, ns: string): void;
    readString(): string;
    readTimeSpanArray(localName: string, namespaceUri: string): TimeSpan[];
    readTimeSpanArray(localName: XmlDictionaryString, namespaceUri: XmlDictionaryString): TimeSpan[];
    readValueAsBase64(buffer: byte[], offset: int, count: int): int;
    startCanonicalization(stream: Stream, includeComments: boolean, inclusivePrefixes: string[]): void;
    tryGetArrayLength(count: { value: ref<int> }): boolean;
    tryGetBase64ContentLength(length: { value: ref<int> }): boolean;
    tryGetLocalNameAsDictionaryString(localName: { value: ref<XmlDictionaryString> }): boolean;
    tryGetNamespaceUriAsDictionaryString(namespaceUri: { value: ref<XmlDictionaryString> }): boolean;
    tryGetValueAsDictionaryString(value: { value: ref<XmlDictionaryString> }): boolean;
    static createBinaryReader5(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static createBinaryReader5(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession): XmlDictionaryReader;
    static createBinaryReader5(buffer: byte[], offset: int, count: int, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createBinaryReader5(buffer: byte[], offset: int, count: int, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createBinaryReader5(buffer: byte[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createBinaryReader5(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static createBinaryReader5(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas, session: XmlBinaryReaderSession): XmlDictionaryReader;
    static createBinaryReader5(stream: Stream, dictionary: IXmlDictionary, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createBinaryReader5(stream: Stream, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createDictionaryReader(reader: XmlReader): XmlDictionaryReader;
    static createMtomReader5(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createMtomReader5(buffer: byte[], offset: int, count: int, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas, maxBufferSize: int, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static createMtomReader5(buffer: byte[], offset: int, count: int, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createMtomReader5(buffer: byte[], offset: int, count: int, encodings: Encoding[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createMtomReader5(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createMtomReader5(stream: Stream, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas, maxBufferSize: int, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static createMtomReader5(stream: Stream, encodings: Encoding[], contentType: string, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createMtomReader5(stream: Stream, encodings: Encoding[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createTextReader3(buffer: byte[], offset: int, count: int, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static createTextReader3(buffer: byte[], offset: int, count: int, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createTextReader3(buffer: byte[], quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
    static createTextReader3(stream: Stream, encoding: Encoding, quotas: XmlDictionaryReaderQuotas, onClose: OnXmlDictionaryReaderClose): XmlDictionaryReader;
    static createTextReader3(stream: Stream, quotas: XmlDictionaryReaderQuotas): XmlDictionaryReader;
}


export interface __XmlDictionaryReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlDictionaryReader = XmlDictionaryReader$instance & __XmlDictionaryReader$views;


export class XmlDictionaryReaderQuotas$instance {
    constructor();
    maxArrayLength: int;
    maxBytesPerRead: int;
    maxDepth: int;
    maxNameTableCharCount: int;
    maxStringContentLength: int;
    readonly modifiedQuotas: XmlDictionaryReaderQuotaTypes;
    copyTo(quotas: XmlDictionaryReaderQuotas): void;
    static readonly max: XmlDictionaryReaderQuotas;
}


export type XmlDictionaryReaderQuotas = XmlDictionaryReaderQuotas$instance;

export class XmlDictionaryString$instance {
    constructor(dictionary: IXmlDictionary, value: string, key: int);
    readonly dictionary: IXmlDictionary;
    readonly key: int;
    readonly value: string;
    toString(): string;
    static readonly empty: XmlDictionaryString;
}


export type XmlDictionaryString = XmlDictionaryString$instance;

export abstract class XmlDictionaryWriter$instance extends XmlWriter$instance {
    readonly canCanonicalize: boolean;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    endCanonicalization(): void;
    startCanonicalization(stream: Stream, includeComments: boolean, inclusivePrefixes: string[]): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: boolean[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: boolean[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: short[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: short[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: int[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: int[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: long[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: long[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: float[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: float[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: double[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: double[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: decimal[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: decimal[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: DateTime[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: DateTime[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: Guid[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: Guid[], offset: int, count: int): void;
    writeArray(prefix: string, localName: string, namespaceUri: string, array: TimeSpan[], offset: int, count: int): void;
    writeArray(prefix: string, localName: XmlDictionaryString, namespaceUri: XmlDictionaryString, array: TimeSpan[], offset: int, count: int): void;
    writeAttributeString(localName: string, ns: string, value: string): void;
    writeAttributeString(localName: string, value: string): void;
    writeAttributeString(prefix: string, localName: string, ns: string, value: string): void;
    writeBase64Async(buffer: byte[], index: int, count: int): Task;
    writeElementString(localName: string, value: string): void;
    writeElementString(localName: string, ns: string, value: string): void;
    writeElementString(prefix: string, localName: string, ns: string, value: string): void;
    writeNode(reader: XmlReader, defattr: boolean): void;
    writeNode(navigator: XPathNavigator, defattr: boolean): void;
    writeQualifiedName(localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeString(text: string): void;
    writeValue(value: unknown): void;
    writeValue(value: string): void;
    writeValue(value: boolean): void;
    writeValue(value: DateTime): void;
    writeValue(value: DateTimeOffset): void;
    writeValue(value: double): void;
    writeValue(value: float): void;
    writeValue(value: decimal): void;
    writeValue(value: int): void;
    writeValue(value: long): void;
    writeValueAsync(value: IStreamProvider): Task;
    writeXmlAttribute(localName: string, value: string): void;
    writeXmlAttribute(localName: XmlDictionaryString, value: XmlDictionaryString): void;
    writeXmlnsAttribute(prefix: string, namespaceUri: string): void;
    writeXmlnsAttribute(prefix: string, namespaceUri: XmlDictionaryString): void;
    static createBinaryWriter4(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession, ownsStream: boolean): XmlDictionaryWriter;
    static createBinaryWriter4(stream: Stream, dictionary: IXmlDictionary, session: XmlBinaryWriterSession): XmlDictionaryWriter;
    static createBinaryWriter4(stream: Stream, dictionary: IXmlDictionary): XmlDictionaryWriter;
    static createBinaryWriter4(stream: Stream): XmlDictionaryWriter;
    static createDictionaryWriter(writer: XmlWriter): XmlDictionaryWriter;
    static createMtomWriter2(stream: Stream, encoding: Encoding, maxSizeInBytes: int, startInfo: string, boundary: string, startUri: string, writeMessageHeaders: boolean, ownsStream: boolean): XmlDictionaryWriter;
    static createMtomWriter2(stream: Stream, encoding: Encoding, maxSizeInBytes: int, startInfo: string): XmlDictionaryWriter;
    static createTextWriter3(stream: Stream, encoding: Encoding, ownsStream: boolean): XmlDictionaryWriter;
    static createTextWriter3(stream: Stream, encoding: Encoding): XmlDictionaryWriter;
    static createTextWriter3(stream: Stream): XmlDictionaryWriter;
}


export interface __XmlDictionaryWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlDictionaryWriter = XmlDictionaryWriter$instance & __XmlDictionaryWriter$views;


export class XmlDocument$instance extends XmlNode$instance {
    constructor();
    constructor(nt: XmlNameTable);
    readonly baseURI: string;
    readonly documentElement: XmlElement;
    readonly documentType: XmlDocumentType;
    readonly implementation: XmlImplementation;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    preserveWhitespace: boolean;
    readonly schemaInfo: IXmlSchemaInfo;
    schemas: XmlSchemaSet;
    xmlResolver: XmlResolver;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createAttribute(name: string): XmlAttribute;
    createAttribute(qualifiedName: string, namespaceURI: string): XmlAttribute;
    createAttribute(prefix: string, localName: string, namespaceURI: string): XmlAttribute;
    createCDataSection(data: string): XmlCDataSection;
    createComment(data: string): XmlComment;
    createDocumentFragment(): XmlDocumentFragment;
    createDocumentType(name: string, publicId: string, systemId: string, internalSubset: string): XmlDocumentType;
    createElement(name: string): XmlElement;
    createElement(qualifiedName: string, namespaceURI: string): XmlElement;
    createElement(prefix: string, localName: string, namespaceURI: string): XmlElement;
    createEntityReference(name: string): XmlEntityReference;
    createNavigator(): XPathNavigator;
    createNode(type_: XmlNodeType, prefix: string, name: string, namespaceURI: string): XmlNode;
    createNode(nodeTypeString: string, name: string, namespaceURI: string): XmlNode;
    createNode(type_: XmlNodeType, name: string, namespaceURI: string): XmlNode;
    createProcessingInstruction(target: string, data: string): XmlProcessingInstruction;
    createSignificantWhitespace(text: string): XmlSignificantWhitespace;
    createTextNode(text: string): XmlText;
    createWhitespace(text: string): XmlWhitespace;
    createXmlDeclaration(version: string, encoding: string, standalone: string): XmlDeclaration;
    getElementById(elementId: string): XmlElement;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    importNode(node: XmlNode, deep: boolean): XmlNode;
    load(filename: string): void;
    load(inStream: Stream): void;
    load(txtReader: TextReader): void;
    load(reader: XmlReader): void;
    loadXml(xml: string): void;
    readNode(reader: XmlReader): XmlNode;
    save(filename: string): void;
    save(outStream: Stream): void;
    save(writer: TextWriter): void;
    save(w: XmlWriter): void;
    validate(validationEventHandler: ValidationEventHandler): void;
    validate(validationEventHandler: ValidationEventHandler, nodeToValidate: XmlNode): void;
    writeContentTo(xw: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDocument$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocument = XmlDocument$instance & __XmlDocument$views;


export class XmlDocumentFragment$instance extends XmlNode$instance {
    innerXml: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDocumentFragment$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocumentFragment = XmlDocumentFragment$instance & __XmlDocumentFragment$views;


export class XmlDocumentType$instance extends XmlLinkedNode$instance {
    readonly entities: XmlNamedNodeMap;
    readonly internalSubset: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly notations: XmlNamedNodeMap;
    readonly publicId: string;
    readonly systemId: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlDocumentType$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlDocumentType = XmlDocumentType$instance & __XmlDocumentType$views;


export class XmlElement$instance extends XmlLinkedNode$instance {
    readonly attributes: XmlAttributeCollection;
    readonly hasAttributes: boolean;
    innerText: string;
    innerXml: string;
    isEmpty: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nextSibling: XmlNode;
    readonly nodeType: XmlNodeType;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly schemaInfo: IXmlSchemaInfo;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttributeNode(name: string): XmlAttribute;
    getAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    getElementsByTagName(name: string): XmlNodeList;
    getElementsByTagName(localName: string, namespaceURI: string): XmlNodeList;
    getEnumerator(): IEnumerator;
    hasAttribute(name: string): boolean;
    hasAttribute(localName: string, namespaceURI: string): boolean;
    removeAll(): void;
    removeAllAttributes(): void;
    removeAttribute(name: string): void;
    removeAttribute(localName: string, namespaceURI: string): void;
    removeAttributeAt(i: int): XmlNode;
    removeAttributeNode(oldAttr: XmlAttribute): XmlAttribute;
    removeAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    setAttribute(name: string, value: string): void;
    setAttribute(localName: string, namespaceURI: string, value: string): string;
    setAttributeNode(newAttr: XmlAttribute): XmlAttribute;
    setAttributeNode(localName: string, namespaceURI: string): XmlAttribute;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlElement$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlElement = XmlElement$instance & __XmlElement$views;


export class XmlEntity$instance extends XmlNode$instance {
    readonly baseURI: string;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly notationName: string;
    readonly outerXml: string;
    readonly publicId: string;
    readonly systemId: string;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlEntity$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlEntity = XmlEntity$instance & __XmlEntity$views;


export class XmlEntityReference$instance extends XmlLinkedNode$instance {
    readonly baseURI: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlEntityReference$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlEntityReference = XmlEntityReference$instance & __XmlEntityReference$views;


export class XmlException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerException: Exception, lineNumber: int, linePosition: int);
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly message: string;
    readonly sourceUri: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XmlException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlException = XmlException$instance & __XmlException$views;


export class XmlImplementation$instance {
    constructor();
    constructor(nt: XmlNameTable);
    createDocument(): XmlDocument;
    hasFeature(strFeature: string, strVersion: string): boolean;
}


export type XmlImplementation = XmlImplementation$instance;

export abstract class XmlLinkedNode$instance extends XmlNode$instance {
    readonly nextSibling: XmlNode;
    readonly previousSibling: XmlNode;
    clone(): XmlNode;
    clone(): unknown;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
}


export interface __XmlLinkedNode$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlLinkedNode = XmlLinkedNode$instance & __XmlLinkedNode$views;


export class XmlNamedNodeMap$instance {
    readonly count: int;
    getEnumerator(): IEnumerator;
    getNamedItem(name: string): XmlNode;
    getNamedItem(localName: string, namespaceURI: string): XmlNode;
    item(index: int): XmlNode;
    removeNamedItem(name: string): XmlNode;
    removeNamedItem(localName: string, namespaceURI: string): XmlNode;
    setNamedItem(node: XmlNode): XmlNode;
}


export interface __XmlNamedNodeMap$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface XmlNamedNodeMap$instance extends System_Collections_Internal.IEnumerable$instance {}

export type XmlNamedNodeMap = XmlNamedNodeMap$instance & __XmlNamedNodeMap$views;


export class XmlNamespaceManager$instance {
    constructor(nameTable: XmlNameTable);
    readonly defaultNamespace: string;
    readonly nameTable: XmlNameTable;
    addNamespace(prefix: string, uri: string): void;
    getEnumerator(): IEnumerator;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    hasNamespace(prefix: string): boolean;
    lookupNamespace(prefix: string): string;
    lookupPrefix(uri: string): string;
    popScope(): boolean;
    pushScope(): void;
    removeNamespace(prefix: string, uri: string): void;
}


export interface __XmlNamespaceManager$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export interface XmlNamespaceManager$instance extends System_Collections_Internal.IEnumerable$instance, IXmlNamespaceResolver$instance {}

export type XmlNamespaceManager = XmlNamespaceManager$instance & __XmlNamespaceManager$views;


export abstract class XmlNameTable$instance {
    abstract add(array: char[], offset: int, length: int): string;
    abstract add(array: string): string;
    abstract get_(array: char[], offset: int, length: int): string;
    abstract get_(array: string): string;
}


export type XmlNameTable = XmlNameTable$instance;

export abstract class XmlNode$instance {
    readonly attributes: XmlAttributeCollection;
    readonly baseURI: string;
    readonly childNodes: XmlNodeList;
    readonly firstChild: XmlNode;
    readonly hasChildNodes: boolean;
    innerText: string;
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly lastChild: XmlNode;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nextSibling: XmlNode;
    readonly nodeType: XmlNodeType;
    readonly outerXml: string;
    readonly ownerDocument: XmlDocument;
    readonly parentNode: XmlNode;
    prefix: string;
    readonly previousSibling: XmlNode;
    readonly previousText: XmlNode;
    readonly schemaInfo: IXmlSchemaInfo;
    value: string;
    appendChild(newChild: XmlNode): XmlNode;
    clone(): XmlNode;
    abstract cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    get_Item(name: string): XmlElement;
    get_Item(localname: string, ns: string): XmlElement;
    getEnumerator(): IEnumerator;
    getNamespaceOfPrefix(prefix: string): string;
    getPrefixOfNamespace(namespaceURI: string): string;
    insertAfter(newChild: XmlNode, refChild: XmlNode): XmlNode;
    insertBefore(newChild: XmlNode, refChild: XmlNode): XmlNode;
    normalize(): void;
    prependChild(newChild: XmlNode): XmlNode;
    removeAll(): void;
    removeChild(oldChild: XmlNode): XmlNode;
    replaceChild(newChild: XmlNode, oldChild: XmlNode): XmlNode;
    selectNodes(xpath: string): XmlNodeList;
    selectNodes(xpath: string, nsmgr: XmlNamespaceManager): XmlNodeList;
    selectSingleNode(xpath: string): XmlNode;
    selectSingleNode(xpath: string, nsmgr: XmlNamespaceManager): XmlNode;
    supports(feature: string, version: string): boolean;
    abstract writeContentTo(w: XmlWriter): void;
    abstract writeTo(w: XmlWriter): void;
}


export interface __XmlNode$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export interface XmlNode$instance extends System_Collections_Internal.IEnumerable$instance, System_Xml_XPath_Internal.IXPathNavigable$instance {}

export type XmlNode = XmlNode$instance & __XmlNode$views;


export class XmlNodeChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(node: XmlNode, oldParent: XmlNode, newParent: XmlNode, oldValue: string, newValue: string, action: XmlNodeChangedAction);
    readonly action: XmlNodeChangedAction;
    readonly newParent: XmlNode;
    readonly newValue: string;
    readonly node: XmlNode;
    readonly oldParent: XmlNode;
    readonly oldValue: string;
}


export type XmlNodeChangedEventArgs = XmlNodeChangedEventArgs$instance;

export class XmlNodeChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: XmlNodeChangedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: XmlNodeChangedEventArgs): void;
}


export interface __XmlNodeChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlNodeChangedEventHandler = XmlNodeChangedEventHandler$instance & __XmlNodeChangedEventHandler$views;


export abstract class XmlNodeList$instance {
    readonly count: int;
    readonly itemOf: XmlNode;
    abstract getEnumerator(): IEnumerator;
    abstract item(index: int): XmlNode;
}


export interface __XmlNodeList$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface XmlNodeList$instance extends System_Collections_Internal.IEnumerable$instance, System_Internal.IDisposable$instance {}

export type XmlNodeList = XmlNodeList$instance & __XmlNodeList$views;


export class XmlNodeReader$instance extends XmlReader$instance {
    constructor(node: XmlNode);
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly EOF: boolean;
    readonly hasAttributes: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly readState: ReadState;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly value: string;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(name: string, namespaceURI: string): string;
    getAttribute(attributeIndex: int): string;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(name: string, namespaceURI: string): boolean;
    moveToAttribute(attributeIndex: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    resolveEntity(): void;
    skip(): void;
}


export interface __XmlNodeReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export type XmlNodeReader = XmlNodeReader$instance & __XmlNodeReader$views;


export class XmlNotation$instance extends XmlNode$instance {
    innerXml: string;
    readonly isReadOnly: boolean;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly outerXml: string;
    readonly publicId: string;
    readonly systemId: string;
    clone(): XmlNode;
    clone(): unknown;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlNotation$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlNotation = XmlNotation$instance & __XmlNotation$views;


export class XmlParserContext$instance {
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, xmlLang: string, xmlSpace: XmlSpace);
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, xmlLang: string, xmlSpace: XmlSpace, enc: Encoding);
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, docTypeName: string, pubId: string, sysId: string, internalSubset: string, baseURI: string, xmlLang: string, xmlSpace: XmlSpace);
    constructor(nt: XmlNameTable, nsMgr: XmlNamespaceManager, docTypeName: string, pubId: string, sysId: string, internalSubset: string, baseURI: string, xmlLang: string, xmlSpace: XmlSpace, enc: Encoding);
    baseURI: string;
    docTypeName: string;
    encoding: Encoding;
    internalSubset: string;
    namespaceManager: XmlNamespaceManager;
    nameTable: XmlNameTable;
    publicId: string;
    systemId: string;
    xmlLang: string;
    xmlSpace: XmlSpace;
}


export type XmlParserContext = XmlParserContext$instance;

export class XmlProcessingInstruction$instance extends XmlLinkedNode$instance {
    data: string;
    innerText: string;
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly target: string;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlProcessingInstruction$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlProcessingInstruction = XmlProcessingInstruction$instance & __XmlProcessingInstruction$views;


export class XmlQualifiedName$instance {
    constructor();
    constructor(name: string);
    constructor(name: string, ns: string);
    readonly isEmpty: boolean;
    readonly name: string;
    readonly namespace_: string;
    equals(other: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly empty: XmlQualifiedName;
    static toString(name: string, ns: string): string;
}


export type XmlQualifiedName = XmlQualifiedName$instance;

export abstract class XmlReader$instance {
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canReadValueChunk: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly EOF: boolean;
    readonly hasAttributes: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly quoteChar: char;
    readonly readState: ReadState;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly settings: XmlReaderSettings;
    readonly value: string;
    readonly valueType: Type;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    get_Item(i: int): string;
    get_Item(name: string): string;
    get_Item(name: string, namespaceURI: string): string;
    abstract getAttribute(name: string): string;
    abstract getAttribute(name: string, namespaceURI: string): string;
    abstract getAttribute(i: int): string;
    getValueAsync(): Task_1<CLROf<string>>;
    isStartElement(): boolean;
    isStartElement(name: string): boolean;
    isStartElement(localname: string, ns: string): boolean;
    abstract lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(name: string, ns: string): boolean;
    moveToAttribute(i: int): void;
    moveToContent(): XmlNodeType;
    moveToContentAsync(): Task_1<XmlNodeType>;
    abstract moveToElement(): boolean;
    abstract moveToFirstAttribute(): boolean;
    abstract moveToNextAttribute(): boolean;
    abstract read(): boolean;
    readAsync(): Task_1<CLROf<boolean>>;
    abstract readAttributeValue(): boolean;
    readContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    readContentAsAsync(returnType: Type, namespaceResolver: IXmlNamespaceResolver): Task_1<unknown>;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBase64Async(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readContentAsBinHexAsync(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readContentAsBoolean(): boolean;
    readContentAsDateTime(): DateTime;
    readContentAsDateTimeOffset(): DateTimeOffset;
    readContentAsDecimal(): decimal;
    readContentAsDouble(): double;
    readContentAsFloat(): float;
    readContentAsInt(): int;
    readContentAsLong(): long;
    readContentAsObject(): unknown;
    readContentAsObjectAsync(): Task_1<unknown>;
    readContentAsString(): string;
    readContentAsStringAsync(): Task_1<CLROf<string>>;
    readElementContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    readElementContentAs(returnType: Type, namespaceResolver: IXmlNamespaceResolver, localName: string, namespaceURI: string): unknown;
    readElementContentAsAsync(returnType: Type, namespaceResolver: IXmlNamespaceResolver): Task_1<unknown>;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64Async(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHexAsync(buffer: byte[], index: int, count: int): Task_1<CLROf<int>>;
    readElementContentAsBoolean(): boolean;
    readElementContentAsBoolean(localName: string, namespaceURI: string): boolean;
    readElementContentAsDateTime(): DateTime;
    readElementContentAsDateTime(localName: string, namespaceURI: string): DateTime;
    readElementContentAsDecimal(): decimal;
    readElementContentAsDecimal(localName: string, namespaceURI: string): decimal;
    readElementContentAsDouble(): double;
    readElementContentAsDouble(localName: string, namespaceURI: string): double;
    readElementContentAsFloat(): float;
    readElementContentAsFloat(localName: string, namespaceURI: string): float;
    readElementContentAsInt(): int;
    readElementContentAsInt(localName: string, namespaceURI: string): int;
    readElementContentAsLong(): long;
    readElementContentAsLong(localName: string, namespaceURI: string): long;
    readElementContentAsObject(): unknown;
    readElementContentAsObject(localName: string, namespaceURI: string): unknown;
    readElementContentAsObjectAsync(): Task_1<unknown>;
    readElementContentAsString(): string;
    readElementContentAsString(localName: string, namespaceURI: string): string;
    readElementContentAsStringAsync(): Task_1<CLROf<string>>;
    readElementString(): string;
    readElementString(name: string): string;
    readElementString(localname: string, ns: string): string;
    readEndElement(): void;
    readInnerXml(): string;
    readInnerXmlAsync(): Task_1<CLROf<string>>;
    readOuterXml(): string;
    readOuterXmlAsync(): Task_1<CLROf<string>>;
    readStartElement(): void;
    readStartElement(name: string): void;
    readStartElement(localname: string, ns: string): void;
    readString(): string;
    readSubtree(): XmlReader;
    readToDescendant(name: string): boolean;
    readToDescendant(localName: string, namespaceURI: string): boolean;
    readToFollowing(name: string): boolean;
    readToFollowing(localName: string, namespaceURI: string): boolean;
    readToNextSibling(name: string): boolean;
    readToNextSibling(localName: string, namespaceURI: string): boolean;
    readValueChunk(buffer: char[], index: int, count: int): int;
    readValueChunkAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    abstract resolveEntity(): void;
    skip(): void;
    skipAsync(): Task;
    static create6(input: Stream, settings: XmlReaderSettings, baseUri: string): XmlReader;
    static create6(input: Stream, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    static create6(input: Stream, settings: XmlReaderSettings): XmlReader;
    static create6(input: Stream): XmlReader;
    static create6(input: TextReader, settings: XmlReaderSettings, baseUri: string): XmlReader;
    static create6(input: TextReader, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    static create6(input: TextReader, settings: XmlReaderSettings): XmlReader;
    static create6(input: TextReader): XmlReader;
    static create6(inputUri: string, settings: XmlReaderSettings, inputContext: XmlParserContext): XmlReader;
    static create6(inputUri: string, settings: XmlReaderSettings): XmlReader;
    static create6(inputUri: string): XmlReader;
    static create6(reader: XmlReader, settings: XmlReaderSettings): XmlReader;
    static isName(str: string): boolean;
    static isNameToken(str: string): boolean;
}


export interface __XmlReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface XmlReader$instance extends System_Internal.IDisposable$instance {}

export type XmlReader = XmlReader$instance & __XmlReader$views;


export class XmlReaderSettings$instance {
    constructor();
    async_: boolean;
    checkCharacters: boolean;
    closeInput: boolean;
    conformanceLevel: ConformanceLevel;
    dtdProcessing: DtdProcessing;
    ignoreComments: boolean;
    ignoreProcessingInstructions: boolean;
    ignoreWhitespace: boolean;
    lineNumberOffset: int;
    linePositionOffset: int;
    maxCharactersFromEntities: long;
    maxCharactersInDocument: long;
    nameTable: XmlNameTable;
    prohibitDtd: boolean;
    schemas: XmlSchemaSet;
    validationFlags: XmlSchemaValidationFlags;
    validationType: ValidationType;
    xmlResolver: XmlResolver;
    clone(): XmlReaderSettings;
    reset(): void;
}


export type XmlReaderSettings = XmlReaderSettings$instance;

export abstract class XmlResolver$instance {
    credentials: ICredentials;
    abstract getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): unknown;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
    supportsType(absoluteUri: Uri, type_: Type): boolean;
    static readonly fileSystemResolver: XmlResolver;
    static readonly throwingResolver: XmlResolver;
}


export type XmlResolver = XmlResolver$instance;

export class XmlSecureResolver$instance extends XmlResolver$instance {
    constructor(resolver: XmlResolver, securityUrl: string);
    credentials: ICredentials;
    getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): unknown;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
}


export type XmlSecureResolver = XmlSecureResolver$instance;

export class XmlSignificantWhitespace$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlSignificantWhitespace$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlSignificantWhitespace = XmlSignificantWhitespace$instance & __XmlSignificantWhitespace$views;


export class XmlText$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    splitText(offset: int): XmlText;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlText$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlText = XmlText$instance & __XmlText$views;


export class XmlTextReader$instance extends XmlReader$instance {
    constructor(input: Stream);
    constructor(url: string, input: Stream);
    constructor(input: Stream, nt: XmlNameTable);
    constructor(url: string, input: Stream, nt: XmlNameTable);
    constructor(input: TextReader);
    constructor(url: string, input: TextReader);
    constructor(input: TextReader, nt: XmlNameTable);
    constructor(url: string, input: TextReader, nt: XmlNameTable);
    constructor(xmlFragment: Stream, fragType: XmlNodeType, context: XmlParserContext);
    constructor(xmlFragment: string, fragType: XmlNodeType, context: XmlParserContext);
    constructor(url: string);
    constructor(url: string, nt: XmlNameTable);
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canReadValueChunk: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    dtdProcessing: DtdProcessing;
    readonly encoding: Encoding;
    entityHandling: EntityHandling;
    readonly EOF: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly localName: string;
    readonly name: string;
    namespaces: boolean;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    normalization: boolean;
    readonly prefix: string;
    prohibitDtd: boolean;
    readonly quoteChar: char;
    readonly readState: ReadState;
    readonly value: string;
    whitespaceHandling: WhitespaceHandling;
    readonly xmlLang: string;
    xmlResolver: XmlResolver;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    getRemainder(): TextReader;
    hasLineInfo(): boolean;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(localName: string, namespaceURI: string): boolean;
    moveToAttribute(i: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readBase64(array: byte[], offset: int, len: int): int;
    readBinHex(array: byte[], offset: int, len: int): int;
    readChars(buffer: char[], index: int, count: int): int;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    resetState(): void;
    resolveEntity(): void;
    skip(): void;
}


export interface __XmlTextReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IXmlLineInfo(): IXmlLineInfo$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export interface XmlTextReader$instance extends IXmlLineInfo$instance {}

export type XmlTextReader = XmlTextReader$instance & __XmlTextReader$views;


export class XmlTextWriter$instance extends XmlWriter$instance {
    constructor(w: Stream, encoding: Encoding);
    constructor(filename: string, encoding: Encoding);
    constructor(w: TextWriter);
    readonly baseStream: Stream;
    formatting: Formatting;
    indentation: int;
    indentChar: char;
    namespaces: boolean;
    quoteChar: char;
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    lookupPrefix(ns: string): string;
    writeBase64(buffer: byte[], index: int, count: int): void;
    writeBinHex(buffer: byte[], index: int, count: int): void;
    writeCData(text: string): void;
    writeCharEntity(ch: char): void;
    writeChars(buffer: char[], index: int, count: int): void;
    writeComment(text: string): void;
    writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeEndAttribute(): void;
    writeEndDocument(): void;
    writeEndElement(): void;
    writeEntityRef(name: string): void;
    writeFullEndElement(): void;
    writeName(name: string): void;
    writeNmToken(name: string): void;
    writeProcessingInstruction(name: string, text: string): void;
    writeQualifiedName(localName: string, ns: string): void;
    writeRaw(buffer: char[], index: int, count: int): void;
    writeRaw(data: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartDocument(): void;
    writeStartDocument(standalone: boolean): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeString(text: string): void;
    writeSurrogateCharEntity(lowChar: char, highChar: char): void;
    writeWhitespace(ws: string): void;
}


export interface __XmlTextWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlTextWriter = XmlTextWriter$instance & __XmlTextWriter$views;


export class XmlUrlResolver$instance extends XmlResolver$instance {
    constructor();
    cachePolicy: RequestCachePolicy;
    credentials: ICredentials;
    proxy: IWebProxy;
    getEntity(absoluteUri: Uri, role: string, ofObjectToReturn: Type): unknown;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    getEntityAsync(absoluteUri: Uri, role: string, ofObjectToReturn: Type): Task_1<unknown>;
    resolveUri(baseUri: Uri, relativeUri: string): Uri;
}


export type XmlUrlResolver = XmlUrlResolver$instance;

export class XmlValidatingReader$instance extends XmlReader$instance {
    constructor(reader: XmlReader);
    constructor(xmlFragment: string, fragType: XmlNodeType, context: XmlParserContext);
    constructor(xmlFragment: Stream, fragType: XmlNodeType, context: XmlParserContext);
    readonly attributeCount: int;
    readonly baseURI: string;
    readonly canReadBinaryContent: boolean;
    readonly canResolveEntity: boolean;
    readonly depth: int;
    readonly encoding: Encoding;
    entityHandling: EntityHandling;
    readonly EOF: boolean;
    readonly hasValue: boolean;
    readonly isDefault: boolean;
    readonly isEmptyElement: boolean;
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly localName: string;
    readonly name: string;
    namespaces: boolean;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XmlNodeType;
    readonly prefix: string;
    readonly quoteChar: char;
    readonly reader: XmlReader;
    readonly readState: ReadState;
    readonly schemas: XmlSchemaCollection;
    readonly schemaType: unknown;
    validationType: ValidationType;
    readonly value: string;
    readonly xmlLang: string;
    xmlResolver: XmlResolver;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    getAttribute(name: string): string;
    getAttribute(localName: string, namespaceURI: string): string;
    getAttribute(i: int): string;
    hasLineInfo(): boolean;
    lookupNamespace(prefix: string): string;
    moveToAttribute(name: string): boolean;
    moveToAttribute(localName: string, namespaceURI: string): boolean;
    moveToAttribute(i: int): void;
    moveToElement(): boolean;
    moveToFirstAttribute(): boolean;
    moveToNextAttribute(): boolean;
    read(): boolean;
    readAttributeValue(): boolean;
    readContentAsBase64(buffer: byte[], index: int, count: int): int;
    readContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readElementContentAsBase64(buffer: byte[], index: int, count: int): int;
    readElementContentAsBinHex(buffer: byte[], index: int, count: int): int;
    readString(): string;
    readTypedValue(): unknown;
    resolveEntity(): void;
}


export interface __XmlValidatingReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IXmlLineInfo(): IXmlLineInfo$instance;
    As_IXmlNamespaceResolver(): IXmlNamespaceResolver$instance;
}

export interface XmlValidatingReader$instance extends IXmlLineInfo$instance {}

export type XmlValidatingReader = XmlValidatingReader$instance & __XmlValidatingReader$views;


export class XmlWhitespace$instance extends XmlCharacterData$instance {
    readonly localName: string;
    readonly name: string;
    readonly nodeType: XmlNodeType;
    readonly parentNode: XmlNode;
    readonly previousText: XmlNode;
    value: string;
    clone(): unknown;
    clone(): XmlNode;
    cloneNode(deep: boolean): XmlNode;
    createNavigator(): XPathNavigator;
    getEnumerator(): IEnumerator;
    writeContentTo(w: XmlWriter): void;
    writeTo(w: XmlWriter): void;
}


export interface __XmlWhitespace$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXPathNavigable(): System_Xml_XPath_Internal.IXPathNavigable$instance;
}

export type XmlWhitespace = XmlWhitespace$instance & __XmlWhitespace$views;


export abstract class XmlWriter$instance {
    readonly settings: XmlWriterSettings;
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    abstract flush(): void;
    flushAsync(): Task;
    abstract lookupPrefix(ns: string): string;
    writeAttributes(reader: XmlReader, defattr: boolean): void;
    writeAttributesAsync(reader: XmlReader, defattr: boolean): Task;
    writeAttributeString(localName: string, ns: string, value: string): void;
    writeAttributeString(localName: string, value: string): void;
    writeAttributeString(prefix: string, localName: string, ns: string, value: string): void;
    writeAttributeStringAsync(prefix: string, localName: string, ns: string, value: string): Task;
    abstract writeBase64(buffer: byte[], index: int, count: int): void;
    writeBase64Async(buffer: byte[], index: int, count: int): Task;
    writeBinHex(buffer: byte[], index: int, count: int): void;
    writeBinHexAsync(buffer: byte[], index: int, count: int): Task;
    abstract writeCData(text: string): void;
    writeCDataAsync(text: string): Task;
    abstract writeCharEntity(ch: char): void;
    writeCharEntityAsync(ch: char): Task;
    abstract writeChars(buffer: char[], index: int, count: int): void;
    writeCharsAsync(buffer: char[], index: int, count: int): Task;
    abstract writeComment(text: string): void;
    writeCommentAsync(text: string): Task;
    abstract writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeDocTypeAsync(name: string, pubid: string, sysid: string, subset: string): Task;
    writeElementString(localName: string, value: string): void;
    writeElementString(localName: string, ns: string, value: string): void;
    writeElementString(prefix: string, localName: string, ns: string, value: string): void;
    writeElementStringAsync(prefix: string, localName: string, ns: string, value: string): Task;
    abstract writeEndAttribute(): void;
    abstract writeEndDocument(): void;
    writeEndDocumentAsync(): Task;
    abstract writeEndElement(): void;
    writeEndElementAsync(): Task;
    abstract writeEntityRef(name: string): void;
    writeEntityRefAsync(name: string): Task;
    abstract writeFullEndElement(): void;
    writeFullEndElementAsync(): Task;
    writeName(name: string): void;
    writeNameAsync(name: string): Task;
    writeNmToken(name: string): void;
    writeNmTokenAsync(name: string): Task;
    writeNode(reader: XmlReader, defattr: boolean): void;
    writeNode(navigator: XPathNavigator, defattr: boolean): void;
    writeNodeAsync(reader: XmlReader, defattr: boolean): Task;
    writeNodeAsync(navigator: XPathNavigator, defattr: boolean): Task;
    abstract writeProcessingInstruction(name: string, text: string): void;
    writeProcessingInstructionAsync(name: string, text: string): Task;
    writeQualifiedName(localName: string, ns: string): void;
    writeQualifiedNameAsync(localName: string, ns: string): Task;
    abstract writeRaw(buffer: char[], index: int, count: int): void;
    abstract writeRaw(data: string): void;
    writeRawAsync(buffer: char[], index: int, count: int): Task;
    writeRawAsync(data: string): Task;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    abstract writeStartDocument(): void;
    abstract writeStartDocument(standalone: boolean): void;
    writeStartDocumentAsync(): Task;
    writeStartDocumentAsync(standalone: boolean): Task;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeStartElementAsync(prefix: string, localName: string, ns: string): Task;
    abstract writeString(text: string): void;
    writeStringAsync(text: string): Task;
    abstract writeSurrogateCharEntity(lowChar: char, highChar: char): void;
    writeSurrogateCharEntityAsync(lowChar: char, highChar: char): Task;
    writeValue(value: unknown): void;
    writeValue(value: string): void;
    writeValue(value: boolean): void;
    writeValue(value: DateTime): void;
    writeValue(value: DateTimeOffset): void;
    writeValue(value: double): void;
    writeValue(value: float): void;
    writeValue(value: decimal): void;
    writeValue(value: int): void;
    writeValue(value: long): void;
    abstract writeWhitespace(ws: string): void;
    writeWhitespaceAsync(ws: string): Task;
    static create4(output: Stream, settings: XmlWriterSettings): XmlWriter;
    static create4(output: Stream): XmlWriter;
    static create4(output: TextWriter, settings: XmlWriterSettings): XmlWriter;
    static create4(output: TextWriter): XmlWriter;
    static create4(outputFileName: string, settings: XmlWriterSettings): XmlWriter;
    static create4(outputFileName: string): XmlWriter;
    static create4(output: StringBuilder, settings: XmlWriterSettings): XmlWriter;
    static create4(output: StringBuilder): XmlWriter;
    static create4(output: XmlWriter, settings: XmlWriterSettings): XmlWriter;
    static create4(output: XmlWriter): XmlWriter;
}


export interface __XmlWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface XmlWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type XmlWriter = XmlWriter$instance & __XmlWriter$views;


export class XmlWriterSettings$instance {
    constructor();
    async_: boolean;
    checkCharacters: boolean;
    closeOutput: boolean;
    conformanceLevel: ConformanceLevel;
    doNotEscapeUriAttributes: boolean;
    encoding: Encoding;
    indent: boolean;
    indentChars: string;
    namespaceHandling: NamespaceHandling;
    newLineChars: string;
    newLineHandling: NewLineHandling;
    newLineOnAttributes: boolean;
    omitXmlDeclaration: boolean;
    readonly outputMethod: XmlOutputMethod;
    writeEndDocumentOnClose: boolean;
    clone(): XmlWriterSettings;
    reset(): void;
}


export type XmlWriterSettings = XmlWriterSettings$instance;

