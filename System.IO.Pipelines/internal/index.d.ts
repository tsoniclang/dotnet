// Generated by tsbindgen - Architecture
// Namespace: System.IO.Pipelines
// Assembly: System.IO.Pipelines

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Buffers_Internal from "../../System.Buffers/internal/index.js";
import type { IBufferWriter_1, MemoryPool_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { Task, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Boolean as ClrBoolean, Byte, Exception, Int32, Int64, Memory_1, Object as ClrObject, ReadOnlyMemory_1, SequencePosition, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDuplexPipe$instance {
    readonly Input: PipeReader;
    readonly Output: PipeWriter;
}


export type IDuplexPipe = IDuplexPipe$instance;

export class FlushResult$instance {
    constructor(isCanceled: boolean, isCompleted: boolean);
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
}


export type FlushResult = FlushResult$instance;

export class ReadResult$instance {
    constructor(buffer: ReadOnlySequence_1<CLROf<byte>>, isCanceled: boolean, isCompleted: boolean);
    readonly buffer: ReadOnlySequence_1<CLROf<byte>>;
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
}


export type ReadResult = ReadResult$instance;

export class Pipe$instance {
    constructor();
    constructor(options: PipeOptions);
    readonly reader: PipeReader;
    readonly writer: PipeWriter;
    reset(): void;
}


export type Pipe = Pipe$instance;

export class PipeOptions$instance {
    constructor(pool: MemoryPool_1<CLROf<byte>>, readerScheduler: PipeScheduler, writerScheduler: PipeScheduler, pauseWriterThreshold: long, resumeWriterThreshold: long, minimumSegmentSize: int, useSynchronizationContext: boolean);
    readonly minimumSegmentSize: int;
    readonly pauseWriterThreshold: long;
    readonly pool: MemoryPool_1<CLROf<byte>>;
    readonly readerScheduler: PipeScheduler;
    readonly resumeWriterThreshold: long;
    readonly useSynchronizationContext: boolean;
    readonly writerScheduler: PipeScheduler;
    static readonly Default: PipeOptions;
}


export type PipeOptions = PipeOptions$instance;

export abstract class PipeReader$instance {
    abstract advanceTo(consumed: SequencePosition): void;
    abstract advanceTo(consumed: SequencePosition, examined: SequencePosition): void;
    asStream(leaveOpen?: boolean): Stream;
    abstract cancelPendingRead(): void;
    abstract complete(exception?: Exception): void;
    completeAsync(exception?: Exception): ValueTask;
    copyToAsync(destination: PipeWriter, cancellationToken?: CancellationToken): Task;
    copyToAsync(destination: Stream, cancellationToken?: CancellationToken): Task;
    onWriterCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    abstract readAsync(cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    readAtLeastAsync(minimumSize: int, cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    abstract tryRead(result: { value: ref<ReadResult> }): boolean;
    static Create(sequence: ReadOnlySequence_1<CLROf<byte>>): PipeReader;
    static Create(stream: Stream, readerOptions?: StreamPipeReaderOptions): PipeReader;
}


export type PipeReader = PipeReader$instance;

export abstract class PipeScheduler$instance {
    abstract schedule(action: Action_1<unknown>, state: unknown): void;
    static readonly ThreadPool: PipeScheduler;
    static readonly Inline: PipeScheduler;
}


export type PipeScheduler = PipeScheduler$instance;

export abstract class PipeWriter$instance {
    readonly canGetUnflushedBytes: boolean;
    readonly unflushedBytes: long;
    abstract advance(bytes: int): void;
    asStream(leaveOpen?: boolean): Stream;
    abstract cancelPendingFlush(): void;
    abstract complete(exception?: Exception): void;
    completeAsync(exception?: Exception): ValueTask;
    abstract flushAsync(cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
    abstract getMemory(sizeHint?: int): Memory_1<CLROf<byte>>;
    abstract getSpan(sizeHint?: int): Span_1<CLROf<byte>>;
    onReaderCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    writeAsync(source: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
    static Create(stream: Stream, writerOptions?: StreamPipeWriterOptions): PipeWriter;
}


export interface __PipeWriter$views {
    As_IBufferWriter_1(): System_Buffers_Internal.IBufferWriter_1$instance<CLROf<byte>>;
}

export type PipeWriter = PipeWriter$instance & __PipeWriter$views;


export class StreamPipeReaderOptions$instance {
    constructor(pool: MemoryPool_1<CLROf<byte>>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean);
    constructor(pool: MemoryPool_1<CLROf<byte>>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean, useZeroByteReads: boolean);
    readonly bufferSize: int;
    readonly leaveOpen: boolean;
    readonly minimumReadSize: int;
    readonly pool: MemoryPool_1<CLROf<byte>>;
    readonly useZeroByteReads: boolean;
}


export type StreamPipeReaderOptions = StreamPipeReaderOptions$instance;

export class StreamPipeWriterOptions$instance {
    constructor(pool: MemoryPool_1<CLROf<byte>>, minimumBufferSize: int, leaveOpen: boolean);
    readonly leaveOpen: boolean;
    readonly minimumBufferSize: int;
    readonly pool: MemoryPool_1<CLROf<byte>>;
}


export type StreamPipeWriterOptions = StreamPipeWriterOptions$instance;

export abstract class StreamPipeExtensions$instance {
    static CopyToAsync(source: Stream, destination: PipeWriter, cancellationToken?: CancellationToken): Task;
}


export type StreamPipeExtensions = StreamPipeExtensions$instance;

