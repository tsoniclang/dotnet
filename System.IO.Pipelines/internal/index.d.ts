// Generated by tsbindgen - Architecture
// Namespace: System.IO.Pipelines
// Assembly: System.IO.Pipelines

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import * as System_Buffers_Internal from "../../System.Buffers/internal/index.js";
import type { IBufferWriter_1, MemoryPool_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { Task, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Boolean as ClrBoolean, Byte, Exception, Int32, Int64, Memory_1, Object as ClrObject, ReadOnlyMemory_1, SequencePosition, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

export interface IDuplexPipe$instance {
    readonly input: PipeReader;
    readonly output: PipeWriter;
}


export type IDuplexPipe = IDuplexPipe$instance;

export interface FlushResult$instance {
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
}


export const FlushResult: {
    new(isCanceled: boolean, isCompleted: boolean): FlushResult$instance;
};


export type FlushResult = FlushResult$instance;

export interface ReadResult$instance {
    readonly buffer: ReadOnlySequence_1<System_Internal.Byte>;
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
}


export const ReadResult: {
    new(buffer: ReadOnlySequence_1<System_Internal.Byte>, isCanceled: boolean, isCompleted: boolean): ReadResult$instance;
};


export type ReadResult = ReadResult$instance;

export interface Pipe$instance {
    readonly reader: PipeReader;
    readonly writer: PipeWriter;
    reset(): void;
}


export const Pipe: {
    new(): Pipe$instance;
    new(options: PipeOptions): Pipe$instance;
};


export type Pipe = Pipe$instance;

export interface PipeOptions$instance {
    readonly minimumSegmentSize: int;
    readonly pauseWriterThreshold: long;
    readonly pool: MemoryPool_1<System_Internal.Byte>;
    readonly readerScheduler: PipeScheduler;
    readonly resumeWriterThreshold: long;
    readonly useSynchronizationContext: boolean;
    readonly writerScheduler: PipeScheduler;
}


export const PipeOptions: {
    new(pool: MemoryPool_1<System_Internal.Byte>, readerScheduler: PipeScheduler, writerScheduler: PipeScheduler, pauseWriterThreshold: long, resumeWriterThreshold: long, minimumSegmentSize: int, useSynchronizationContext: boolean): PipeOptions$instance;
    readonly default_: PipeOptions;
};


export type PipeOptions = PipeOptions$instance;

export interface PipeReader$instance {
    advanceTo(consumed: SequencePosition): void;
    advanceTo(consumed: SequencePosition, examined: SequencePosition): void;
    asStream(leaveOpen?: boolean): Stream;
    cancelPendingRead(): void;
    complete(exception?: Exception): void;
    completeAsync(exception?: Exception): ValueTask;
    copyToAsync(destination: PipeWriter, cancellationToken?: CancellationToken): Task;
    copyToAsync(destination: Stream, cancellationToken?: CancellationToken): Task;
    onWriterCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    readAsync(cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    readAtLeastAsync(minimumSize: int, cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    tryRead(result: ReadResult): boolean;
}


export const PipeReader: {
    create(sequence: ReadOnlySequence_1<System_Internal.Byte>): PipeReader;
    create(stream: Stream, readerOptions?: StreamPipeReaderOptions): PipeReader;
};


export type PipeReader = PipeReader$instance;

export interface PipeScheduler$instance {
    schedule(action: Action_1<unknown>, state: unknown): void;
}


export const PipeScheduler: {
    readonly threadPool: PipeScheduler;
    readonly inline: PipeScheduler;
};


export type PipeScheduler = PipeScheduler$instance;

export interface PipeWriter$instance {
    readonly canGetUnflushedBytes: boolean;
    readonly unflushedBytes: long;
    advance(bytes: int): void;
    asStream(leaveOpen?: boolean): Stream;
    cancelPendingFlush(): void;
    complete(exception?: Exception): void;
    completeAsync(exception?: Exception): ValueTask;
    flushAsync(cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
    getMemory(sizeHint?: int): Memory_1<System_Internal.Byte>;
    getSpan(sizeHint?: int): Span_1<System_Internal.Byte>;
    onReaderCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    writeAsync(source: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
}


export const PipeWriter: {
    create(stream: Stream, writerOptions?: StreamPipeWriterOptions): PipeWriter;
};


export interface __PipeWriter$views {
    As_IBufferWriter_1(): System_Buffers_Internal.IBufferWriter_1$instance<System_Internal.Byte>;
}

export interface PipeWriter$instance extends System_Buffers_Internal.IBufferWriter_1$instance<System_Internal.Byte> {}

export type PipeWriter = PipeWriter$instance & __PipeWriter$views;


export interface StreamPipeReaderOptions$instance {
    readonly bufferSize: int;
    readonly leaveOpen: boolean;
    readonly minimumReadSize: int;
    readonly pool: MemoryPool_1<System_Internal.Byte>;
    readonly useZeroByteReads: boolean;
}


export const StreamPipeReaderOptions: {
    new(pool: MemoryPool_1<System_Internal.Byte>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean): StreamPipeReaderOptions$instance;
    new(pool: MemoryPool_1<System_Internal.Byte>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean, useZeroByteReads: boolean): StreamPipeReaderOptions$instance;
};


export type StreamPipeReaderOptions = StreamPipeReaderOptions$instance;

export interface StreamPipeWriterOptions$instance {
    readonly leaveOpen: boolean;
    readonly minimumBufferSize: int;
    readonly pool: MemoryPool_1<System_Internal.Byte>;
}


export const StreamPipeWriterOptions: {
    new(pool: MemoryPool_1<System_Internal.Byte>, minimumBufferSize: int, leaveOpen: boolean): StreamPipeWriterOptions$instance;
};


export type StreamPipeWriterOptions = StreamPipeWriterOptions$instance;

export abstract class StreamPipeExtensions$instance {
    static copyToAsync(source: Stream, destination: PipeWriter, cancellationToken?: CancellationToken): Task;
}


export type StreamPipeExtensions = StreamPipeExtensions$instance;

