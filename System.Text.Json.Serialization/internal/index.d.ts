// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json.Serialization
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Text_Json_Serialization_Metadata_Internal from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { IJsonTypeInfoResolver, JsonTypeInfo } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonCommentHandling, JsonNamingPolicy, JsonSerializerDefaults, JsonSerializerOptions, Utf8JsonReader, Utf8JsonWriter } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Char, Enum, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum JsonIgnoreCondition {
    never_ = 0,
    always = 1,
    whenWritingDefault = 2,
    whenWritingNull = 3,
    whenWriting = 4,
    whenReading = 5
}


export enum JsonKnownNamingPolicy {
    unspecified = 0,
    camelCase = 1,
    snakeCaseLower = 2,
    snakeCaseUpper = 3,
    kebabCaseLower = 4,
    kebabCaseUpper = 5
}


export enum JsonKnownReferenceHandler {
    unspecified = 0,
    preserve = 1,
    ignoreCycles = 2
}


export enum JsonNumberHandling {
    strict = 0,
    allowReadingFromString = 1,
    writeAsString = 2,
    allowNamedFloatingPointLiterals = 4
}


export enum JsonObjectCreationHandling {
    replace = 0,
    populate = 1
}


export enum JsonSourceGenerationMode {
    default_ = 0,
    metadata = 1,
    serialization = 2
}


export enum JsonUnknownDerivedTypeHandling {
    failSerialization = 0,
    fallBackToBaseType = 1,
    fallBackToNearestAncestor = 2
}


export enum JsonUnknownTypeHandling {
    jsonElement = 0,
    jsonNode = 1
}


export enum JsonUnmappedMemberHandling {
    skip = 0,
    disallow = 1
}


export interface IJsonOnDeserialized$instance {
    OnDeserialized(): void;
}


export type IJsonOnDeserialized = IJsonOnDeserialized$instance;

export interface IJsonOnDeserializing$instance {
    OnDeserializing(): void;
}


export type IJsonOnDeserializing = IJsonOnDeserializing$instance;

export interface IJsonOnSerialized$instance {
    OnSerialized(): void;
}


export type IJsonOnSerialized = IJsonOnSerialized$instance;

export interface IJsonOnSerializing$instance {
    OnSerializing(): void;
}


export type IJsonOnSerializing = IJsonOnSerializing$instance;

export abstract class JsonAttribute$instance extends System_Internal.Attribute$instance {
}


export type JsonAttribute = JsonAttribute$instance;

export class JsonConstructorAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonConstructorAttribute = JsonConstructorAttribute$instance;

export abstract class JsonConverter$instance {
    readonly type_: Type;
    abstract canConvert(typeToConvert: Type): boolean;
}


export type JsonConverter = JsonConverter$instance;

export abstract class JsonConverter_1$instance<T> extends JsonConverter$instance {
    readonly handleNull: boolean;
    readonly type_: Type;
    canConvert(typeToConvert: Type): boolean;
    abstract read(reader: { value: ref<Utf8JsonReader> }, typeToConvert: Type, options: JsonSerializerOptions): T;
    readAsPropertyName(reader: { value: ref<Utf8JsonReader> }, typeToConvert: Type, options: JsonSerializerOptions): T;
    abstract write(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
    writeAsPropertyName(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
}


export type JsonConverter_1<T> = JsonConverter_1$instance<T>;

export class JsonConverterAttribute$instance extends JsonAttribute$instance {
    constructor(converterType: Type);
    readonly converterType: Type;
    createConverter(typeToConvert: Type): JsonConverter;
}


export type JsonConverterAttribute = JsonConverterAttribute$instance;

export abstract class JsonConverterFactory$instance extends JsonConverter$instance {
    readonly type_: Type;
    abstract createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonConverterFactory = JsonConverterFactory$instance;

export class JsonDerivedTypeAttribute$instance extends JsonAttribute$instance {
    constructor(derivedType: Type);
    constructor(derivedType: Type, typeDiscriminator: string);
    constructor(derivedType: Type, typeDiscriminator: int);
    readonly derivedType: Type;
    readonly typeDiscriminator: any;
}


export type JsonDerivedTypeAttribute = JsonDerivedTypeAttribute$instance;

export class JsonExtensionDataAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonExtensionDataAttribute = JsonExtensionDataAttribute$instance;

export class JsonIgnoreAttribute$instance extends JsonAttribute$instance {
    constructor();
    condition: JsonIgnoreCondition;
}


export type JsonIgnoreAttribute = JsonIgnoreAttribute$instance;

export class JsonIncludeAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonIncludeAttribute = JsonIncludeAttribute$instance;

export class JsonNumberEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory$instance {
    constructor();
    canConvert(typeToConvert: Type): boolean;
    createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonNumberEnumConverter_1<TEnum extends number> = JsonNumberEnumConverter_1$instance<TEnum>;

export class JsonNumberHandlingAttribute$instance extends JsonAttribute$instance {
    constructor(handling: JsonNumberHandling);
    readonly handling: JsonNumberHandling;
}


export type JsonNumberHandlingAttribute = JsonNumberHandlingAttribute$instance;

export class JsonObjectCreationHandlingAttribute$instance extends JsonAttribute$instance {
    constructor(handling: JsonObjectCreationHandling);
    readonly handling: JsonObjectCreationHandling;
}


export type JsonObjectCreationHandlingAttribute = JsonObjectCreationHandlingAttribute$instance;

export class JsonPolymorphicAttribute$instance extends JsonAttribute$instance {
    constructor();
    ignoreUnrecognizedTypeDiscriminators: boolean;
    typeDiscriminatorPropertyName: string;
    unknownDerivedTypeHandling: JsonUnknownDerivedTypeHandling;
}


export type JsonPolymorphicAttribute = JsonPolymorphicAttribute$instance;

export class JsonPropertyNameAttribute$instance extends JsonAttribute$instance {
    constructor(name: string);
    readonly name: string;
}


export type JsonPropertyNameAttribute = JsonPropertyNameAttribute$instance;

export class JsonPropertyOrderAttribute$instance extends JsonAttribute$instance {
    constructor(order: int);
    readonly order: int;
}


export type JsonPropertyOrderAttribute = JsonPropertyOrderAttribute$instance;

export class JsonRequiredAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonRequiredAttribute = JsonRequiredAttribute$instance;

export class JsonSerializableAttribute$instance extends JsonAttribute$instance {
    constructor(type_: Type);
    generationMode: JsonSourceGenerationMode;
    typeInfoPropertyName: string;
}


export type JsonSerializableAttribute = JsonSerializableAttribute$instance;

export abstract class JsonSerializerContext$instance {
    readonly options: JsonSerializerOptions;
    abstract getTypeInfo(type_: Type): JsonTypeInfo;
}


export interface __JsonSerializerContext$views {
    readonly As_IJsonTypeInfoResolver: System_Text_Json_Serialization_Metadata_Internal.IJsonTypeInfoResolver$instance;
}

export type JsonSerializerContext = JsonSerializerContext$instance & __JsonSerializerContext$views;


export class JsonSourceGenerationOptionsAttribute$instance extends JsonAttribute$instance {
    constructor();
    constructor(defaults: JsonSerializerDefaults);
    allowDuplicateProperties: boolean;
    allowOutOfOrderMetadataProperties: boolean;
    allowTrailingCommas: boolean;
    converters: Type[];
    defaultBufferSize: int;
    defaultIgnoreCondition: JsonIgnoreCondition;
    dictionaryKeyPolicy: JsonKnownNamingPolicy;
    generationMode: JsonSourceGenerationMode;
    ignoreReadOnlyFields: boolean;
    ignoreReadOnlyProperties: boolean;
    includeFields: boolean;
    indentCharacter: string;
    indentSize: int;
    maxDepth: int;
    newLine: string;
    numberHandling: JsonNumberHandling;
    preferredObjectCreationHandling: JsonObjectCreationHandling;
    propertyNameCaseInsensitive: boolean;
    propertyNamingPolicy: JsonKnownNamingPolicy;
    readCommentHandling: JsonCommentHandling;
    referenceHandler: JsonKnownReferenceHandler;
    respectNullableAnnotations: boolean;
    respectRequiredConstructorParameters: boolean;
    unknownTypeHandling: JsonUnknownTypeHandling;
    unmappedMemberHandling: JsonUnmappedMemberHandling;
    useStringEnumConverter: boolean;
    writeIndented: boolean;
}


export type JsonSourceGenerationOptionsAttribute = JsonSourceGenerationOptionsAttribute$instance;

export class JsonStringEnumConverter$instance extends JsonConverterFactory$instance {
    constructor();
    constructor(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean);
    canConvert(typeToConvert: Type): boolean;
    createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonStringEnumConverter = JsonStringEnumConverter$instance;

export class JsonStringEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory$instance {
    constructor();
    constructor(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean);
    canConvert(typeToConvert: Type): boolean;
    createConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonStringEnumConverter_1<TEnum extends number> = JsonStringEnumConverter_1$instance<TEnum>;

export class JsonStringEnumMemberNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly name: string;
}


export type JsonStringEnumMemberNameAttribute = JsonStringEnumMemberNameAttribute$instance;

export class JsonUnmappedMemberHandlingAttribute$instance extends JsonAttribute$instance {
    constructor(unmappedMemberHandling: JsonUnmappedMemberHandling);
    readonly unmappedMemberHandling: JsonUnmappedMemberHandling;
}


export type JsonUnmappedMemberHandlingAttribute = JsonUnmappedMemberHandlingAttribute$instance;

export abstract class ReferenceHandler$instance {
    abstract createResolver(): ReferenceResolver;
    static readonly Preserve: ReferenceHandler;
    static readonly IgnoreCycles: ReferenceHandler;
}


export type ReferenceHandler = ReferenceHandler$instance;

export class ReferenceHandler_1$instance<T extends ReferenceResolver> extends ReferenceHandler$instance {
    constructor();
    createResolver(): ReferenceResolver;
}


export type ReferenceHandler_1<T extends ReferenceResolver> = ReferenceHandler_1$instance<T>;

export abstract class ReferenceResolver$instance {
    abstract addReference(referenceId: string, value: any): void;
    abstract getReference(value: any, alreadyExists: { value: ref<boolean> }): string;
    abstract resolveReference(referenceId: string): any;
}


export type ReferenceResolver = ReferenceResolver$instance;

