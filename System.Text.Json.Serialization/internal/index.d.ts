// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json.Serialization
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Text_Json_Serialization_Metadata_Internal from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { IJsonTypeInfoResolver, JsonTypeInfo } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonCommentHandling, JsonNamingPolicy, JsonSerializerDefaults, JsonSerializerOptions, Utf8JsonReader, Utf8JsonWriter } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Char, Enum, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum JsonIgnoreCondition {
    Never = 0,
    Always = 1,
    WhenWritingDefault = 2,
    WhenWritingNull = 3,
    WhenWriting = 4,
    WhenReading = 5
}


export enum JsonKnownNamingPolicy {
    Unspecified = 0,
    CamelCase = 1,
    SnakeCaseLower = 2,
    SnakeCaseUpper = 3,
    KebabCaseLower = 4,
    KebabCaseUpper = 5
}


export enum JsonKnownReferenceHandler {
    Unspecified = 0,
    Preserve = 1,
    IgnoreCycles = 2
}


export enum JsonNumberHandling {
    Strict = 0,
    AllowReadingFromString = 1,
    WriteAsString = 2,
    AllowNamedFloatingPointLiterals = 4
}


export enum JsonObjectCreationHandling {
    Replace = 0,
    Populate = 1
}


export enum JsonSourceGenerationMode {
    Default = 0,
    Metadata = 1,
    Serialization = 2
}


export enum JsonUnknownDerivedTypeHandling {
    FailSerialization = 0,
    FallBackToBaseType = 1,
    FallBackToNearestAncestor = 2
}


export enum JsonUnknownTypeHandling {
    JsonElement = 0,
    JsonNode = 1
}


export enum JsonUnmappedMemberHandling {
    Skip = 0,
    Disallow = 1
}


export interface IJsonOnDeserialized$instance {
    OnDeserialized(): void;
}


export type IJsonOnDeserialized = IJsonOnDeserialized$instance;

export interface IJsonOnDeserializing$instance {
    OnDeserializing(): void;
}


export type IJsonOnDeserializing = IJsonOnDeserializing$instance;

export interface IJsonOnSerialized$instance {
    OnSerialized(): void;
}


export type IJsonOnSerialized = IJsonOnSerialized$instance;

export interface IJsonOnSerializing$instance {
    OnSerializing(): void;
}


export type IJsonOnSerializing = IJsonOnSerializing$instance;

export abstract class JsonAttribute$instance extends System_Internal.Attribute$instance {
}


export type JsonAttribute = JsonAttribute$instance;

export class JsonConstructorAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonConstructorAttribute = JsonConstructorAttribute$instance;

export abstract class JsonConverter$instance {
    readonly Type: Type;
    abstract CanConvert(typeToConvert: Type): boolean;
}


export type JsonConverter = JsonConverter$instance;

export abstract class JsonConverter_1$instance<T> extends JsonConverter$instance {
    readonly HandleNull: boolean;
    readonly Type: Type;
    CanConvert(typeToConvert: Type): boolean;
    abstract Read(reader: { value: ref<Utf8JsonReader> }, typeToConvert: Type, options: JsonSerializerOptions): T;
    ReadAsPropertyName(reader: { value: ref<Utf8JsonReader> }, typeToConvert: Type, options: JsonSerializerOptions): T;
    abstract Write(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
    WriteAsPropertyName(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
}


export type JsonConverter_1<T> = JsonConverter_1$instance<T>;

export class JsonConverterAttribute$instance extends JsonAttribute$instance {
    constructor(converterType: Type);
    readonly ConverterType: Type;
    CreateConverter(typeToConvert: Type): JsonConverter;
}


export type JsonConverterAttribute = JsonConverterAttribute$instance;

export abstract class JsonConverterFactory$instance extends JsonConverter$instance {
    readonly Type: Type;
    abstract CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonConverterFactory = JsonConverterFactory$instance;

export class JsonDerivedTypeAttribute$instance extends JsonAttribute$instance {
    constructor(derivedType: Type);
    constructor(derivedType: Type, typeDiscriminator: string);
    constructor(derivedType: Type, typeDiscriminator: int);
    readonly DerivedType: Type;
    readonly TypeDiscriminator: unknown;
}


export type JsonDerivedTypeAttribute = JsonDerivedTypeAttribute$instance;

export class JsonExtensionDataAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonExtensionDataAttribute = JsonExtensionDataAttribute$instance;

export class JsonIgnoreAttribute$instance extends JsonAttribute$instance {
    constructor();
    Condition: JsonIgnoreCondition;
}


export type JsonIgnoreAttribute = JsonIgnoreAttribute$instance;

export class JsonIncludeAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonIncludeAttribute = JsonIncludeAttribute$instance;

export class JsonNumberEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory$instance {
    constructor();
    CanConvert(typeToConvert: Type): boolean;
    CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonNumberEnumConverter_1<TEnum extends number> = JsonNumberEnumConverter_1$instance<TEnum>;

export class JsonNumberHandlingAttribute$instance extends JsonAttribute$instance {
    constructor(handling: JsonNumberHandling);
    readonly Handling: JsonNumberHandling;
}


export type JsonNumberHandlingAttribute = JsonNumberHandlingAttribute$instance;

export class JsonObjectCreationHandlingAttribute$instance extends JsonAttribute$instance {
    constructor(handling: JsonObjectCreationHandling);
    readonly Handling: JsonObjectCreationHandling;
}


export type JsonObjectCreationHandlingAttribute = JsonObjectCreationHandlingAttribute$instance;

export class JsonPolymorphicAttribute$instance extends JsonAttribute$instance {
    constructor();
    IgnoreUnrecognizedTypeDiscriminators: boolean;
    TypeDiscriminatorPropertyName: string;
    UnknownDerivedTypeHandling: JsonUnknownDerivedTypeHandling;
}


export type JsonPolymorphicAttribute = JsonPolymorphicAttribute$instance;

export class JsonPropertyNameAttribute$instance extends JsonAttribute$instance {
    constructor(name: string);
    readonly Name: string;
}


export type JsonPropertyNameAttribute = JsonPropertyNameAttribute$instance;

export class JsonPropertyOrderAttribute$instance extends JsonAttribute$instance {
    constructor(order: int);
    readonly Order: int;
}


export type JsonPropertyOrderAttribute = JsonPropertyOrderAttribute$instance;

export class JsonRequiredAttribute$instance extends JsonAttribute$instance {
    constructor();
}


export type JsonRequiredAttribute = JsonRequiredAttribute$instance;

export class JsonSerializableAttribute$instance extends JsonAttribute$instance {
    constructor(type_: Type);
    GenerationMode: JsonSourceGenerationMode;
    TypeInfoPropertyName: string;
}


export type JsonSerializableAttribute = JsonSerializableAttribute$instance;

export abstract class JsonSerializerContext$instance {
    readonly Options: JsonSerializerOptions;
    abstract GetTypeInfo(type_: Type): JsonTypeInfo;
}


export interface __JsonSerializerContext$views {
    As_IJsonTypeInfoResolver(): System_Text_Json_Serialization_Metadata_Internal.IJsonTypeInfoResolver$instance;
}

export type JsonSerializerContext = JsonSerializerContext$instance & __JsonSerializerContext$views;


export class JsonSourceGenerationOptionsAttribute$instance extends JsonAttribute$instance {
    constructor();
    constructor(defaults: JsonSerializerDefaults);
    AllowDuplicateProperties: boolean;
    AllowOutOfOrderMetadataProperties: boolean;
    AllowTrailingCommas: boolean;
    Converters: Type[];
    DefaultBufferSize: int;
    DefaultIgnoreCondition: JsonIgnoreCondition;
    DictionaryKeyPolicy: JsonKnownNamingPolicy;
    GenerationMode: JsonSourceGenerationMode;
    IgnoreReadOnlyFields: boolean;
    IgnoreReadOnlyProperties: boolean;
    IncludeFields: boolean;
    IndentCharacter: char;
    IndentSize: int;
    MaxDepth: int;
    NewLine: string;
    NumberHandling: JsonNumberHandling;
    PreferredObjectCreationHandling: JsonObjectCreationHandling;
    PropertyNameCaseInsensitive: boolean;
    PropertyNamingPolicy: JsonKnownNamingPolicy;
    ReadCommentHandling: JsonCommentHandling;
    ReferenceHandler: JsonKnownReferenceHandler;
    RespectNullableAnnotations: boolean;
    RespectRequiredConstructorParameters: boolean;
    UnknownTypeHandling: JsonUnknownTypeHandling;
    UnmappedMemberHandling: JsonUnmappedMemberHandling;
    UseStringEnumConverter: boolean;
    WriteIndented: boolean;
}


export type JsonSourceGenerationOptionsAttribute = JsonSourceGenerationOptionsAttribute$instance;

export class JsonStringEnumConverter$instance extends JsonConverterFactory$instance {
    constructor();
    constructor(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean);
    CanConvert(typeToConvert: Type): boolean;
    CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonStringEnumConverter = JsonStringEnumConverter$instance;

export class JsonStringEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory$instance {
    constructor();
    constructor(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean);
    CanConvert(typeToConvert: Type): boolean;
    CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export type JsonStringEnumConverter_1<TEnum extends number> = JsonStringEnumConverter_1$instance<TEnum>;

export class JsonStringEnumMemberNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly Name: string;
}


export type JsonStringEnumMemberNameAttribute = JsonStringEnumMemberNameAttribute$instance;

export class JsonUnmappedMemberHandlingAttribute$instance extends JsonAttribute$instance {
    constructor(unmappedMemberHandling: JsonUnmappedMemberHandling);
    readonly UnmappedMemberHandling: JsonUnmappedMemberHandling;
}


export type JsonUnmappedMemberHandlingAttribute = JsonUnmappedMemberHandlingAttribute$instance;

export abstract class ReferenceHandler$instance {
    abstract CreateResolver(): ReferenceResolver;
    static readonly Preserve: ReferenceHandler;
    static readonly IgnoreCycles: ReferenceHandler;
}


export type ReferenceHandler = ReferenceHandler$instance;

export class ReferenceHandler_1$instance<T extends ReferenceResolver> extends ReferenceHandler$instance {
    constructor();
    CreateResolver(): ReferenceResolver;
}


export type ReferenceHandler_1<T extends ReferenceResolver> = ReferenceHandler_1$instance<T>;

export abstract class ReferenceResolver$instance {
    abstract AddReference(referenceId: string, value: unknown): void;
    abstract GetReference(value: unknown, alreadyExists: { value: ref<boolean> }): string;
    abstract ResolveReference(referenceId: string): unknown;
}


export type ReferenceResolver = ReferenceResolver$instance;

