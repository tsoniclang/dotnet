// Generated by tsbindgen - Architecture
// Namespace: System.Collections
// Assembly: System.Collections, System.Collections.NonGeneric, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, ICloneable, Int32, Object as ClrObject, Single, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface ICollection$instance {
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
}


export type ICollection = ICollection$instance;

export interface IComparer$instance {
    Compare(x: any, y: any): int;
}


export type IComparer = IComparer$instance;

export interface IDictionary$instance {
    Item: any;
    readonly Keys: ICollection;
    readonly Values: ICollection;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(key: any, value: any): void;
    Clear(): void;
    Contains(key: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IDictionaryEnumerator;
    GetEnumerator(): IEnumerator;
    Remove(key: any): void;
}


export type IDictionary = IDictionary$instance;

export interface IDictionaryEnumerator$instance {
    readonly Key: any;
    readonly Value: any;
    readonly Entry: DictionaryEntry;
    readonly Current: any;
    MoveNext(): boolean;
    Reset(): void;
}


export type IDictionaryEnumerator = IDictionaryEnumerator$instance;

export interface IEnumerable$instance {
    GetEnumerator(): IEnumerator;
}


export type IEnumerable = IEnumerable$instance;

export interface IEnumerator$instance {
    readonly Current: any;
    MoveNext(): boolean;
    Reset(): void;
}


export type IEnumerator = IEnumerator$instance;

export interface IEqualityComparer$instance {
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
}


export type IEqualityComparer = IEqualityComparer$instance;

export interface IHashCodeProvider$instance {
    GetHashCode(obj: any): int;
}


export type IHashCodeProvider = IHashCodeProvider$instance;

export interface IList$instance {
    Item: any;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(value: any): int;
    Clear(): void;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    Insert(index: int, value: any): void;
    Remove(value: any): void;
    RemoveAt(index: int): void;
}


export type IList = IList$instance;

export interface IStructuralComparable$instance {
    CompareTo(other: any, comparer: IComparer): int;
}


export type IStructuralComparable = IStructuralComparable$instance;

export interface IStructuralEquatable$instance {
    Equals(other: any, comparer: IEqualityComparer): boolean;
    GetHashCode(comparer: IEqualityComparer): int;
}


export type IStructuralEquatable = IStructuralEquatable$instance;

export class DictionaryEntry$instance {
    constructor(key: any, value: any);
    Key: any;
    Value: any;
    Deconstruct(key: { value: TSByRef<any> }, value: { value: TSByRef<any> }): void;
    ToString(): string;
}


export type DictionaryEntry = DictionaryEntry$instance;

export class ArrayList$instance {
    constructor();
    constructor(capacity: int);
    constructor(c: ICollection);
    Capacity: int;
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Item: any;
    readonly SyncRoot: any;
    Add(value: any): int;
    AddRange(c: ICollection): void;
    BinarySearch(index: int, count: int, value: any, comparer: IComparer): int;
    BinarySearch(value: any): int;
    BinarySearch(value: any, comparer: IComparer): int;
    Clear(): void;
    Clone(): any;
    Contains(item: any): boolean;
    CopyTo(array: ClrArray): void;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(index: int, array: ClrArray, arrayIndex: int, count: int): void;
    GetEnumerator(): IEnumerator;
    GetEnumerator(index: int, count: int): IEnumerator;
    GetRange(index: int, count: int): ArrayList;
    IndexOf(value: any): int;
    IndexOf(value: any, startIndex: int): int;
    IndexOf(value: any, startIndex: int, count: int): int;
    Insert(index: int, value: any): void;
    InsertRange(index: int, c: ICollection): void;
    LastIndexOf(value: any): int;
    LastIndexOf(value: any, startIndex: int): int;
    LastIndexOf(value: any, startIndex: int, count: int): int;
    Remove(obj: any): void;
    RemoveAt(index: int): void;
    RemoveRange(index: int, count: int): void;
    Reverse(): void;
    Reverse(index: int, count: int): void;
    SetRange(index: int, c: ICollection): void;
    Sort(): void;
    Sort(comparer: IComparer): void;
    Sort(index: int, count: int, comparer: IComparer): void;
    ToArray(): any[];
    ToArray(type_: Type): ClrArray;
    TrimToSize(): void;
    static Adapter(list: IList): ArrayList;
    static FixedSize(list: ArrayList): ArrayList;
    static FixedSize(list: IList): IList;
    static ReadOnly(list: ArrayList): ArrayList;
    static ReadOnly(list: IList): IList;
    static Repeat(value: any, count: int): ArrayList;
    static Synchronized(list: ArrayList): ArrayList;
    static Synchronized(list: IList): IList;
}


export interface __ArrayList$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_IList: IList$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ArrayList = ArrayList$instance & __ArrayList$views;


export class BitArray$instance {
    constructor(length: int);
    constructor(length: int, defaultValue: boolean);
    constructor(bytes: byte[]);
    constructor(values: boolean[]);
    constructor(values: int[]);
    constructor(bits: BitArray);
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Item: boolean;
    Length: int;
    readonly SyncRoot: any;
    And(value: BitArray): BitArray;
    Clone(): any;
    CopyTo(array: ClrArray, index: int): void;
    Get(index: int): boolean;
    GetEnumerator(): IEnumerator;
    HasAllSet(): boolean;
    HasAnySet(): boolean;
    LeftShift(count: int): BitArray;
    Not(): BitArray;
    Or(value: BitArray): BitArray;
    RightShift(count: int): BitArray;
    Set(index: int, value: boolean): void;
    SetAll(value: boolean): void;
    Xor(value: BitArray): BitArray;
}


export interface __BitArray$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BitArray = BitArray$instance & __BitArray$views;


export class CaseInsensitiveComparer$instance {
    constructor();
    constructor(culture: CultureInfo);
    Compare(a: any, b: any): int;
    static readonly Default: CaseInsensitiveComparer;
    static readonly DefaultInvariant: CaseInsensitiveComparer;
}


export interface __CaseInsensitiveComparer$views {
    readonly As_IComparer: IComparer$instance;
}

export type CaseInsensitiveComparer = CaseInsensitiveComparer$instance & __CaseInsensitiveComparer$views;


export class CaseInsensitiveHashCodeProvider$instance {
    constructor();
    constructor(culture: CultureInfo);
    GetHashCode(obj: any): int;
    static readonly Default: CaseInsensitiveHashCodeProvider;
    static readonly DefaultInvariant: CaseInsensitiveHashCodeProvider;
}


export interface __CaseInsensitiveHashCodeProvider$views {
    readonly As_IHashCodeProvider: IHashCodeProvider$instance;
}

export type CaseInsensitiveHashCodeProvider = CaseInsensitiveHashCodeProvider$instance & __CaseInsensitiveHashCodeProvider$views;


export abstract class CollectionBase$instance {
    Capacity: int;
    readonly Count: int;
    Clear(): void;
    GetEnumerator(): IEnumerator;
    RemoveAt(index: int): void;
}


export interface __CollectionBase$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_IList: IList$instance;
}

export type CollectionBase = CollectionBase$instance & __CollectionBase$views;


export class Comparer$instance {
    constructor(culture: CultureInfo);
    Compare(a: any, b: any): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    static readonly Default: Comparer;
    static readonly DefaultInvariant: Comparer;
}


export interface __Comparer$views {
    readonly As_IComparer: IComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Comparer = Comparer$instance & __Comparer$views;


export abstract class DictionaryBase$instance {
    readonly Count: int;
    Clear(): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IDictionaryEnumerator;
}


export interface __DictionaryBase$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
}

export type DictionaryBase = DictionaryBase$instance & __DictionaryBase$views;


export class Hashtable$instance {
    constructor();
    constructor(capacity: int);
    constructor(capacity: int, loadFactor: float);
    constructor(capacity: int, loadFactor: float, equalityComparer: IEqualityComparer);
    constructor(hcp: IHashCodeProvider, comparer: IComparer);
    constructor(equalityComparer: IEqualityComparer);
    constructor(capacity: int, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(capacity: int, equalityComparer: IEqualityComparer);
    constructor(d: IDictionary);
    constructor(d: IDictionary, loadFactor: float);
    constructor(d: IDictionary, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(d: IDictionary, equalityComparer: IEqualityComparer);
    constructor(capacity: int, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(d: IDictionary, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(d: IDictionary, loadFactor: float, equalityComparer: IEqualityComparer);
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Item: any;
    readonly Keys: ICollection;
    readonly SyncRoot: any;
    readonly Values: ICollection;
    Add(key: any, value: any): void;
    Clear(): void;
    Clone(): any;
    Contains(key: any): boolean;
    ContainsKey(key: any): boolean;
    ContainsValue(value: any): boolean;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    GetEnumerator(): IDictionaryEnumerator;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    OnDeserialization(sender: any): void;
    Remove(key: any): void;
    static Synchronized(table: Hashtable): Hashtable;
}


export interface __Hashtable$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Hashtable = Hashtable$instance & __Hashtable$views;


export class ListDictionaryInternal$instance {
    constructor();
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Item: any;
    readonly Keys: ICollection;
    readonly SyncRoot: any;
    readonly Values: ICollection;
    Add(key: any, value: any): void;
    Clear(): void;
    Contains(key: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IDictionaryEnumerator;
    Remove(key: any): void;
}


export interface __ListDictionaryInternal$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
}

export type ListDictionaryInternal = ListDictionaryInternal$instance & __ListDictionaryInternal$views;


export class Queue$instance {
    constructor();
    constructor(capacity: int);
    constructor(capacity: int, growFactor: float);
    constructor(col: ICollection);
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: any;
    Clear(): void;
    Clone(): any;
    Contains(obj: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Dequeue(): any;
    Enqueue(obj: any): void;
    GetEnumerator(): IEnumerator;
    Peek(): any;
    ToArray(): any[];
    TrimToSize(): void;
    static Synchronized(queue: Queue): Queue;
}


export interface __Queue$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type Queue = Queue$instance & __Queue$views;


export abstract class ReadOnlyCollectionBase$instance {
    readonly Count: int;
    GetEnumerator(): IEnumerator;
}


export interface __ReadOnlyCollectionBase$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
}

export type ReadOnlyCollectionBase = ReadOnlyCollectionBase$instance & __ReadOnlyCollectionBase$views;


export class SortedList$instance {
    constructor();
    constructor(initialCapacity: int);
    constructor(comparer: IComparer);
    constructor(comparer: IComparer, capacity: int);
    constructor(d: IDictionary);
    constructor(d: IDictionary, comparer: IComparer);
    Capacity: int;
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Item: any;
    readonly Keys: ICollection;
    readonly SyncRoot: any;
    readonly Values: ICollection;
    Add(key: any, value: any): void;
    Clear(): void;
    Clone(): any;
    Contains(key: any): boolean;
    ContainsKey(key: any): boolean;
    ContainsValue(value: any): boolean;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    GetByIndex(index: int): any;
    GetEnumerator(): IDictionaryEnumerator;
    GetKey(index: int): any;
    GetKeyList(): IList;
    GetValueList(): IList;
    IndexOfKey(key: any): int;
    IndexOfValue(value: any): int;
    Remove(key: any): void;
    RemoveAt(index: int): void;
    SetByIndex(index: int, value: any): void;
    TrimToSize(): void;
    static Synchronized(list: SortedList): SortedList;
}


export interface __SortedList$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type SortedList = SortedList$instance & __SortedList$views;


export class Stack$instance {
    constructor();
    constructor(initialCapacity: int);
    constructor(col: ICollection);
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: any;
    Clear(): void;
    Clone(): any;
    Contains(obj: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    Peek(): any;
    Pop(): any;
    Push(obj: any): void;
    ToArray(): any[];
    static Synchronized(stack: Stack): Stack;
}


export interface __Stack$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type Stack = Stack$instance & __Stack$views;


export abstract class StructuralComparisons$instance {
    static readonly StructuralComparer: IComparer;
    static readonly StructuralEqualityComparer: IEqualityComparer;
}


export type StructuralComparisons = StructuralComparisons$instance;

