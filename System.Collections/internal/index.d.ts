// Generated by tsbindgen - Architecture
// Namespace: System.Collections
// Assembly: System.Collections, System.Private.CoreLib, System.Collections.NonGeneric

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, ICloneable, Int32, Object as ClrObject, Single, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface ICollection$instance {
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
}


export type ICollection = ICollection$instance;

export interface IComparer$instance {
    Compare(x: any, y: any): int;
}


export type IComparer = IComparer$instance;

export interface IDictionary$instance {
    Item: any;
    readonly Keys: ICollection;
    readonly Values: ICollection;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(key: any, value: any): void;
    Clear(): void;
    Contains(key: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IDictionaryEnumerator;
    GetEnumerator(): IEnumerator;
    Remove(key: any): void;
}


export type IDictionary = IDictionary$instance;

export interface IDictionaryEnumerator$instance {
    readonly Key: any;
    readonly Value: any;
    readonly Entry: DictionaryEntry;
    readonly Current: any;
    MoveNext(): boolean;
    Reset(): void;
}


export type IDictionaryEnumerator = IDictionaryEnumerator$instance;

export interface IEnumerable$instance {
    GetEnumerator(): IEnumerator;
}


export type IEnumerable = IEnumerable$instance;

export interface IEnumerator$instance {
    readonly Current: any;
    MoveNext(): boolean;
    Reset(): void;
}


export type IEnumerator = IEnumerator$instance;

export interface IEqualityComparer$instance {
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
}


export type IEqualityComparer = IEqualityComparer$instance;

export interface IHashCodeProvider$instance {
    GetHashCode(obj: any): int;
}


export type IHashCodeProvider = IHashCodeProvider$instance;

export interface IList$instance {
    Item: any;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(value: any): int;
    Clear(): void;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    Insert(index: int, value: any): void;
    Remove(value: any): void;
    RemoveAt(index: int): void;
}


export type IList = IList$instance;

export interface IStructuralComparable$instance {
    CompareTo(other: any, comparer: IComparer): int;
}


export type IStructuralComparable = IStructuralComparable$instance;

export interface IStructuralEquatable$instance {
    Equals(other: any, comparer: IEqualityComparer): boolean;
    GetHashCode(comparer: IEqualityComparer): int;
}


export type IStructuralEquatable = IStructuralEquatable$instance;

export class DictionaryEntry$instance {
    constructor(key: any, value: any);
    key: any;
    value: any;
    deconstruct(key: { value: TSByRef<any> }, value: { value: TSByRef<any> }): void;
    toString(): string;
}


export type DictionaryEntry = DictionaryEntry$instance;

export class ArrayList$instance {
    constructor();
    constructor(capacity: int);
    constructor(c: ICollection);
    capacity: int;
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: any;
    readonly syncRoot: any;
    add(value: any): int;
    addRange(c: ICollection): void;
    binarySearch(index: int, count: int, value: any, comparer: IComparer): int;
    binarySearch(value: any): int;
    binarySearch(value: any, comparer: IComparer): int;
    clear(): void;
    clone(): any;
    contains(item: any): boolean;
    copyTo(array: ClrArray): void;
    copyTo(array: ClrArray, arrayIndex: int): void;
    copyTo(index: int, array: ClrArray, arrayIndex: int, count: int): void;
    getEnumerator(): IEnumerator;
    getEnumerator(index: int, count: int): IEnumerator;
    getRange(index: int, count: int): ArrayList;
    indexOf(value: any): int;
    indexOf(value: any, startIndex: int): int;
    indexOf(value: any, startIndex: int, count: int): int;
    insert(index: int, value: any): void;
    insertRange(index: int, c: ICollection): void;
    lastIndexOf(value: any): int;
    lastIndexOf(value: any, startIndex: int): int;
    lastIndexOf(value: any, startIndex: int, count: int): int;
    remove(obj: any): void;
    removeAt(index: int): void;
    removeRange(index: int, count: int): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    setRange(index: int, c: ICollection): void;
    sort(): void;
    sort(comparer: IComparer): void;
    sort(index: int, count: int, comparer: IComparer): void;
    toArray(): any[];
    toArray(type_: Type): ClrArray;
    trimToSize(): void;
    static Adapter(list: IList): ArrayList;
    static FixedSize(list: ArrayList): ArrayList;
    static FixedSize(list: IList): IList;
    static ReadOnly(list: ArrayList): ArrayList;
    static ReadOnly(list: IList): IList;
    static Repeat(value: any, count: int): ArrayList;
    static Synchronized(list: ArrayList): ArrayList;
    static Synchronized(list: IList): IList;
}


export interface __ArrayList$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_IList: IList$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ArrayList = ArrayList$instance & __ArrayList$views;


export class BitArray$instance {
    constructor(length: int);
    constructor(length: int, defaultValue: boolean);
    constructor(bytes: byte[]);
    constructor(values: boolean[]);
    constructor(values: int[]);
    constructor(bits: BitArray);
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: boolean;
    length: int;
    readonly syncRoot: any;
    and(value: BitArray): BitArray;
    clone(): any;
    copyTo(array: ClrArray, index: int): void;
    get_(index: int): boolean;
    getEnumerator(): IEnumerator;
    hasAllSet(): boolean;
    hasAnySet(): boolean;
    leftShift(count: int): BitArray;
    not(): BitArray;
    or(value: BitArray): BitArray;
    rightShift(count: int): BitArray;
    set_(index: int, value: boolean): void;
    setAll(value: boolean): void;
    xor(value: BitArray): BitArray;
}


export interface __BitArray$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BitArray = BitArray$instance & __BitArray$views;


export class CaseInsensitiveComparer$instance {
    constructor();
    constructor(culture: CultureInfo);
    compare(a: any, b: any): int;
    static readonly Default: CaseInsensitiveComparer;
    static readonly DefaultInvariant: CaseInsensitiveComparer;
}


export interface __CaseInsensitiveComparer$views {
    readonly As_IComparer: IComparer$instance;
}

export type CaseInsensitiveComparer = CaseInsensitiveComparer$instance & __CaseInsensitiveComparer$views;


export class CaseInsensitiveHashCodeProvider$instance {
    constructor();
    constructor(culture: CultureInfo);
    getHashCode(obj: any): int;
    static readonly Default: CaseInsensitiveHashCodeProvider;
    static readonly DefaultInvariant: CaseInsensitiveHashCodeProvider;
}


export interface __CaseInsensitiveHashCodeProvider$views {
    readonly As_IHashCodeProvider: IHashCodeProvider$instance;
}

export type CaseInsensitiveHashCodeProvider = CaseInsensitiveHashCodeProvider$instance & __CaseInsensitiveHashCodeProvider$views;


export abstract class CollectionBase$instance {
    capacity: int;
    readonly count: int;
    clear(): void;
    getEnumerator(): IEnumerator;
    removeAt(index: int): void;
}


export interface __CollectionBase$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_IList: IList$instance;
}

export type CollectionBase = CollectionBase$instance & __CollectionBase$views;


export class Comparer$instance {
    constructor(culture: CultureInfo);
    compare(a: any, b: any): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static readonly default_: Comparer;
    static readonly defaultInvariant: Comparer;
}


export interface __Comparer$views {
    readonly As_IComparer: IComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Comparer = Comparer$instance & __Comparer$views;


export abstract class DictionaryBase$instance {
    readonly count: int;
    clear(): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IDictionaryEnumerator;
}


export interface __DictionaryBase$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
}

export type DictionaryBase = DictionaryBase$instance & __DictionaryBase$views;


export class Hashtable$instance {
    constructor();
    constructor(capacity: int);
    constructor(capacity: int, loadFactor: float);
    constructor(capacity: int, loadFactor: float, equalityComparer: IEqualityComparer);
    constructor(hcp: IHashCodeProvider, comparer: IComparer);
    constructor(equalityComparer: IEqualityComparer);
    constructor(capacity: int, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(capacity: int, equalityComparer: IEqualityComparer);
    constructor(d: IDictionary);
    constructor(d: IDictionary, loadFactor: float);
    constructor(d: IDictionary, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(d: IDictionary, equalityComparer: IEqualityComparer);
    constructor(capacity: int, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(d: IDictionary, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer);
    constructor(d: IDictionary, loadFactor: float, equalityComparer: IEqualityComparer);
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: any;
    readonly keys: ICollection;
    readonly syncRoot: any;
    readonly values: ICollection;
    add(key: any, value: any): void;
    clear(): void;
    clone(): any;
    contains(key: any): boolean;
    containsKey(key: any): boolean;
    containsValue(value: any): boolean;
    copyTo(array: ClrArray, arrayIndex: int): void;
    getEnumerator(): IDictionaryEnumerator;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: any): void;
    remove(key: any): void;
    static Synchronized(table: Hashtable): Hashtable;
}


export interface __Hashtable$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Hashtable = Hashtable$instance & __Hashtable$views;


export class ListDictionaryInternal$instance {
    constructor();
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: any;
    readonly keys: ICollection;
    readonly syncRoot: any;
    readonly values: ICollection;
    add(key: any, value: any): void;
    clear(): void;
    contains(key: any): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IDictionaryEnumerator;
    remove(key: any): void;
}


export interface __ListDictionaryInternal$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
}

export type ListDictionaryInternal = ListDictionaryInternal$instance & __ListDictionaryInternal$views;


export class Queue$instance {
    constructor();
    constructor(capacity: int);
    constructor(capacity: int, growFactor: float);
    constructor(col: ICollection);
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: any;
    clear(): void;
    clone(): any;
    contains(obj: any): boolean;
    copyTo(array: ClrArray, index: int): void;
    dequeue(): any;
    enqueue(obj: any): void;
    getEnumerator(): IEnumerator;
    peek(): any;
    toArray(): any[];
    trimToSize(): void;
    static Synchronized(queue: Queue): Queue;
}


export interface __Queue$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type Queue = Queue$instance & __Queue$views;


export abstract class ReadOnlyCollectionBase$instance {
    readonly count: int;
    getEnumerator(): IEnumerator;
}


export interface __ReadOnlyCollectionBase$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
}

export type ReadOnlyCollectionBase = ReadOnlyCollectionBase$instance & __ReadOnlyCollectionBase$views;


export class SortedList$instance {
    constructor();
    constructor(initialCapacity: int);
    constructor(comparer: IComparer);
    constructor(comparer: IComparer, capacity: int);
    constructor(d: IDictionary);
    constructor(d: IDictionary, comparer: IComparer);
    capacity: int;
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    item: any;
    readonly keys: ICollection;
    readonly syncRoot: any;
    readonly values: ICollection;
    add(key: any, value: any): void;
    clear(): void;
    clone(): any;
    contains(key: any): boolean;
    containsKey(key: any): boolean;
    containsValue(value: any): boolean;
    copyTo(array: ClrArray, arrayIndex: int): void;
    getByIndex(index: int): any;
    getEnumerator(): IDictionaryEnumerator;
    getKey(index: int): any;
    getKeyList(): IList;
    getValueList(): IList;
    indexOfKey(key: any): int;
    indexOfValue(value: any): int;
    remove(key: any): void;
    removeAt(index: int): void;
    setByIndex(index: int, value: any): void;
    trimToSize(): void;
    static Synchronized(list: SortedList): SortedList;
}


export interface __SortedList$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IDictionary: IDictionary$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type SortedList = SortedList$instance & __SortedList$views;


export class Stack$instance {
    constructor();
    constructor(initialCapacity: int);
    constructor(col: ICollection);
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: any;
    clear(): void;
    clone(): any;
    contains(obj: any): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    peek(): any;
    pop(): any;
    push(obj: any): void;
    toArray(): any[];
    static Synchronized(stack: Stack): Stack;
}


export interface __Stack$views {
    readonly As_ICollection: ICollection$instance;
    readonly As_IEnumerable: IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type Stack = Stack$instance & __Stack$views;


export abstract class StructuralComparisons$instance {
    static readonly StructuralComparer: IComparer;
    static readonly StructuralEqualityComparer: IEqualityComparer;
}


export type StructuralComparisons = StructuralComparisons$instance;

