// Generated by tsbindgen - Architecture
// Namespace: System.Data
// Assembly: System.Data.Common

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEnumerable_1, IEnumerator_1, IEqualityComparer_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { Hashtable, ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AttributeCollection, CollectionChangeEventHandler, DescriptionAttribute, EventDescriptor, EventDescriptorCollection, IBindingList, IBindingListView, IComponent, IContainer, ICustomTypeDescriptor, IDataErrorInfo, IEditableObject, IListSource, INotifyPropertyChanged, ISite, ISupportInitialize, ISupportInitializeNotification, ITypedList, ListChangedEventHandler, ListSortDescriptionCollection, ListSortDirection, MarshalByValueComponent, PropertyChangedEventHandler, PropertyDescriptor, PropertyDescriptorCollection, TypeConverter } from "../../System.ComponentModel/internal/index.js";
import * as System_Data_Common_Internal from "../../System.Data.Common/internal/index.js";
import type { DbColumn, DbDataReader } from "../../System.Data.Common/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { XmlSchema, XmlSchemaComplexType, XmlSchemaSet } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import type { XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Converter_2, DateTime, Decimal, Delegate, Double, Enum, EventArgs, EventHandler, Exception, Func_2, Guid, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IServiceProvider, ISpanFormattable, MulticastDelegate, Nullable_1, Object as ClrObject, Single, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AcceptRejectRule {
    none = 0,
    cascade = 1
}


export enum CommandBehavior {
    default_ = 0,
    singleResult = 1,
    schemaOnly = 2,
    keyInfo = 4,
    singleRow = 8,
    sequentialAccess = 16,
    closeConnection = 32
}


export enum CommandType {
    text = 1,
    storedProcedure = 4,
    tableDirect = 512
}


export enum ConflictOption {
    compareAllSearchableValues = 1,
    compareRowVersion = 2,
    overwriteChanges = 3
}


export enum ConnectionState {
    closed = 0,
    open = 1,
    connecting = 2,
    executing = 4,
    fetching = 8,
    broken = 16
}


export enum DataRowAction {
    nothing = 0,
    delete_ = 1,
    change = 2,
    rollback = 4,
    commit = 8,
    add = 16,
    changeOriginal = 32,
    changeCurrentAndOriginal = 64
}


export enum DataRowState {
    detached = 1,
    unchanged = 2,
    added = 4,
    deleted = 8,
    modified = 16
}


export enum DataRowVersion {
    original = 256,
    current = 512,
    proposed = 1024,
    default_ = 1536
}


export enum DataSetDateTime {
    local = 1,
    unspecified = 2,
    unspecifiedLocal = 3,
    utc = 4
}


export enum DataViewRowState {
    none = 0,
    unchanged = 2,
    added = 4,
    deleted = 8,
    modifiedCurrent = 16,
    modifiedOriginal = 32,
    originalRows = 42,
    currentRows = 22
}


export enum DbType {
    ansiString = 0,
    binary = 1,
    byte = 2,
    boolean_ = 3,
    currency = 4,
    date = 5,
    dateTime = 6,
    decimal = 7,
    double = 8,
    guid = 9,
    int16 = 10,
    int32 = 11,
    int64 = 12,
    object_ = 13,
    sByte = 14,
    single = 15,
    string_ = 16,
    time = 17,
    uInt16 = 18,
    uInt32 = 19,
    uInt64 = 20,
    varNumeric = 21,
    ansiStringFixedLength = 22,
    stringFixedLength = 23,
    xml = 25,
    dateTime2 = 26,
    dateTimeOffset = 27
}


export enum IsolationLevel {
    unspecified = -1,
    chaos = 16,
    readUncommitted = 256,
    readCommitted = 4096,
    repeatableRead = 65536,
    serializable = 1048576,
    snapshot = 16777216
}


export enum KeyRestrictionBehavior {
    allowOnly = 0,
    preventUsage = 1
}


export enum LoadOption {
    overwriteChanges = 1,
    preserveChanges = 2,
    upsert = 3
}


export enum MappingType {
    element = 1,
    attribute = 2,
    simpleContent = 3,
    hidden = 4
}


export enum MissingMappingAction {
    passthrough = 1,
    ignore = 2,
    error = 3
}


export enum MissingSchemaAction {
    add = 1,
    ignore = 2,
    error = 3,
    addWithKey = 4
}


export enum ParameterDirection {
    input = 1,
    output = 2,
    inputOutput = 3,
    returnValue = 6
}


export enum Rule {
    none = 0,
    cascade = 1,
    setNull = 2,
    setDefault = 3
}


export enum SchemaSerializationMode {
    includeSchema = 1,
    excludeSchema = 2
}


export enum SchemaType {
    source = 1,
    mapped = 2
}


export enum SerializationFormat {
    xml = 0,
    binary = 1
}


export enum SqlDbType {
    bigInt = 0,
    binary = 1,
    bit = 2,
    char = 3,
    dateTime = 4,
    decimal = 5,
    float = 6,
    image = 7,
    int = 8,
    money = 9,
    nChar = 10,
    nText = 11,
    nVarChar = 12,
    real = 13,
    uniqueIdentifier = 14,
    smallDateTime = 15,
    smallInt = 16,
    smallMoney = 17,
    text = 18,
    timestamp = 19,
    tinyInt = 20,
    varBinary = 21,
    varChar = 22,
    variant = 23,
    xml = 25,
    udt = 29,
    structured = 30,
    date = 31,
    time = 32,
    dateTime2 = 33,
    dateTimeOffset = 34,
    json = 35,
    vector = 36
}


export enum StatementType {
    select = 0,
    insert = 1,
    update = 2,
    delete_ = 3,
    batch = 4
}


export enum UpdateRowSource {
    none = 0,
    outputParameters = 1,
    firstReturnedRecord = 2,
    both = 3
}


export enum UpdateStatus {
    continue_ = 0,
    errorsOccurred = 1,
    skipCurrentRow = 2,
    skipAllRemainingRows = 3
}


export enum XmlReadMode {
    auto = 0,
    readSchema = 1,
    ignoreSchema = 2,
    inferSchema = 3,
    diffGram = 4,
    fragment = 5,
    inferTypedSchema = 6
}


export enum XmlWriteMode {
    writeSchema = 0,
    ignoreSchema = 1,
    diffGram = 2
}


export interface IColumnMapping$instance {
    DataSetColumn: string;
    SourceColumn: string;
}


export type IColumnMapping = IColumnMapping$instance;

export interface IColumnMappingCollection$instance {
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(sourceColumnName: string, dataSetColumnName: string): IColumnMapping;
    Add(value: any): int;
    Clear(): void;
    Contains(sourceColumnName: string): boolean;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    get_Item(index: int): any;
    get_Item(index: string): any;
    GetByDataSetColumn(dataSetColumnName: string): IColumnMapping;
    GetEnumerator(): IEnumerator;
    IndexOf(sourceColumnName: string): int;
    Insert(index: int, value: any): void;
    Remove(value: any): void;
    RemoveAt(sourceColumnName: string): void;
    RemoveAt(index: int): void;
    set_Item(index: int, value: any): void;
    set_Item(index: string, value: any): void;
}


export type IColumnMappingCollection = IColumnMappingCollection$instance;

export interface IDataAdapter$instance {
    MissingMappingAction: MissingMappingAction;
    MissingSchemaAction: MissingSchemaAction;
    readonly TableMappings: ITableMappingCollection;
    Fill(dataSet: DataSet): int;
    FillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    GetFillParameters(): IDataParameter[];
}


export type IDataAdapter = IDataAdapter$instance;

export interface IDataParameter$instance {
    DbType: DbType;
    Direction: ParameterDirection;
    readonly IsNullable: boolean;
    ParameterName: string;
    SourceColumn: string;
    SourceVersion: DataRowVersion;
    Value: any;
}


export type IDataParameter = IDataParameter$instance;

export interface IDataParameterCollection$instance {
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(value: any): int;
    Clear(): void;
    Contains(parameterName: string): boolean;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    get_Item(index: int): any;
    get_Item(parameterName: string): any;
    GetEnumerator(): IEnumerator;
    IndexOf(parameterName: string): int;
    Insert(index: int, value: any): void;
    Remove(value: any): void;
    RemoveAt(parameterName: string): void;
    RemoveAt(index: int): void;
    set_Item(index: int, value: any): void;
    set_Item(parameterName: string, value: any): void;
}


export type IDataParameterCollection = IDataParameterCollection$instance;

export interface IDataReader$instance {
    readonly Depth: int;
    readonly IsClosed: boolean;
    readonly RecordsAffected: int;
    readonly FieldCount: int;
    Close(): void;
    get_Item(i: int): any;
    get_Item(name: string): any;
    GetBoolean(i: int): boolean;
    GetByte(i: int): byte;
    GetBytes(i: int, fieldOffset: long, buffer: byte[], bufferoffset: int, length: int): long;
    GetChar(i: int): string;
    GetChars(i: int, fieldoffset: long, buffer: string[], bufferoffset: int, length: int): long;
    GetData(i: int): IDataReader;
    GetDateTime(i: int): DateTime;
    GetDecimal(i: int): decimal;
    GetDouble(i: int): double;
    GetFieldType(i: int): Type;
    GetFloat(i: int): float;
    GetGuid(i: int): Guid;
    GetInt16(i: int): short;
    GetInt32(i: int): int;
    GetInt64(i: int): long;
    GetName(i: int): string;
    GetOrdinal(name: string): int;
    GetSchemaTable(): DataTable;
    GetValue(i: int): any;
    GetValues(values: any[]): int;
    NextResult(): boolean;
}


export type IDataReader = IDataReader$instance;

export interface IDataRecord$instance {
    readonly FieldCount: int;
    get_Item(i: int): any;
    get_Item(name: string): any;
    GetBoolean(i: int): boolean;
    GetByte(i: int): byte;
    GetBytes(i: int, fieldOffset: long, buffer: byte[], bufferoffset: int, length: int): long;
    GetChar(i: int): string;
    GetChars(i: int, fieldoffset: long, buffer: string[], bufferoffset: int, length: int): long;
    GetData(i: int): IDataReader;
    GetDateTime(i: int): DateTime;
    GetDecimal(i: int): decimal;
    GetDouble(i: int): double;
    GetFieldType(i: int): Type;
    GetFloat(i: int): float;
    GetGuid(i: int): Guid;
    GetInt16(i: int): short;
    GetInt32(i: int): int;
    GetInt64(i: int): long;
    GetName(i: int): string;
    GetOrdinal(name: string): int;
    GetValue(i: int): any;
    GetValues(values: any[]): int;
}


export type IDataRecord = IDataRecord$instance;

export interface IDbCommand$instance {
    Connection: IDbConnection;
    Transaction: IDbTransaction;
    CommandText: string;
    CommandTimeout: int;
    CommandType: CommandType;
    readonly Parameters: IDataParameterCollection;
    UpdatedRowSource: UpdateRowSource;
    CreateParameter(): IDbDataParameter;
    ExecuteNonQuery(): int;
    ExecuteReader(): IDataReader;
    ExecuteReader(behavior: CommandBehavior): IDataReader;
    ExecuteScalar(): any;
    Prepare(): void;
}


export type IDbCommand = IDbCommand$instance;

export interface IDbConnection$instance {
    ConnectionString: string;
    readonly ConnectionTimeout: int;
    readonly Database: string;
    readonly State: ConnectionState;
    BeginTransaction(): IDbTransaction;
    BeginTransaction(il: IsolationLevel): IDbTransaction;
    ChangeDatabase(databaseName: string): void;
    Close(): void;
    CreateCommand(): IDbCommand;
}


export type IDbConnection = IDbConnection$instance;

export interface IDbDataAdapter$instance {
    SelectCommand: IDbCommand;
    InsertCommand: IDbCommand;
    UpdateCommand: IDbCommand;
    DeleteCommand: IDbCommand;
    MissingMappingAction: MissingMappingAction;
    MissingSchemaAction: MissingSchemaAction;
    readonly TableMappings: ITableMappingCollection;
    Fill(dataSet: DataSet): int;
    FillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    GetFillParameters(): IDataParameter[];
}


export type IDbDataAdapter = IDbDataAdapter$instance;

export interface IDbDataParameter$instance {
    Precision: byte;
    Scale: byte;
    Size: int;
    DbType: DbType;
    Direction: ParameterDirection;
    readonly IsNullable: boolean;
    ParameterName: string;
    SourceColumn: string;
    SourceVersion: DataRowVersion;
    Value: any;
}


export type IDbDataParameter = IDbDataParameter$instance;

export interface IDbTransaction$instance {
    readonly Connection: IDbConnection;
    readonly IsolationLevel: IsolationLevel;
    Commit(): void;
}


export type IDbTransaction = IDbTransaction$instance;

export interface ITableMapping$instance {
    readonly ColumnMappings: IColumnMappingCollection;
    DataSetTable: string;
    SourceTable: string;
}


export type ITableMapping = ITableMapping$instance;

export interface ITableMappingCollection$instance {
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(sourceTableName: string, dataSetTableName: string): ITableMapping;
    Add(value: any): int;
    Clear(): void;
    Contains(sourceTableName: string): boolean;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    get_Item(index: int): any;
    get_Item(index: string): any;
    GetByDataSetTable(dataSetTableName: string): ITableMapping;
    GetEnumerator(): IEnumerator;
    IndexOf(sourceTableName: string): int;
    Insert(index: int, value: any): void;
    Remove(value: any): void;
    RemoveAt(sourceTableName: string): void;
    RemoveAt(index: int): void;
    set_Item(index: int, value: any): void;
    set_Item(index: string, value: any): void;
}


export type ITableMappingCollection = ITableMappingCollection$instance;

export abstract class Constraint$instance {
    constraintName: string;
    readonly extendedProperties: PropertyCollection;
    readonly table: DataTable;
    toString(): string;
}


export type Constraint = Constraint$instance;

export class ConstraintCollection$instance extends InternalDataCollectionBase$instance {
    add(constraint: Constraint): void;
    add(name: string, columns: DataColumn[], primaryKey: boolean): Constraint;
    add(name: string, column: DataColumn, primaryKey: boolean): Constraint;
    add(name: string, primaryKeyColumn: DataColumn, foreignKeyColumn: DataColumn): Constraint;
    add(name: string, primaryKeyColumns: DataColumn[], foreignKeyColumns: DataColumn[]): Constraint;
    addRange(constraints: Constraint[]): void;
    canRemove(constraint: Constraint): boolean;
    clear(): void;
    contains(name: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): Constraint;
    get_Item(name: string): Constraint;
    getEnumerator(): IEnumerator;
    indexOf(constraint: Constraint): int;
    indexOf(constraintName: string): int;
    remove(constraint: Constraint): void;
    remove(name: string): void;
    removeAt(index: int): void;
}


export interface __ConstraintCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ConstraintCollection = ConstraintCollection$instance & __ConstraintCollection$views;


export class ConstraintException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ConstraintException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ConstraintException = ConstraintException$instance & __ConstraintException$views;


export class DataColumn$instance extends System_ComponentModel_Internal.MarshalByValueComponent$instance {
    constructor();
    constructor(columnName: string);
    constructor(columnName: string, dataType: Type);
    constructor(columnName: string, dataType: Type, expr: string);
    constructor(columnName: string, dataType: Type, expr: string, type_: MappingType);
    allowDBNull: boolean;
    autoIncrement: boolean;
    autoIncrementSeed: long;
    autoIncrementStep: long;
    caption: string;
    columnMapping: MappingType;
    columnName: string;
    dataType: Type;
    dateTimeMode: DataSetDateTime;
    defaultValue: any;
    expression: string;
    readonly extendedProperties: PropertyCollection;
    maxLength: int;
    namespace_: string;
    readonly ordinal: int;
    prefix: string;
    readOnly: boolean;
    readonly table: DataTable;
    unique: boolean;
    dispose(): void;
    getService(service: Type): any;
    setOrdinal(ordinal: int): void;
    toString(): string;
}


export interface __DataColumn$views {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DataColumn = DataColumn$instance & __DataColumn$views;


export class DataColumnChangeEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(row: DataRow, column: DataColumn, value: any);
    readonly column: DataColumn;
    proposedValue: any;
    readonly row: DataRow;
}


export type DataColumnChangeEventArgs = DataColumnChangeEventArgs$instance;

export class DataColumnChangeEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: DataColumnChangeEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: DataColumnChangeEventArgs): void;
}


export interface __DataColumnChangeEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataColumnChangeEventHandler = DataColumnChangeEventHandler$instance & __DataColumnChangeEventHandler$views;


export class DataColumnCollection$instance extends InternalDataCollectionBase$instance {
    add(column: DataColumn): void;
    add(columnName: string, type_: Type, expression: string): DataColumn;
    add(columnName: string, type_: Type): DataColumn;
    add(columnName: string): DataColumn;
    add(): DataColumn;
    addRange(columns: DataColumn[]): void;
    canRemove(column: DataColumn): boolean;
    clear(): void;
    contains(name: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): DataColumn;
    get_Item(name: string): DataColumn;
    getEnumerator(): IEnumerator;
    indexOf(column: DataColumn): int;
    indexOf(columnName: string): int;
    remove(column: DataColumn): void;
    remove(name: string): void;
    removeAt(index: int): void;
}


export interface __DataColumnCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type DataColumnCollection = DataColumnCollection$instance & __DataColumnCollection$views;


export class DataException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(s: string);
    constructor(s: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DataException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataException = DataException$instance & __DataException$views;


export class DataRelation$instance {
    constructor(relationName: string, parentColumn: DataColumn, childColumn: DataColumn);
    constructor(relationName: string, parentColumn: DataColumn, childColumn: DataColumn, createConstraints: boolean);
    constructor(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[]);
    constructor(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[], createConstraints: boolean);
    constructor(relationName: string, parentTableName: string, childTableName: string, parentColumnNames: string[], childColumnNames: string[], nested: boolean);
    constructor(relationName: string, parentTableName: string, parentTableNamespace: string, childTableName: string, childTableNamespace: string, parentColumnNames: string[], childColumnNames: string[], nested: boolean);
    readonly childColumns: DataColumn[];
    readonly childKeyConstraint: ForeignKeyConstraint;
    readonly childTable: DataTable;
    readonly dataSet: DataSet;
    readonly extendedProperties: PropertyCollection;
    nested: boolean;
    readonly parentColumns: DataColumn[];
    readonly parentKeyConstraint: UniqueConstraint;
    readonly parentTable: DataTable;
    relationName: string;
    toString(): string;
}


export type DataRelation = DataRelation$instance;

export abstract class DataRelationCollection$instance extends InternalDataCollectionBase$instance {
    add(relation: DataRelation): void;
    add(name: string, parentColumns: DataColumn[], childColumns: DataColumn[]): DataRelation;
    add(name: string, parentColumns: DataColumn[], childColumns: DataColumn[], createConstraints: boolean): DataRelation;
    add(parentColumns: DataColumn[], childColumns: DataColumn[]): DataRelation;
    add(name: string, parentColumn: DataColumn, childColumn: DataColumn): DataRelation;
    add(name: string, parentColumn: DataColumn, childColumn: DataColumn, createConstraints: boolean): DataRelation;
    add(parentColumn: DataColumn, childColumn: DataColumn): DataRelation;
    addRange(relations: DataRelation[]): void;
    canRemove(relation: DataRelation): boolean;
    clear(): void;
    contains(name: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): DataRelation;
    get_Item(name: string): DataRelation;
    getEnumerator(): IEnumerator;
    indexOf(relation: DataRelation): int;
    indexOf(relationName: string): int;
    remove(relation: DataRelation): void;
    remove(name: string): void;
    removeAt(index: int): void;
}


export interface __DataRelationCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type DataRelationCollection = DataRelationCollection$instance & __DataRelationCollection$views;


export class DataRow$instance {
    readonly hasErrors: boolean;
    itemArray: any[];
    rowError: string;
    readonly rowState: DataRowState;
    readonly table: DataTable;
    acceptChanges(): void;
    beginEdit(): void;
    cancelEdit(): void;
    clearErrors(): void;
    delete_(): void;
    endEdit(): void;
    get_Item(columnIndex: int): any;
    get_Item(columnName: string): any;
    get_Item(column: DataColumn): any;
    get_Item(columnIndex: int, version: DataRowVersion): any;
    get_Item(columnName: string, version: DataRowVersion): any;
    get_Item(column: DataColumn, version: DataRowVersion): any;
    getChildRows(relationName: string): DataRow[];
    getChildRows(relationName: string, version: DataRowVersion): DataRow[];
    getChildRows(relation: DataRelation): DataRow[];
    getChildRows(relation: DataRelation, version: DataRowVersion): DataRow[];
    getColumnError(columnIndex: int): string;
    getColumnError(columnName: string): string;
    getColumnError(column: DataColumn): string;
    getColumnsInError(): DataColumn[];
    getParentRow(relationName: string): DataRow;
    getParentRow(relationName: string, version: DataRowVersion): DataRow;
    getParentRow(relation: DataRelation): DataRow;
    getParentRow(relation: DataRelation, version: DataRowVersion): DataRow;
    getParentRows(relationName: string): DataRow[];
    getParentRows(relationName: string, version: DataRowVersion): DataRow[];
    getParentRows(relation: DataRelation): DataRow[];
    getParentRows(relation: DataRelation, version: DataRowVersion): DataRow[];
    hasVersion(version: DataRowVersion): boolean;
    isNull(columnIndex: int): boolean;
    isNull(columnName: string): boolean;
    isNull(column: DataColumn): boolean;
    isNull(column: DataColumn, version: DataRowVersion): boolean;
    rejectChanges(): void;
    set_Item(columnIndex: int, value: any): void;
    set_Item(columnName: string, value: any): void;
    set_Item(column: DataColumn, value: any): void;
    setAdded(): void;
    setColumnError(columnIndex: int, error: string): void;
    setColumnError(columnName: string, error: string): void;
    setColumnError(column: DataColumn, error: string): void;
    setModified(): void;
    setParentRow(parentRow: DataRow): void;
    setParentRow(parentRow: DataRow, relation: DataRelation): void;
}


export type DataRow = DataRow$instance;

export class DataRowBuilder$instance {
}


export type DataRowBuilder = DataRowBuilder$instance;

export class DataRowChangeEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(row: DataRow, action: DataRowAction);
    readonly action: DataRowAction;
    readonly row: DataRow;
}


export type DataRowChangeEventArgs = DataRowChangeEventArgs$instance;

export class DataRowChangeEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: DataRowChangeEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: DataRowChangeEventArgs): void;
}


export interface __DataRowChangeEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataRowChangeEventHandler = DataRowChangeEventHandler$instance & __DataRowChangeEventHandler$views;


export class DataRowCollection$instance extends InternalDataCollectionBase$instance {
    readonly count: int;
    readonly item: DataRow;
    add(row: DataRow): void;
    add(values: any[]): DataRow;
    clear(): void;
    contains(key: any): boolean;
    contains(keys: any[]): boolean;
    copyTo(ar: ClrArray, index: int): void;
    find(key: any): DataRow;
    find(keys: any[]): DataRow;
    getEnumerator(): IEnumerator;
    indexOf(row: DataRow): int;
    insertAt(row: DataRow, pos: int): void;
    remove(row: DataRow): void;
    removeAt(index: int): void;
}


export interface __DataRowCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type DataRowCollection = DataRowCollection$instance & __DataRowCollection$views;


export class DataRowComparer_1$instance<TRow extends DataRow> {
    equals(leftRow: TRow, rightRow: TRow): boolean;
    getHashCode(row: TRow): int;
    static readonly Default: unknown;
}


export interface __DataRowComparer_1$views<TRow extends DataRow> {
    readonly As_IEqualityComparer_1_of_String: System_Collections_Generic_Internal.IEqualityComparer_1$instance<TRow>;
}

export type DataRowComparer_1<TRow extends DataRow> = DataRowComparer_1$instance<TRow> & __DataRowComparer_1$views<TRow>;


export class DataRowView$instance {
    readonly dataView: DataView;
    readonly isEdit: boolean;
    readonly isNew: boolean;
    readonly row: DataRow;
    readonly rowVersion: DataRowVersion;
    beginEdit(): void;
    cancelEdit(): void;
    createChildView(relation: DataRelation, followParent: boolean): DataView;
    createChildView(relation: DataRelation): DataView;
    createChildView(relationName: string, followParent: boolean): DataView;
    createChildView(relationName: string): DataView;
    delete_(): void;
    endEdit(): void;
    equals(other: any): boolean;
    get_Item(ndx: int): any;
    get_Item(property: string): any;
    getHashCode(): int;
    set_Item(ndx: int, value: any): void;
    set_Item(property: string, value: any): void;
}


export interface __DataRowView$views {
    readonly As_IEditableObject: System_ComponentModel_Internal.IEditableObject$instance;
    readonly As_ICustomTypeDescriptor: System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    readonly As_IDataErrorInfo: System_ComponentModel_Internal.IDataErrorInfo$instance;
}

export type DataRowView = DataRowView$instance & __DataRowView$views;


export class DataSet$instance extends System_ComponentModel_Internal.MarshalByValueComponent$instance {
    constructor();
    constructor(dataSetName: string);
    caseSensitive: boolean;
    dataSetName: string;
    readonly defaultViewManager: DataViewManager;
    enforceConstraints: boolean;
    readonly extendedProperties: PropertyCollection;
    readonly hasErrors: boolean;
    readonly isInitialized: boolean;
    locale: CultureInfo;
    namespace_: string;
    prefix: string;
    readonly relations: DataRelationCollection;
    remotingFormat: SerializationFormat;
    schemaSerializationMode: SchemaSerializationMode;
    site: ISite;
    readonly tables: DataTableCollection;
    acceptChanges(): void;
    beginInit(): void;
    clear(): void;
    clone(): DataSet;
    copy(): DataSet;
    createDataReader(): DataTableReader;
    createDataReader(dataTables: DataTable[]): DataTableReader;
    dispose(): void;
    endInit(): void;
    getChanges(): DataSet;
    getChanges(rowStates: DataRowState): DataSet;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getService(service: Type): any;
    getXml(): string;
    getXmlSchema(): string;
    hasChanges(): boolean;
    hasChanges(rowStates: DataRowState): boolean;
    inferXmlSchema(reader: XmlReader, nsArray: string[]): void;
    inferXmlSchema(stream: Stream, nsArray: string[]): void;
    inferXmlSchema(reader: TextReader, nsArray: string[]): void;
    inferXmlSchema(fileName: string, nsArray: string[]): void;
    load(reader: IDataReader, loadOption: LoadOption, errorHandler: FillErrorEventHandler, tables: DataTable[]): void;
    load(reader: IDataReader, loadOption: LoadOption, tables: DataTable[]): void;
    load(reader: IDataReader, loadOption: LoadOption, tables: string[]): void;
    merge(dataSet: DataSet): void;
    merge(dataSet: DataSet, preserveChanges: boolean): void;
    merge(dataSet: DataSet, preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    merge(table: DataTable): void;
    merge(table: DataTable, preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    merge(rows: DataRow[]): void;
    merge(rows: DataRow[], preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    readXml(reader: XmlReader): XmlReadMode;
    readXml(stream: Stream): XmlReadMode;
    readXml(reader: TextReader): XmlReadMode;
    readXml(fileName: string): XmlReadMode;
    readXml(reader: XmlReader, mode: XmlReadMode): XmlReadMode;
    readXml(stream: Stream, mode: XmlReadMode): XmlReadMode;
    readXml(reader: TextReader, mode: XmlReadMode): XmlReadMode;
    readXml(fileName: string, mode: XmlReadMode): XmlReadMode;
    readXmlSchema(reader: XmlReader): void;
    readXmlSchema(stream: Stream): void;
    readXmlSchema(reader: TextReader): void;
    readXmlSchema(fileName: string): void;
    rejectChanges(): void;
    reset(): void;
    writeXml(stream: Stream): void;
    writeXml(writer: TextWriter): void;
    writeXml(writer: XmlWriter): void;
    writeXml(fileName: string): void;
    writeXml(stream: Stream, mode: XmlWriteMode): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode): void;
    writeXml(fileName: string, mode: XmlWriteMode): void;
    writeXmlSchema(stream: Stream): void;
    writeXmlSchema(stream: Stream, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
    writeXmlSchema(fileName: string): void;
    writeXmlSchema(fileName: string, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
    writeXmlSchema(writer: TextWriter): void;
    writeXmlSchema(writer: TextWriter, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
    writeXmlSchema(writer: XmlWriter): void;
    writeXmlSchema(writer: XmlWriter, multipleTargetConverter: Converter_2<Type, CLROf<string>>): void;
    static GetDataSetSchema(schemaSet: XmlSchemaSet): XmlSchemaComplexType;
}


export interface __DataSet$views {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_ISupportInitialize: System_ComponentModel_Internal.ISupportInitialize$instance;
    readonly As_IListSource: System_ComponentModel_Internal.IListSource$instance;
    readonly As_ISupportInitializeNotification: System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export type DataSet = DataSet$instance & __DataSet$views;


export class DataSysDescriptionAttribute$instance extends System_ComponentModel_Internal.DescriptionAttribute$instance {
    constructor(description: string);
    readonly description: string;
}


export type DataSysDescriptionAttribute = DataSysDescriptionAttribute$instance;

export class DataTable$instance extends System_ComponentModel_Internal.MarshalByValueComponent$instance {
    constructor();
    constructor(tableName: string);
    constructor(tableName: string, tableNamespace: string);
    caseSensitive: boolean;
    readonly childRelations: DataRelationCollection;
    readonly columns: DataColumnCollection;
    readonly constraints: ConstraintCollection;
    readonly dataSet: DataSet;
    readonly defaultView: DataView;
    displayExpression: string;
    readonly extendedProperties: PropertyCollection;
    readonly hasErrors: boolean;
    readonly isInitialized: boolean;
    locale: CultureInfo;
    minimumCapacity: int;
    namespace_: string;
    readonly parentRelations: DataRelationCollection;
    prefix: string;
    primaryKey: DataColumn[];
    remotingFormat: SerializationFormat;
    readonly rows: DataRowCollection;
    site: ISite;
    tableName: string;
    acceptChanges(): void;
    beginInit(): void;
    beginLoadData(): void;
    clear(): void;
    clone(): DataTable;
    compute(expression: string, filter: string): any;
    copy(): DataTable;
    createDataReader(): DataTableReader;
    dispose(): void;
    endInit(): void;
    endLoadData(): void;
    getChanges(): DataTable;
    getChanges(rowStates: DataRowState): DataTable;
    getErrors(): DataRow[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getService(service: Type): any;
    importRow(row: DataRow): void;
    load(reader: IDataReader): void;
    load(reader: IDataReader, loadOption: LoadOption): void;
    load(reader: IDataReader, loadOption: LoadOption, errorHandler: FillErrorEventHandler): void;
    loadDataRow(values: any[], fAcceptChanges: boolean): DataRow;
    loadDataRow(values: any[], loadOption: LoadOption): DataRow;
    merge(table: DataTable): void;
    merge(table: DataTable, preserveChanges: boolean): void;
    merge(table: DataTable, preserveChanges: boolean, missingSchemaAction: MissingSchemaAction): void;
    newRow(): DataRow;
    readXml(stream: Stream): XmlReadMode;
    readXml(reader: TextReader): XmlReadMode;
    readXml(fileName: string): XmlReadMode;
    readXml(reader: XmlReader): XmlReadMode;
    readXmlSchema(stream: Stream): void;
    readXmlSchema(reader: TextReader): void;
    readXmlSchema(fileName: string): void;
    readXmlSchema(reader: XmlReader): void;
    rejectChanges(): void;
    reset(): void;
    select(): DataRow[];
    select(filterExpression: string): DataRow[];
    select(filterExpression: string, sort: string): DataRow[];
    select(filterExpression: string, sort: string, recordStates: DataViewRowState): DataRow[];
    toString(): string;
    writeXml(stream: Stream): void;
    writeXml(stream: Stream, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter): void;
    writeXml(writer: TextWriter, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter): void;
    writeXml(writer: XmlWriter, writeHierarchy: boolean): void;
    writeXml(fileName: string): void;
    writeXml(fileName: string, writeHierarchy: boolean): void;
    writeXml(stream: Stream, mode: XmlWriteMode): void;
    writeXml(stream: Stream, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(fileName: string, mode: XmlWriteMode): void;
    writeXml(fileName: string, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXmlSchema(stream: Stream): void;
    writeXmlSchema(stream: Stream, writeHierarchy: boolean): void;
    writeXmlSchema(writer: TextWriter): void;
    writeXmlSchema(writer: TextWriter, writeHierarchy: boolean): void;
    writeXmlSchema(writer: XmlWriter): void;
    writeXmlSchema(writer: XmlWriter, writeHierarchy: boolean): void;
    writeXmlSchema(fileName: string): void;
    writeXmlSchema(fileName: string, writeHierarchy: boolean): void;
    static GetDataTableSchema(schemaSet: XmlSchemaSet): XmlSchemaComplexType;
}


export interface __DataTable$views {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_ISupportInitialize: System_ComponentModel_Internal.ISupportInitialize$instance;
    readonly As_IListSource: System_ComponentModel_Internal.IListSource$instance;
    readonly As_ISupportInitializeNotification: System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export type DataTable = DataTable$instance & __DataTable$views;


export class DataTableClearEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(dataTable: DataTable);
    readonly table: DataTable;
    readonly tableName: string;
    readonly tableNamespace: string;
}


export type DataTableClearEventArgs = DataTableClearEventArgs$instance;

export class DataTableClearEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: DataTableClearEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: DataTableClearEventArgs): void;
}


export interface __DataTableClearEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataTableClearEventHandler = DataTableClearEventHandler$instance & __DataTableClearEventHandler$views;


export class DataTableCollection$instance extends InternalDataCollectionBase$instance {
    add(table: DataTable): void;
    add(name: string): DataTable;
    add(name: string, tableNamespace: string): DataTable;
    add(): DataTable;
    addRange(tables: DataTable[]): void;
    canRemove(table: DataTable): boolean;
    clear(): void;
    contains(name: string): boolean;
    contains(name: string, tableNamespace: string): boolean;
    copyTo(ar: ClrArray, index: int): void;
    get_Item(index: int): DataTable;
    get_Item(name: string): DataTable;
    get_Item(name: string, tableNamespace: string): DataTable;
    getEnumerator(): IEnumerator;
    indexOf(table: DataTable): int;
    indexOf(tableName: string): int;
    indexOf(tableName: string, tableNamespace: string): int;
    remove(table: DataTable): void;
    remove(name: string): void;
    remove(name: string, tableNamespace: string): void;
    removeAt(index: int): void;
}


export interface __DataTableCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type DataTableCollection = DataTableCollection$instance & __DataTableCollection$views;


export class DataTableNewRowEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(dataRow: DataRow);
    readonly row: DataRow;
}


export type DataTableNewRowEventArgs = DataTableNewRowEventArgs$instance;

export class DataTableNewRowEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: DataTableNewRowEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: DataTableNewRowEventArgs): void;
}


export interface __DataTableNewRowEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataTableNewRowEventHandler = DataTableNewRowEventHandler$instance & __DataTableNewRowEventHandler$views;


export class DataTableReader$instance extends System_Data_Common_Internal.DbDataReader$instance {
    constructor(dataTable: DataTable);
    constructor(dataTables: DataTable[]);
    readonly depth: int;
    readonly fieldCount: int;
    readonly hasRows: boolean;
    readonly isClosed: boolean;
    readonly recordsAffected: int;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    get_Item(ordinal: int): any;
    get_Item(name: string): any;
    getBoolean(ordinal: int): boolean;
    getByte(ordinal: int): byte;
    getBytes(ordinal: int, dataIndex: long, buffer: byte[], bufferIndex: int, length: int): long;
    getChar(ordinal: int): string;
    getChars(ordinal: int, dataIndex: long, buffer: string[], bufferIndex: int, length: int): long;
    getData(ordinal: int): DbDataReader;
    getData(i: int): IDataReader;
    getDataTypeName(ordinal: int): string;
    getDateTime(ordinal: int): DateTime;
    getDecimal(ordinal: int): decimal;
    getDouble(ordinal: int): double;
    getEnumerator(): IEnumerator;
    getFieldType(ordinal: int): Type;
    getFloat(ordinal: int): float;
    getGuid(ordinal: int): Guid;
    getInt16(ordinal: int): short;
    getInt32(ordinal: int): int;
    getInt64(ordinal: int): long;
    getName(ordinal: int): string;
    getOrdinal(name: string): int;
    getProviderSpecificFieldType(ordinal: int): Type;
    getProviderSpecificValue(ordinal: int): any;
    getProviderSpecificValues(values: any[]): int;
    getSchemaTable(): DataTable;
    getString(ordinal: int): string;
    getValue(ordinal: int): any;
    getValues(values: any[]): int;
    isDBNull(ordinal: int): boolean;
    nextResult(): boolean;
    read(): boolean;
}


export interface __DataTableReader$views {
    readonly As_IDataReader: IDataReader$instance;
    readonly As_IDataRecord: IDataRecord$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DataTableReader = DataTableReader$instance & __DataTableReader$views;


export class DataView$instance extends System_ComponentModel_Internal.MarshalByValueComponent$instance {
    constructor();
    constructor(table: DataTable);
    constructor(table: DataTable, RowFilter: string, Sort: string, RowState: DataViewRowState);
    allowDelete: boolean;
    allowEdit: boolean;
    allowNew: boolean;
    applyDefaultSort: boolean;
    readonly count: int;
    readonly dataViewManager: DataViewManager;
    readonly isInitialized: boolean;
    readonly item: DataRowView;
    rowFilter: string;
    rowStateFilter: DataViewRowState;
    sort: string;
    table: DataTable;
    addNew(): DataRowView;
    beginInit(): void;
    copyTo(array: ClrArray, index: int): void;
    delete_(index: int): void;
    dispose(): void;
    endInit(): void;
    equals(view: DataView): boolean;
    equals(obj: any): boolean;
    find(key: any): int;
    find(key: any[]): int;
    findRows(key: any): DataRowView[];
    findRows(key: any[]): DataRowView[];
    getEnumerator(): IEnumerator;
    getService(service: Type): any;
    toTable(): DataTable;
    toTable(tableName: string): DataTable;
    toTable(distinct: boolean, columnNames: string[]): DataTable;
    toTable(tableName: string, distinct: boolean, columnNames: string[]): DataTable;
}


export interface __DataView$views {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_ISupportInitialize: System_ComponentModel_Internal.ISupportInitialize$instance;
    readonly As_IBindingList: System_ComponentModel_Internal.IBindingList$instance;
    readonly As_IBindingListView: System_ComponentModel_Internal.IBindingListView$instance;
    readonly As_ISupportInitializeNotification: System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    readonly As_ITypedList: System_ComponentModel_Internal.ITypedList$instance;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DataView = DataView$instance & __DataView$views;


export class DataViewManager$instance extends System_ComponentModel_Internal.MarshalByValueComponent$instance {
    constructor();
    constructor(dataSet: DataSet);
    dataSet: DataSet;
    dataViewSettingCollectionString: string;
    readonly dataViewSettings: DataViewSettingCollection;
    createDataView(table: DataTable): DataView;
    dispose(): void;
    getService(service: Type): any;
}


export interface __DataViewManager$views {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IBindingList: System_ComponentModel_Internal.IBindingList$instance;
    readonly As_ITypedList: System_ComponentModel_Internal.ITypedList$instance;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DataViewManager = DataViewManager$instance & __DataViewManager$views;


export class DataViewSetting$instance {
    applyDefaultSort: boolean;
    readonly dataViewManager: DataViewManager;
    rowFilter: string;
    rowStateFilter: DataViewRowState;
    sort: string;
    readonly table: DataTable;
}


export type DataViewSetting = DataViewSetting$instance;

export class DataViewSettingCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: any;
    copyTo(ar: ClrArray, index: int): void;
    copyTo(ar: DataViewSetting[], index: int): void;
    get_Item(table: DataTable): DataViewSetting;
    get_Item(tableName: string): DataViewSetting;
    get_Item(index: int): DataViewSetting;
    getEnumerator(): IEnumerator;
    set_Item(table: DataTable, value: DataViewSetting): void;
    set_Item(index: int, value: DataViewSetting): void;
}


export interface __DataViewSettingCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type DataViewSettingCollection = DataViewSettingCollection$instance & __DataViewSettingCollection$views;


export class DBConcurrencyException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, inner: Exception, dataRows: DataRow[]);
    row: DataRow;
    readonly rowCount: int;
    copyToRows(array: DataRow[]): void;
    copyToRows(array: DataRow[], arrayIndex: int): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DBConcurrencyException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DBConcurrencyException = DBConcurrencyException$instance & __DBConcurrencyException$views;


export class DeletedRowInaccessibleException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DeletedRowInaccessibleException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DeletedRowInaccessibleException = DeletedRowInaccessibleException$instance & __DeletedRowInaccessibleException$views;


export class DuplicateNameException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DuplicateNameException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DuplicateNameException = DuplicateNameException$instance & __DuplicateNameException$views;


export abstract class EnumerableRowCollection$instance {
}


export interface __EnumerableRowCollection$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type EnumerableRowCollection = EnumerableRowCollection$instance & __EnumerableRowCollection$views;


export class EnumerableRowCollection_1$instance<TRow> extends EnumerableRowCollection$instance {
    getEnumerator(): IEnumerator;
}


export interface __EnumerableRowCollection_1$views<TRow> {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<TRow>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type EnumerableRowCollection_1<TRow> = EnumerableRowCollection_1$instance<TRow> & __EnumerableRowCollection_1$views<TRow>;


export class EvaluateException$instance extends InvalidExpressionException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __EvaluateException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EvaluateException = EvaluateException$instance & __EvaluateException$views;


export class FillErrorEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(dataTable: DataTable, values: any[]);
    continue_: boolean;
    readonly dataTable: DataTable;
    errors: Exception;
    readonly values: any[];
}


export type FillErrorEventArgs = FillErrorEventArgs$instance;

export class FillErrorEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: FillErrorEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: FillErrorEventArgs): void;
}


export interface __FillErrorEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FillErrorEventHandler = FillErrorEventHandler$instance & __FillErrorEventHandler$views;


export class ForeignKeyConstraint$instance extends Constraint$instance {
    constructor(parentColumn: DataColumn, childColumn: DataColumn);
    constructor(constraintName: string, parentColumn: DataColumn, childColumn: DataColumn);
    constructor(parentColumns: DataColumn[], childColumns: DataColumn[]);
    constructor(constraintName: string, parentColumns: DataColumn[], childColumns: DataColumn[]);
    constructor(constraintName: string, parentTableName: string, parentColumnNames: string[], childColumnNames: string[], acceptRejectRule: AcceptRejectRule, deleteRule: Rule, updateRule: Rule);
    constructor(constraintName: string, parentTableName: string, parentTableNamespace: string, parentColumnNames: string[], childColumnNames: string[], acceptRejectRule: AcceptRejectRule, deleteRule: Rule, updateRule: Rule);
    acceptRejectRule: AcceptRejectRule;
    readonly columns: DataColumn[];
    deleteRule: Rule;
    readonly relatedColumns: DataColumn[];
    readonly relatedTable: DataTable;
    readonly table: DataTable;
    updateRule: Rule;
    equals(key: any): boolean;
    getHashCode(): int;
}


export type ForeignKeyConstraint = ForeignKeyConstraint$instance;

export class InRowChangingEventException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InRowChangingEventException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InRowChangingEventException = InRowChangingEventException$instance & __InRowChangingEventException$views;


export class InternalDataCollectionBase$instance {
    constructor();
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: any;
    copyTo(ar: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
}


export interface __InternalDataCollectionBase$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type InternalDataCollectionBase = InternalDataCollectionBase$instance & __InternalDataCollectionBase$views;


export class InvalidConstraintException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidConstraintException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidConstraintException = InvalidConstraintException$instance & __InvalidConstraintException$views;


export class InvalidExpressionException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidExpressionException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidExpressionException = InvalidExpressionException$instance & __InvalidExpressionException$views;


export class MergeFailedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(table: DataTable, conflict: string);
    readonly conflict: string;
    readonly table: DataTable;
}


export type MergeFailedEventArgs = MergeFailedEventArgs$instance;

export class MergeFailedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: MergeFailedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: MergeFailedEventArgs): void;
}


export interface __MergeFailedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MergeFailedEventHandler = MergeFailedEventHandler$instance & __MergeFailedEventHandler$views;


export class MissingPrimaryKeyException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MissingPrimaryKeyException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingPrimaryKeyException = MissingPrimaryKeyException$instance & __MissingPrimaryKeyException$views;


export class NoNullAllowedException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NoNullAllowedException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NoNullAllowedException = NoNullAllowedException$instance & __NoNullAllowedException$views;


export class OrderedEnumerableRowCollection_1$instance<TRow> extends EnumerableRowCollection_1$instance<TRow> {
    getEnumerator(): IEnumerator_1<TRow>;
    getEnumerator(): IEnumerator;
}


export interface __OrderedEnumerableRowCollection_1$views<TRow> {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<TRow>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type OrderedEnumerableRowCollection_1<TRow> = OrderedEnumerableRowCollection_1$instance<TRow> & __OrderedEnumerableRowCollection_1$views<TRow>;


export class PropertyCollection$instance extends System_Collections_Internal.Hashtable$instance {
    constructor();
    add(key: any, value: any): void;
    clear(): void;
    clone(): any;
    contains(key: any): boolean;
    copyTo(array: ClrArray, arrayIndex: int): void;
    getEnumerator(): IDictionaryEnumerator;
    getEnumerator(): IEnumerator;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: any): void;
    remove(key: any): void;
}


export interface __PropertyCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PropertyCollection = PropertyCollection$instance & __PropertyCollection$views;


export class ReadOnlyException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ReadOnlyException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReadOnlyException = ReadOnlyException$instance & __ReadOnlyException$views;


export class RowNotInTableException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __RowNotInTableException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RowNotInTableException = RowNotInTableException$instance & __RowNotInTableException$views;


export class StateChangeEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(originalState: ConnectionState, currentState: ConnectionState);
    readonly currentState: ConnectionState;
    readonly originalState: ConnectionState;
}


export type StateChangeEventArgs = StateChangeEventArgs$instance;

export class StateChangeEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: StateChangeEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: StateChangeEventArgs): void;
}


export interface __StateChangeEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StateChangeEventHandler = StateChangeEventHandler$instance & __StateChangeEventHandler$views;


export class StatementCompletedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(recordCount: int);
    readonly recordCount: int;
}


export type StatementCompletedEventArgs = StatementCompletedEventArgs$instance;

export class StatementCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: StatementCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: StatementCompletedEventArgs): void;
}


export interface __StatementCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StatementCompletedEventHandler = StatementCompletedEventHandler$instance & __StatementCompletedEventHandler$views;


export class StrongTypingException$instance extends DataException$instance {
    constructor();
    constructor(message: string);
    constructor(s: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __StrongTypingException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StrongTypingException = StrongTypingException$instance & __StrongTypingException$views;


export class SyntaxErrorException$instance extends InvalidExpressionException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SyntaxErrorException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SyntaxErrorException = SyntaxErrorException$instance & __SyntaxErrorException$views;


export abstract class TypedTableBase_1$instance<T extends DataRow> extends DataTable$instance {
    beginInit(): void;
    cast<TResult>(): EnumerableRowCollection_1<TResult>;
    dispose(): void;
    getEnumerator(): IEnumerator_1<T>;
    getList(): IList;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getSchema(): XmlSchema;
    getService(serviceType: Type): any;
    readXml(stream: Stream): XmlReadMode;
    readXml(reader: TextReader): XmlReadMode;
    readXml(fileName: string): XmlReadMode;
    readXml(reader: XmlReader): XmlReadMode;
    readXml(reader: XmlReader): void;
    writeXml(stream: Stream): void;
    writeXml(stream: Stream, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter): void;
    writeXml(writer: TextWriter, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter): void;
    writeXml(writer: XmlWriter, writeHierarchy: boolean): void;
    writeXml(fileName: string): void;
    writeXml(fileName: string, writeHierarchy: boolean): void;
    writeXml(stream: Stream, mode: XmlWriteMode): void;
    writeXml(stream: Stream, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode): void;
    writeXml(writer: TextWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode): void;
    writeXml(writer: XmlWriter, mode: XmlWriteMode, writeHierarchy: boolean): void;
    writeXml(fileName: string, mode: XmlWriteMode): void;
    writeXml(fileName: string, mode: XmlWriteMode, writeHierarchy: boolean): void;
}


export interface __TypedTableBase_1$views<T extends DataRow> {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_ISupportInitialize: System_ComponentModel_Internal.ISupportInitialize$instance;
    readonly As_IListSource: System_ComponentModel_Internal.IListSource$instance;
    readonly As_ISupportInitializeNotification: System_ComponentModel_Internal.ISupportInitializeNotification$instance;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export type TypedTableBase_1<T extends DataRow> = TypedTableBase_1$instance<T> & __TypedTableBase_1$views<T>;


export class UniqueConstraint$instance extends Constraint$instance {
    constructor(name: string, column: DataColumn);
    constructor(column: DataColumn);
    constructor(name: string, columns: DataColumn[]);
    constructor(columns: DataColumn[]);
    constructor(name: string, columnNames: string[], isPrimaryKey: boolean);
    constructor(name: string, column: DataColumn, isPrimaryKey: boolean);
    constructor(column: DataColumn, isPrimaryKey: boolean);
    constructor(name: string, columns: DataColumn[], isPrimaryKey: boolean);
    constructor(columns: DataColumn[], isPrimaryKey: boolean);
    readonly columns: DataColumn[];
    readonly isPrimaryKey: boolean;
    readonly table: DataTable;
    equals(key2: any): boolean;
    getHashCode(): int;
}


export type UniqueConstraint = UniqueConstraint$instance;

export class VersionNotFoundException$instance extends DataException$instance {
    constructor();
    constructor(s: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __VersionNotFoundException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type VersionNotFoundException = VersionNotFoundException$instance & __VersionNotFoundException$views;


export abstract class DataReaderExtensions$instance {
    static GetBoolean(reader: DbDataReader, name: string): boolean;
    static GetByte(reader: DbDataReader, name: string): byte;
    static GetBytes(reader: DbDataReader, name: string, dataOffset: long, buffer: byte[], bufferOffset: int, length: int): long;
    static GetChar(reader: DbDataReader, name: string): string;
    static GetChars(reader: DbDataReader, name: string, dataOffset: long, buffer: string[], bufferOffset: int, length: int): long;
    static GetData(reader: DbDataReader, name: string): DbDataReader;
    static GetDataTypeName(reader: DbDataReader, name: string): string;
    static GetDateTime(reader: DbDataReader, name: string): DateTime;
    static GetDecimal(reader: DbDataReader, name: string): decimal;
    static GetDouble(reader: DbDataReader, name: string): double;
    static GetFieldType(reader: DbDataReader, name: string): Type;
    static GetFieldValue<T>(reader: DbDataReader, name: string): T;
    static GetFieldValueAsync<T>(reader: DbDataReader, name: string, cancellationToken?: CancellationToken): Task_1<T>;
    static GetFloat(reader: DbDataReader, name: string): float;
    static GetGuid(reader: DbDataReader, name: string): Guid;
    static GetInt16(reader: DbDataReader, name: string): short;
    static GetInt32(reader: DbDataReader, name: string): int;
    static GetInt64(reader: DbDataReader, name: string): long;
    static GetProviderSpecificFieldType(reader: DbDataReader, name: string): Type;
    static GetProviderSpecificValue(reader: DbDataReader, name: string): any;
    static GetStream(reader: DbDataReader, name: string): Stream;
    static GetString(reader: DbDataReader, name: string): string;
    static GetTextReader(reader: DbDataReader, name: string): TextReader;
    static GetValue(reader: DbDataReader, name: string): any;
    static IsDBNull(reader: DbDataReader, name: string): boolean;
    static IsDBNullAsync(reader: DbDataReader, name: string, cancellationToken?: CancellationToken): Task_1<CLROf<boolean>>;
}


export type DataReaderExtensions = DataReaderExtensions$instance;

export abstract class DataRowComparer$instance {
    static readonly Default: DataRowComparer_1<DataRow>;
}


export type DataRowComparer = DataRowComparer$instance;

export abstract class DataRowExtensions$instance {
    static Field<T>(row: DataRow, column: DataColumn, version: DataRowVersion): T;
    static Field<T>(row: DataRow, column: DataColumn): T;
    static Field<T>(row: DataRow, columnIndex: int, version: DataRowVersion): T;
    static Field<T>(row: DataRow, columnIndex: int): T;
    static Field<T>(row: DataRow, columnName: string, version: DataRowVersion): T;
    static Field<T>(row: DataRow, columnName: string): T;
    static SetField<T>(row: DataRow, column: DataColumn, value: T): void;
    static SetField<T>(row: DataRow, columnIndex: int, value: T): void;
    static SetField<T>(row: DataRow, columnName: string, value: T): void;
}


export type DataRowExtensions = DataRowExtensions$instance;

export abstract class DataTableExtensions$instance {
    static AsDataView<T extends DataRow>(source: EnumerableRowCollection_1<T>): DataView;
    static AsDataView(table: DataTable): DataView;
    static AsEnumerable(source: DataTable): EnumerableRowCollection_1<DataRow>;
    static CopyToDataTable<T extends DataRow>(source: IEnumerable_1<T>, table: DataTable, options: LoadOption, errorHandler: FillErrorEventHandler): void;
    static CopyToDataTable<T extends DataRow>(source: IEnumerable_1<T>, table: DataTable, options: LoadOption): void;
    static CopyToDataTable<T extends DataRow>(source: IEnumerable_1<T>): DataTable;
}


export type DataTableExtensions = DataTableExtensions$instance;

export abstract class EnumerableRowCollectionExtensions$instance {
    static Cast<TResult>(source: EnumerableRowCollection): EnumerableRowCollection_1<TResult>;
    static OrderBy<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static OrderBy<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static OrderByDescending<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static OrderByDescending<TRow, TKey>(source: EnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static Select<TRow, S>(source: EnumerableRowCollection_1<TRow>, selector: Func_2<TRow, S>): EnumerableRowCollection_1<S>;
    static ThenBy<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static ThenBy<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static ThenByDescending<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static ThenByDescending<TRow, TKey>(source: OrderedEnumerableRowCollection_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static Where<TRow>(source: EnumerableRowCollection_1<TRow>, predicate: Func_2<TRow, CLROf<boolean>>): EnumerableRowCollection_1<TRow>;
}


export type EnumerableRowCollectionExtensions = EnumerableRowCollectionExtensions$instance;

export abstract class TypedTableBaseExtensions$instance {
    static AsEnumerable<TRow extends DataRow>(source: TypedTableBase_1<TRow>): EnumerableRowCollection_1<TRow>;
    static ElementAtOrDefault<TRow extends DataRow>(source: TypedTableBase_1<TRow>, index: int): TRow;
    static OrderBy<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static OrderBy<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static OrderByDescending<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>, comparer: IComparer_1<TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static OrderByDescending<TRow extends DataRow, TKey>(source: TypedTableBase_1<TRow>, keySelector: Func_2<TRow, TKey>): OrderedEnumerableRowCollection_1<TRow>;
    static Select<TRow extends DataRow, S>(source: TypedTableBase_1<TRow>, selector: Func_2<TRow, S>): EnumerableRowCollection_1<S>;
    static Where<TRow extends DataRow>(source: TypedTableBase_1<TRow>, predicate: Func_2<TRow, CLROf<boolean>>): EnumerableRowCollection_1<TRow>;
}


export type TypedTableBaseExtensions = TypedTableBaseExtensions$instance;

