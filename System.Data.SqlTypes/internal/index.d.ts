// Generated by tsbindgen - Architecture
// Namespace: System.Data.SqlTypes
// Assembly: System.Data.Common

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CompareInfo, CompareOptions, CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { XmlSchema, XmlSchemaSet } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import type { XmlQualifiedName, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Enum, Exception, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, Span_1, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt32, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum SqlCompareOptions {
    None = 0,
    IgnoreCase = 1,
    IgnoreNonSpace = 2,
    IgnoreKanaType = 8,
    IgnoreWidth = 16,
    BinarySort = 32768,
    BinarySort2 = 16384
}


export enum StorageState {
    Buffer = 0,
    Stream = 1,
    UnmanagedBuffer = 2
}


export interface INullable$instance {
    readonly IsNull: boolean;
}


export type INullable = INullable$instance;

export class SqlBinary$instance {
    constructor(value: byte[]);
    readonly IsNull: boolean;
    readonly Item: byte;
    readonly Length: int;
    readonly Value: byte[];
    CompareTo(value: unknown): int;
    CompareTo(value: SqlBinary): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlBinary): boolean;
    GetHashCode(): int;
    ToSqlGuid(): SqlGuid;
    ToString(): string;
    static readonly Null: SqlBinary;
    static Add(x: SqlBinary, y: SqlBinary): SqlBinary;
    static Concat(x: SqlBinary, y: SqlBinary): SqlBinary;
    static Equals(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static GreaterThanOrEqual(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static LessThan(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static LessThanOrEqual(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static NotEquals(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static WrapBytes(bytes: byte[]): SqlBinary;
}


export interface __SqlBinary$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlBinary>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlBinary): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlBinary$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlBinary = SqlBinary$instance & __SqlBinary$views;


export class SqlBoolean$instance {
    constructor(value: boolean);
    constructor(value: int);
    readonly ByteValue: byte;
    readonly IsFalse: boolean;
    readonly IsNull: boolean;
    readonly IsTrue: boolean;
    readonly Value: boolean;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlBoolean): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlBoolean): boolean;
    GetHashCode(): int;
    ToSqlByte(): SqlByte;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly True: SqlBoolean;
    static readonly False: SqlBoolean;
    static readonly Null: SqlBoolean;
    static readonly Zero: SqlBoolean;
    static readonly One: SqlBoolean;
    static And(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static Equals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static GreaterThanOrEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static LessThan(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static LessThanOrEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static NotEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static OnesComplement(x: SqlBoolean): SqlBoolean;
    static Or(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static Parse(s: string): SqlBoolean;
    static Xor(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
}


export interface __SqlBoolean$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlBoolean>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlBoolean): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlBoolean$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlBoolean = SqlBoolean$instance & __SqlBoolean$views;


export class SqlByte$instance {
    constructor(value: byte);
    readonly IsNull: boolean;
    readonly Value: byte;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlByte): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlByte): boolean;
    GetHashCode(): int;
    ToSqlBoolean(): SqlBoolean;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlByte;
    static readonly Zero: SqlByte;
    static readonly MinValue: SqlByte;
    static readonly MaxValue: SqlByte;
    static Add(x: SqlByte, y: SqlByte): SqlByte;
    static BitwiseAnd(x: SqlByte, y: SqlByte): SqlByte;
    static BitwiseOr(x: SqlByte, y: SqlByte): SqlByte;
    static Divide(x: SqlByte, y: SqlByte): SqlByte;
    static Equals(x: SqlByte, y: SqlByte): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlByte, y: SqlByte): SqlBoolean;
    static GreaterThanOrEqual(x: SqlByte, y: SqlByte): SqlBoolean;
    static LessThan(x: SqlByte, y: SqlByte): SqlBoolean;
    static LessThanOrEqual(x: SqlByte, y: SqlByte): SqlBoolean;
    static Mod(x: SqlByte, y: SqlByte): SqlByte;
    static Modulus(x: SqlByte, y: SqlByte): SqlByte;
    static Multiply(x: SqlByte, y: SqlByte): SqlByte;
    static NotEquals(x: SqlByte, y: SqlByte): SqlBoolean;
    static OnesComplement(x: SqlByte): SqlByte;
    static Parse(s: string): SqlByte;
    static Subtract(x: SqlByte, y: SqlByte): SqlByte;
    static Xor(x: SqlByte, y: SqlByte): SqlByte;
}


export interface __SqlByte$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlByte>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlByte): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlByte$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlByte = SqlByte$instance & __SqlByte$views;


export class SqlDateTime$instance {
    constructor(value: DateTime);
    constructor(year: int, month: int, day: int);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: double);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, bilisecond: int);
    constructor(dayTicks: int, timeTicks: int);
    readonly DayTicks: int;
    readonly IsNull: boolean;
    readonly TimeTicks: int;
    readonly Value: DateTime;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlDateTime): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlDateTime): boolean;
    GetHashCode(): int;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly SQLTicksPerSecond: int;
    static readonly SQLTicksPerMinute: int;
    static readonly SQLTicksPerHour: int;
    static readonly MinValue: SqlDateTime;
    static readonly MaxValue: SqlDateTime;
    static readonly Null: SqlDateTime;
    static Add(x: SqlDateTime, t: TimeSpan): SqlDateTime;
    static Equals(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static GreaterThanOrEqual(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static LessThan(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static LessThanOrEqual(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static NotEquals(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static Parse(s: string): SqlDateTime;
    static Subtract(x: SqlDateTime, t: TimeSpan): SqlDateTime;
}


export interface __SqlDateTime$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlDateTime>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDateTime): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlDateTime$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlDateTime = SqlDateTime$instance & __SqlDateTime$views;


export class SqlDecimal$instance {
    constructor(value: decimal);
    constructor(value: int);
    constructor(value: long);
    constructor(bPrecision: byte, bScale: byte, fPositive: boolean, bits: int[]);
    constructor(bPrecision: byte, bScale: byte, fPositive: boolean, data1: int, data2: int, data3: int, data4: int);
    constructor(dVal: double);
    readonly BinData: byte[];
    readonly Data: int[];
    readonly IsNull: boolean;
    readonly IsPositive: boolean;
    readonly Precision: byte;
    readonly Scale: byte;
    readonly Value: decimal;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlDecimal): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlDecimal): boolean;
    GetHashCode(): int;
    ToDouble(): double;
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDouble(): SqlDouble;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    WriteTdsValue(destination: Span_1<CLROf<uint>>): int;
    static readonly MaxPrecision: byte;
    static readonly MaxScale: byte;
    static readonly Null: SqlDecimal;
    static readonly MinValue: SqlDecimal;
    static readonly MaxValue: SqlDecimal;
    static Abs(n: SqlDecimal): SqlDecimal;
    static Add(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static AdjustScale(n: SqlDecimal, digits: int, fRound: boolean): SqlDecimal;
    static Ceiling(n: SqlDecimal): SqlDecimal;
    static ConvertToPrecScale(n: SqlDecimal, precision: int, scale: int): SqlDecimal;
    static Divide(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static Equals(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static Floor(n: SqlDecimal): SqlDecimal;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static GreaterThanOrEqual(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static LessThan(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static LessThanOrEqual(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static Multiply(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static NotEquals(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static Parse(s: string): SqlDecimal;
    static Power(n: SqlDecimal, exp: double): SqlDecimal;
    static Round(n: SqlDecimal, position: int): SqlDecimal;
    static Sign(n: SqlDecimal): SqlInt32;
    static Subtract(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static Truncate(n: SqlDecimal, position: int): SqlDecimal;
}


export interface __SqlDecimal$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlDecimal>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDecimal): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlDecimal$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlDecimal = SqlDecimal$instance & __SqlDecimal$views;


export class SqlDouble$instance {
    constructor(value: double);
    readonly IsNull: boolean;
    readonly Value: double;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlDouble): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlDouble): boolean;
    GetHashCode(): int;
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDecimal(): SqlDecimal;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlDouble;
    static readonly Zero: SqlDouble;
    static readonly MinValue: SqlDouble;
    static readonly MaxValue: SqlDouble;
    static Add(x: SqlDouble, y: SqlDouble): SqlDouble;
    static Divide(x: SqlDouble, y: SqlDouble): SqlDouble;
    static Equals(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static GreaterThanOrEqual(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static LessThan(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static LessThanOrEqual(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static Multiply(x: SqlDouble, y: SqlDouble): SqlDouble;
    static NotEquals(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static Parse(s: string): SqlDouble;
    static Subtract(x: SqlDouble, y: SqlDouble): SqlDouble;
}


export interface __SqlDouble$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlDouble>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDouble): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlDouble$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlDouble = SqlDouble$instance & __SqlDouble$views;


export class SqlGuid$instance {
    constructor(value: byte[]);
    constructor(s: string);
    constructor(g: Guid);
    constructor(a: int, b: short, c: short, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte);
    readonly IsNull: boolean;
    readonly Value: Guid;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlGuid): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlGuid): boolean;
    GetHashCode(): int;
    ToByteArray(): byte[];
    ToSqlBinary(): SqlBinary;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlGuid;
    static Equals(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static GreaterThanOrEqual(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static LessThan(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static LessThanOrEqual(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static NotEquals(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static Parse(s: string): SqlGuid;
}


export interface __SqlGuid$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlGuid>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlGuid): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlGuid$instance extends INullable$instance, System_Internal.IComparable$instance, System_Runtime_Serialization_Internal.ISerializable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlGuid = SqlGuid$instance & __SqlGuid$views;


export class SqlInt16$instance {
    constructor(value: short);
    readonly IsNull: boolean;
    readonly Value: short;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlInt16): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlInt16): boolean;
    GetHashCode(): int;
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlInt16;
    static readonly Zero: SqlInt16;
    static readonly MinValue: SqlInt16;
    static readonly MaxValue: SqlInt16;
    static Add(x: SqlInt16, y: SqlInt16): SqlInt16;
    static BitwiseAnd(x: SqlInt16, y: SqlInt16): SqlInt16;
    static BitwiseOr(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Divide(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Equals(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static GreaterThanOrEqual(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static LessThan(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static LessThanOrEqual(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static Mod(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Modulus(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Multiply(x: SqlInt16, y: SqlInt16): SqlInt16;
    static NotEquals(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static OnesComplement(x: SqlInt16): SqlInt16;
    static Parse(s: string): SqlInt16;
    static Subtract(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Xor(x: SqlInt16, y: SqlInt16): SqlInt16;
}


export interface __SqlInt16$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlInt16>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt16): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlInt16$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlInt16 = SqlInt16$instance & __SqlInt16$views;


export class SqlInt32$instance {
    constructor(value: int);
    readonly IsNull: boolean;
    readonly Value: int;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlInt32): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlInt32): boolean;
    GetHashCode(): int;
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlInt16(): SqlInt16;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlInt32;
    static readonly Zero: SqlInt32;
    static readonly MinValue: SqlInt32;
    static readonly MaxValue: SqlInt32;
    static Add(x: SqlInt32, y: SqlInt32): SqlInt32;
    static BitwiseAnd(x: SqlInt32, y: SqlInt32): SqlInt32;
    static BitwiseOr(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Divide(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Equals(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static GreaterThanOrEqual(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static LessThan(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static LessThanOrEqual(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static Mod(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Modulus(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Multiply(x: SqlInt32, y: SqlInt32): SqlInt32;
    static NotEquals(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static OnesComplement(x: SqlInt32): SqlInt32;
    static Parse(s: string): SqlInt32;
    static Subtract(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Xor(x: SqlInt32, y: SqlInt32): SqlInt32;
}


export interface __SqlInt32$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlInt32>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt32): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlInt32$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlInt32 = SqlInt32$instance & __SqlInt32$views;


export class SqlInt64$instance {
    constructor(value: long);
    readonly IsNull: boolean;
    readonly Value: long;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlInt64): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlInt64): boolean;
    GetHashCode(): int;
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlInt64;
    static readonly Zero: SqlInt64;
    static readonly MinValue: SqlInt64;
    static readonly MaxValue: SqlInt64;
    static Add(x: SqlInt64, y: SqlInt64): SqlInt64;
    static BitwiseAnd(x: SqlInt64, y: SqlInt64): SqlInt64;
    static BitwiseOr(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Divide(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Equals(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static GreaterThanOrEqual(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static LessThan(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static LessThanOrEqual(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static Mod(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Modulus(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Multiply(x: SqlInt64, y: SqlInt64): SqlInt64;
    static NotEquals(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static OnesComplement(x: SqlInt64): SqlInt64;
    static Parse(s: string): SqlInt64;
    static Subtract(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Xor(x: SqlInt64, y: SqlInt64): SqlInt64;
}


export interface __SqlInt64$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlInt64>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt64): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlInt64$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlInt64 = SqlInt64$instance & __SqlInt64$views;


export class SqlMoney$instance {
    constructor(value: int);
    constructor(value: long);
    constructor(value: decimal);
    constructor(value: double);
    readonly IsNull: boolean;
    readonly Value: decimal;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlMoney): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlMoney): boolean;
    GetHashCode(): int;
    GetTdsValue(): long;
    ToDecimal(): decimal;
    ToDouble(): double;
    ToInt32(): int;
    ToInt64(): long;
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlSingle(): SqlSingle;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlMoney;
    static readonly Zero: SqlMoney;
    static readonly MinValue: SqlMoney;
    static readonly MaxValue: SqlMoney;
    static Add(x: SqlMoney, y: SqlMoney): SqlMoney;
    static Divide(x: SqlMoney, y: SqlMoney): SqlMoney;
    static Equals(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static FromTdsValue(value: long): SqlMoney;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static GreaterThanOrEqual(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static LessThan(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static LessThanOrEqual(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static Multiply(x: SqlMoney, y: SqlMoney): SqlMoney;
    static NotEquals(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static Parse(s: string): SqlMoney;
    static Subtract(x: SqlMoney, y: SqlMoney): SqlMoney;
}


export interface __SqlMoney$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlMoney>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlMoney): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlMoney$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlMoney = SqlMoney$instance & __SqlMoney$views;


export class SqlSingle$instance {
    constructor(value: float);
    constructor(value: double);
    readonly IsNull: boolean;
    readonly Value: float;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlSingle): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlSingle): boolean;
    GetHashCode(): int;
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlString(): SqlString;
    ToString(): string;
    static readonly Null: SqlSingle;
    static readonly Zero: SqlSingle;
    static readonly MinValue: SqlSingle;
    static readonly MaxValue: SqlSingle;
    static Add(x: SqlSingle, y: SqlSingle): SqlSingle;
    static Divide(x: SqlSingle, y: SqlSingle): SqlSingle;
    static Equals(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static GreaterThanOrEqual(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static LessThan(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static LessThanOrEqual(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static Multiply(x: SqlSingle, y: SqlSingle): SqlSingle;
    static NotEquals(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static Parse(s: string): SqlSingle;
    static Subtract(x: SqlSingle, y: SqlSingle): SqlSingle;
}


export interface __SqlSingle$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlSingle>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlSingle): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlSingle$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlSingle = SqlSingle$instance & __SqlSingle$views;


export class SqlString$instance {
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[], index: int, count: int, fUnicode: boolean);
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[], fUnicode: boolean);
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[], index: int, count: int);
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[]);
    constructor(data: string, lcid: int, compareOptions: SqlCompareOptions);
    constructor(data: string, lcid: int);
    constructor(data: string);
    readonly CompareInfo: CompareInfo;
    readonly CultureInfo: CultureInfo;
    readonly IsNull: boolean;
    readonly LCID: int;
    readonly SqlCompareOptions: SqlCompareOptions;
    readonly Value: string;
    Clone(): SqlString;
    CompareTo(value: unknown): int;
    CompareTo(value: SqlString): int;
    Equals(value: unknown): boolean;
    Equals(other: SqlString): boolean;
    GetHashCode(): int;
    GetNonUnicodeBytes(): byte[];
    GetUnicodeBytes(): byte[];
    ToSqlBoolean(): SqlBoolean;
    ToSqlByte(): SqlByte;
    ToSqlDateTime(): SqlDateTime;
    ToSqlDecimal(): SqlDecimal;
    ToSqlDouble(): SqlDouble;
    ToSqlGuid(): SqlGuid;
    ToSqlInt16(): SqlInt16;
    ToSqlInt32(): SqlInt32;
    ToSqlInt64(): SqlInt64;
    ToSqlMoney(): SqlMoney;
    ToSqlSingle(): SqlSingle;
    ToString(): string;
    static readonly Null: SqlString;
    static readonly IgnoreCase: int;
    static readonly IgnoreWidth: int;
    static readonly IgnoreNonSpace: int;
    static readonly IgnoreKanaType: int;
    static readonly BinarySort: int;
    static readonly BinarySort2: int;
    static Add(x: SqlString, y: SqlString): SqlString;
    static CompareOptionsFromSqlCompareOptions(compareOptions: SqlCompareOptions): CompareOptions;
    static Concat(x: SqlString, y: SqlString): SqlString;
    static Equals(x: SqlString, y: SqlString): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlString, y: SqlString): SqlBoolean;
    static GreaterThanOrEqual(x: SqlString, y: SqlString): SqlBoolean;
    static LessThan(x: SqlString, y: SqlString): SqlBoolean;
    static LessThanOrEqual(x: SqlString, y: SqlString): SqlBoolean;
    static NotEquals(x: SqlString, y: SqlString): SqlBoolean;
}


export interface __SqlString$views {
    As_INullable(): INullable$instance;
    As_IComparable(): System_Internal.IComparable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SqlString>;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlString): boolean;
    CompareTo(obj: unknown): int;
}

export interface SqlString$instance extends INullable$instance, System_Internal.IComparable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlString = SqlString$instance & __SqlString$views;


export class SqlAlreadyFilledException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlAlreadyFilledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlAlreadyFilledException = SqlAlreadyFilledException$instance & __SqlAlreadyFilledException$views;


export class SqlBytes$instance {
    constructor();
    constructor(buffer: byte[]);
    constructor(value: SqlBinary);
    constructor(s: Stream);
    readonly Buffer: byte[];
    readonly IsNull: boolean;
    Item: byte;
    readonly Length: long;
    readonly MaxLength: long;
    readonly Storage: StorageState;
    Stream: Stream;
    readonly Value: byte[];
    Read(offset: long, buffer: byte[], offsetInBuffer: int, count: int): long;
    SetLength(value: long): void;
    SetNull(): void;
    ToSqlBinary(): SqlBinary;
    Write(offset: long, buffer: byte[], offsetInBuffer: int, count: int): void;
    static readonly Null: SqlBytes;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
}


export interface __SqlBytes$views {
    As_INullable(): INullable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface SqlBytes$instance extends INullable$instance, System_Runtime_Serialization_Internal.ISerializable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlBytes = SqlBytes$instance & __SqlBytes$views;


export class SqlChars$instance {
    constructor();
    constructor(buffer: char[]);
    constructor(value: SqlString);
    readonly Buffer: char[];
    readonly IsNull: boolean;
    Item: char;
    readonly Length: long;
    readonly MaxLength: long;
    readonly Storage: StorageState;
    readonly Value: char[];
    Read(offset: long, buffer: char[], offsetInBuffer: int, count: int): long;
    SetLength(value: long): void;
    SetNull(): void;
    ToSqlString(): SqlString;
    Write(offset: long, buffer: char[], offsetInBuffer: int, count: int): void;
    static readonly Null: SqlChars;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
}


export interface __SqlChars$views {
    As_INullable(): INullable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface SqlChars$instance extends INullable$instance, System_Runtime_Serialization_Internal.ISerializable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlChars = SqlChars$instance & __SqlChars$views;


export class SqlNotFilledException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlNotFilledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlNotFilledException = SqlNotFilledException$instance & __SqlNotFilledException$views;


export class SqlNullValueException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlNullValueException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlNullValueException = SqlNullValueException$instance & __SqlNullValueException$views;


export class SqlTruncateException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlTruncateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlTruncateException = SqlTruncateException$instance & __SqlTruncateException$views;


export class SqlTypeException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlTypeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlTypeException = SqlTypeException$instance & __SqlTypeException$views;


export class SqlXml$instance {
    constructor();
    constructor(value: XmlReader);
    constructor(value: Stream);
    readonly IsNull: boolean;
    readonly Value: string;
    CreateReader(): XmlReader;
    static readonly Null: SqlXml;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
}


export interface __SqlXml$views {
    As_INullable(): INullable$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface SqlXml$instance extends INullable$instance, System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type SqlXml = SqlXml$instance & __SqlXml$views;


