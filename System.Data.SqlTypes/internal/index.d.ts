// Generated by tsbindgen - Architecture
// Namespace: System.Data.SqlTypes
// Assembly: System.Data.Common

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CompareInfo, CompareOptions, CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { XmlSchema, XmlSchemaSet } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import type { XmlQualifiedName, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Enum, Exception, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, Span_1, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt32, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum SqlCompareOptions {
    none = 0,
    ignoreCase = 1,
    ignoreNonSpace = 2,
    ignoreKanaType = 8,
    ignoreWidth = 16,
    binarySort = 32768,
    binarySort2 = 16384
}


export enum StorageState {
    buffer = 0,
    stream = 1,
    unmanagedBuffer = 2
}


export interface INullable$instance {
    readonly IsNull: boolean;
}


export type INullable = INullable$instance;

export class SqlBinary$instance {
    constructor(value: byte[]);
    readonly isNull: boolean;
    readonly item: byte;
    readonly length: int;
    readonly value: byte[];
    compareTo(value: any): int;
    compareTo(value: SqlBinary): int;
    equals(value: any): boolean;
    equals(other: SqlBinary): boolean;
    getHashCode(): int;
    toSqlGuid(): SqlGuid;
    toString(): string;
    static readonly null_: SqlBinary;
    static Add(x: SqlBinary, y: SqlBinary): SqlBinary;
    static Concat(x: SqlBinary, y: SqlBinary): SqlBinary;
    static Equals(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static GreaterThanOrEqual(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static LessThan(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static LessThanOrEqual(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static NotEquals(x: SqlBinary, y: SqlBinary): SqlBoolean;
    static WrapBytes(bytes: byte[]): SqlBinary;
}


export interface __SqlBinary$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlBinary>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlBinary): boolean;
    CompareTo(obj: any): int;
}

export type SqlBinary = SqlBinary$instance & __SqlBinary$views;


export class SqlBoolean$instance {
    constructor(value: boolean);
    constructor(value: int);
    readonly byteValue: byte;
    readonly isFalse: boolean;
    readonly isNull: boolean;
    readonly isTrue: boolean;
    readonly value: boolean;
    compareTo(value: any): int;
    compareTo(value: SqlBoolean): int;
    equals(value: any): boolean;
    equals(other: SqlBoolean): boolean;
    getHashCode(): int;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    static readonly true_: SqlBoolean;
    static readonly false_: SqlBoolean;
    static readonly null_: SqlBoolean;
    static readonly zero: SqlBoolean;
    static readonly one: SqlBoolean;
    static And(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static Equals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static GreaterThanOrEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static LessThan(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static LessThanOrEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static NotEquals(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static OnesComplement(x: SqlBoolean): SqlBoolean;
    static Or(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
    static Parse(s: string): SqlBoolean;
    static Xor(x: SqlBoolean, y: SqlBoolean): SqlBoolean;
}


export interface __SqlBoolean$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlBoolean>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlBoolean): boolean;
    CompareTo(obj: any): int;
}

export type SqlBoolean = SqlBoolean$instance & __SqlBoolean$views;


export class SqlByte$instance {
    constructor(value: byte);
    readonly isNull: boolean;
    readonly value: byte;
    compareTo(value: any): int;
    compareTo(value: SqlByte): int;
    equals(value: any): boolean;
    equals(other: SqlByte): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlByte;
    static readonly zero: SqlByte;
    static readonly minValue: SqlByte;
    static readonly maxValue: SqlByte;
    static Add(x: SqlByte, y: SqlByte): SqlByte;
    static BitwiseAnd(x: SqlByte, y: SqlByte): SqlByte;
    static BitwiseOr(x: SqlByte, y: SqlByte): SqlByte;
    static Divide(x: SqlByte, y: SqlByte): SqlByte;
    static Equals(x: SqlByte, y: SqlByte): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlByte, y: SqlByte): SqlBoolean;
    static GreaterThanOrEqual(x: SqlByte, y: SqlByte): SqlBoolean;
    static LessThan(x: SqlByte, y: SqlByte): SqlBoolean;
    static LessThanOrEqual(x: SqlByte, y: SqlByte): SqlBoolean;
    static Mod(x: SqlByte, y: SqlByte): SqlByte;
    static Modulus(x: SqlByte, y: SqlByte): SqlByte;
    static Multiply(x: SqlByte, y: SqlByte): SqlByte;
    static NotEquals(x: SqlByte, y: SqlByte): SqlBoolean;
    static OnesComplement(x: SqlByte): SqlByte;
    static Parse(s: string): SqlByte;
    static Subtract(x: SqlByte, y: SqlByte): SqlByte;
    static Xor(x: SqlByte, y: SqlByte): SqlByte;
}


export interface __SqlByte$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlByte>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlByte): boolean;
    CompareTo(obj: any): int;
}

export type SqlByte = SqlByte$instance & __SqlByte$views;


export class SqlDateTime$instance {
    constructor(value: DateTime);
    constructor(year: int, month: int, day: int);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: double);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, bilisecond: int);
    constructor(dayTicks: int, timeTicks: int);
    readonly dayTicks: int;
    readonly isNull: boolean;
    readonly timeTicks: int;
    readonly value: DateTime;
    compareTo(value: any): int;
    compareTo(value: SqlDateTime): int;
    equals(value: any): boolean;
    equals(other: SqlDateTime): boolean;
    getHashCode(): int;
    toSqlString(): SqlString;
    toString(): string;
    static readonly sqlTicksPerSecond: int;
    static readonly sqlTicksPerMinute: int;
    static readonly sqlTicksPerHour: int;
    static readonly minValue: SqlDateTime;
    static readonly maxValue: SqlDateTime;
    static readonly null_: SqlDateTime;
    static Add(x: SqlDateTime, t: TimeSpan): SqlDateTime;
    static Equals(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static GreaterThanOrEqual(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static LessThan(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static LessThanOrEqual(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static NotEquals(x: SqlDateTime, y: SqlDateTime): SqlBoolean;
    static Parse(s: string): SqlDateTime;
    static Subtract(x: SqlDateTime, t: TimeSpan): SqlDateTime;
}


export interface __SqlDateTime$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlDateTime>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDateTime): boolean;
    CompareTo(obj: any): int;
}

export type SqlDateTime = SqlDateTime$instance & __SqlDateTime$views;


export class SqlDecimal$instance {
    constructor(value: decimal);
    constructor(value: int);
    constructor(value: long);
    constructor(bPrecision: byte, bScale: byte, fPositive: boolean, bits: int[]);
    constructor(bPrecision: byte, bScale: byte, fPositive: boolean, data1: int, data2: int, data3: int, data4: int);
    constructor(dVal: double);
    readonly binData: byte[];
    readonly data: int[];
    readonly isNull: boolean;
    readonly isPositive: boolean;
    readonly precision: byte;
    readonly scale: byte;
    readonly value: decimal;
    compareTo(value: any): int;
    compareTo(value: SqlDecimal): int;
    equals(value: any): boolean;
    equals(other: SqlDecimal): boolean;
    getHashCode(): int;
    toDouble(): double;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    writeTdsValue(destination: Span_1<CLROf<uint>>): int;
    static readonly maxPrecision: byte;
    static readonly maxScale: byte;
    static readonly null_: SqlDecimal;
    static readonly minValue: SqlDecimal;
    static readonly maxValue: SqlDecimal;
    static Abs(n: SqlDecimal): SqlDecimal;
    static Add(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static AdjustScale(n: SqlDecimal, digits: int, fRound: boolean): SqlDecimal;
    static Ceiling(n: SqlDecimal): SqlDecimal;
    static ConvertToPrecScale(n: SqlDecimal, precision: int, scale: int): SqlDecimal;
    static Divide(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static Equals(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static Floor(n: SqlDecimal): SqlDecimal;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static GreaterThanOrEqual(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static LessThan(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static LessThanOrEqual(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static Multiply(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static NotEquals(x: SqlDecimal, y: SqlDecimal): SqlBoolean;
    static Parse(s: string): SqlDecimal;
    static Power(n: SqlDecimal, exp: double): SqlDecimal;
    static Round(n: SqlDecimal, position: int): SqlDecimal;
    static Sign(n: SqlDecimal): SqlInt32;
    static Subtract(x: SqlDecimal, y: SqlDecimal): SqlDecimal;
    static Truncate(n: SqlDecimal, position: int): SqlDecimal;
}


export interface __SqlDecimal$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlDecimal>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDecimal): boolean;
    CompareTo(obj: any): int;
}

export type SqlDecimal = SqlDecimal$instance & __SqlDecimal$views;


export class SqlDouble$instance {
    constructor(value: double);
    readonly isNull: boolean;
    readonly value: double;
    compareTo(value: any): int;
    compareTo(value: SqlDouble): int;
    equals(value: any): boolean;
    equals(other: SqlDouble): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlDouble;
    static readonly zero: SqlDouble;
    static readonly minValue: SqlDouble;
    static readonly maxValue: SqlDouble;
    static Add(x: SqlDouble, y: SqlDouble): SqlDouble;
    static Divide(x: SqlDouble, y: SqlDouble): SqlDouble;
    static Equals(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static GreaterThanOrEqual(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static LessThan(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static LessThanOrEqual(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static Multiply(x: SqlDouble, y: SqlDouble): SqlDouble;
    static NotEquals(x: SqlDouble, y: SqlDouble): SqlBoolean;
    static Parse(s: string): SqlDouble;
    static Subtract(x: SqlDouble, y: SqlDouble): SqlDouble;
}


export interface __SqlDouble$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlDouble>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlDouble): boolean;
    CompareTo(obj: any): int;
}

export type SqlDouble = SqlDouble$instance & __SqlDouble$views;


export class SqlGuid$instance {
    constructor(value: byte[]);
    constructor(s: string);
    constructor(g: Guid);
    constructor(a: int, b: short, c: short, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte);
    readonly isNull: boolean;
    readonly value: Guid;
    compareTo(value: any): int;
    compareTo(value: SqlGuid): int;
    equals(value: any): boolean;
    equals(other: SqlGuid): boolean;
    getHashCode(): int;
    toByteArray(): byte[];
    toSqlBinary(): SqlBinary;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlGuid;
    static Equals(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static GreaterThanOrEqual(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static LessThan(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static LessThanOrEqual(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static NotEquals(x: SqlGuid, y: SqlGuid): SqlBoolean;
    static Parse(s: string): SqlGuid;
}


export interface __SqlGuid$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlGuid>;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlGuid): boolean;
    CompareTo(obj: any): int;
}

export type SqlGuid = SqlGuid$instance & __SqlGuid$views;


export class SqlInt16$instance {
    constructor(value: short);
    readonly isNull: boolean;
    readonly value: short;
    compareTo(value: any): int;
    compareTo(value: SqlInt16): int;
    equals(value: any): boolean;
    equals(other: SqlInt16): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlInt16;
    static readonly zero: SqlInt16;
    static readonly minValue: SqlInt16;
    static readonly maxValue: SqlInt16;
    static Add(x: SqlInt16, y: SqlInt16): SqlInt16;
    static BitwiseAnd(x: SqlInt16, y: SqlInt16): SqlInt16;
    static BitwiseOr(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Divide(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Equals(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static GreaterThanOrEqual(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static LessThan(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static LessThanOrEqual(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static Mod(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Modulus(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Multiply(x: SqlInt16, y: SqlInt16): SqlInt16;
    static NotEquals(x: SqlInt16, y: SqlInt16): SqlBoolean;
    static OnesComplement(x: SqlInt16): SqlInt16;
    static Parse(s: string): SqlInt16;
    static Subtract(x: SqlInt16, y: SqlInt16): SqlInt16;
    static Xor(x: SqlInt16, y: SqlInt16): SqlInt16;
}


export interface __SqlInt16$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlInt16>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt16): boolean;
    CompareTo(obj: any): int;
}

export type SqlInt16 = SqlInt16$instance & __SqlInt16$views;


export class SqlInt32$instance {
    constructor(value: int);
    readonly isNull: boolean;
    readonly value: int;
    compareTo(value: any): int;
    compareTo(value: SqlInt32): int;
    equals(value: any): boolean;
    equals(other: SqlInt32): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlInt32;
    static readonly zero: SqlInt32;
    static readonly minValue: SqlInt32;
    static readonly maxValue: SqlInt32;
    static Add(x: SqlInt32, y: SqlInt32): SqlInt32;
    static BitwiseAnd(x: SqlInt32, y: SqlInt32): SqlInt32;
    static BitwiseOr(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Divide(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Equals(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static GreaterThanOrEqual(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static LessThan(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static LessThanOrEqual(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static Mod(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Modulus(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Multiply(x: SqlInt32, y: SqlInt32): SqlInt32;
    static NotEquals(x: SqlInt32, y: SqlInt32): SqlBoolean;
    static OnesComplement(x: SqlInt32): SqlInt32;
    static Parse(s: string): SqlInt32;
    static Subtract(x: SqlInt32, y: SqlInt32): SqlInt32;
    static Xor(x: SqlInt32, y: SqlInt32): SqlInt32;
}


export interface __SqlInt32$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlInt32>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt32): boolean;
    CompareTo(obj: any): int;
}

export type SqlInt32 = SqlInt32$instance & __SqlInt32$views;


export class SqlInt64$instance {
    constructor(value: long);
    readonly isNull: boolean;
    readonly value: long;
    compareTo(value: any): int;
    compareTo(value: SqlInt64): int;
    equals(value: any): boolean;
    equals(other: SqlInt64): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlInt64;
    static readonly zero: SqlInt64;
    static readonly minValue: SqlInt64;
    static readonly maxValue: SqlInt64;
    static Add(x: SqlInt64, y: SqlInt64): SqlInt64;
    static BitwiseAnd(x: SqlInt64, y: SqlInt64): SqlInt64;
    static BitwiseOr(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Divide(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Equals(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static GreaterThanOrEqual(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static LessThan(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static LessThanOrEqual(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static Mod(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Modulus(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Multiply(x: SqlInt64, y: SqlInt64): SqlInt64;
    static NotEquals(x: SqlInt64, y: SqlInt64): SqlBoolean;
    static OnesComplement(x: SqlInt64): SqlInt64;
    static Parse(s: string): SqlInt64;
    static Subtract(x: SqlInt64, y: SqlInt64): SqlInt64;
    static Xor(x: SqlInt64, y: SqlInt64): SqlInt64;
}


export interface __SqlInt64$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlInt64>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlInt64): boolean;
    CompareTo(obj: any): int;
}

export type SqlInt64 = SqlInt64$instance & __SqlInt64$views;


export class SqlMoney$instance {
    constructor(value: int);
    constructor(value: long);
    constructor(value: decimal);
    constructor(value: double);
    readonly isNull: boolean;
    readonly value: decimal;
    compareTo(value: any): int;
    compareTo(value: SqlMoney): int;
    equals(value: any): boolean;
    equals(other: SqlMoney): boolean;
    getHashCode(): int;
    getTdsValue(): long;
    toDecimal(): decimal;
    toDouble(): double;
    toInt32(): int;
    toInt64(): long;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlSingle(): SqlSingle;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlMoney;
    static readonly zero: SqlMoney;
    static readonly minValue: SqlMoney;
    static readonly maxValue: SqlMoney;
    static Add(x: SqlMoney, y: SqlMoney): SqlMoney;
    static Divide(x: SqlMoney, y: SqlMoney): SqlMoney;
    static Equals(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static FromTdsValue(value: long): SqlMoney;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static GreaterThanOrEqual(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static LessThan(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static LessThanOrEqual(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static Multiply(x: SqlMoney, y: SqlMoney): SqlMoney;
    static NotEquals(x: SqlMoney, y: SqlMoney): SqlBoolean;
    static Parse(s: string): SqlMoney;
    static Subtract(x: SqlMoney, y: SqlMoney): SqlMoney;
}


export interface __SqlMoney$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlMoney>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlMoney): boolean;
    CompareTo(obj: any): int;
}

export type SqlMoney = SqlMoney$instance & __SqlMoney$views;


export class SqlSingle$instance {
    constructor(value: float);
    constructor(value: double);
    readonly isNull: boolean;
    readonly value: float;
    compareTo(value: any): int;
    compareTo(value: SqlSingle): int;
    equals(value: any): boolean;
    equals(other: SqlSingle): boolean;
    getHashCode(): int;
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlString(): SqlString;
    toString(): string;
    static readonly null_: SqlSingle;
    static readonly zero: SqlSingle;
    static readonly minValue: SqlSingle;
    static readonly maxValue: SqlSingle;
    static Add(x: SqlSingle, y: SqlSingle): SqlSingle;
    static Divide(x: SqlSingle, y: SqlSingle): SqlSingle;
    static Equals(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static GreaterThanOrEqual(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static LessThan(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static LessThanOrEqual(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static Multiply(x: SqlSingle, y: SqlSingle): SqlSingle;
    static NotEquals(x: SqlSingle, y: SqlSingle): SqlBoolean;
    static Parse(s: string): SqlSingle;
    static Subtract(x: SqlSingle, y: SqlSingle): SqlSingle;
}


export interface __SqlSingle$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlSingle>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlSingle): boolean;
    CompareTo(obj: any): int;
}

export type SqlSingle = SqlSingle$instance & __SqlSingle$views;


export class SqlString$instance {
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[], index: int, count: int, fUnicode: boolean);
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[], fUnicode: boolean);
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[], index: int, count: int);
    constructor(lcid: int, compareOptions: SqlCompareOptions, data: byte[]);
    constructor(data: string, lcid: int, compareOptions: SqlCompareOptions);
    constructor(data: string, lcid: int);
    constructor(data: string);
    readonly compareInfo: CompareInfo;
    readonly cultureInfo: CultureInfo;
    readonly isNull: boolean;
    readonly lcid: int;
    readonly sqlCompareOptions: SqlCompareOptions;
    readonly value: string;
    clone(): SqlString;
    compareTo(value: any): int;
    compareTo(value: SqlString): int;
    equals(value: any): boolean;
    equals(other: SqlString): boolean;
    getHashCode(): int;
    getNonUnicodeBytes(): byte[];
    getUnicodeBytes(): byte[];
    toSqlBoolean(): SqlBoolean;
    toSqlByte(): SqlByte;
    toSqlDateTime(): SqlDateTime;
    toSqlDecimal(): SqlDecimal;
    toSqlDouble(): SqlDouble;
    toSqlGuid(): SqlGuid;
    toSqlInt16(): SqlInt16;
    toSqlInt32(): SqlInt32;
    toSqlInt64(): SqlInt64;
    toSqlMoney(): SqlMoney;
    toSqlSingle(): SqlSingle;
    toString(): string;
    static readonly null_: SqlString;
    static readonly ignoreCase: int;
    static readonly ignoreWidth: int;
    static readonly ignoreNonSpace: int;
    static readonly ignoreKanaType: int;
    static readonly binarySort: int;
    static readonly binarySort2: int;
    static Add(x: SqlString, y: SqlString): SqlString;
    static CompareOptionsFromSqlCompareOptions(compareOptions: SqlCompareOptions): CompareOptions;
    static Concat(x: SqlString, y: SqlString): SqlString;
    static Equals(x: SqlString, y: SqlString): SqlBoolean;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
    static GreaterThan(x: SqlString, y: SqlString): SqlBoolean;
    static GreaterThanOrEqual(x: SqlString, y: SqlString): SqlBoolean;
    static LessThan(x: SqlString, y: SqlString): SqlBoolean;
    static LessThanOrEqual(x: SqlString, y: SqlString): SqlBoolean;
    static NotEquals(x: SqlString, y: SqlString): SqlBoolean;
}


export interface __SqlString$views {
    readonly As_INullable: INullable$instance;
    readonly As_IComparable: System_Internal.IComparable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SqlString>;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: SqlString): boolean;
    CompareTo(obj: any): int;
}

export type SqlString = SqlString$instance & __SqlString$views;


export class SqlAlreadyFilledException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlAlreadyFilledException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlAlreadyFilledException = SqlAlreadyFilledException$instance & __SqlAlreadyFilledException$views;


export class SqlBytes$instance {
    constructor();
    constructor(buffer: byte[]);
    constructor(value: SqlBinary);
    constructor(s: Stream);
    readonly buffer: byte[];
    readonly isNull: boolean;
    item: byte;
    readonly length: long;
    readonly maxLength: long;
    readonly storage: StorageState;
    stream: Stream;
    readonly value: byte[];
    read(offset: long, buffer: byte[], offsetInBuffer: int, count: int): long;
    setLength(value: long): void;
    setNull(): void;
    toSqlBinary(): SqlBinary;
    write(offset: long, buffer: byte[], offsetInBuffer: int, count: int): void;
    static readonly Null: SqlBytes;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
}


export interface __SqlBytes$views {
    readonly As_INullable: INullable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export type SqlBytes = SqlBytes$instance & __SqlBytes$views;


export class SqlChars$instance {
    constructor();
    constructor(buffer: string[]);
    constructor(value: SqlString);
    readonly buffer: string[];
    readonly isNull: boolean;
    item: string;
    readonly length: long;
    readonly maxLength: long;
    readonly storage: StorageState;
    readonly value: string[];
    read(offset: long, buffer: string[], offsetInBuffer: int, count: int): long;
    setLength(value: long): void;
    setNull(): void;
    toSqlString(): SqlString;
    write(offset: long, buffer: string[], offsetInBuffer: int, count: int): void;
    static readonly Null: SqlChars;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
}


export interface __SqlChars$views {
    readonly As_INullable: INullable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export type SqlChars = SqlChars$instance & __SqlChars$views;


export class SqlNotFilledException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlNotFilledException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlNotFilledException = SqlNotFilledException$instance & __SqlNotFilledException$views;


export class SqlNullValueException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlNullValueException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlNullValueException = SqlNullValueException$instance & __SqlNullValueException$views;


export class SqlTruncateException$instance extends SqlTypeException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlTruncateException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlTruncateException = SqlTruncateException$instance & __SqlTruncateException$views;


export class SqlTypeException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, e: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SqlTypeException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SqlTypeException = SqlTypeException$instance & __SqlTypeException$views;


export class SqlXml$instance {
    constructor();
    constructor(value: XmlReader);
    constructor(value: Stream);
    readonly isNull: boolean;
    readonly value: string;
    createReader(): XmlReader;
    static readonly Null: SqlXml;
    static GetXsdType(schemaSet: XmlSchemaSet): XmlQualifiedName;
}


export interface __SqlXml$views {
    readonly As_INullable: INullable$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export type SqlXml = SqlXml$instance & __SqlXml$views;


