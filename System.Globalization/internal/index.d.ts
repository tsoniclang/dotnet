// Generated by tsbindgen - Architecture
// Namespace: System.Globalization
// Assembly: System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Assembly, MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Rune } from "../../System.Text/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, DateOnly, DateTime, DayOfWeek, Double, Enum, Exception, Guid, ICloneable, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlySpan_1, Span_1, String as ClrString, StringComparer, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CalendarAlgorithmType {
    Unknown = 0,
    SolarCalendar = 1,
    LunarCalendar = 2,
    LunisolarCalendar = 3
}


export enum CalendarWeekRule {
    FirstDay = 0,
    FirstFullWeek = 1,
    FirstFourDayWeek = 2
}


export enum CompareOptions {
    None = 0,
    IgnoreCase = 1,
    IgnoreNonSpace = 2,
    IgnoreSymbols = 4,
    IgnoreKanaType = 8,
    IgnoreWidth = 16,
    NumericOrdering = 32,
    OrdinalIgnoreCase = 268435456,
    StringSort = 536870912,
    Ordinal = 1073741824
}


export enum CultureTypes {
    NeutralCultures = 1,
    SpecificCultures = 2,
    InstalledWin32Cultures = 4,
    AllCultures = 7,
    UserCustomCulture = 8,
    ReplacementCultures = 16,
    WindowsOnlyCultures = 32,
    FrameworkCultures = 64
}


export enum DateTimeStyles {
    None = 0,
    AllowLeadingWhite = 1,
    AllowTrailingWhite = 2,
    AllowInnerWhite = 4,
    AllowWhiteSpaces = 7,
    NoCurrentDateDefault = 8,
    AdjustToUniversal = 16,
    AssumeLocal = 32,
    AssumeUniversal = 64,
    RoundtripKind = 128
}


export enum DigitShapes {
    Context = 0,
    None = 1,
    NativeNational = 2
}


export enum GregorianCalendarTypes {
    Localized = 1,
    USEnglish = 2,
    MiddleEastFrench = 9,
    Arabic = 10,
    TransliteratedEnglish = 11,
    TransliteratedFrench = 12
}


export enum NumberStyles {
    None = 0,
    AllowLeadingWhite = 1,
    AllowTrailingWhite = 2,
    AllowLeadingSign = 4,
    AllowTrailingSign = 8,
    AllowParentheses = 16,
    AllowDecimalPoint = 32,
    AllowThousands = 64,
    AllowExponent = 128,
    AllowCurrencySymbol = 256,
    AllowHexSpecifier = 512,
    AllowBinarySpecifier = 1024,
    Integer = 7,
    HexNumber = 515,
    BinaryNumber = 1027,
    Number = 111,
    Float = 167,
    Currency = 383,
    Any = 511
}


export enum TimeSpanStyles {
    None = 0,
    AssumeNegative = 1
}


export enum UnicodeCategory {
    UppercaseLetter = 0,
    LowercaseLetter = 1,
    TitlecaseLetter = 2,
    ModifierLetter = 3,
    OtherLetter = 4,
    NonSpacingMark = 5,
    SpacingCombiningMark = 6,
    EnclosingMark = 7,
    DecimalDigitNumber = 8,
    LetterNumber = 9,
    OtherNumber = 10,
    SpaceSeparator = 11,
    LineSeparator = 12,
    ParagraphSeparator = 13,
    Control = 14,
    Format = 15,
    Surrogate = 16,
    PrivateUse = 17,
    ConnectorPunctuation = 18,
    DashPunctuation = 19,
    OpenPunctuation = 20,
    ClosePunctuation = 21,
    InitialQuotePunctuation = 22,
    FinalQuotePunctuation = 23,
    OtherPunctuation = 24,
    MathSymbol = 25,
    CurrencySymbol = 26,
    ModifierSymbol = 27,
    OtherSymbol = 28,
    OtherNotAssigned = 29
}


export abstract class Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly IsReadOnly: boolean;
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddDays(time: DateTime, days: int): DateTime;
    AddHours(time: DateTime, hours: int): DateTime;
    AddMilliseconds(time: DateTime, milliseconds: double): DateTime;
    AddMinutes(time: DateTime, minutes: int): DateTime;
    abstract AddMonths(time: DateTime, months: int): DateTime;
    AddSeconds(time: DateTime, seconds: int): DateTime;
    AddWeeks(time: DateTime, weeks: int): DateTime;
    abstract AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    abstract GetDayOfMonth(time: DateTime): int;
    abstract GetDayOfWeek(time: DateTime): DayOfWeek;
    abstract GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetDaysInYear(year: int, era: int): int;
    abstract GetEra(time: DateTime): int;
    GetHour(time: DateTime): int;
    GetLeapMonth(year: int): int;
    GetLeapMonth(year: int, era: int): int;
    GetMilliseconds(time: DateTime): double;
    GetMinute(time: DateTime): int;
    abstract GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int): int;
    GetMonthsInYear(year: int, era: int): int;
    GetSecond(time: DateTime): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    abstract GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly CurrentEra: int;
    static ReadOnly(calendar: Calendar): Calendar;
}


export interface __Calendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type Calendar = Calendar$instance & __Calendar$views;


export class ChineseLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    constructor();
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): any;
    GetEra(time: DateTime): int;
    static readonly ChineseEra: int;
}


export interface __ChineseLunisolarCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ChineseLunisolarCalendar = ChineseLunisolarCalendar$instance & __ChineseLunisolarCalendar$views;


export class CompareInfo$instance {
    readonly LCID: int;
    readonly Name: string;
    readonly Version: SortVersion;
    Compare(string1: string, string2: string): int;
    Compare(string1: string, string2: string, options: CompareOptions): int;
    Compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int): int;
    Compare(string1: string, offset1: int, string2: string, offset2: int, options: CompareOptions): int;
    Compare(string1: string, offset1: int, string2: string, offset2: int): int;
    Compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int, options: CompareOptions): int;
    Compare(string1: ReadOnlySpan_1<CLROf<string>>, string2: ReadOnlySpan_1<CLROf<string>>, options?: CompareOptions): int;
    Equals(value: any): boolean;
    GetHashCode(): int;
    GetHashCode(source: string, options: CompareOptions): int;
    GetHashCode(source: ReadOnlySpan_1<CLROf<string>>, options: CompareOptions): int;
    GetSortKey(source: string, options: CompareOptions): SortKey;
    GetSortKey(source: string): SortKey;
    GetSortKey(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, options?: CompareOptions): int;
    GetSortKeyLength(source: ReadOnlySpan_1<CLROf<string>>, options?: CompareOptions): int;
    IndexOf(source: string, value: string): int;
    IndexOf(source: string, value: string): int;
    IndexOf(source: string, value: string, options: CompareOptions): int;
    IndexOf(source: string, value: string, options: CompareOptions): int;
    IndexOf(source: string, value: string, startIndex: int): int;
    IndexOf(source: string, value: string, startIndex: int): int;
    IndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    IndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    IndexOf(source: string, value: string, startIndex: int, count: int): int;
    IndexOf(source: string, value: string, startIndex: int, count: int): int;
    IndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    IndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    IndexOf(source: ReadOnlySpan_1<CLROf<string>>, value: ReadOnlySpan_1<CLROf<string>>, options?: CompareOptions): int;
    IndexOf(source: ReadOnlySpan_1<CLROf<string>>, value: ReadOnlySpan_1<CLROf<string>>, options: CompareOptions, matchLength: { value: ref<int> }): int;
    IndexOf(source: ReadOnlySpan_1<CLROf<string>>, value: Rune, options?: CompareOptions): int;
    IsPrefix(source: string, prefix: string, options: CompareOptions): boolean;
    IsPrefix(source: ReadOnlySpan_1<CLROf<string>>, prefix: ReadOnlySpan_1<CLROf<string>>, options?: CompareOptions): boolean;
    IsPrefix(source: ReadOnlySpan_1<CLROf<string>>, prefix: ReadOnlySpan_1<CLROf<string>>, options: CompareOptions, matchLength: { value: ref<int> }): boolean;
    IsPrefix(source: string, prefix: string): boolean;
    IsSuffix(source: string, suffix: string, options: CompareOptions): boolean;
    IsSuffix(source: ReadOnlySpan_1<CLROf<string>>, suffix: ReadOnlySpan_1<CLROf<string>>, options?: CompareOptions): boolean;
    IsSuffix(source: ReadOnlySpan_1<CLROf<string>>, suffix: ReadOnlySpan_1<CLROf<string>>, options: CompareOptions, matchLength: { value: ref<int> }): boolean;
    IsSuffix(source: string, suffix: string): boolean;
    LastIndexOf(source: string, value: string): int;
    LastIndexOf(source: string, value: string): int;
    LastIndexOf(source: string, value: string, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, startIndex: int): int;
    LastIndexOf(source: string, value: string, startIndex: int): int;
    LastIndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, startIndex: int, count: int): int;
    LastIndexOf(source: string, value: string, startIndex: int, count: int): int;
    LastIndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    LastIndexOf(source: ReadOnlySpan_1<CLROf<string>>, value: ReadOnlySpan_1<CLROf<string>>, options?: CompareOptions): int;
    LastIndexOf(source: ReadOnlySpan_1<CLROf<string>>, value: ReadOnlySpan_1<CLROf<string>>, options: CompareOptions, matchLength: { value: ref<int> }): int;
    LastIndexOf(source: ReadOnlySpan_1<CLROf<string>>, value: Rune, options?: CompareOptions): int;
    ToString(): string;
    static GetCompareInfo(culture: int, assembly: Assembly): CompareInfo;
    static GetCompareInfo(culture: int): CompareInfo;
    static GetCompareInfo(name: string, assembly: Assembly): CompareInfo;
    static GetCompareInfo(name: string): CompareInfo;
    static IsSortable(ch: string): boolean;
    static IsSortable(text: ReadOnlySpan_1<CLROf<string>>): boolean;
    static IsSortable(text: string): boolean;
    static IsSortable(value: Rune): boolean;
}


export interface __CompareInfo$views {
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
}

export type CompareInfo = CompareInfo$instance & __CompareInfo$views;


export class CultureInfo$instance {
    constructor(name: string);
    constructor(name: string, useUserOverride: boolean);
    constructor(culture: int);
    constructor(culture: int, useUserOverride: boolean);
    readonly Calendar: Calendar;
    readonly CompareInfo: CompareInfo;
    readonly CultureTypes: CultureTypes;
    DateTimeFormat: DateTimeFormatInfo;
    readonly DisplayName: string;
    readonly EnglishName: string;
    readonly IetfLanguageTag: string;
    readonly IsNeutralCulture: boolean;
    readonly IsReadOnly: boolean;
    readonly KeyboardLayoutId: int;
    readonly LCID: int;
    readonly Name: string;
    readonly NativeName: string;
    NumberFormat: NumberFormatInfo;
    readonly OptionalCalendars: Calendar[];
    readonly Parent: CultureInfo;
    readonly TextInfo: TextInfo;
    readonly ThreeLetterISOLanguageName: string;
    readonly ThreeLetterWindowsLanguageName: string;
    readonly TwoLetterISOLanguageName: string;
    readonly UseUserOverride: boolean;
    ClearCachedData(): void;
    Clone(): any;
    Equals(value: any): boolean;
    GetConsoleFallbackUICulture(): CultureInfo;
    GetFormat(formatType: Type): any;
    GetHashCode(): int;
    ToString(): string;
    static CurrentCulture: CultureInfo;
    static CurrentUICulture: CultureInfo;
    static readonly InstalledUICulture: CultureInfo;
    static DefaultThreadCurrentCulture: CultureInfo;
    static DefaultThreadCurrentUICulture: CultureInfo;
    static readonly InvariantCulture: CultureInfo;
    static CreateSpecificCulture(name: string): CultureInfo;
    static GetCultureInfo(culture: int): CultureInfo;
    static GetCultureInfo(name: string, predefinedOnly: boolean): CultureInfo;
    static GetCultureInfo(name: string, altName: string): CultureInfo;
    static GetCultureInfo(name: string): CultureInfo;
    static GetCultureInfoByIetfLanguageTag(name: string): CultureInfo;
    static GetCultures(types: CultureTypes): CultureInfo[];
    static ReadOnly(ci: CultureInfo): CultureInfo;
}


export interface __CultureInfo$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IFormatProvider: System_Internal.IFormatProvider$instance;
}

export type CultureInfo = CultureInfo$instance & __CultureInfo$views;


export class CultureNotFoundException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(paramName: string, message: string);
    constructor(message: string, innerException: Exception);
    constructor(paramName: string, invalidCultureName: string, message: string);
    constructor(message: string, invalidCultureName: string, innerException: Exception);
    constructor(message: string, invalidCultureId: int, innerException: Exception);
    constructor(paramName: string, invalidCultureId: int, message: string);
    readonly InvalidCultureId: Nullable_1<CLROf<int>>;
    readonly InvalidCultureName: string;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CultureNotFoundException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CultureNotFoundException = CultureNotFoundException$instance & __CultureNotFoundException$views;


export class DateTimeFormatInfo$instance {
    constructor();
    AbbreviatedDayNames: string[];
    AbbreviatedMonthGenitiveNames: string[];
    AbbreviatedMonthNames: string[];
    AMDesignator: string;
    Calendar: Calendar;
    CalendarWeekRule: CalendarWeekRule;
    DateSeparator: string;
    DayNames: string[];
    FirstDayOfWeek: DayOfWeek;
    FullDateTimePattern: string;
    readonly IsReadOnly: boolean;
    LongDatePattern: string;
    LongTimePattern: string;
    MonthDayPattern: string;
    MonthGenitiveNames: string[];
    MonthNames: string[];
    readonly NativeCalendarName: string;
    PMDesignator: string;
    readonly RFC1123Pattern: string;
    ShortDatePattern: string;
    ShortestDayNames: string[];
    ShortTimePattern: string;
    readonly SortableDateTimePattern: string;
    TimeSeparator: string;
    readonly UniversalSortableDateTimePattern: string;
    YearMonthPattern: string;
    Clone(): any;
    GetAbbreviatedDayName(dayofweek: DayOfWeek): string;
    GetAbbreviatedEraName(era: int): string;
    GetAbbreviatedMonthName(month: int): string;
    GetAllDateTimePatterns(): string[];
    GetAllDateTimePatterns(format: string): string[];
    GetDayName(dayofweek: DayOfWeek): string;
    GetEra(eraName: string): int;
    GetEraName(era: int): string;
    GetFormat(formatType: Type): any;
    GetMonthName(month: int): string;
    GetShortestDayName(dayOfWeek: DayOfWeek): string;
    SetAllDateTimePatterns(patterns: string[], format: string): void;
    static readonly InvariantInfo: DateTimeFormatInfo;
    static readonly CurrentInfo: DateTimeFormatInfo;
    static GetInstance(provider: IFormatProvider): DateTimeFormatInfo;
    static ReadOnly(dtfi: DateTimeFormatInfo): DateTimeFormatInfo;
}


export interface __DateTimeFormatInfo$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IFormatProvider: System_Internal.IFormatProvider$instance;
}

export type DateTimeFormatInfo = DateTimeFormatInfo$instance & __DateTimeFormatInfo$views;


export class DaylightTime$instance {
    constructor(start: DateTime, end: DateTime, delta: TimeSpan);
    readonly Delta: TimeSpan;
    readonly End: DateTime;
    readonly Start: DateTime;
}


export type DaylightTime = DaylightTime$instance;

export abstract class EastAsianLunisolarCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetCelestialStem(sexagenaryYear: int): int;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetSexagenaryYear(time: DateTime): int;
    GetTerrestrialBranch(sexagenaryYear: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export interface __EastAsianLunisolarCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type EastAsianLunisolarCalendar = EastAsianLunisolarCalendar$instance & __EastAsianLunisolarCalendar$views;


export class GregorianCalendar$instance extends Calendar$instance {
    constructor();
    constructor(type_: GregorianCalendarTypes);
    readonly AlgorithmType: CalendarAlgorithmType;
    CalendarType: GregorianCalendarTypes;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly ADEra: int;
}


export interface __GregorianCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type GregorianCalendar = GregorianCalendar$instance & __GregorianCalendar$views;


export class HebrewCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly HebrewEra: int;
}


export interface __HebrewCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type HebrewCalendar = HebrewCalendar$instance & __HebrewCalendar$views;


export class HijriCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    HijriAdjustment: int;
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly HijriEra: int;
}


export interface __HijriCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type HijriCalendar = HijriCalendar$instance & __HijriCalendar$views;


export class IdnMapping$instance {
    constructor();
    AllowUnassigned: boolean;
    UseStd3AsciiRules: boolean;
    Equals(obj: any): boolean;
    GetAscii(unicode: string): string;
    GetAscii(unicode: string, index: int): string;
    GetAscii(unicode: string, index: int, count: int): string;
    GetHashCode(): int;
    GetUnicode(ascii: string): string;
    GetUnicode(ascii: string, index: int): string;
    GetUnicode(ascii: string, index: int, count: int): string;
}


export type IdnMapping = IdnMapping$instance;

export class JapaneseCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export interface __JapaneseCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type JapaneseCalendar = JapaneseCalendar$instance & __JapaneseCalendar$views;


export class JapaneseLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    constructor();
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): any;
    GetEra(time: DateTime): int;
    static readonly JapaneseEra: int;
}


export interface __JapaneseLunisolarCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type JapaneseLunisolarCalendar = JapaneseLunisolarCalendar$instance & __JapaneseLunisolarCalendar$views;


export class JulianCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly JulianEra: int;
}


export interface __JulianCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type JulianCalendar = JulianCalendar$instance & __JulianCalendar$views;


export class KoreanCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly KoreanEra: int;
}


export interface __KoreanCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type KoreanCalendar = KoreanCalendar$instance & __KoreanCalendar$views;


export class KoreanLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    constructor();
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): any;
    GetEra(time: DateTime): int;
    static readonly GregorianEra: int;
}


export interface __KoreanLunisolarCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type KoreanLunisolarCalendar = KoreanLunisolarCalendar$instance & __KoreanLunisolarCalendar$views;


export class NumberFormatInfo$instance {
    constructor();
    CurrencyDecimalDigits: int;
    CurrencyDecimalSeparator: string;
    CurrencyGroupSeparator: string;
    CurrencyGroupSizes: int[];
    CurrencyNegativePattern: int;
    CurrencyPositivePattern: int;
    CurrencySymbol: string;
    DigitSubstitution: DigitShapes;
    readonly IsReadOnly: boolean;
    NaNSymbol: string;
    NativeDigits: string[];
    NegativeInfinitySymbol: string;
    NegativeSign: string;
    NumberDecimalDigits: int;
    NumberDecimalSeparator: string;
    NumberGroupSeparator: string;
    NumberGroupSizes: int[];
    NumberNegativePattern: int;
    PercentDecimalDigits: int;
    PercentDecimalSeparator: string;
    PercentGroupSeparator: string;
    PercentGroupSizes: int[];
    PercentNegativePattern: int;
    PercentPositivePattern: int;
    PercentSymbol: string;
    PerMilleSymbol: string;
    PositiveInfinitySymbol: string;
    PositiveSign: string;
    Clone(): any;
    GetFormat(formatType: Type): any;
    static readonly InvariantInfo: NumberFormatInfo;
    static readonly CurrentInfo: NumberFormatInfo;
    static GetInstance(formatProvider: IFormatProvider): NumberFormatInfo;
    static ReadOnly(nfi: NumberFormatInfo): NumberFormatInfo;
}


export interface __NumberFormatInfo$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IFormatProvider: System_Internal.IFormatProvider$instance;
}

export type NumberFormatInfo = NumberFormatInfo$instance & __NumberFormatInfo$views;


export class PersianCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly PersianEra: int;
}


export interface __PersianCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type PersianCalendar = PersianCalendar$instance & __PersianCalendar$views;


export class RegionInfo$instance {
    constructor(name: string);
    constructor(culture: int);
    readonly CurrencyEnglishName: string;
    readonly CurrencyNativeName: string;
    readonly CurrencySymbol: string;
    readonly DisplayName: string;
    readonly EnglishName: string;
    readonly GeoId: int;
    readonly IsMetric: boolean;
    readonly ISOCurrencySymbol: string;
    readonly Name: string;
    readonly NativeName: string;
    readonly ThreeLetterISORegionName: string;
    readonly ThreeLetterWindowsRegionName: string;
    readonly TwoLetterISORegionName: string;
    Equals(value: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly CurrentRegion: RegionInfo;
}


export type RegionInfo = RegionInfo$instance;

export class SortKey$instance {
    readonly KeyData: byte[];
    readonly OriginalString: string;
    Equals(value: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Compare(sortkey1: SortKey, sortkey2: SortKey): int;
}


export type SortKey = SortKey$instance;

export class SortVersion$instance {
    constructor(fullVersion: int, sortId: Guid);
    readonly FullVersion: int;
    readonly SortId: Guid;
    Equals(obj: any): boolean;
    Equals(other: SortVersion): boolean;
    GetHashCode(): int;
}


export interface __SortVersion$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SortVersion>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SortVersion): boolean;
}

export type SortVersion = SortVersion$instance & __SortVersion$views;


export class StringInfo$instance {
    constructor();
    constructor(value: string);
    readonly LengthInTextElements: int;
    String: string;
    Equals(value: any): boolean;
    GetHashCode(): int;
    SubstringByTextElements(startingTextElement: int): string;
    SubstringByTextElements(startingTextElement: int, lengthInTextElements: int): string;
    static GetNextTextElement(str: string, index: int): string;
    static GetNextTextElement(str: string): string;
    static GetNextTextElementLength(str: ReadOnlySpan_1<CLROf<string>>): int;
    static GetNextTextElementLength(str: string, index: int): int;
    static GetNextTextElementLength(str: string): int;
    static GetTextElementEnumerator(str: string, index: int): TextElementEnumerator;
    static GetTextElementEnumerator(str: string): TextElementEnumerator;
    static ParseCombiningCharacters(str: string): int[];
}


export type StringInfo = StringInfo$instance;

export class TaiwanCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export interface __TaiwanCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type TaiwanCalendar = TaiwanCalendar$instance & __TaiwanCalendar$views;


export class TaiwanLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    constructor();
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): any;
    GetEra(time: DateTime): int;
}


export interface __TaiwanLunisolarCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type TaiwanLunisolarCalendar = TaiwanLunisolarCalendar$instance & __TaiwanLunisolarCalendar$views;


export class TextElementEnumerator$instance {
    readonly Current: any;
    readonly ElementIndex: int;
    GetTextElement(): string;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __TextElementEnumerator$views {
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type TextElementEnumerator = TextElementEnumerator$instance & __TextElementEnumerator$views;


export class TextInfo$instance {
    readonly ANSICodePage: int;
    readonly CultureName: string;
    readonly EBCDICCodePage: int;
    readonly IsReadOnly: boolean;
    readonly IsRightToLeft: boolean;
    readonly LCID: int;
    ListSeparator: string;
    readonly MacCodePage: int;
    readonly OEMCodePage: int;
    Clone(): any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToLower(c: string): string;
    ToLower(str: string): string;
    ToString(): string;
    ToTitleCase(str: string): string;
    ToUpper(c: string): string;
    ToUpper(str: string): string;
    static ReadOnly(textInfo: TextInfo): TextInfo;
}


export interface __TextInfo$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
}

export type TextInfo = TextInfo$instance & __TextInfo$views;


export class ThaiBuddhistCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly ThaiBuddhistEra: int;
}


export interface __ThaiBuddhistCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ThaiBuddhistCalendar = ThaiBuddhistCalendar$instance & __ThaiBuddhistCalendar$views;


export class UmAlQuraCalendar$instance extends Calendar$instance {
    constructor();
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): any;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
    static readonly UmAlQuraEra: int;
}


export interface __UmAlQuraCalendar$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type UmAlQuraCalendar = UmAlQuraCalendar$instance & __UmAlQuraCalendar$views;


export abstract class CharUnicodeInfo$instance {
    static GetDecimalDigitValue(ch: string): int;
    static GetDecimalDigitValue(s: string, index: int): int;
    static GetDigitValue(ch: string): int;
    static GetDigitValue(s: string, index: int): int;
    static GetNumericValue(ch: string): double;
    static GetNumericValue(s: string, index: int): double;
    static GetUnicodeCategory(ch: string): UnicodeCategory;
    static GetUnicodeCategory(codePoint: int): UnicodeCategory;
    static GetUnicodeCategory(s: string, index: int): UnicodeCategory;
}


export type CharUnicodeInfo = CharUnicodeInfo$instance;

export abstract class GlobalizationExtensions$instance {
    static GetStringComparer(compareInfo: CompareInfo, options: CompareOptions): StringComparer;
}


export type GlobalizationExtensions = GlobalizationExtensions$instance;

export abstract class ISOWeek$instance {
    static GetWeekOfYear(date: DateOnly): int;
    static GetWeekOfYear(date: DateTime): int;
    static GetWeeksInYear(year: int): int;
    static GetYear(date: DateOnly): int;
    static GetYear(date: DateTime): int;
    static GetYearEnd(year: int): DateTime;
    static GetYearStart(year: int): DateTime;
    static ToDateOnly(year: int, week: int, dayOfWeek: DayOfWeek): DateOnly;
    static ToDateTime(year: int, week: int, dayOfWeek: DayOfWeek): DateTime;
}


export type ISOWeek = ISOWeek$instance;

