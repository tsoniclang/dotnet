// Generated by tsbindgen - Architecture
// Namespace: System.Threading.Tasks
// Assembly: System.Threading.Tasks.Parallel, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { OrderablePartitioner_1, Partitioner_1 } from "../../System.Collections.Concurrent/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { IBinaryInteger_1 } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import type { ConfiguredAsyncDisposable, ConfiguredCancelableAsyncEnumerable_1, ConfiguredTaskAwaitable, ConfiguredTaskAwaitable_1, ConfiguredValueTaskAwaitable, ConfiguredValueTaskAwaitable_1, TaskAwaiter, TaskAwaiter_1, ValueTaskAwaiter, ValueTaskAwaiter_1, YieldAwaitable } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IValueTaskSource, IValueTaskSource_1 } from "../../System.Threading.Tasks.Sources/internal/index.js";
import type { CancellationToken, WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, Action_3, AggregateException, AsyncCallback, Boolean as ClrBoolean, Enum, EventArgs, EventHandler_1, Exception, Func_1, Func_2, Func_3, Func_4, Func_5, Func_6, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, OperationCanceledException, ReadOnlySpan_1, String as ClrString, TimeProvider, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ConfigureAwaitOptions {
    none = 0,
    continueOnCapturedContext = 1,
    suppressThrowing = 2,
    forceYielding = 4
}


export enum TaskContinuationOptions {
    none = 0,
    preferFairness = 1,
    longRunning = 2,
    attachedToParent = 4,
    denyChildAttach = 8,
    hideScheduler = 16,
    lazyCancellation = 32,
    runContinuationsAsynchronously = 64,
    notOnRanToCompletion = 65536,
    notOnFaulted = 131072,
    notOnCanceled = 262144,
    onlyOnRanToCompletion = 393216,
    onlyOnFaulted = 327680,
    onlyOnCanceled = 196608,
    executeSynchronously = 524288
}


export enum TaskCreationOptions {
    none = 0,
    preferFairness = 1,
    longRunning = 2,
    attachedToParent = 4,
    denyChildAttach = 8,
    hideScheduler = 16,
    runContinuationsAsynchronously = 64
}


export enum TaskStatus {
    created = 0,
    waitingForActivation = 1,
    waitingToRun = 2,
    running = 3,
    waitingForChildrenToComplete = 4,
    ranToCompletion = 5,
    canceled = 6,
    faulted = 7
}


export class ParallelLoopResult$instance {
    readonly isCompleted: boolean;
    readonly lowestBreakIteration: Nullable_1<CLROf<long>>;
}


export type ParallelLoopResult = ParallelLoopResult$instance;

export class ValueTask$instance {
    constructor(task: Task);
    constructor(source: IValueTaskSource, token: short);
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
    readonly isCompletedSuccessfully: boolean;
    readonly isFaulted: boolean;
    asTask(): Task;
    configureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable;
    equals(obj: any): boolean;
    equals(other: ValueTask): boolean;
    getAwaiter(): ValueTaskAwaiter;
    getHashCode(): int;
    preserve(): ValueTask;
    static readonly CompletedTask: ValueTask;
    static FromCanceled(cancellationToken: CancellationToken): ValueTask;
    static FromCanceled<TResult>(cancellationToken: CancellationToken): ValueTask_1<TResult>;
    static FromException(exception: Exception): ValueTask;
    static FromException<TResult>(exception: Exception): ValueTask_1<TResult>;
    static FromResult<TResult>(result: TResult): ValueTask_1<TResult>;
}


export interface __ValueTask$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ValueTask>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTask): boolean;
}

export type ValueTask = ValueTask$instance & __ValueTask$views;


export class ValueTask_1$instance<TResult> {
    constructor(result: TResult);
    constructor(task: Task_1<TResult>);
    constructor(source: IValueTaskSource_1<TResult>, token: short);
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
    readonly isCompletedSuccessfully: boolean;
    readonly isFaulted: boolean;
    readonly result: TResult;
    asTask(): Task_1<TResult>;
    configureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable_1<TResult>;
    equals(obj: any): boolean;
    equals(other: ValueTask_1<TResult>): boolean;
    getAwaiter(): ValueTaskAwaiter_1<TResult>;
    getHashCode(): int;
    preserve(): ValueTask_1<TResult>;
    toString(): string;
}


export interface __ValueTask_1$views<TResult> {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ValueTask_1<TResult>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTask_1<TResult>): boolean;
}

export type ValueTask_1<TResult> = ValueTask_1$instance<TResult> & __ValueTask_1$views<TResult>;


export class ConcurrentExclusiveSchedulerPair$instance {
    constructor();
    constructor(taskScheduler: TaskScheduler);
    constructor(taskScheduler: TaskScheduler, maxConcurrencyLevel: int);
    constructor(taskScheduler: TaskScheduler, maxConcurrencyLevel: int, maxItemsPerTask: int);
    readonly completion: Task;
    readonly concurrentScheduler: TaskScheduler;
    readonly exclusiveScheduler: TaskScheduler;
    complete(): void;
}


export type ConcurrentExclusiveSchedulerPair = ConcurrentExclusiveSchedulerPair$instance;

export class ParallelLoopState$instance {
    readonly isExceptional: boolean;
    readonly isStopped: boolean;
    readonly lowestBreakIteration: Nullable_1<CLROf<long>>;
    readonly shouldExitCurrentIteration: boolean;
    break_(): void;
    stop(): void;
}


export type ParallelLoopState = ParallelLoopState$instance;

export class ParallelOptions$instance {
    constructor();
    cancellationToken: CancellationToken;
    maxDegreeOfParallelism: int;
    taskScheduler: TaskScheduler;
}


export type ParallelOptions = ParallelOptions$instance;

export class Task$instance {
    constructor(action: Action);
    constructor(action: Action, cancellationToken: CancellationToken);
    constructor(action: Action, creationOptions: TaskCreationOptions);
    constructor(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    constructor(action: Action_1<any>, state: any);
    constructor(action: Action_1<any>, state: any, cancellationToken: CancellationToken);
    constructor(action: Action_1<any>, state: any, creationOptions: TaskCreationOptions);
    constructor(action: Action_1<any>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    readonly asyncState: any;
    readonly creationOptions: TaskCreationOptions;
    readonly exception: AggregateException;
    readonly id: int;
    readonly isCanceled: boolean;
    readonly isCompleted: boolean;
    readonly isCompletedSuccessfully: boolean;
    readonly isFaulted: boolean;
    readonly status: TaskStatus;
    configureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable;
    configureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable;
    continueWith(continuationAction: Action_1<Task>): Task;
    continueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    continueWith(continuationAction: Action_1<Task>, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    continueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, continuationOptions: TaskContinuationOptions): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, scheduler: TaskScheduler): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, scheduler: TaskScheduler): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    dispose(): void;
    getAwaiter(): TaskAwaiter;
    runSynchronously(): void;
    runSynchronously(scheduler: TaskScheduler): void;
    start(): void;
    start(scheduler: TaskScheduler): void;
    wait(): void;
    wait(timeout: TimeSpan): boolean;
    wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    wait(cancellationToken: CancellationToken): void;
    wait(millisecondsTimeout: int): boolean;
    wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    waitAsync(cancellationToken: CancellationToken): Task;
    waitAsync(timeout: TimeSpan): Task;
    waitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task;
    waitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task;
    waitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
    static readonly CurrentId: Nullable_1<CLROf<int>>;
    static readonly Factory: TaskFactory;
    static readonly CompletedTask: Task;
    static Delay(millisecondsDelay: int, cancellationToken: CancellationToken): Task;
    static Delay(millisecondsDelay: int): Task;
    static Delay(delay: TimeSpan, cancellationToken: CancellationToken): Task;
    static Delay(delay: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
    static Delay(delay: TimeSpan, timeProvider: TimeProvider): Task;
    static Delay(delay: TimeSpan): Task;
    static FromCanceled(cancellationToken: CancellationToken): Task;
    static FromCanceled<TResult>(cancellationToken: CancellationToken): Task_1<TResult>;
    static FromException(exception: Exception): Task;
    static FromException<TResult>(exception: Exception): Task_1<TResult>;
    static FromResult<TResult>(result: TResult): Task_1<TResult>;
    static Run<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    static Run<TResult>(function_: Func_1<TResult>): Task_1<TResult>;
    static Run(action: Action, cancellationToken: CancellationToken): Task;
    static Run(action: Action): Task;
    static Run(function_: Func_1<Task>, cancellationToken: CancellationToken): Task;
    static Run(function_: Func_1<Task>): Task;
    static WaitAll(tasks: IEnumerable_1<Task>, cancellationToken?: CancellationToken): void;
    static WaitAll(tasks: ReadOnlySpan_1<Task>): void;
    static WaitAll(tasks: Task[], millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    static WaitAll(tasks: Task[], millisecondsTimeout: int): boolean;
    static WaitAll(tasks: Task[], cancellationToken: CancellationToken): void;
    static WaitAll(tasks: Task[], timeout: TimeSpan): boolean;
    static WaitAll(tasks: Task[]): void;
    static WaitAny(tasks: Task[], millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    static WaitAny(tasks: Task[], millisecondsTimeout: int): int;
    static WaitAny(tasks: Task[], cancellationToken: CancellationToken): int;
    static WaitAny(tasks: Task[], timeout: TimeSpan): int;
    static WaitAny(tasks: Task[]): int;
    static WhenAll<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): Task_1<TResult[]>;
    static WhenAll<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): Task_1<TResult[]>;
    static WhenAll(tasks: IEnumerable_1<Task>): Task;
    static WhenAll(tasks: ReadOnlySpan_1<Task>): Task;
    static WhenAll(tasks: Task[]): Task;
    static WhenAll<TResult>(tasks: Task_1<TResult>[]): Task_1<TResult[]>;
    static WhenAny<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): Task_1<Task_1<TResult>>;
    static WhenAny<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): Task_1<Task_1<TResult>>;
    static WhenAny(tasks: IEnumerable_1<Task>): Task_1<Task>;
    static WhenAny(tasks: ReadOnlySpan_1<Task>): Task_1<Task>;
    static WhenAny(task1: Task, task2: Task): Task_1<Task>;
    static WhenAny(tasks: Task[]): Task_1<Task>;
    static WhenAny<TResult>(task1: Task_1<TResult>, task2: Task_1<TResult>): Task_1<Task_1<TResult>>;
    static WhenAny<TResult>(tasks: Task_1<TResult>[]): Task_1<Task_1<TResult>>;
    static WhenEach<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): IAsyncEnumerable_1<Task_1<TResult>>;
    static WhenEach<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): IAsyncEnumerable_1<Task_1<TResult>>;
    static WhenEach(tasks: IEnumerable_1<Task>): IAsyncEnumerable_1<Task>;
    static WhenEach(tasks: ReadOnlySpan_1<Task>): IAsyncEnumerable_1<Task>;
    static WhenEach(tasks: Task[]): IAsyncEnumerable_1<Task>;
    static WhenEach<TResult>(tasks: Task_1<TResult>[]): IAsyncEnumerable_1<Task_1<TResult>>;
    static Yield(): YieldAwaitable;
}


export interface __Task$views {
    readonly As_IAsyncResult: System_Internal.IAsyncResult$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Task = Task$instance & __Task$views;


export class Task_1$instance<TResult> extends Task$instance {
    constructor(function_: Func_1<TResult>);
    constructor(function_: Func_1<TResult>, cancellationToken: CancellationToken);
    constructor(function_: Func_1<TResult>, creationOptions: TaskCreationOptions);
    constructor(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    constructor(function_: Func_2<any, TResult>, state: any);
    constructor(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken);
    constructor(function_: Func_2<any, TResult>, state: any, creationOptions: TaskCreationOptions);
    constructor(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    readonly result: TResult;
    configureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable;
    configureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable;
    continueWith(continuationAction: Action_1<Task_1<TResult>>): Task;
    continueWith(continuationAction: Action_1<Task_1<TResult>>, cancellationToken: CancellationToken): Task;
    continueWith(continuationAction: Action_1<Task_1<TResult>>, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_1<Task_1<TResult>>, continuationOptions: TaskContinuationOptions): Task;
    continueWith(continuationAction: Action_1<Task_1<TResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any): Task;
    continueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, cancellationToken: CancellationToken): Task;
    continueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, continuationOptions: TaskContinuationOptions): Task;
    continueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, cancellationToken: CancellationToken): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, scheduler: TaskScheduler): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, continuationOptions: TaskContinuationOptions): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, cancellationToken: CancellationToken): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, scheduler: TaskScheduler): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, continuationOptions: TaskContinuationOptions): Task_1<TNewResult>;
    continueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TNewResult>;
    continueWith(continuationAction: Action_1<Task>): Task;
    continueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    continueWith(continuationAction: Action_1<Task>, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    continueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, scheduler: TaskScheduler): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, continuationOptions: TaskContinuationOptions): Task;
    continueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, scheduler: TaskScheduler): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, scheduler: TaskScheduler): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    dispose(): void;
    getAwaiter(): TaskAwaiter;
    waitAsync(cancellationToken: CancellationToken): Task;
    waitAsync(timeout: TimeSpan): Task;
    waitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task;
    waitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task;
    waitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
}


export interface __Task_1$views<TResult> {
    readonly As_IAsyncResult: System_Internal.IAsyncResult$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Task_1<TResult> = Task_1$instance<TResult> & __Task_1$views<TResult>;


export class TaskCanceledException$instance extends System_Internal.OperationCanceledException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerException: Exception, token: CancellationToken);
    constructor(task: Task);
    readonly task: Task;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TaskCanceledException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TaskCanceledException = TaskCanceledException$instance & __TaskCanceledException$views;


export class TaskCompletionSource$instance {
    constructor();
    constructor(creationOptions: TaskCreationOptions);
    constructor(state: any);
    constructor(state: any, creationOptions: TaskCreationOptions);
    readonly task: Task;
    setCanceled(): void;
    setCanceled(cancellationToken: CancellationToken): void;
    setException(exception: Exception): void;
    setException(exceptions: IEnumerable_1<Exception>): void;
    setFromTask(completedTask: Task): void;
    setResult(): void;
    trySetCanceled(): boolean;
    trySetCanceled(cancellationToken: CancellationToken): boolean;
    trySetException(exception: Exception): boolean;
    trySetException(exceptions: IEnumerable_1<Exception>): boolean;
    trySetFromTask(completedTask: Task): boolean;
    trySetResult(): boolean;
}


export type TaskCompletionSource = TaskCompletionSource$instance;

export class TaskCompletionSource_1$instance<TResult> {
    constructor();
    constructor(creationOptions: TaskCreationOptions);
    constructor(state: any);
    constructor(state: any, creationOptions: TaskCreationOptions);
    readonly task: Task_1<TResult>;
    setCanceled(): void;
    setCanceled(cancellationToken: CancellationToken): void;
    setException(exception: Exception): void;
    setException(exceptions: IEnumerable_1<Exception>): void;
    setFromTask(completedTask: Task_1<TResult>): void;
    setResult(result: TResult): void;
    trySetCanceled(): boolean;
    trySetCanceled(cancellationToken: CancellationToken): boolean;
    trySetException(exception: Exception): boolean;
    trySetException(exceptions: IEnumerable_1<Exception>): boolean;
    trySetFromTask(completedTask: Task_1<TResult>): boolean;
    trySetResult(result: TResult): boolean;
}


export type TaskCompletionSource_1<TResult> = TaskCompletionSource_1$instance<TResult>;

export class TaskFactory$instance {
    constructor();
    constructor(cancellationToken: CancellationToken);
    constructor(scheduler: TaskScheduler);
    constructor(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions);
    constructor(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler);
    readonly cancellationToken: CancellationToken;
    readonly continuationOptions: TaskContinuationOptions;
    readonly creationOptions: TaskCreationOptions;
    readonly scheduler: TaskScheduler;
    continueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>): Task;
    continueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, cancellationToken: CancellationToken): Task;
    continueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, continuationOptions: TaskContinuationOptions): Task;
    continueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>): Task;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, cancellationToken: CancellationToken): Task;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, continuationOptions: TaskContinuationOptions): Task;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>): Task_1<TResult>;
    continueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>): Task_1<TResult>;
    continueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWhenAny(tasks: Task[], continuationAction: Action_1<Task>): Task;
    continueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    continueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    continueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    continueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    continueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>): Task_1<TResult>;
    continueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>): Task;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, cancellationToken: CancellationToken): Task;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, continuationOptions: TaskContinuationOptions): Task;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    fromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>): Task;
    fromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>, creationOptions: TaskCreationOptions): Task;
    fromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    fromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, state: any): Task;
    fromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, state: any, creationOptions: TaskCreationOptions): Task;
    fromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, state: any): Task;
    fromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task;
    fromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: any): Task;
    fromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task;
    fromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task;
    fromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task;
    fromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>): Task_1<TResult>;
    fromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    fromAsync<TResult>(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any): Task_1<TResult>;
    fromAsync<TResult>(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync<TArg1, TResult>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any): Task_1<TResult>;
    fromAsync<TArg1, TResult>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync<TArg1, TArg2, TResult>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any): Task_1<TResult>;
    fromAsync<TArg1, TArg2, TResult>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync<TArg1, TArg2, TArg3, TResult>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task_1<TResult>;
    fromAsync<TArg1, TArg2, TArg3, TResult>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    startNew(action: Action): Task;
    startNew(action: Action, cancellationToken: CancellationToken): Task;
    startNew(action: Action, creationOptions: TaskCreationOptions): Task;
    startNew(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    startNew(action: Action_1<any>, state: any): Task;
    startNew(action: Action_1<any>, state: any, cancellationToken: CancellationToken): Task;
    startNew(action: Action_1<any>, state: any, creationOptions: TaskCreationOptions): Task;
    startNew(action: Action_1<any>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    startNew<TResult>(function_: Func_1<TResult>): Task_1<TResult>;
    startNew<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    startNew<TResult>(function_: Func_1<TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    startNew<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    startNew<TResult>(function_: Func_2<any, TResult>, state: any): Task_1<TResult>;
    startNew<TResult>(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    startNew<TResult>(function_: Func_2<any, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    startNew<TResult>(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
}


export type TaskFactory = TaskFactory$instance;

export class TaskFactory_1$instance<TResult> {
    constructor();
    constructor(cancellationToken: CancellationToken);
    constructor(scheduler: TaskScheduler);
    constructor(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions);
    constructor(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler);
    readonly cancellationToken: CancellationToken;
    readonly continuationOptions: TaskContinuationOptions;
    readonly creationOptions: TaskCreationOptions;
    readonly scheduler: TaskScheduler;
    continueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>): Task_1<TResult>;
    continueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>): Task_1<TResult>;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    continueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>): Task_1<TResult>;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    continueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    fromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>): Task_1<TResult>;
    fromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    fromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any): Task_1<TResult>;
    fromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any): Task_1<TResult>;
    fromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any): Task_1<TResult>;
    fromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    fromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task_1<TResult>;
    fromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    startNew(function_: Func_1<TResult>): Task_1<TResult>;
    startNew(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    startNew(function_: Func_1<TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    startNew(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    startNew(function_: Func_2<any, TResult>, state: any): Task_1<TResult>;
    startNew(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    startNew(function_: Func_2<any, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    startNew(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
}


export type TaskFactory_1<TResult> = TaskFactory_1$instance<TResult>;

export abstract class TaskScheduler$instance {
    readonly id: int;
    readonly maximumConcurrencyLevel: int;
    static readonly Default: TaskScheduler;
    static readonly Current: TaskScheduler;
    static FromCurrentSynchronizationContext(): TaskScheduler;
}


export type TaskScheduler = TaskScheduler$instance;

export class TaskSchedulerException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(innerException: Exception);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TaskSchedulerException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TaskSchedulerException = TaskSchedulerException$instance & __TaskSchedulerException$views;


export class UnobservedTaskExceptionEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(exception: AggregateException);
    readonly exception: AggregateException;
    readonly observed: boolean;
    setObserved(): void;
}


export type UnobservedTaskExceptionEventArgs = UnobservedTaskExceptionEventArgs$instance;

export abstract class Parallel$instance {
    static For<TLocal>(fromInclusive: int, toExclusive: int, localInit: Func_1<TLocal>, body: Func_4<CLROf<int>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, body: Action_1<CLROf<int>>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, body: Action_2<CLROf<int>, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<CLROf<int>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action_1<CLROf<int>>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action_2<CLROf<int>, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: long, toExclusive: long, localInit: Func_1<TLocal>, body: Func_4<CLROf<long>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, body: Action_1<CLROf<long>>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, body: Action_2<CLROf<long>, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<CLROf<long>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, body: Action_1<CLROf<long>>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, body: Action_2<CLROf<long>, ParallelLoopState>): ParallelLoopResult;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, cancellationToken: CancellationToken, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, parallelOptions: ParallelOptions, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: OrderablePartitioner_1<TSource>, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: OrderablePartitioner_1<TSource>, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: OrderablePartitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: OrderablePartitioner_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: Partitioner_1<TSource>, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken: CancellationToken, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, cancellationToken: CancellationToken, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static Invoke(actions: Action[]): void;
    static Invoke(parallelOptions: ParallelOptions, actions: Action[]): void;
}


export type Parallel = Parallel$instance;

export abstract class TaskAsyncEnumerableExtensions$instance {
    static ConfigureAwait<T>(source: IAsyncEnumerable_1<T>, continueOnCapturedContext: boolean): ConfiguredCancelableAsyncEnumerable_1<T>;
    static ConfigureAwait(source: IAsyncDisposable, continueOnCapturedContext: boolean): ConfiguredAsyncDisposable;
    static ToBlockingEnumerable<T>(source: IAsyncEnumerable_1<T>, cancellationToken?: CancellationToken): IEnumerable_1<T>;
    static WithCancellation<T>(source: IAsyncEnumerable_1<T>, cancellationToken: CancellationToken): ConfiguredCancelableAsyncEnumerable_1<T>;
}


export type TaskAsyncEnumerableExtensions = TaskAsyncEnumerableExtensions$instance;

export abstract class TaskExtensions$instance {
    static Unwrap(task: Task_1<Task>): Task;
    static Unwrap<TResult>(task: Task_1<Task_1<TResult>>): Task_1<TResult>;
}


export type TaskExtensions = TaskExtensions$instance;

export abstract class TaskToAsyncResult$instance {
    static Begin(task: Task, callback: AsyncCallback, state: any): IAsyncResult;
    static End(asyncResult: IAsyncResult): void;
    static End<TResult>(asyncResult: IAsyncResult): TResult;
    static Unwrap(asyncResult: IAsyncResult): Task;
    static Unwrap<TResult>(asyncResult: IAsyncResult): Task_1<TResult>;
}


export type TaskToAsyncResult = TaskToAsyncResult$instance;

