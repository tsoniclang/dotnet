// Generated by tsbindgen - Architecture
// Namespace: System.Threading.Tasks
// Assembly: System.Private.CoreLib, System.Threading.Tasks.Parallel

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { OrderablePartitioner_1, Partitioner_1 } from "../../System.Collections.Concurrent/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { IBinaryInteger_1 } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import type { ConfiguredAsyncDisposable, ConfiguredCancelableAsyncEnumerable_1, ConfiguredTaskAwaitable, ConfiguredTaskAwaitable_1, ConfiguredValueTaskAwaitable, ConfiguredValueTaskAwaitable_1, TaskAwaiter, TaskAwaiter_1, ValueTaskAwaiter, ValueTaskAwaiter_1, YieldAwaitable } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IValueTaskSource, IValueTaskSource_1 } from "../../System.Threading.Tasks.Sources/internal/index.js";
import type { CancellationToken, WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, Action_3, AggregateException, AsyncCallback, Boolean as ClrBoolean, Enum, EventArgs, EventHandler_1, Exception, Func_1, Func_2, Func_3, Func_4, Func_5, Func_6, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, OperationCanceledException, ReadOnlySpan_1, String as ClrString, TimeProvider, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ConfigureAwaitOptions {
    None = 0,
    ContinueOnCapturedContext = 1,
    SuppressThrowing = 2,
    ForceYielding = 4
}


export enum TaskContinuationOptions {
    None = 0,
    PreferFairness = 1,
    LongRunning = 2,
    AttachedToParent = 4,
    DenyChildAttach = 8,
    HideScheduler = 16,
    LazyCancellation = 32,
    RunContinuationsAsynchronously = 64,
    NotOnRanToCompletion = 65536,
    NotOnFaulted = 131072,
    NotOnCanceled = 262144,
    OnlyOnRanToCompletion = 393216,
    OnlyOnFaulted = 327680,
    OnlyOnCanceled = 196608,
    ExecuteSynchronously = 524288
}


export enum TaskCreationOptions {
    None = 0,
    PreferFairness = 1,
    LongRunning = 2,
    AttachedToParent = 4,
    DenyChildAttach = 8,
    HideScheduler = 16,
    RunContinuationsAsynchronously = 64
}


export enum TaskStatus {
    Created = 0,
    WaitingForActivation = 1,
    WaitingToRun = 2,
    Running = 3,
    WaitingForChildrenToComplete = 4,
    RanToCompletion = 5,
    Canceled = 6,
    Faulted = 7
}


export class ParallelLoopResult$instance {
    readonly IsCompleted: boolean;
    readonly LowestBreakIteration: Nullable_1<CLROf<long>>;
}


export type ParallelLoopResult = ParallelLoopResult$instance;

export class ValueTask$instance {
    constructor(task: Task);
    constructor(source: IValueTaskSource, token: short);
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
    readonly IsCompletedSuccessfully: boolean;
    readonly IsFaulted: boolean;
    AsTask(): Task;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable;
    Equals(obj: any): boolean;
    Equals(other: ValueTask): boolean;
    GetAwaiter(): ValueTaskAwaiter;
    GetHashCode(): int;
    Preserve(): ValueTask;
    static readonly CompletedTask: ValueTask;
    static FromCanceled(cancellationToken: CancellationToken): ValueTask;
    static FromCanceled<TResult>(cancellationToken: CancellationToken): ValueTask_1<TResult>;
    static FromException(exception: Exception): ValueTask;
    static FromException<TResult>(exception: Exception): ValueTask_1<TResult>;
    static FromResult<TResult>(result: TResult): ValueTask_1<TResult>;
}


export interface __ValueTask$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ValueTask>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTask): boolean;
}

export type ValueTask = ValueTask$instance & __ValueTask$views;


export class ValueTask_1$instance<TResult> {
    constructor(result: TResult);
    constructor(task: Task_1<TResult>);
    constructor(source: IValueTaskSource_1<TResult>, token: short);
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
    readonly IsCompletedSuccessfully: boolean;
    readonly IsFaulted: boolean;
    readonly Result: TResult;
    AsTask(): Task_1<TResult>;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable_1<TResult>;
    Equals(obj: any): boolean;
    Equals(other: ValueTask_1<TResult>): boolean;
    GetAwaiter(): ValueTaskAwaiter_1<TResult>;
    GetHashCode(): int;
    Preserve(): ValueTask_1<TResult>;
    ToString(): string;
}


export interface __ValueTask_1$views<TResult> {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ValueTask_1<TResult>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTask_1<TResult>): boolean;
}

export type ValueTask_1<TResult> = ValueTask_1$instance<TResult> & __ValueTask_1$views<TResult>;


export class ConcurrentExclusiveSchedulerPair$instance {
    constructor();
    constructor(taskScheduler: TaskScheduler);
    constructor(taskScheduler: TaskScheduler, maxConcurrencyLevel: int);
    constructor(taskScheduler: TaskScheduler, maxConcurrencyLevel: int, maxItemsPerTask: int);
    readonly Completion: Task;
    readonly ConcurrentScheduler: TaskScheduler;
    readonly ExclusiveScheduler: TaskScheduler;
    Complete(): void;
}


export type ConcurrentExclusiveSchedulerPair = ConcurrentExclusiveSchedulerPair$instance;

export class ParallelLoopState$instance {
    readonly IsExceptional: boolean;
    readonly IsStopped: boolean;
    readonly LowestBreakIteration: Nullable_1<CLROf<long>>;
    readonly ShouldExitCurrentIteration: boolean;
    Break(): void;
    Stop(): void;
}


export type ParallelLoopState = ParallelLoopState$instance;

export class ParallelOptions$instance {
    constructor();
    CancellationToken: CancellationToken;
    MaxDegreeOfParallelism: int;
    TaskScheduler: TaskScheduler;
}


export type ParallelOptions = ParallelOptions$instance;

export class Task$instance {
    constructor(action: Action);
    constructor(action: Action, cancellationToken: CancellationToken);
    constructor(action: Action, creationOptions: TaskCreationOptions);
    constructor(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    constructor(action: Action_1<any>, state: any);
    constructor(action: Action_1<any>, state: any, cancellationToken: CancellationToken);
    constructor(action: Action_1<any>, state: any, creationOptions: TaskCreationOptions);
    constructor(action: Action_1<any>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    readonly AsyncState: any;
    readonly CreationOptions: TaskCreationOptions;
    readonly Exception: AggregateException;
    readonly Id: int;
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
    readonly IsCompletedSuccessfully: boolean;
    readonly IsFaulted: boolean;
    readonly Status: TaskStatus;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable;
    ConfigureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable;
    ContinueWith(continuationAction: Action_1<Task>): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_1<Task>, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    Dispose(): void;
    GetAwaiter(): TaskAwaiter;
    RunSynchronously(): void;
    RunSynchronously(scheduler: TaskScheduler): void;
    Start(): void;
    Start(scheduler: TaskScheduler): void;
    Wait(): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(cancellationToken: CancellationToken): void;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    WaitAsync(cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task;
    WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
    static readonly CurrentId: Nullable_1<CLROf<int>>;
    static readonly Factory: TaskFactory;
    static readonly CompletedTask: Task;
    static Delay(millisecondsDelay: int, cancellationToken: CancellationToken): Task;
    static Delay(millisecondsDelay: int): Task;
    static Delay(delay: TimeSpan, cancellationToken: CancellationToken): Task;
    static Delay(delay: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
    static Delay(delay: TimeSpan, timeProvider: TimeProvider): Task;
    static Delay(delay: TimeSpan): Task;
    static FromCanceled(cancellationToken: CancellationToken): Task;
    static FromCanceled<TResult>(cancellationToken: CancellationToken): Task_1<TResult>;
    static FromException(exception: Exception): Task;
    static FromException<TResult>(exception: Exception): Task_1<TResult>;
    static FromResult<TResult>(result: TResult): Task_1<TResult>;
    static Run<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    static Run<TResult>(function_: Func_1<TResult>): Task_1<TResult>;
    static Run(action: Action, cancellationToken: CancellationToken): Task;
    static Run(action: Action): Task;
    static Run(function_: Func_1<Task>, cancellationToken: CancellationToken): Task;
    static Run(function_: Func_1<Task>): Task;
    static WaitAll(tasks: IEnumerable_1<Task>, cancellationToken?: CancellationToken): void;
    static WaitAll(tasks: ReadOnlySpan_1<Task>): void;
    static WaitAll(tasks: Task[], millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    static WaitAll(tasks: Task[], millisecondsTimeout: int): boolean;
    static WaitAll(tasks: Task[], cancellationToken: CancellationToken): void;
    static WaitAll(tasks: Task[], timeout: TimeSpan): boolean;
    static WaitAll(tasks: Task[]): void;
    static WaitAny(tasks: Task[], millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    static WaitAny(tasks: Task[], millisecondsTimeout: int): int;
    static WaitAny(tasks: Task[], cancellationToken: CancellationToken): int;
    static WaitAny(tasks: Task[], timeout: TimeSpan): int;
    static WaitAny(tasks: Task[]): int;
    static WhenAll<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): Task_1<TResult[]>;
    static WhenAll<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): Task_1<TResult[]>;
    static WhenAll(tasks: IEnumerable_1<Task>): Task;
    static WhenAll(tasks: ReadOnlySpan_1<Task>): Task;
    static WhenAll(tasks: Task[]): Task;
    static WhenAll<TResult>(tasks: Task_1<TResult>[]): Task_1<TResult[]>;
    static WhenAny<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): Task_1<Task_1<TResult>>;
    static WhenAny<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): Task_1<Task_1<TResult>>;
    static WhenAny(tasks: IEnumerable_1<Task>): Task_1<Task>;
    static WhenAny(tasks: ReadOnlySpan_1<Task>): Task_1<Task>;
    static WhenAny(task1: Task, task2: Task): Task_1<Task>;
    static WhenAny(tasks: Task[]): Task_1<Task>;
    static WhenAny<TResult>(task1: Task_1<TResult>, task2: Task_1<TResult>): Task_1<Task_1<TResult>>;
    static WhenAny<TResult>(tasks: Task_1<TResult>[]): Task_1<Task_1<TResult>>;
    static WhenEach<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): IAsyncEnumerable_1<Task_1<TResult>>;
    static WhenEach<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): IAsyncEnumerable_1<Task_1<TResult>>;
    static WhenEach(tasks: IEnumerable_1<Task>): IAsyncEnumerable_1<Task>;
    static WhenEach(tasks: ReadOnlySpan_1<Task>): IAsyncEnumerable_1<Task>;
    static WhenEach(tasks: Task[]): IAsyncEnumerable_1<Task>;
    static WhenEach<TResult>(tasks: Task_1<TResult>[]): IAsyncEnumerable_1<Task_1<TResult>>;
    static Yield(): YieldAwaitable;
}


export interface __Task$views {
    readonly As_IAsyncResult: System_Internal.IAsyncResult$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Task = Task$instance & __Task$views;


export class Task_1$instance<TResult> extends Task$instance {
    constructor(function_: Func_1<TResult>);
    constructor(function_: Func_1<TResult>, cancellationToken: CancellationToken);
    constructor(function_: Func_1<TResult>, creationOptions: TaskCreationOptions);
    constructor(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    constructor(function_: Func_2<any, TResult>, state: any);
    constructor(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken);
    constructor(function_: Func_2<any, TResult>, state: any, creationOptions: TaskCreationOptions);
    constructor(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions);
    readonly Result: TResult;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable;
    ConfigureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, cancellationToken: CancellationToken): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, continuationOptions: TaskContinuationOptions): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, cancellationToken: CancellationToken): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, continuationOptions: TaskContinuationOptions): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, any, TNewResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith(continuationAction: Action_1<Task>): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_1<Task>, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_2<Task, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, any, TResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    Dispose(): void;
    GetAwaiter(): TaskAwaiter;
    WaitAsync(cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task;
    WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
}


export interface __Task_1$views<TResult> {
    readonly As_IAsyncResult: System_Internal.IAsyncResult$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Task_1<TResult> = Task_1$instance<TResult> & __Task_1$views<TResult>;


export class TaskCanceledException$instance extends System_Internal.OperationCanceledException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerException: Exception, token: CancellationToken);
    constructor(task: Task);
    readonly Task: Task;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TaskCanceledException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TaskCanceledException = TaskCanceledException$instance & __TaskCanceledException$views;


export class TaskCompletionSource$instance {
    constructor();
    constructor(creationOptions: TaskCreationOptions);
    constructor(state: any);
    constructor(state: any, creationOptions: TaskCreationOptions);
    readonly Task: Task;
    SetCanceled(): void;
    SetCanceled(cancellationToken: CancellationToken): void;
    SetException(exception: Exception): void;
    SetException(exceptions: IEnumerable_1<Exception>): void;
    SetFromTask(completedTask: Task): void;
    SetResult(): void;
    TrySetCanceled(): boolean;
    TrySetCanceled(cancellationToken: CancellationToken): boolean;
    TrySetException(exception: Exception): boolean;
    TrySetException(exceptions: IEnumerable_1<Exception>): boolean;
    TrySetFromTask(completedTask: Task): boolean;
    TrySetResult(): boolean;
}


export type TaskCompletionSource = TaskCompletionSource$instance;

export class TaskCompletionSource_1$instance<TResult> {
    constructor();
    constructor(creationOptions: TaskCreationOptions);
    constructor(state: any);
    constructor(state: any, creationOptions: TaskCreationOptions);
    readonly Task: Task_1<TResult>;
    SetCanceled(): void;
    SetCanceled(cancellationToken: CancellationToken): void;
    SetException(exception: Exception): void;
    SetException(exceptions: IEnumerable_1<Exception>): void;
    SetFromTask(completedTask: Task_1<TResult>): void;
    SetResult(result: TResult): void;
    TrySetCanceled(): boolean;
    TrySetCanceled(cancellationToken: CancellationToken): boolean;
    TrySetException(exception: Exception): boolean;
    TrySetException(exceptions: IEnumerable_1<Exception>): boolean;
    TrySetFromTask(completedTask: Task_1<TResult>): boolean;
    TrySetResult(result: TResult): boolean;
}


export type TaskCompletionSource_1<TResult> = TaskCompletionSource_1$instance<TResult>;

export class TaskFactory$instance {
    constructor();
    constructor(cancellationToken: CancellationToken);
    constructor(scheduler: TaskScheduler);
    constructor(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions);
    constructor(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler);
    readonly CancellationToken: CancellationToken;
    readonly ContinuationOptions: TaskContinuationOptions;
    readonly CreationOptions: TaskCreationOptions;
    readonly Scheduler: TaskScheduler;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>): Task;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, cancellationToken: CancellationToken): Task;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, cancellationToken: CancellationToken): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>): Task_1<TResult>;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>): Task;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>): Task;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, cancellationToken: CancellationToken): Task;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    FromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>): Task;
    FromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>, creationOptions: TaskCreationOptions): Task;
    FromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    FromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, state: any): Task;
    FromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, state: any, creationOptions: TaskCreationOptions): Task;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, state: any): Task;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: any): Task;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task;
    FromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>): Task_1<TResult>;
    FromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    FromAsync<TResult>(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any): Task_1<TResult>;
    FromAsync<TResult>(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TResult>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any): Task_1<TResult>;
    FromAsync<TArg1, TResult>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TResult>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TResult>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3, TResult>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3, TResult>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(action: Action): Task;
    StartNew(action: Action, cancellationToken: CancellationToken): Task;
    StartNew(action: Action, creationOptions: TaskCreationOptions): Task;
    StartNew(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    StartNew(action: Action_1<any>, state: any): Task;
    StartNew(action: Action_1<any>, state: any, cancellationToken: CancellationToken): Task;
    StartNew(action: Action_1<any>, state: any, creationOptions: TaskCreationOptions): Task;
    StartNew(action: Action_1<any>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    StartNew<TResult>(function_: Func_1<TResult>): Task_1<TResult>;
    StartNew<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew<TResult>(function_: Func_1<TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<any, TResult>, state: any): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<any, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
}


export type TaskFactory = TaskFactory$instance;

export class TaskFactory_1$instance<TResult> {
    constructor();
    constructor(cancellationToken: CancellationToken);
    constructor(scheduler: TaskScheduler);
    constructor(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions);
    constructor(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler);
    readonly CancellationToken: CancellationToken;
    readonly ContinuationOptions: TaskContinuationOptions;
    readonly CreationOptions: TaskCreationOptions;
    readonly Scheduler: TaskScheduler;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>): Task_1<TResult>;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    FromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>): Task_1<TResult>;
    FromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    FromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any): Task_1<TResult>;
    FromAsync(beginMethod: Func_3<AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any): Task_1<TResult>;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any): Task_1<TResult>;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    StartNew(function_: Func_2<any, TResult>, state: any): Task_1<TResult>;
    StartNew(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew(function_: Func_2<any, TResult>, state: any, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(function_: Func_2<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
}


export type TaskFactory_1<TResult> = TaskFactory_1$instance<TResult>;

export abstract class TaskScheduler$instance {
    readonly Id: int;
    readonly MaximumConcurrencyLevel: int;
    static readonly Default: TaskScheduler;
    static readonly Current: TaskScheduler;
    static FromCurrentSynchronizationContext(): TaskScheduler;
}


export type TaskScheduler = TaskScheduler$instance;

export class TaskSchedulerException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(innerException: Exception);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TaskSchedulerException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TaskSchedulerException = TaskSchedulerException$instance & __TaskSchedulerException$views;


export class UnobservedTaskExceptionEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(exception: AggregateException);
    readonly Exception: AggregateException;
    readonly Observed: boolean;
    SetObserved(): void;
}


export type UnobservedTaskExceptionEventArgs = UnobservedTaskExceptionEventArgs$instance;

export abstract class Parallel$instance {
    static For<TLocal>(fromInclusive: int, toExclusive: int, localInit: Func_1<TLocal>, body: Func_4<CLROf<int>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, body: Action_1<CLROf<int>>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, body: Action_2<CLROf<int>, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<CLROf<int>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action_1<CLROf<int>>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action_2<CLROf<int>, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: long, toExclusive: long, localInit: Func_1<TLocal>, body: Func_4<CLROf<long>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, body: Action_1<CLROf<long>>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, body: Action_2<CLROf<long>, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<CLROf<long>, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, body: Action_1<CLROf<long>>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, body: Action_2<CLROf<long>, ParallelLoopState>): ParallelLoopResult;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, cancellationToken: CancellationToken, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, parallelOptions: ParallelOptions, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: OrderablePartitioner_1<TSource>, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: OrderablePartitioner_1<TSource>, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: OrderablePartitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_3<TSource, ParallelLoopState, CLROf<long>>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: OrderablePartitioner_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, CLROf<long>, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: Partitioner_1<TSource>, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken: CancellationToken, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, cancellationToken: CancellationToken, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static Invoke(actions: Action[]): void;
    static Invoke(parallelOptions: ParallelOptions, actions: Action[]): void;
}


export type Parallel = Parallel$instance;

export abstract class TaskAsyncEnumerableExtensions$instance {
    static ConfigureAwait<T>(source: IAsyncEnumerable_1<T>, continueOnCapturedContext: boolean): ConfiguredCancelableAsyncEnumerable_1<T>;
    static ConfigureAwait(source: IAsyncDisposable, continueOnCapturedContext: boolean): ConfiguredAsyncDisposable;
    static ToBlockingEnumerable<T>(source: IAsyncEnumerable_1<T>, cancellationToken?: CancellationToken): IEnumerable_1<T>;
    static WithCancellation<T>(source: IAsyncEnumerable_1<T>, cancellationToken: CancellationToken): ConfiguredCancelableAsyncEnumerable_1<T>;
}


export type TaskAsyncEnumerableExtensions = TaskAsyncEnumerableExtensions$instance;

export abstract class TaskExtensions$instance {
    static Unwrap(task: Task_1<Task>): Task;
    static Unwrap<TResult>(task: Task_1<Task_1<TResult>>): Task_1<TResult>;
}


export type TaskExtensions = TaskExtensions$instance;

export abstract class TaskToAsyncResult$instance {
    static Begin(task: Task, callback: AsyncCallback, state: any): IAsyncResult;
    static End(asyncResult: IAsyncResult): void;
    static End<TResult>(asyncResult: IAsyncResult): TResult;
    static Unwrap(asyncResult: IAsyncResult): Task;
    static Unwrap<TResult>(asyncResult: IAsyncResult): Task_1<TResult>;
}


export type TaskToAsyncResult = TaskToAsyncResult$instance;

