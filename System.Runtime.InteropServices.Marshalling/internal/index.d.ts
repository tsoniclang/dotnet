// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.Marshalling
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IFloatingPointIeee754_1, INumber_1 } from "../../System.Numerics/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ComWrappers, ComWrappers_ComInterfaceEntry, CreateComInterfaceFlags, CreateObjectFlags, IDynamicInterfaceCastable, SafeHandle, StringMarshalling, VarEnum } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, Guid, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, ReadOnlySpan_1, RuntimeTypeHandle, Span_1, String as ClrString, Type, TypeCode, UInt16, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ComInterfaceOptions {
    none = 0,
    managedObjectWrapper = 1,
    comObjectWrapper = 2
}


export enum MarshalMode {
    default_ = 0,
    managedToUnmanagedIn = 1,
    managedToUnmanagedRef = 2,
    managedToUnmanagedOut = 3,
    unmanagedToManagedIn = 4,
    unmanagedToManagedRef = 5,
    unmanagedToManagedOut = 6,
    elementIn = 7,
    elementRef = 8,
    elementOut = 9
}


export interface IComExposedClass$instance {
}


export type IComExposedClass = IComExposedClass$instance;

export interface IComExposedDetails$instance {
    GetComInterfaceEntries(count: { value: ref<int> }): ptr<ComWrappers_ComInterfaceEntry>;
}


export type IComExposedDetails = IComExposedDetails$instance;

export interface IIUnknownCacheStrategy$instance {
    Clear(unknownStrategy: IIUnknownStrategy): void;
    ConstructTableInfo(handle: RuntimeTypeHandle, interfaceDetails: IIUnknownDerivedDetails, ptr: ptr<void>): IIUnknownCacheStrategy_TableInfo;
    TryGetTableInfo(handle: RuntimeTypeHandle, info: { value: ref<IIUnknownCacheStrategy_TableInfo> }): boolean;
    TrySetTableInfo(handle: RuntimeTypeHandle, info: IIUnknownCacheStrategy_TableInfo): boolean;
}


export type IIUnknownCacheStrategy = IIUnknownCacheStrategy$instance;

export interface IIUnknownDerivedDetails$instance {
    readonly Iid: Guid;
    readonly Implementation: Type;
    readonly ManagedVirtualMethodTable: ptr<void>;
}


export type IIUnknownDerivedDetails = IIUnknownDerivedDetails$instance;

export interface IIUnknownInterfaceDetailsStrategy$instance {
    GetComExposedTypeDetails(type_: RuntimeTypeHandle): IComExposedDetails;
    GetIUnknownDerivedDetails(type_: RuntimeTypeHandle): IIUnknownDerivedDetails;
}


export type IIUnknownInterfaceDetailsStrategy = IIUnknownInterfaceDetailsStrategy$instance;

export interface IIUnknownInterfaceType$instance {
}


export type IIUnknownInterfaceType = IIUnknownInterfaceType$instance;

export interface IIUnknownStrategy$instance {
    CreateInstancePointer(unknown_: ptr<void>): ptr<void>;
    QueryInterface(instancePtr: ptr<void>, iid: { value: ref<Guid> }, ppObj: { value: ref<ptr<void>> }): int;
    Release(instancePtr: ptr<void>): int;
}


export type IIUnknownStrategy = IIUnknownStrategy$instance;

export interface IUnmanagedVirtualMethodTableProvider$instance {
    GetVirtualMethodTableInfoForKey(type_: Type): VirtualMethodTableInfo;
}


export type IUnmanagedVirtualMethodTableProvider = IUnmanagedVirtualMethodTableProvider$instance;

export class AnsiStringMarshaller_ManagedToUnmanagedIn$instance {
    free(): void;
    fromManaged(managed: string, buffer: Span_1<CLROf<byte>>): void;
    toUnmanaged(): ptr<byte>;
    static readonly BufferSize: int;
}


export type AnsiStringMarshaller_ManagedToUnmanagedIn = AnsiStringMarshaller_ManagedToUnmanagedIn$instance;

export class ArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(array: T[], buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<T>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
    static readonly BufferSize: int;
    static GetPinnableReference<T, TUnmanagedElement extends unknown>(array: T[]): ref<T>;
}


export type ArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = ArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export class BStrStringMarshaller_ManagedToUnmanagedIn$instance {
    free(): void;
    fromManaged(managed: string, buffer: Span_1<CLROf<byte>>): void;
    toUnmanaged(): ptr<ushort>;
    static readonly BufferSize: int;
}


export type BStrStringMarshaller_ManagedToUnmanagedIn = BStrStringMarshaller_ManagedToUnmanagedIn$instance;

export class ComVariant$instance {
    readonly varType: VarEnum;
    as_<T>(): T;
    dispose(): void;
    getRawDataRef<T extends unknown>(): ref<T>;
    static readonly Null: ComVariant;
    static Create<T>(value: T): ComVariant;
    static CreateRaw<T extends unknown>(vt: VarEnum, rawValue: T): ComVariant;
}


export interface __ComVariant$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ComVariant = ComVariant$instance & __ComVariant$views;


export class ComVariantMarshaller_RefPropagate$instance {
    free(): void;
    fromManaged(managed: unknown): void;
    fromUnmanaged(unmanaged: ComVariant): void;
    toManaged(): unknown;
    toUnmanaged(): ComVariant;
}


export type ComVariantMarshaller_RefPropagate = ComVariantMarshaller_RefPropagate$instance;

export class CustomMarshallerAttribute_GenericPlaceholder$instance {
}


export type CustomMarshallerAttribute_GenericPlaceholder = CustomMarshallerAttribute_GenericPlaceholder$instance;

export class IIUnknownCacheStrategy_TableInfo$instance {
    managedType: RuntimeTypeHandle;
    table: ptr<void>;
    thisPtr: ptr<void>;
}


export type IIUnknownCacheStrategy_TableInfo = IIUnknownCacheStrategy_TableInfo$instance;

export class PointerArrayMarshaller_2_ManagedToUnmanagedIn$instance<T extends unknown, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(array: ptr<T>[], buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<CLROf<nint>>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
    static readonly BufferSize: int;
    static GetPinnableReference<T extends unknown, TUnmanagedElement extends unknown>(array: ptr<T>[]): ref<byte>;
}


export type PointerArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = PointerArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export class ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(managed: ReadOnlySpan_1<T>, buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<T>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
    static readonly BufferSize: int;
    static GetPinnableReference<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>): ref<T>;
}


export type ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export class ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromUnmanaged(unmanaged: ptr<TUnmanagedElement>): void;
    getManagedValuesDestination(numElements: int): Span_1<T>;
    getUnmanagedValuesSource(numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
    toManaged(): ReadOnlySpan_1<T>;
}


export type ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut<T, TUnmanagedElement> = ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut$instance<T, TUnmanagedElement>;

export class SafeHandleMarshaller_1_ManagedToUnmanagedIn$instance<T extends SafeHandle> {
    free(): void;
    fromManaged(handle: T): void;
    toUnmanaged(): nint;
}


export type SafeHandleMarshaller_1_ManagedToUnmanagedIn<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedIn$instance<T>;

export class SafeHandleMarshaller_1_ManagedToUnmanagedOut$instance<T extends SafeHandle> {
    constructor();
    free(): void;
    fromUnmanaged(value: nint): void;
    toManaged(): T;
}


export type SafeHandleMarshaller_1_ManagedToUnmanagedOut<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedOut$instance<T>;

export class SafeHandleMarshaller_1_ManagedToUnmanagedRef$instance<T extends SafeHandle> {
    constructor();
    free(): void;
    fromManaged(handle: T): void;
    fromUnmanaged(value: nint): void;
    onInvoked(): void;
    toManagedFinally(): T;
    toUnmanaged(): nint;
}


export type SafeHandleMarshaller_1_ManagedToUnmanagedRef<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedRef$instance<T>;

export class SpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    free(): void;
    fromManaged(managed: Span_1<T>, buffer: Span_1<TUnmanagedElement>): void;
    getManagedValuesSource(): ReadOnlySpan_1<T>;
    getPinnableReference(): ref<TUnmanagedElement>;
    getUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    toUnmanaged(): ptr<TUnmanagedElement>;
    static readonly BufferSize: int;
    static GetPinnableReference<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): ref<T>;
}


export type SpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = SpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export class Utf8StringMarshaller_ManagedToUnmanagedIn$instance {
    free(): void;
    fromManaged(managed: string, buffer: Span_1<CLROf<byte>>): void;
    toUnmanaged(): ptr<byte>;
    static readonly BufferSize: int;
}


export type Utf8StringMarshaller_ManagedToUnmanagedIn = Utf8StringMarshaller_ManagedToUnmanagedIn$instance;

export class VirtualMethodTableInfo$instance {
    constructor(thisPointer: ptr<void>, virtualMethodTable: ptr<void>);
    readonly thisPointer: ptr<void>;
    readonly virtualMethodTable: ptr<void>;
    deconstruct(thisPointer: { value: ref<ptr<void>> }, virtualMethodTable: { value: ref<ptr<void>> }): void;
}


export type VirtualMethodTableInfo = VirtualMethodTableInfo$instance;

export class ComExposedClassAttribute_1$instance<T extends IComExposedClass> extends System_Internal.Attribute$instance {
    constructor();
    getComInterfaceEntries(count: { value: ref<int> }): ptr<ComWrappers_ComInterfaceEntry>;
}


export interface __ComExposedClassAttribute_1$views<T extends IComExposedClass> {
    As_IComExposedDetails(): IComExposedDetails$instance;
}

export type ComExposedClassAttribute_1<T extends IComExposedClass> = ComExposedClassAttribute_1$instance<T> & __ComExposedClassAttribute_1$views<T>;


export class ComObject$instance {
    finalRelease(): void;
}


export interface __ComObject$views {
    As_IDynamicInterfaceCastable(): System_Runtime_InteropServices_Internal.IDynamicInterfaceCastable$instance;
    As_IUnmanagedVirtualMethodTableProvider(): IUnmanagedVirtualMethodTableProvider$instance;
}

export type ComObject = ComObject$instance & __ComObject$views;


export class ContiguousCollectionMarshallerAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ContiguousCollectionMarshallerAttribute = ContiguousCollectionMarshallerAttribute$instance;

export class CustomMarshallerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(managedType: Type, marshalMode: MarshalMode, marshallerType: Type);
    readonly managedType: Type;
    readonly marshallerType: Type;
    readonly marshalMode: MarshalMode;
}


export type CustomMarshallerAttribute = CustomMarshallerAttribute$instance;

export class GeneratedComClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type GeneratedComClassAttribute = GeneratedComClassAttribute$instance;

export class GeneratedComInterfaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    exceptionToUnmanagedMarshaller: Type;
    options: ComInterfaceOptions;
    stringMarshalling: StringMarshalling;
    stringMarshallingCustomType: Type;
}


export type GeneratedComInterfaceAttribute = GeneratedComInterfaceAttribute$instance;

export class IUnknownDerivedAttribute_2$instance<T extends IIUnknownInterfaceType, TImpl> extends System_Internal.Attribute$instance {
    constructor();
    readonly iid: Guid;
    readonly implementation: Type;
    readonly managedVirtualMethodTable: ptr<void>;
}


export interface __IUnknownDerivedAttribute_2$views<T extends IIUnknownInterfaceType, TImpl> {
    As_IIUnknownDerivedDetails(): IIUnknownDerivedDetails$instance;
}

export type IUnknownDerivedAttribute_2<T extends IIUnknownInterfaceType, TImpl> = IUnknownDerivedAttribute_2$instance<T, TImpl> & __IUnknownDerivedAttribute_2$views<T, TImpl>;


export class MarshalUsingAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(nativeType: Type);
    constantElementCount: int;
    countElementName: string;
    elementIndirectionDepth: int;
    readonly nativeType: Type;
    static readonly ReturnsCountValue: string;
}


export type MarshalUsingAttribute = MarshalUsingAttribute$instance;

export class NativeMarshallingAttribute$instance extends System_Internal.Attribute$instance {
    constructor(nativeType: Type);
    readonly nativeType: Type;
}


export type NativeMarshallingAttribute = NativeMarshallingAttribute$instance;

export class StrategyBasedComWrappers$instance extends System_Runtime_InteropServices_Internal.ComWrappers$instance {
    constructor();
    static readonly DefaultIUnknownInterfaceDetailsStrategy: IIUnknownInterfaceDetailsStrategy;
    static readonly DefaultIUnknownStrategy: IIUnknownStrategy;
}


export type StrategyBasedComWrappers = StrategyBasedComWrappers$instance;

export abstract class AnsiStringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<byte>): string;
    static ConvertToUnmanaged(managed: string): ptr<byte>;
    static Free(unmanaged: ptr<byte>): void;
}


export type AnsiStringMarshaller = AnsiStringMarshaller$instance;

export abstract class ArrayMarshaller_2$instance {
    static AllocateContainerForManagedElements<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): T[];
    static AllocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: T[], numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static Free<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static GetManagedValuesDestination<T, TUnmanagedElement extends unknown>(managed: T[]): Span_1<T>;
    static GetManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: T[]): ReadOnlySpan_1<T>;
    static GetUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static GetUnmanagedValuesSource<T, TUnmanagedElement extends unknown>(unmanagedValue: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class BStrStringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<ushort>): string;
    static ConvertToUnmanaged(managed: string): ptr<ushort>;
    static Free(unmanaged: ptr<ushort>): void;
}


export type BStrStringMarshaller = BStrStringMarshaller$instance;

export abstract class ComInterfaceMarshaller_1$instance {
    static ConvertToManaged<T>(unmanaged: ptr<void>): T;
    static ConvertToUnmanaged<T>(managed: T): ptr<void>;
    static Free<T>(unmanaged: ptr<void>): void;
}


export abstract class ComVariantMarshaller$instance {
    static ConvertToManaged(unmanaged: ComVariant): unknown;
    static ConvertToUnmanaged(managed: unknown): ComVariant;
    static Free(unmanaged: ComVariant): void;
}


export type ComVariantMarshaller = ComVariantMarshaller$instance;

export abstract class ExceptionAsDefaultMarshaller_1$instance {
    static ConvertToUnmanaged<T extends unknown>(e: Exception): T;
}


export abstract class ExceptionAsHResultMarshaller_1$instance {
    static ConvertToUnmanaged<T extends INumber_1<T>>(e: Exception): T;
}


export abstract class ExceptionAsNaNMarshaller_1$instance {
    static ConvertToUnmanaged<T extends IFloatingPointIeee754_1<T>>(e: Exception): T;
}


export abstract class ExceptionAsVoidMarshaller$instance {
    static ConvertToUnmanaged(e: Exception): void;
}


export type ExceptionAsVoidMarshaller = ExceptionAsVoidMarshaller$instance;

export abstract class PointerArrayMarshaller_2$instance {
    static AllocateContainerForManagedElements<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): ptr<T>[];
    static AllocateContainerForUnmanagedElements<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[], numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static Free<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static GetManagedValuesDestination<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[]): Span_1<CLROf<nint>>;
    static GetManagedValuesSource<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[]): ReadOnlySpan_1<CLROf<nint>>;
    static GetUnmanagedValuesDestination<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static GetUnmanagedValuesSource<T extends unknown, TUnmanagedElement extends unknown>(unmanagedValue: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class ReadOnlySpanMarshaller_2$instance {
}


export abstract class ReadOnlySpanMarshaller_2_UnmanagedToManagedOut$instance {
    static AllocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>, numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static GetManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static GetUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
}


export abstract class SafeHandleMarshaller_1$instance {
}


export abstract class SpanMarshaller_2$instance {
    static AllocateContainerForManagedElements<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<T>;
    static AllocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: Span_1<T>, numElements: { value: ref<int> }): ptr<TUnmanagedElement>;
    static Free<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static GetManagedValuesDestination<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): Span_1<T>;
    static GetManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): ReadOnlySpan_1<T>;
    static GetUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static GetUnmanagedValuesSource<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class UniqueComInterfaceMarshaller_1$instance {
    static ConvertToManaged<T>(unmanaged: ptr<void>): T;
    static ConvertToUnmanaged<T>(managed: T): ptr<void>;
    static Free<T>(unmanaged: ptr<void>): void;
}


export abstract class Utf16StringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<ushort>): string;
    static ConvertToUnmanaged(managed: string): ptr<ushort>;
    static Free(unmanaged: ptr<ushort>): void;
    static GetPinnableReference(str: string): ref<char>;
}


export type Utf16StringMarshaller = Utf16StringMarshaller$instance;

export abstract class Utf8StringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<byte>): string;
    static ConvertToUnmanaged(managed: string): ptr<byte>;
    static Free(unmanaged: ptr<byte>): void;
}


export type Utf8StringMarshaller = Utf8StringMarshaller$instance;

