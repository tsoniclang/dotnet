// Generated by tsbindgen - Architecture
// Namespace: System.Text.RegularExpressions
// Assembly: System.Text.RegularExpressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { CustomAttributeBuilder } from "../../System.Reflection.Emit/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Char, Delegate, Enum, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, Range, ReadOnlySpan_1, String as ClrString, TimeoutException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum RegexOptions {
    None = 0,
    IgnoreCase = 1,
    Multiline = 2,
    ExplicitCapture = 4,
    Compiled = 8,
    Singleline = 16,
    IgnorePatternWhitespace = 32,
    RightToLeft = 64,
    ECMAScript = 256,
    CultureInvariant = 512,
    NonBacktracking = 1024
}


export enum RegexParseError {
    Unknown = 0,
    AlternationHasTooManyConditions = 1,
    AlternationHasMalformedCondition = 2,
    InvalidUnicodePropertyEscape = 3,
    MalformedUnicodePropertyEscape = 4,
    UnrecognizedEscape = 5,
    UnrecognizedControlCharacter = 6,
    MissingControlCharacter = 7,
    InsufficientOrInvalidHexDigits = 8,
    QuantifierOrCaptureGroupOutOfRange = 9,
    UndefinedNamedReference = 10,
    UndefinedNumberedReference = 11,
    MalformedNamedReference = 12,
    UnescapedEndingBackslash = 13,
    UnterminatedComment = 14,
    InvalidGroupingConstruct = 15,
    AlternationHasNamedCapture = 16,
    AlternationHasComment = 17,
    AlternationHasMalformedReference = 18,
    AlternationHasUndefinedReference = 19,
    CaptureGroupNameInvalid = 20,
    CaptureGroupOfZero = 21,
    UnterminatedBracket = 22,
    ExclusionGroupNotLast = 23,
    ReversedCharacterRange = 24,
    ShorthandClassInCharacterRange = 25,
    InsufficientClosingParentheses = 26,
    ReversedQuantifierRange = 27,
    NestedQuantifiersNotParenthesized = 28,
    QuantifierAfterNothing = 29,
    InsufficientOpeningParentheses = 30,
    UnrecognizedUnicodeProperty = 31
}


export class Regex_ValueMatchEnumerator$instance {
    readonly Current: ValueMatch;
    GetEnumerator(): Regex_ValueMatchEnumerator;
    MoveNext(): boolean;
}


export interface __Regex_ValueMatchEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<ValueMatch>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Regex_ValueMatchEnumerator = Regex_ValueMatchEnumerator$instance & __Regex_ValueMatchEnumerator$views;


export class Regex_ValueSplitEnumerator$instance {
    readonly Current: Range;
    GetEnumerator(): Regex_ValueSplitEnumerator;
    MoveNext(): boolean;
}


export interface __Regex_ValueSplitEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<Range>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Regex_ValueSplitEnumerator = Regex_ValueSplitEnumerator$instance & __Regex_ValueSplitEnumerator$views;


export class ValueMatch$instance {
    readonly Index: int;
    readonly Length: int;
}


export type ValueMatch = ValueMatch$instance;

export class Capture$instance {
    readonly Index: int;
    readonly Length: int;
    readonly Value: string;
    readonly ValueSpan: ReadOnlySpan_1<CLROf<string>>;
    ToString(): string;
}


export type Capture = Capture$instance;

export class CaptureCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly Item: Capture;
    readonly SyncRoot: any;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(array: Capture[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator;
}


export interface __CaptureCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<Capture>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<Capture>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<Capture>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Capture>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type CaptureCollection = CaptureCollection$instance & __CaptureCollection$views;


export class GeneratedRegexAttribute$instance extends System_Internal.Attribute$instance {
    constructor(pattern: string);
    constructor(pattern: string, options: RegexOptions);
    constructor(pattern: string, options: RegexOptions, cultureName: string);
    constructor(pattern: string, options: RegexOptions, matchTimeoutMilliseconds: int);
    constructor(pattern: string, options: RegexOptions, matchTimeoutMilliseconds: int, cultureName: string);
    readonly CultureName: string;
    readonly MatchTimeoutMilliseconds: int;
    readonly Options: RegexOptions;
    readonly Pattern: string;
}


export type GeneratedRegexAttribute = GeneratedRegexAttribute$instance;

export class Group$instance extends Capture$instance {
    readonly Captures: CaptureCollection;
    readonly Name: string;
    readonly Success: boolean;
    static Synchronized(inner: Group): Group;
}


export type Group = Group$instance;

export class GroupCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly Keys: IEnumerable_1<CLROf<string>>;
    readonly SyncRoot: any;
    readonly Values: IEnumerable_1<Group>;
    ContainsKey(key: string): boolean;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(array: Group[], arrayIndex: int): void;
    get_Item(groupnum: int): Group;
    get_Item(groupname: string): Group;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: string, value: { value: TSByRef<Group> }): boolean;
}


export interface __GroupCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<Group>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<Group>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<Group>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Group>;
    readonly As_IReadOnlyDictionary_2: System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<CLROf<string>, Group>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type GroupCollection = GroupCollection$instance & __GroupCollection$views;


export class Match$instance extends Group$instance {
    readonly Groups: GroupCollection;
    NextMatch(): Match;
    Result(replacement: string): string;
    static readonly Empty: Match;
}


export type Match = Match$instance;

export class MatchCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly Item: Match;
    readonly SyncRoot: any;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(array: Match[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator;
}


export interface __MatchCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<Match>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<Match>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<Match>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Match>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type MatchCollection = MatchCollection$instance & __MatchCollection$views;


export class MatchEvaluator$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(match: Match, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(match: Match): string;
}


export interface __MatchEvaluator$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MatchEvaluator = MatchEvaluator$instance & __MatchEvaluator$views;


export class Regex$instance {
    constructor(pattern: string);
    constructor(pattern: string, options: RegexOptions);
    constructor(pattern: string, options: RegexOptions, matchTimeout: TimeSpan);
    readonly MatchTimeout: TimeSpan;
    readonly Options: RegexOptions;
    readonly RightToLeft: boolean;
    Count(input: string): int;
    Count(input: ReadOnlySpan_1<CLROf<string>>): int;
    Count(input: ReadOnlySpan_1<CLROf<string>>, startat: int): int;
    EnumerateMatches(input: ReadOnlySpan_1<CLROf<string>>): Regex_ValueMatchEnumerator;
    EnumerateMatches(input: ReadOnlySpan_1<CLROf<string>>, startat: int): Regex_ValueMatchEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<CLROf<string>>): Regex_ValueSplitEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<CLROf<string>>, count: int): Regex_ValueSplitEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<CLROf<string>>, count: int, startat: int): Regex_ValueSplitEnumerator;
    GetGroupNames(): string[];
    GetGroupNumbers(): int[];
    GroupNameFromNumber(i: int): string;
    GroupNumberFromName(name: string): int;
    IsMatch(input: string): boolean;
    IsMatch(input: string, startat: int): boolean;
    IsMatch(input: ReadOnlySpan_1<CLROf<string>>): boolean;
    IsMatch(input: ReadOnlySpan_1<CLROf<string>>, startat: int): boolean;
    Match(input: string): Match;
    Match(input: string, startat: int): Match;
    Match(input: string, beginning: int, length: int): Match;
    Matches(input: string): MatchCollection;
    Matches(input: string, startat: int): MatchCollection;
    Replace(input: string, replacement: string): string;
    Replace(input: string, replacement: string, count: int): string;
    Replace(input: string, replacement: string, count: int, startat: int): string;
    Replace(input: string, evaluator: MatchEvaluator): string;
    Replace(input: string, evaluator: MatchEvaluator, count: int): string;
    Replace(input: string, evaluator: MatchEvaluator, count: int, startat: int): string;
    Split(input: string): string[];
    Split(input: string, count: int): string[];
    Split(input: string, count: int, startat: int): string[];
    ToString(): string;
    static readonly InfiniteMatchTimeout: TimeSpan;
    static CacheSize: int;
    static CompileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName, attributes: CustomAttributeBuilder[], resourceFile: string): void;
    static CompileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName, attributes: CustomAttributeBuilder[]): void;
    static CompileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName): void;
    static Count(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): int;
    static Count(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions): int;
    static Count(input: ReadOnlySpan_1<CLROf<string>>, pattern: string): int;
    static Count(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): int;
    static Count(input: string, pattern: string, options: RegexOptions): int;
    static Count(input: string, pattern: string): int;
    static EnumerateMatches(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex_ValueMatchEnumerator;
    static EnumerateMatches(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions): Regex_ValueMatchEnumerator;
    static EnumerateMatches(input: ReadOnlySpan_1<CLROf<string>>, pattern: string): Regex_ValueMatchEnumerator;
    static EnumerateSplits(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex_ValueSplitEnumerator;
    static EnumerateSplits(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions): Regex_ValueSplitEnumerator;
    static EnumerateSplits(input: ReadOnlySpan_1<CLROf<string>>, pattern: string): Regex_ValueSplitEnumerator;
    static Escape(str: string): string;
    static IsMatch(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): boolean;
    static IsMatch(input: ReadOnlySpan_1<CLROf<string>>, pattern: string, options: RegexOptions): boolean;
    static IsMatch(input: ReadOnlySpan_1<CLROf<string>>, pattern: string): boolean;
    static IsMatch(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): boolean;
    static IsMatch(input: string, pattern: string, options: RegexOptions): boolean;
    static IsMatch(input: string, pattern: string): boolean;
    static Match(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Match;
    static Match(input: string, pattern: string, options: RegexOptions): Match;
    static Match(input: string, pattern: string): Match;
    static Matches(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): MatchCollection;
    static Matches(input: string, pattern: string, options: RegexOptions): MatchCollection;
    static Matches(input: string, pattern: string): MatchCollection;
    static Replace(input: string, pattern: string, replacement: string, options: RegexOptions, matchTimeout: TimeSpan): string;
    static Replace(input: string, pattern: string, replacement: string, options: RegexOptions): string;
    static Replace(input: string, pattern: string, replacement: string): string;
    static Replace(input: string, pattern: string, evaluator: MatchEvaluator, options: RegexOptions, matchTimeout: TimeSpan): string;
    static Replace(input: string, pattern: string, evaluator: MatchEvaluator, options: RegexOptions): string;
    static Replace(input: string, pattern: string, evaluator: MatchEvaluator): string;
    static Split(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): string[];
    static Split(input: string, pattern: string, options: RegexOptions): string[];
    static Split(input: string, pattern: string): string[];
    static Unescape(str: string): string;
}


export interface __Regex$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Regex = Regex$instance & __Regex$views;


export class RegexCompilationInfo$instance {
    constructor(pattern: string, options: RegexOptions, name: string, fullnamespace: string, ispublic: boolean);
    constructor(pattern: string, options: RegexOptions, name: string, fullnamespace: string, ispublic: boolean, matchTimeout: TimeSpan);
    IsPublic: boolean;
    MatchTimeout: TimeSpan;
    Name: string;
    Namespace: string;
    Options: RegexOptions;
    Pattern: string;
}


export type RegexCompilationInfo = RegexCompilationInfo$instance;

export class RegexMatchTimeoutException$instance extends System_Internal.TimeoutException$instance {
    constructor(regexInput: string, regexPattern: string, matchTimeout: TimeSpan);
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    readonly Input: string;
    readonly MatchTimeout: TimeSpan;
    readonly Pattern: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __RegexMatchTimeoutException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RegexMatchTimeoutException = RegexMatchTimeoutException$instance & __RegexMatchTimeoutException$views;


export class RegexParseException$instance extends System_Internal.ArgumentException$instance {
    readonly Error: RegexParseError;
    readonly Offset: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __RegexParseException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RegexParseException = RegexParseException$instance & __RegexParseException$views;


export abstract class RegexRunner$instance {
    static CharInClass(ch: string, charClass: string): boolean;
}


export type RegexRunner = RegexRunner$instance;

export abstract class RegexRunnerFactory$instance {
}


export type RegexRunnerFactory = RegexRunnerFactory$instance;

