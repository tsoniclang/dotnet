// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Collections, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { ReadOnlyCollection_1, ReadOnlyDictionary_2, ReadOnlySet_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { DictionaryEntry, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IEqualityComparer, IList } from "../../System.Collections/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, Boolean as ClrBoolean, Byte, Comparison_1, Converter_2, Enum, Exception, Func_2, Func_3, IComparable_1, IDisposable, IEquatable_1, Int32, Nullable_1, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IAlternateEqualityComparer_2$instance<TAlternate, T> {
    Create(alternate: TAlternate): T;
    Equals(alternate: TAlternate, other: T): boolean;
    GetHashCode(alternate: TAlternate): int;
}


export type IAlternateEqualityComparer_2<TAlternate, T> = IAlternateEqualityComparer_2$instance<TAlternate, T>;

export interface IAsyncEnumerable_1$instance<T> {
    GetAsyncEnumerator(cancellationToken?: CancellationToken): IAsyncEnumerator_1<T>;
}


export type IAsyncEnumerable_1<T> = IAsyncEnumerable_1$instance<T>;

export interface IAsyncEnumerator_1$instance<T> {
    readonly Current: T;
    DisposeAsync(): ValueTask;
    MoveNextAsync(): ValueTask_1<CLROf<boolean>>;
}


export type IAsyncEnumerator_1<T> = IAsyncEnumerator_1$instance<T>;

export interface ICollection_1$instance<T> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type ICollection_1<T> = ICollection_1$instance<T>;

export interface IComparer_1$instance<T> {
    Compare(x: T, y: T): int;
}


export type IComparer_1<T> = IComparer_1$instance<T>;

export interface IDictionary_2$instance<TKey, TValue> {
    Item: TValue;
    readonly Keys: ICollection_1<TKey>;
    readonly Values: ICollection_1<TValue>;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: KeyValuePair_2<TKey, TValue>): void;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    CopyTo(array: KeyValuePair_2<TKey, TValue>[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export type IDictionary_2<TKey, TValue> = IDictionary_2$instance<TKey, TValue>;

export interface IEnumerable_1$instance<T> {
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type IEnumerable_1<T> = IEnumerable_1$instance<T>;

export interface IEnumerator_1$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export type IEnumerator_1<T> = IEnumerator_1$instance<T>;

export interface IEqualityComparer_1$instance<T> {
    Equals(x: T, y: T): boolean;
    GetHashCode(obj: T): int;
}


export type IEqualityComparer_1<T> = IEqualityComparer_1$instance<T>;

export interface IList_1$instance<T> {
    Item: T;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: T): int;
    Insert(index: int, item: T): void;
    RemoveAt(index: int): void;
}


export type IList_1<T> = IList_1$instance<T>;

export interface IReadOnlyCollection_1$instance<T> {
    readonly Count: int;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type IReadOnlyCollection_1<T> = IReadOnlyCollection_1$instance<T>;

export interface IReadOnlyDictionary_2$instance<TKey, TValue> {
    readonly Item: TValue;
    readonly Keys: IEnumerable_1<TKey>;
    readonly Values: IEnumerable_1<TValue>;
    readonly Count: int;
    ContainsKey(key: TKey): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export type IReadOnlyDictionary_2<TKey, TValue> = IReadOnlyDictionary_2$instance<TKey, TValue>;

export interface IReadOnlyList_1$instance<T> {
    readonly Item: T;
    readonly Count: int;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type IReadOnlyList_1<T> = IReadOnlyList_1$instance<T>;

export interface IReadOnlySet_1$instance<T> {
    readonly Count: int;
    Contains(item: T): boolean;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
}


export type IReadOnlySet_1<T> = IReadOnlySet_1$instance<T>;

export interface ISet_1$instance<T> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Add(item: T): boolean;
    Clear(): void;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
}


export type ISet_1<T> = ISet_1$instance<T>;

export class Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly dictionary: Dictionary_2<TKey, TValue>;
    item: TValue;
    containsKey(key: TAlternateKey): boolean;
    remove(key: TAlternateKey): boolean;
    remove(key: TAlternateKey, actualKey: { value: ref<TKey> }, value: { value: ref<TValue> }): boolean;
    tryAdd(key: TAlternateKey, value: TValue): boolean;
    tryGetValue(key: TAlternateKey, value: { value: ref<TValue> }): boolean;
    tryGetValue(key: TAlternateKey, actualKey: { value: ref<TKey> }, value: { value: ref<TValue> }): boolean;
}


export type Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export class Dictionary_2_Enumerator$instance<TKey, TValue> {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
}


export interface __Dictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionaryEnumerator: System_Collections_Internal.IDictionaryEnumerator$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_Enumerator<TKey, TValue> = Dictionary_2_Enumerator$instance<TKey, TValue> & __Dictionary_2_Enumerator$views<TKey, TValue>;


export class Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TKey;
    dispose(): void;
    moveNext(): boolean;
}


export interface __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TKey>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_KeyCollection_Enumerator<TKey, TValue> = Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export class Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TValue;
    dispose(): void;
    moveNext(): boolean;
}


export interface __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TValue>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_ValueCollection_Enumerator<TKey, TValue> = Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export class HashSet_1_AlternateLookup_1$instance<T, TAlternate> {
    readonly set_: HashSet_1<T>;
    add(item: TAlternate): boolean;
    contains(item: TAlternate): boolean;
    remove(item: TAlternate): boolean;
    tryGetValue(equalValue: TAlternate, actualValue: { value: ref<T> }): boolean;
}


export type HashSet_1_AlternateLookup_1<T, TAlternate> = HashSet_1_AlternateLookup_1$instance<T, TAlternate>;

export class HashSet_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface __HashSet_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type HashSet_1_Enumerator<T> = HashSet_1_Enumerator$instance<T> & __HashSet_1_Enumerator$views<T>;


export class KeyValuePair_2$instance<TKey, TValue> {
    constructor(key: TKey, value: TValue);
    readonly key: TKey;
    readonly value: TValue;
    deconstruct(key: { value: ref<TKey> }, value: { value: ref<TValue> }): void;
    toString(): string;
}


export type KeyValuePair_2<TKey, TValue> = KeyValuePair_2$instance<TKey, TValue>;

export class LinkedList_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface __LinkedList_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LinkedList_1_Enumerator<T> = LinkedList_1_Enumerator$instance<T> & __LinkedList_1_Enumerator$views<T>;


export class List_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface __List_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type List_1_Enumerator<T> = List_1_Enumerator$instance<T> & __List_1_Enumerator$views<T>;


export class OrderedDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly current: KeyValuePair_2<TKey, TValue>;
    moveNext(): boolean;
}


export interface __OrderedDictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionaryEnumerator: System_Collections_Internal.IDictionaryEnumerator$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_Enumerator<TKey, TValue> = OrderedDictionary_2_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_Enumerator$views<TKey, TValue>;


export class OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TKey;
    moveNext(): boolean;
}


export interface __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TKey>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export class OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TValue;
    moveNext(): boolean;
}


export interface __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TValue>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export class PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> {
    readonly current: ValueTuple_2<TElement, TPriority>;
    dispose(): void;
    moveNext(): boolean;
}


export interface __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<ValueTuple_2<TElement, TPriority>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority>;


export class Queue_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface __Queue_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Queue_1_Enumerator<T> = Queue_1_Enumerator$instance<T> & __Queue_1_Enumerator$views<T>;


export class SortedDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
}


export interface __SortedDictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionaryEnumerator: System_Collections_Internal.IDictionaryEnumerator$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_Enumerator<TKey, TValue> = SortedDictionary_2_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_Enumerator$views<TKey, TValue>;


export class SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TKey;
    dispose(): void;
    moveNext(): boolean;
}


export interface __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TKey>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export class SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly current: TValue;
    dispose(): void;
    moveNext(): boolean;
}


export interface __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TValue>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export class SortedSet_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface __SortedSet_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SortedSet_1_Enumerator<T> = SortedSet_1_Enumerator$instance<T> & __SortedSet_1_Enumerator$views<T>;


export class Stack_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface __Stack_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Stack_1_Enumerator<T> = Stack_1_Enumerator$instance<T> & __Stack_1_Enumerator$views<T>;


export class ByteEqualityComparer$instance extends EqualityComparer_1$instance<CLROf<byte>> {
    constructor();
    equals(x: any, y: any): boolean;
    getHashCode(obj: any): int;
}


export interface __ByteEqualityComparer$views {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<CLROf<byte>>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type ByteEqualityComparer = ByteEqualityComparer$instance & __ByteEqualityComparer$views;


export abstract class Comparer_1$instance<T> {
    abstract compare(x: T, y: T): int;
    static readonly Default: unknown;
    static Create<T>(comparison: Comparison_1<T>): Comparer_1<T>;
}


export interface __Comparer_1$views<T> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<T>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type Comparer_1<T> = Comparer_1$instance<T> & __Comparer_1$views<T>;


export class Dictionary_2$instance<TKey, TValue> {
    constructor();
    constructor(capacity: int);
    constructor(comparer: IEqualityComparer_1<TKey>);
    constructor(capacity: int, comparer: IEqualityComparer_1<TKey>);
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>);
    readonly capacity: int;
    readonly comparer: IEqualityComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: Dictionary_2_KeyCollection<TKey, TValue>;
    readonly values: Dictionary_2_ValueCollection<TKey, TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    ensureCapacity(capacity: int): int;
    getAlternateLookup<TAlternateKey>(): Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    getEnumerator(): Dictionary_2_Enumerator<TKey, TValue>;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: any): void;
    remove(key: TKey): boolean;
    remove(key: TKey, value: { value: ref<TValue> }): boolean;
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryAdd(key: TKey, value: TValue): boolean;
    tryGetAlternateLookup<TAlternateKey>(lookup: { value: ref<Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export interface __Dictionary_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Dictionary_2<TKey, TValue> = Dictionary_2$instance<TKey, TValue> & __Dictionary_2$views<TKey, TValue>;


export class Dictionary_2_KeyCollection$instance<TKey, TValue> {
    constructor(dictionary: Dictionary_2<TKey, TValue>);
    readonly count: int;
    contains(item: TKey): boolean;
    copyTo(array: TKey[], index: int): void;
    getEnumerator(): Dictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export interface __Dictionary_2_KeyCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_KeyCollection<TKey, TValue> = Dictionary_2_KeyCollection$instance<TKey, TValue> & __Dictionary_2_KeyCollection$views<TKey, TValue>;


export class Dictionary_2_ValueCollection$instance<TKey, TValue> {
    constructor(dictionary: Dictionary_2<TKey, TValue>);
    readonly count: int;
    copyTo(array: TValue[], index: int): void;
    getEnumerator(): Dictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export interface __Dictionary_2_ValueCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_ValueCollection<TKey, TValue> = Dictionary_2_ValueCollection$instance<TKey, TValue> & __Dictionary_2_ValueCollection$views<TKey, TValue>;


export class EnumEqualityComparer_1$instance<T extends number> extends EqualityComparer_1$instance<T> {
    constructor();
    equals(x: any, y: any): boolean;
    getHashCode(obj: any): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __EnumEqualityComparer_1$views<T extends number & any> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EnumEqualityComparer_1<T extends number> = EnumEqualityComparer_1$instance<T> & __EnumEqualityComparer_1$views<T>;


export abstract class EqualityComparer_1$instance<T> {
    abstract equals(x: T, y: T): boolean;
    abstract getHashCode(obj: T): int;
    static readonly Default: unknown;
    static Create<T>(equals: Func_3<T, T, CLROf<boolean>>, getHashCode?: Func_2<T, CLROf<int>>): EqualityComparer_1<T>;
}


export interface __EqualityComparer_1$views<T> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type EqualityComparer_1<T> = EqualityComparer_1$instance<T> & __EqualityComparer_1$views<T>;


export class GenericComparer_1$instance<T extends IComparable_1<T>> extends Comparer_1$instance<T> {
    constructor();
    compare(x: any, y: any): int;
    equals(obj: any): boolean;
    getHashCode(): int;
}


export interface __GenericComparer_1$views<T extends IComparable_1<T>> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<T>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type GenericComparer_1<T extends IComparable_1<T>> = GenericComparer_1$instance<T> & __GenericComparer_1$views<T>;


export class GenericEqualityComparer_1$instance<T extends IEquatable_1<T>> extends EqualityComparer_1$instance<T> {
    constructor();
    equals(x: any, y: any): boolean;
    getHashCode(obj: any): int;
}


export interface __GenericEqualityComparer_1$views<T extends IEquatable_1<T>> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type GenericEqualityComparer_1<T extends IEquatable_1<T>> = GenericEqualityComparer_1$instance<T> & __GenericEqualityComparer_1$views<T>;


export class HashSet_1$instance<T> {
    constructor();
    constructor(comparer: IEqualityComparer_1<T>);
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    constructor(collection: IEnumerable_1<T>, comparer: IEqualityComparer_1<T>);
    constructor(capacity: int, comparer: IEqualityComparer_1<T>);
    readonly capacity: int;
    readonly comparer: IEqualityComparer_1<T>;
    readonly count: int;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[]): void;
    copyTo(array: T[], arrayIndex: int): void;
    copyTo(array: T[], arrayIndex: int, count: int): void;
    ensureCapacity(capacity: int): int;
    exceptWith(other: IEnumerable_1<T>): void;
    getAlternateLookup<TAlternate>(): HashSet_1_AlternateLookup_1<T, TAlternate>;
    getEnumerator(): HashSet_1_Enumerator<T>;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    onDeserialization(sender: any): void;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    removeWhere(match: Predicate_1<T>): int;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryGetAlternateLookup<TAlternate>(lookup: { value: ref<HashSet_1_AlternateLookup_1<T, TAlternate>> }): boolean;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
    static CreateSetComparer<T>(): IEqualityComparer_1<HashSet_1<T>>;
}


export interface __HashSet_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: ISet_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HashSet_1<T> = HashSet_1$instance<T> & __HashSet_1$views<T>;


export class KeyNotFoundException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __KeyNotFoundException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type KeyNotFoundException = KeyNotFoundException$instance & __KeyNotFoundException$views;


export class LinkedList_1$instance<T> {
    constructor();
    constructor(collection: IEnumerable_1<T>);
    readonly count: int;
    readonly first: LinkedListNode_1<T>;
    readonly last: LinkedListNode_1<T>;
    addAfter(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    addAfter(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    addBefore(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    addBefore(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    addFirst(value: T): LinkedListNode_1<T>;
    addFirst(node: LinkedListNode_1<T>): void;
    addLast(value: T): LinkedListNode_1<T>;
    addLast(node: LinkedListNode_1<T>): void;
    clear(): void;
    contains(value: T): boolean;
    copyTo(array: T[], index: int): void;
    find(value: T): LinkedListNode_1<T>;
    findLast(value: T): LinkedListNode_1<T>;
    getEnumerator(): LinkedList_1_Enumerator<T>;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    onDeserialization(sender: any): void;
    remove(value: T): boolean;
    remove(node: LinkedListNode_1<T>): void;
    removeFirst(): void;
    removeLast(): void;
}


export interface __LinkedList_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LinkedList_1<T> = LinkedList_1$instance<T> & __LinkedList_1$views<T>;


export class LinkedListNode_1$instance<T> {
    constructor(value: T);
    readonly list: LinkedList_1<T>;
    readonly next: LinkedListNode_1<T>;
    readonly previous: LinkedListNode_1<T>;
    value: T;
    readonly valueRef: ref<T>;
}


export type LinkedListNode_1<T> = LinkedListNode_1$instance<T>;

export class List_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    capacity: int;
    readonly count: int;
    item: T;
    add(item: T): void;
    addRange(collection: IEnumerable_1<T>): void;
    asReadOnly(): ReadOnlyCollection_1<T>;
    binarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    binarySearch(item: T): int;
    binarySearch(item: T, comparer: IComparer_1<T>): int;
    clear(): void;
    contains(item: T): boolean;
    convertAll<TOutput>(converter: Converter_2<T, TOutput>): List_1<TOutput>;
    copyTo(array: T[]): void;
    copyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    copyTo(array: T[], arrayIndex: int): void;
    ensureCapacity(capacity: int): int;
    exists(match: Predicate_1<T>): boolean;
    find(match: Predicate_1<T>): T;
    findAll(match: Predicate_1<T>): List_1<T>;
    findIndex(match: Predicate_1<T>): int;
    findIndex(startIndex: int, match: Predicate_1<T>): int;
    findIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    findLast(match: Predicate_1<T>): T;
    findLastIndex(match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    forEach(action: Action_1<T>): void;
    getEnumerator(): List_1_Enumerator<T>;
    getRange(index: int, count: int): List_1<T>;
    indexOf(item: T): int;
    indexOf(item: T, index: int): int;
    indexOf(item: T, index: int, count: int): int;
    insert(index: int, item: T): void;
    insertRange(index: int, collection: IEnumerable_1<T>): void;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, index: int): int;
    lastIndexOf(item: T, index: int, count: int): int;
    remove(item: T): boolean;
    removeAll(match: Predicate_1<T>): int;
    removeAt(index: int): void;
    removeRange(index: int, count: int): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    slice(start: int, length: int): List_1<T>;
    sort(): void;
    sort(comparer: IComparer_1<T>): void;
    sort(index: int, count: int, comparer: IComparer_1<T>): void;
    sort(comparison: Comparison_1<T>): void;
    toArray(): T[];
    trimExcess(): void;
    trueForAll(match: Predicate_1<T>): boolean;
}


export interface __List_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IList_1: IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type List_1<T> = List_1$instance<T> & __List_1$views<T>;


export class NonRandomizedStringEqualityComparer$instance {
    equals(x: string, y: string): boolean;
    getHashCode(obj: string): int;
    getUnderlyingEqualityComparer(): IEqualityComparer_1<CLROf<string>>;
    static GetStringComparer(comparer: any): IEqualityComparer_1<CLROf<string>>;
}


export interface __NonRandomizedStringEqualityComparer$views {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<CLROf<string>>;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NonRandomizedStringEqualityComparer = NonRandomizedStringEqualityComparer$instance & __NonRandomizedStringEqualityComparer$views;


export class NullableComparer_1$instance<T extends any> extends Comparer_1$instance<Nullable_1<T>> {
    constructor();
    compare(x: any, y: any): int;
    equals(obj: any): boolean;
    getHashCode(): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NullableComparer_1$views<T extends any> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<Nullable_1<T>>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NullableComparer_1<T> = NullableComparer_1$instance<T> & __NullableComparer_1$views<T>;


export class NullableEqualityComparer_1$instance<T extends any> extends EqualityComparer_1$instance<Nullable_1<T>> {
    constructor();
    equals(x: any, y: any): boolean;
    getHashCode(obj: any): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NullableEqualityComparer_1$views<T extends any> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<Nullable_1<T>>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NullableEqualityComparer_1<T> = NullableEqualityComparer_1$instance<T> & __NullableEqualityComparer_1$views<T>;


export class ObjectComparer_1$instance<T> extends Comparer_1$instance<T> {
    constructor();
    compare(x: any, y: any): int;
    equals(obj: any): boolean;
    getHashCode(): int;
}


export interface __ObjectComparer_1$views<T> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<T>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type ObjectComparer_1<T> = ObjectComparer_1$instance<T> & __ObjectComparer_1$views<T>;


export class ObjectEqualityComparer_1$instance<T> extends EqualityComparer_1$instance<T> {
    constructor();
    equals(x: any, y: any): boolean;
    getHashCode(obj: any): int;
}


export interface __ObjectEqualityComparer_1$views<T> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type ObjectEqualityComparer_1<T> = ObjectEqualityComparer_1$instance<T> & __ObjectEqualityComparer_1$views<T>;


export class OrderedDictionary_2$instance<TKey, TValue> {
    constructor();
    constructor(capacity: int);
    constructor(comparer: IEqualityComparer_1<TKey>);
    constructor(capacity: int, comparer: IEqualityComparer_1<TKey>);
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>);
    readonly capacity: int;
    readonly comparer: IEqualityComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: OrderedDictionary_2_KeyCollection<TKey, TValue>;
    readonly values: OrderedDictionary_2_ValueCollection<TKey, TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    ensureCapacity(capacity: int): int;
    getAt(index: int): KeyValuePair_2<TKey, TValue>;
    getEnumerator(): OrderedDictionary_2_Enumerator<TKey, TValue>;
    indexOf(key: TKey): int;
    insert(index: int, key: TKey, value: TValue): void;
    remove(key: TKey): boolean;
    remove(key: TKey, value: { value: ref<TValue> }): boolean;
    removeAt(index: int): void;
    setAt(index: int, value: TValue): void;
    setAt(index: int, key: TKey, value: TValue): void;
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryAdd(key: TKey, value: TValue): boolean;
    tryAdd(key: TKey, value: TValue, index: { value: ref<int> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }, index: { value: ref<int> }): boolean;
}


export interface __OrderedDictionary_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IList_1: IList_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2<TKey, TValue> = OrderedDictionary_2$instance<TKey, TValue> & __OrderedDictionary_2$views<TKey, TValue>;


export class OrderedDictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly count: int;
    contains(key: TKey): boolean;
    copyTo(array: TKey[], arrayIndex: int): void;
    getEnumerator(): OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export interface __OrderedDictionary_2_KeyCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IList_1: IList_1$instance<TKey>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_KeyCollection<TKey, TValue> = OrderedDictionary_2_KeyCollection$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection$views<TKey, TValue>;


export class OrderedDictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly count: int;
    copyTo(array: TValue[], arrayIndex: int): void;
    getEnumerator(): OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export interface __OrderedDictionary_2_ValueCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IList_1: IList_1$instance<TValue>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_ValueCollection<TKey, TValue> = OrderedDictionary_2_ValueCollection$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection$views<TKey, TValue>;


export class PriorityQueue_2$instance<TElement, TPriority> {
    constructor();
    constructor(initialCapacity: int);
    constructor(comparer: IComparer_1<TPriority>);
    constructor(initialCapacity: int, comparer: IComparer_1<TPriority>);
    constructor(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>);
    constructor(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>, comparer: IComparer_1<TPriority>);
    readonly capacity: int;
    readonly comparer: IComparer_1<TPriority>;
    readonly count: int;
    readonly unorderedItems: PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority>;
    clear(): void;
    dequeue(): TElement;
    dequeueEnqueue(element: TElement, priority: TPriority): TElement;
    enqueue(element: TElement, priority: TPriority): void;
    enqueueDequeue(element: TElement, priority: TPriority): TElement;
    enqueueRange(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>): void;
    enqueueRange(elements: IEnumerable_1<TElement>, priority: TPriority): void;
    ensureCapacity(capacity: int): int;
    peek(): TElement;
    remove(element: TElement, removedElement: { value: ref<TElement> }, priority: { value: ref<TPriority> }, equalityComparer?: IEqualityComparer_1<TElement>): boolean;
    trimExcess(): void;
    tryDequeue(element: { value: ref<TElement> }, priority: { value: ref<TPriority> }): boolean;
    tryPeek(element: { value: ref<TElement> }, priority: { value: ref<TPriority> }): boolean;
}


export type PriorityQueue_2<TElement, TPriority> = PriorityQueue_2$instance<TElement, TPriority>;

export class PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> {
    readonly count: int;
    getEnumerator(): PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority>;
}


export interface __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority> {
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<ValueTuple_2<TElement, TPriority>>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<ValueTuple_2<TElement, TPriority>>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority>;


export class Queue_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    readonly capacity: int;
    readonly count: int;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    dequeue(): T;
    enqueue(item: T): void;
    ensureCapacity(capacity: int): int;
    getEnumerator(): Queue_1_Enumerator<T>;
    peek(): T;
    toArray(): T[];
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryDequeue(result: { value: ref<T> }): boolean;
    tryPeek(result: { value: ref<T> }): boolean;
}


export interface __Queue_1$views<T> {
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Queue_1<T> = Queue_1$instance<T> & __Queue_1$views<T>;


export class ReferenceEqualityComparer$instance {
    equals(x: any, y: any): boolean;
    getHashCode(obj: any): int;
    static readonly Instance: ReferenceEqualityComparer;
}


export interface __ReferenceEqualityComparer$views {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<any>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type ReferenceEqualityComparer = ReferenceEqualityComparer$instance & __ReferenceEqualityComparer$views;


export class SortedDictionary_2$instance<TKey, TValue> {
    constructor();
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey>);
    constructor(comparer: IComparer_1<TKey>);
    readonly comparer: IComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: SortedDictionary_2_KeyCollection<TKey, TValue>;
    readonly values: SortedDictionary_2_ValueCollection<TKey, TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    copyTo(array: KeyValuePair_2<TKey, TValue>[], index: int): void;
    getEnumerator(): SortedDictionary_2_Enumerator<TKey, TValue>;
    remove(key: TKey): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export interface __SortedDictionary_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2<TKey, TValue> = SortedDictionary_2$instance<TKey, TValue> & __SortedDictionary_2$views<TKey, TValue>;


export class SortedDictionary_2_KeyCollection$instance<TKey, TValue> {
    constructor(dictionary: SortedDictionary_2<TKey, TValue>);
    readonly count: int;
    contains(item: TKey): boolean;
    copyTo(array: TKey[], index: int): void;
    getEnumerator(): SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export interface __SortedDictionary_2_KeyCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_KeyCollection<TKey, TValue> = SortedDictionary_2_KeyCollection$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection$views<TKey, TValue>;


export class SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> extends Comparer_1$instance<KeyValuePair_2<TKey, TValue>> {
    constructor(keyComparer: IComparer_1<TKey>);
    compare(x: any, y: any): int;
    equals(obj: any): boolean;
    getHashCode(): int;
}


export interface __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type SortedDictionary_2_KeyValuePairComparer<TKey, TValue> = SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> & __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue>;


export class SortedDictionary_2_ValueCollection$instance<TKey, TValue> {
    constructor(dictionary: SortedDictionary_2<TKey, TValue>);
    readonly count: int;
    copyTo(array: TValue[], index: int): void;
    getEnumerator(): SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export interface __SortedDictionary_2_ValueCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_ValueCollection<TKey, TValue> = SortedDictionary_2_ValueCollection$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection$views<TKey, TValue>;


export class SortedList_2$instance<TKey, TValue> {
    constructor();
    constructor(capacity: int);
    constructor(comparer: IComparer_1<TKey>);
    constructor(capacity: int, comparer: IComparer_1<TKey>);
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey>);
    capacity: int;
    readonly comparer: IComparer_1<TKey>;
    readonly count: int;
    item: TValue;
    readonly keys: IList_1<TKey>;
    readonly values: IList_1<TValue>;
    add(key: TKey, value: TValue): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    getKeyAtIndex(index: int): TKey;
    getValueAtIndex(index: int): TValue;
    indexOfKey(key: TKey): int;
    indexOfValue(value: TValue): int;
    remove(key: TKey): boolean;
    removeAt(index: int): void;
    setValueAtIndex(index: int, value: TValue): void;
    trimExcess(): void;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export interface __SortedList_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2<TKey, TValue> = SortedList_2$instance<TKey, TValue> & __SortedList_2$views<TKey, TValue>;


export class SortedList_2_KeyList$instance<TKey, TValue> {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: TKey;
    add(key: TKey): void;
    clear(): void;
    contains(key: TKey): boolean;
    copyTo(array: TKey[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<TKey>;
    indexOf(key: TKey): int;
    insert(index: int, value: TKey): void;
    remove(key: TKey): boolean;
    removeAt(index: int): void;
}


export interface __SortedList_2_KeyList$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IList_1: IList_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_KeyList<TKey, TValue> = SortedList_2_KeyList$instance<TKey, TValue> & __SortedList_2_KeyList$views<TKey, TValue>;


export class SortedList_2_ValueList$instance<TKey, TValue> {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: TValue;
    add(key: TValue): void;
    clear(): void;
    contains(value: TValue): boolean;
    copyTo(array: TValue[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<TValue>;
    indexOf(value: TValue): int;
    insert(index: int, value: TValue): void;
    remove(value: TValue): boolean;
    removeAt(index: int): void;
}


export interface __SortedList_2_ValueList$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IList_1: IList_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_ValueList<TKey, TValue> = SortedList_2_ValueList$instance<TKey, TValue> & __SortedList_2_ValueList$views<TKey, TValue>;


export class SortedSet_1$instance<T> {
    constructor();
    constructor(comparer: IComparer_1<T>);
    constructor(collection: IEnumerable_1<T>);
    constructor(collection: IEnumerable_1<T>, comparer: IComparer_1<T>);
    readonly comparer: IComparer_1<T>;
    readonly count: int;
    readonly max: T;
    readonly min: T;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[]): void;
    copyTo(array: T[], index: int): void;
    copyTo(array: T[], index: int, count: int): void;
    exceptWith(other: IEnumerable_1<T>): void;
    getEnumerator(): SortedSet_1_Enumerator<T>;
    getViewBetween(lowerValue: T, upperValue: T): SortedSet_1<T>;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    removeWhere(match: Predicate_1<T>): int;
    reverse(): IEnumerable_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
    static CreateSetComparer<T>(): IEqualityComparer_1<SortedSet_1<T>>;
    static CreateSetComparer<T>(memberEqualityComparer: IEqualityComparer_1<T>): IEqualityComparer_1<SortedSet_1<T>>;
}


export interface __SortedSet_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: ISet_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SortedSet_1<T> = SortedSet_1$instance<T> & __SortedSet_1$views<T>;


export class Stack_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    readonly capacity: int;
    readonly count: int;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    ensureCapacity(capacity: int): int;
    getEnumerator(): Stack_1_Enumerator<T>;
    peek(): T;
    pop(): T;
    push(item: T): void;
    toArray(): T[];
    trimExcess(): void;
    trimExcess(capacity: int): void;
    tryPeek(result: { value: ref<T> }): boolean;
    tryPop(result: { value: ref<T> }): boolean;
}


export interface __Stack_1$views<T> {
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Stack_1<T> = Stack_1$instance<T> & __Stack_1$views<T>;


export class TreeSet_1$instance<T> extends SortedSet_1$instance<T> {
    constructor();
    constructor(comparer: IComparer_1<T>);
    add(item: T): boolean;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[]): void;
    copyTo(array: T[], index: int): void;
    copyTo(array: T[], index: int, count: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): SortedSet_1_Enumerator<T>;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    onDeserialization(sender: any): void;
    unionWith(other: IEnumerable_1<T>): void;
}


export interface __TreeSet_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: ISet_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TreeSet_1<T> = TreeSet_1$instance<T> & __TreeSet_1$views<T>;


export abstract class CollectionExtensions$instance {
    static AddRange<T>(list: List_1<T>, source: ReadOnlySpan_1<T>): void;
    static AsReadOnly<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): ReadOnlyDictionary_2<TKey, TValue>;
    static AsReadOnly<T>(list: IList_1<T>): ReadOnlyCollection_1<T>;
    static AsReadOnly<T>(set_: ISet_1<T>): ReadOnlySet_1<T>;
    static CopyTo<T>(list: List_1<T>, destination: Span_1<T>): void;
    static GetValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey, defaultValue: TValue): TValue;
    static GetValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey): TValue;
    static InsertRange<T>(list: List_1<T>, index: int, source: ReadOnlySpan_1<T>): void;
    static Remove<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: { value: ref<TValue> }): boolean;
    static TryAdd<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
}


export type CollectionExtensions = CollectionExtensions$instance;

export abstract class KeyValuePair$instance {
    static Create<TKey, TValue>(key: TKey, value: TValue): KeyValuePair_2<TKey, TValue>;
}


export type KeyValuePair = KeyValuePair$instance;

