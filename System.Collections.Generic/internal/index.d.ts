// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Collections, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { ReadOnlyCollection_1, ReadOnlyDictionary_2, ReadOnlySet_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { DictionaryEntry, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IEqualityComparer, IList } from "../../System.Collections/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, Boolean as ClrBoolean, Byte, Comparison_1, Converter_2, Enum, Exception, Func_2, Func_3, IComparable_1, IDisposable, IEquatable_1, Int32, Nullable_1, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IAlternateEqualityComparer_2$instance<TAlternate, T> {
    Create(alternate: TAlternate): T;
    Equals(alternate: TAlternate, other: T): boolean;
    GetHashCode(alternate: TAlternate): int;
}


export type IAlternateEqualityComparer_2<TAlternate, T> = IAlternateEqualityComparer_2$instance<TAlternate, T>;

export interface IAsyncEnumerable_1$instance<T> {
    GetAsyncEnumerator(cancellationToken?: CancellationToken): IAsyncEnumerator_1<T>;
}


export type IAsyncEnumerable_1<T> = IAsyncEnumerable_1$instance<T>;

export interface IAsyncEnumerator_1$instance<T> {
    readonly Current: T;
    DisposeAsync(): ValueTask;
    MoveNextAsync(): ValueTask_1<CLROf<boolean>>;
}


export type IAsyncEnumerator_1<T> = IAsyncEnumerator_1$instance<T>;

export interface ICollection_1$instance<T> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type ICollection_1<T> = ICollection_1$instance<T>;

export interface IComparer_1$instance<T> {
    Compare(x: T, y: T): int;
}


export type IComparer_1<T> = IComparer_1$instance<T>;

export interface IDictionary_2$instance<TKey, TValue> {
    Item: TValue;
    readonly Keys: ICollection_1<TKey>;
    readonly Values: ICollection_1<TValue>;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: KeyValuePair_2<TKey, TValue>): void;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    CopyTo(array: KeyValuePair_2<TKey, TValue>[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: TKey, value: { value: TSByRef<TValue> }): boolean;
}


export type IDictionary_2<TKey, TValue> = IDictionary_2$instance<TKey, TValue>;

export interface IEnumerable_1$instance<T> {
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type IEnumerable_1<T> = IEnumerable_1$instance<T>;

export interface IEnumerator_1$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export type IEnumerator_1<T> = IEnumerator_1$instance<T>;

export interface IEqualityComparer_1$instance<T> {
    Equals(x: T, y: T): boolean;
    GetHashCode(obj: T): int;
}


export type IEqualityComparer_1<T> = IEqualityComparer_1$instance<T>;

export interface IList_1$instance<T> {
    Item: T;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: T): int;
    Insert(index: int, item: T): void;
    RemoveAt(index: int): void;
}


export type IList_1<T> = IList_1$instance<T>;

export interface IReadOnlyCollection_1$instance<T> {
    readonly Count: int;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type IReadOnlyCollection_1<T> = IReadOnlyCollection_1$instance<T>;

export interface IReadOnlyDictionary_2$instance<TKey, TValue> {
    readonly Item: TValue;
    readonly Keys: IEnumerable_1<TKey>;
    readonly Values: IEnumerable_1<TValue>;
    readonly Count: int;
    ContainsKey(key: TKey): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: TKey, value: { value: TSByRef<TValue> }): boolean;
}


export type IReadOnlyDictionary_2<TKey, TValue> = IReadOnlyDictionary_2$instance<TKey, TValue>;

export interface IReadOnlyList_1$instance<T> {
    readonly Item: T;
    readonly Count: int;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type IReadOnlyList_1<T> = IReadOnlyList_1$instance<T>;

export interface IReadOnlySet_1$instance<T> {
    readonly Count: int;
    Contains(item: T): boolean;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
}


export type IReadOnlySet_1<T> = IReadOnlySet_1$instance<T>;

export interface ISet_1$instance<T> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Add(item: T): boolean;
    Clear(): void;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
}


export type ISet_1<T> = ISet_1$instance<T>;

export class Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly Dictionary: Dictionary_2<TKey, TValue>;
    Item: TValue;
    ContainsKey(key: TAlternateKey): boolean;
    Remove(key: TAlternateKey): boolean;
    Remove(key: TAlternateKey, actualKey: { value: TSByRef<TKey> }, value: { value: TSByRef<TValue> }): boolean;
    TryAdd(key: TAlternateKey, value: TValue): boolean;
    TryGetValue(key: TAlternateKey, value: { value: TSByRef<TValue> }): boolean;
    TryGetValue(key: TAlternateKey, actualKey: { value: TSByRef<TKey> }, value: { value: TSByRef<TValue> }): boolean;
}


export type Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export class Dictionary_2_Enumerator$instance<TKey, TValue> {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __Dictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionaryEnumerator: System_Collections_Internal.IDictionaryEnumerator$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_Enumerator<TKey, TValue> = Dictionary_2_Enumerator$instance<TKey, TValue> & __Dictionary_2_Enumerator$views<TKey, TValue>;


export class Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TKey;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TKey>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_KeyCollection_Enumerator<TKey, TValue> = Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export class Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TValue;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TValue>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_ValueCollection_Enumerator<TKey, TValue> = Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export class HashSet_1_AlternateLookup_1$instance<T, TAlternate> {
    readonly Set: HashSet_1<T>;
    Add(item: TAlternate): boolean;
    Contains(item: TAlternate): boolean;
    Remove(item: TAlternate): boolean;
    TryGetValue(equalValue: TAlternate, actualValue: { value: TSByRef<T> }): boolean;
}


export type HashSet_1_AlternateLookup_1<T, TAlternate> = HashSet_1_AlternateLookup_1$instance<T, TAlternate>;

export class HashSet_1_Enumerator$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __HashSet_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type HashSet_1_Enumerator<T> = HashSet_1_Enumerator$instance<T> & __HashSet_1_Enumerator$views<T>;


export class KeyValuePair_2$instance<TKey, TValue> {
    constructor(key: TKey, value: TValue);
    readonly Key: TKey;
    readonly Value: TValue;
    Deconstruct(key: { value: TSByRef<TKey> }, value: { value: TSByRef<TValue> }): void;
    ToString(): string;
}


export type KeyValuePair_2<TKey, TValue> = KeyValuePair_2$instance<TKey, TValue>;

export class LinkedList_1_Enumerator$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __LinkedList_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LinkedList_1_Enumerator<T> = LinkedList_1_Enumerator$instance<T> & __LinkedList_1_Enumerator$views<T>;


export class List_1_Enumerator$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __List_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type List_1_Enumerator<T> = List_1_Enumerator$instance<T> & __List_1_Enumerator$views<T>;


export class OrderedDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    MoveNext(): boolean;
}


export interface __OrderedDictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionaryEnumerator: System_Collections_Internal.IDictionaryEnumerator$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_Enumerator<TKey, TValue> = OrderedDictionary_2_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_Enumerator$views<TKey, TValue>;


export class OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TKey;
    MoveNext(): boolean;
}


export interface __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TKey>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export class OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TValue;
    MoveNext(): boolean;
}


export interface __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TValue>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export class PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> {
    readonly Current: ValueTuple_2<TElement, TPriority>;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<ValueTuple_2<TElement, TPriority>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority>;


export class Queue_1_Enumerator$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __Queue_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Queue_1_Enumerator<T> = Queue_1_Enumerator$instance<T> & __Queue_1_Enumerator$views<T>;


export class SortedDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __SortedDictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionaryEnumerator: System_Collections_Internal.IDictionaryEnumerator$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_Enumerator<TKey, TValue> = SortedDictionary_2_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_Enumerator$views<TKey, TValue>;


export class SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TKey;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TKey>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export class SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TValue;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<TValue>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export class SortedSet_1_Enumerator$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __SortedSet_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SortedSet_1_Enumerator<T> = SortedSet_1_Enumerator$instance<T> & __SortedSet_1_Enumerator$views<T>;


export class Stack_1_Enumerator$instance<T> {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __Stack_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type Stack_1_Enumerator<T> = Stack_1_Enumerator$instance<T> & __Stack_1_Enumerator$views<T>;


export class ByteEqualityComparer$instance extends EqualityComparer_1$instance<CLROf<byte>> {
    constructor();
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
}


export interface __ByteEqualityComparer$views {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<CLROf<byte>>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type ByteEqualityComparer = ByteEqualityComparer$instance & __ByteEqualityComparer$views;


export abstract class Comparer_1$instance<T> {
    abstract Compare(x: T, y: T): int;
    static readonly Default: unknown;
    static Create<T>(comparison: Comparison_1<T>): Comparer_1<T>;
}


export interface __Comparer_1$views<T> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<T>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type Comparer_1<T> = Comparer_1$instance<T> & __Comparer_1$views<T>;


export class Dictionary_2$instance<TKey, TValue> {
    constructor();
    constructor(capacity: int);
    constructor(comparer: IEqualityComparer_1<TKey>);
    constructor(capacity: int, comparer: IEqualityComparer_1<TKey>);
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>);
    readonly Capacity: int;
    readonly Comparer: IEqualityComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: Dictionary_2_KeyCollection<TKey, TValue>;
    readonly Values: Dictionary_2_ValueCollection<TKey, TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    EnsureCapacity(capacity: int): int;
    GetAlternateLookup<TAlternateKey>(): Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    GetEnumerator(): Dictionary_2_Enumerator<TKey, TValue>;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    OnDeserialization(sender: any): void;
    Remove(key: TKey): boolean;
    Remove(key: TKey, value: { value: TSByRef<TValue> }): boolean;
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryAdd(key: TKey, value: TValue): boolean;
    TryGetAlternateLookup<TAlternateKey>(lookup: { value: TSByRef<Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>> }): boolean;
    TryGetValue(key: TKey, value: { value: TSByRef<TValue> }): boolean;
}


export interface __Dictionary_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Dictionary_2<TKey, TValue> = Dictionary_2$instance<TKey, TValue> & __Dictionary_2$views<TKey, TValue>;


export class Dictionary_2_KeyCollection$instance<TKey, TValue> {
    constructor(dictionary: Dictionary_2<TKey, TValue>);
    readonly Count: int;
    Contains(item: TKey): boolean;
    CopyTo(array: TKey[], index: int): void;
    GetEnumerator(): Dictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export interface __Dictionary_2_KeyCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_KeyCollection<TKey, TValue> = Dictionary_2_KeyCollection$instance<TKey, TValue> & __Dictionary_2_KeyCollection$views<TKey, TValue>;


export class Dictionary_2_ValueCollection$instance<TKey, TValue> {
    constructor(dictionary: Dictionary_2<TKey, TValue>);
    readonly Count: int;
    CopyTo(array: TValue[], index: int): void;
    GetEnumerator(): Dictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export interface __Dictionary_2_ValueCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_ValueCollection<TKey, TValue> = Dictionary_2_ValueCollection$instance<TKey, TValue> & __Dictionary_2_ValueCollection$views<TKey, TValue>;


export class EnumEqualityComparer_1$instance<T extends number> extends EqualityComparer_1$instance<T> {
    constructor();
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __EnumEqualityComparer_1$views<T extends number & any> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EnumEqualityComparer_1<T extends number> = EnumEqualityComparer_1$instance<T> & __EnumEqualityComparer_1$views<T>;


export abstract class EqualityComparer_1$instance<T> {
    abstract Equals(x: T, y: T): boolean;
    abstract GetHashCode(obj: T): int;
    static readonly Default: unknown;
    static Create<T>(equals: Func_3<T, T, CLROf<boolean>>, getHashCode?: Func_2<T, CLROf<int>>): EqualityComparer_1<T>;
}


export interface __EqualityComparer_1$views<T> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type EqualityComparer_1<T> = EqualityComparer_1$instance<T> & __EqualityComparer_1$views<T>;


export class GenericComparer_1$instance<T extends IComparable_1<T>> extends Comparer_1$instance<T> {
    constructor();
    Compare(x: any, y: any): int;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export interface __GenericComparer_1$views<T extends IComparable_1<T>> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<T>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type GenericComparer_1<T extends IComparable_1<T>> = GenericComparer_1$instance<T> & __GenericComparer_1$views<T>;


export class GenericEqualityComparer_1$instance<T extends IEquatable_1<T>> extends EqualityComparer_1$instance<T> {
    constructor();
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
}


export interface __GenericEqualityComparer_1$views<T extends IEquatable_1<T>> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type GenericEqualityComparer_1<T extends IEquatable_1<T>> = GenericEqualityComparer_1$instance<T> & __GenericEqualityComparer_1$views<T>;


export class HashSet_1$instance<T> {
    constructor();
    constructor(comparer: IEqualityComparer_1<T>);
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    constructor(collection: IEnumerable_1<T>, comparer: IEqualityComparer_1<T>);
    constructor(capacity: int, comparer: IEqualityComparer_1<T>);
    readonly Capacity: int;
    readonly Comparer: IEqualityComparer_1<T>;
    readonly Count: int;
    Add(item: T): boolean;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], arrayIndex: int): void;
    CopyTo(array: T[], arrayIndex: int, count: int): void;
    EnsureCapacity(capacity: int): int;
    ExceptWith(other: IEnumerable_1<T>): void;
    GetAlternateLookup<TAlternate>(): HashSet_1_AlternateLookup_1<T, TAlternate>;
    GetEnumerator(): HashSet_1_Enumerator<T>;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    IntersectWith(other: IEnumerable_1<T>): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    OnDeserialization(sender: any): void;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(item: T): boolean;
    RemoveWhere(match: Predicate_1<T>): int;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExceptWith(other: IEnumerable_1<T>): void;
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryGetAlternateLookup<TAlternate>(lookup: { value: TSByRef<HashSet_1_AlternateLookup_1<T, TAlternate>> }): boolean;
    TryGetValue(equalValue: T, actualValue: { value: TSByRef<T> }): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
    static CreateSetComparer<T>(): IEqualityComparer_1<HashSet_1<T>>;
}


export interface __HashSet_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: ISet_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HashSet_1<T> = HashSet_1$instance<T> & __HashSet_1$views<T>;


export class KeyNotFoundException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __KeyNotFoundException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type KeyNotFoundException = KeyNotFoundException$instance & __KeyNotFoundException$views;


export class LinkedList_1$instance<T> {
    constructor();
    constructor(collection: IEnumerable_1<T>);
    readonly Count: int;
    readonly First: LinkedListNode_1<T>;
    readonly Last: LinkedListNode_1<T>;
    AddAfter(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    AddAfter(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    AddBefore(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    AddBefore(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    AddFirst(value: T): LinkedListNode_1<T>;
    AddFirst(node: LinkedListNode_1<T>): void;
    AddLast(value: T): LinkedListNode_1<T>;
    AddLast(node: LinkedListNode_1<T>): void;
    Clear(): void;
    Contains(value: T): boolean;
    CopyTo(array: T[], index: int): void;
    Find(value: T): LinkedListNode_1<T>;
    FindLast(value: T): LinkedListNode_1<T>;
    GetEnumerator(): LinkedList_1_Enumerator<T>;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    OnDeserialization(sender: any): void;
    Remove(value: T): boolean;
    Remove(node: LinkedListNode_1<T>): void;
    RemoveFirst(): void;
    RemoveLast(): void;
}


export interface __LinkedList_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LinkedList_1<T> = LinkedList_1$instance<T> & __LinkedList_1$views<T>;


export class LinkedListNode_1$instance<T> {
    constructor(value: T);
    readonly List: LinkedList_1<T>;
    readonly Next: LinkedListNode_1<T>;
    readonly Previous: LinkedListNode_1<T>;
    Value: T;
    readonly ValueRef: TSByRef<T>;
}


export type LinkedListNode_1<T> = LinkedListNode_1$instance<T>;

export class List_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    Capacity: int;
    readonly Count: int;
    Item: T;
    Add(item: T): void;
    AddRange(collection: IEnumerable_1<T>): void;
    AsReadOnly(): ReadOnlyCollection_1<T>;
    BinarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    BinarySearch(item: T): int;
    BinarySearch(item: T, comparer: IComparer_1<T>): int;
    Clear(): void;
    Contains(item: T): boolean;
    ConvertAll<TOutput>(converter: Converter_2<T, TOutput>): List_1<TOutput>;
    CopyTo(array: T[]): void;
    CopyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    CopyTo(array: T[], arrayIndex: int): void;
    EnsureCapacity(capacity: int): int;
    Exists(match: Predicate_1<T>): boolean;
    Find(match: Predicate_1<T>): T;
    FindAll(match: Predicate_1<T>): List_1<T>;
    FindIndex(match: Predicate_1<T>): int;
    FindIndex(startIndex: int, match: Predicate_1<T>): int;
    FindIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    FindLast(match: Predicate_1<T>): T;
    FindLastIndex(match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    ForEach(action: Action_1<T>): void;
    GetEnumerator(): List_1_Enumerator<T>;
    GetRange(index: int, count: int): List_1<T>;
    IndexOf(item: T): int;
    IndexOf(item: T, index: int): int;
    IndexOf(item: T, index: int, count: int): int;
    Insert(index: int, item: T): void;
    InsertRange(index: int, collection: IEnumerable_1<T>): void;
    LastIndexOf(item: T): int;
    LastIndexOf(item: T, index: int): int;
    LastIndexOf(item: T, index: int, count: int): int;
    Remove(item: T): boolean;
    RemoveAll(match: Predicate_1<T>): int;
    RemoveAt(index: int): void;
    RemoveRange(index: int, count: int): void;
    Reverse(): void;
    Reverse(index: int, count: int): void;
    Slice(start: int, length: int): List_1<T>;
    Sort(): void;
    Sort(comparer: IComparer_1<T>): void;
    Sort(index: int, count: int, comparer: IComparer_1<T>): void;
    Sort(comparison: Comparison_1<T>): void;
    ToArray(): T[];
    TrimExcess(): void;
    TrueForAll(match: Predicate_1<T>): boolean;
}


export interface __List_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IList_1: IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type List_1<T> = List_1$instance<T> & __List_1$views<T>;


export class NonRandomizedStringEqualityComparer$instance {
    Equals(x: string, y: string): boolean;
    GetHashCode(obj: string): int;
    GetUnderlyingEqualityComparer(): IEqualityComparer_1<CLROf<string>>;
    static GetStringComparer(comparer: any): IEqualityComparer_1<CLROf<string>>;
}


export interface __NonRandomizedStringEqualityComparer$views {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<CLROf<string>>;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NonRandomizedStringEqualityComparer = NonRandomizedStringEqualityComparer$instance & __NonRandomizedStringEqualityComparer$views;


export class NullableComparer_1$instance<T extends any> extends Comparer_1$instance<Nullable_1<T>> {
    constructor();
    Compare(x: any, y: any): int;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NullableComparer_1$views<T extends any> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<Nullable_1<T>>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NullableComparer_1<T> = NullableComparer_1$instance<T> & __NullableComparer_1$views<T>;


export class NullableEqualityComparer_1$instance<T extends any> extends EqualityComparer_1$instance<Nullable_1<T>> {
    constructor();
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NullableEqualityComparer_1$views<T extends any> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<Nullable_1<T>>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NullableEqualityComparer_1<T> = NullableEqualityComparer_1$instance<T> & __NullableEqualityComparer_1$views<T>;


export class ObjectComparer_1$instance<T> extends Comparer_1$instance<T> {
    constructor();
    Compare(x: any, y: any): int;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export interface __ObjectComparer_1$views<T> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<T>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type ObjectComparer_1<T> = ObjectComparer_1$instance<T> & __ObjectComparer_1$views<T>;


export class ObjectEqualityComparer_1$instance<T> extends EqualityComparer_1$instance<T> {
    constructor();
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
}


export interface __ObjectEqualityComparer_1$views<T> {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<T>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type ObjectEqualityComparer_1<T> = ObjectEqualityComparer_1$instance<T> & __ObjectEqualityComparer_1$views<T>;


export class OrderedDictionary_2$instance<TKey, TValue> {
    constructor();
    constructor(capacity: int);
    constructor(comparer: IEqualityComparer_1<TKey>);
    constructor(capacity: int, comparer: IEqualityComparer_1<TKey>);
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>);
    constructor(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>);
    readonly Capacity: int;
    readonly Comparer: IEqualityComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: OrderedDictionary_2_KeyCollection<TKey, TValue>;
    readonly Values: OrderedDictionary_2_ValueCollection<TKey, TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    EnsureCapacity(capacity: int): int;
    GetAt(index: int): KeyValuePair_2<TKey, TValue>;
    GetEnumerator(): OrderedDictionary_2_Enumerator<TKey, TValue>;
    IndexOf(key: TKey): int;
    Insert(index: int, key: TKey, value: TValue): void;
    Remove(key: TKey): boolean;
    Remove(key: TKey, value: { value: TSByRef<TValue> }): boolean;
    RemoveAt(index: int): void;
    SetAt(index: int, value: TValue): void;
    SetAt(index: int, key: TKey, value: TValue): void;
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryAdd(key: TKey, value: TValue): boolean;
    TryAdd(key: TKey, value: TValue, index: { value: TSByRef<int> }): boolean;
    TryGetValue(key: TKey, value: { value: TSByRef<TValue> }): boolean;
    TryGetValue(key: TKey, value: { value: TSByRef<TValue> }, index: { value: TSByRef<int> }): boolean;
}


export interface __OrderedDictionary_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IList_1: IList_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2<TKey, TValue> = OrderedDictionary_2$instance<TKey, TValue> & __OrderedDictionary_2$views<TKey, TValue>;


export class OrderedDictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly Count: int;
    Contains(key: TKey): boolean;
    CopyTo(array: TKey[], arrayIndex: int): void;
    GetEnumerator(): OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export interface __OrderedDictionary_2_KeyCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IList_1: IList_1$instance<TKey>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_KeyCollection<TKey, TValue> = OrderedDictionary_2_KeyCollection$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection$views<TKey, TValue>;


export class OrderedDictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly Count: int;
    CopyTo(array: TValue[], arrayIndex: int): void;
    GetEnumerator(): OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export interface __OrderedDictionary_2_ValueCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IList_1: IList_1$instance<TValue>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_ValueCollection<TKey, TValue> = OrderedDictionary_2_ValueCollection$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection$views<TKey, TValue>;


export class PriorityQueue_2$instance<TElement, TPriority> {
    constructor();
    constructor(initialCapacity: int);
    constructor(comparer: IComparer_1<TPriority>);
    constructor(initialCapacity: int, comparer: IComparer_1<TPriority>);
    constructor(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>);
    constructor(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>, comparer: IComparer_1<TPriority>);
    readonly Capacity: int;
    readonly Comparer: IComparer_1<TPriority>;
    readonly Count: int;
    readonly UnorderedItems: PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority>;
    Clear(): void;
    Dequeue(): TElement;
    DequeueEnqueue(element: TElement, priority: TPriority): TElement;
    Enqueue(element: TElement, priority: TPriority): void;
    EnqueueDequeue(element: TElement, priority: TPriority): TElement;
    EnqueueRange(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>): void;
    EnqueueRange(elements: IEnumerable_1<TElement>, priority: TPriority): void;
    EnsureCapacity(capacity: int): int;
    Peek(): TElement;
    Remove(element: TElement, removedElement: { value: TSByRef<TElement> }, priority: { value: TSByRef<TPriority> }, equalityComparer?: IEqualityComparer_1<TElement>): boolean;
    TrimExcess(): void;
    TryDequeue(element: { value: TSByRef<TElement> }, priority: { value: TSByRef<TPriority> }): boolean;
    TryPeek(element: { value: TSByRef<TElement> }, priority: { value: TSByRef<TPriority> }): boolean;
}


export type PriorityQueue_2<TElement, TPriority> = PriorityQueue_2$instance<TElement, TPriority>;

export class PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> {
    readonly Count: int;
    GetEnumerator(): PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority>;
}


export interface __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority> {
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<ValueTuple_2<TElement, TPriority>>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<ValueTuple_2<TElement, TPriority>>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority>;


export class Queue_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    readonly Capacity: int;
    readonly Count: int;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    Dequeue(): T;
    Enqueue(item: T): void;
    EnsureCapacity(capacity: int): int;
    GetEnumerator(): Queue_1_Enumerator<T>;
    Peek(): T;
    ToArray(): T[];
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryDequeue(result: { value: TSByRef<T> }): boolean;
    TryPeek(result: { value: TSByRef<T> }): boolean;
}


export interface __Queue_1$views<T> {
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Queue_1<T> = Queue_1$instance<T> & __Queue_1$views<T>;


export class ReferenceEqualityComparer$instance {
    Equals(x: any, y: any): boolean;
    GetHashCode(obj: any): int;
    static readonly Instance: ReferenceEqualityComparer;
}


export interface __ReferenceEqualityComparer$views {
    readonly As_IEqualityComparer_1_of_String: IEqualityComparer_1$instance<any>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type ReferenceEqualityComparer = ReferenceEqualityComparer$instance & __ReferenceEqualityComparer$views;


export class SortedDictionary_2$instance<TKey, TValue> {
    constructor();
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey>);
    constructor(comparer: IComparer_1<TKey>);
    readonly Comparer: IComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: SortedDictionary_2_KeyCollection<TKey, TValue>;
    readonly Values: SortedDictionary_2_ValueCollection<TKey, TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    CopyTo(array: KeyValuePair_2<TKey, TValue>[], index: int): void;
    GetEnumerator(): SortedDictionary_2_Enumerator<TKey, TValue>;
    Remove(key: TKey): boolean;
    TryGetValue(key: TKey, value: { value: TSByRef<TValue> }): boolean;
}


export interface __SortedDictionary_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2<TKey, TValue> = SortedDictionary_2$instance<TKey, TValue> & __SortedDictionary_2$views<TKey, TValue>;


export class SortedDictionary_2_KeyCollection$instance<TKey, TValue> {
    constructor(dictionary: SortedDictionary_2<TKey, TValue>);
    readonly Count: int;
    Contains(item: TKey): boolean;
    CopyTo(array: TKey[], index: int): void;
    GetEnumerator(): SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export interface __SortedDictionary_2_KeyCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_KeyCollection<TKey, TValue> = SortedDictionary_2_KeyCollection$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection$views<TKey, TValue>;


export class SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> extends Comparer_1$instance<KeyValuePair_2<TKey, TValue>> {
    constructor(keyComparer: IComparer_1<TKey>);
    Compare(x: any, y: any): int;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export interface __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue> {
    readonly As_IComparer_1_of_String: IComparer_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type SortedDictionary_2_KeyValuePairComparer<TKey, TValue> = SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> & __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue>;


export class SortedDictionary_2_ValueCollection$instance<TKey, TValue> {
    constructor(dictionary: SortedDictionary_2<TKey, TValue>);
    readonly Count: int;
    CopyTo(array: TValue[], index: int): void;
    GetEnumerator(): SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export interface __SortedDictionary_2_ValueCollection$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_ValueCollection<TKey, TValue> = SortedDictionary_2_ValueCollection$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection$views<TKey, TValue>;


export class SortedList_2$instance<TKey, TValue> {
    constructor();
    constructor(capacity: int);
    constructor(comparer: IComparer_1<TKey>);
    constructor(capacity: int, comparer: IComparer_1<TKey>);
    constructor(dictionary: IDictionary_2<TKey, TValue>);
    constructor(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey>);
    Capacity: int;
    readonly Comparer: IComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: IList_1<TKey>;
    readonly Values: IList_1<TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetKeyAtIndex(index: int): TKey;
    GetValueAtIndex(index: int): TValue;
    IndexOfKey(key: TKey): int;
    IndexOfValue(value: TValue): int;
    Remove(key: TKey): boolean;
    RemoveAt(index: int): void;
    SetValueAtIndex(index: int, value: TValue): void;
    TrimExcess(): void;
    TryGetValue(key: TKey, value: { value: TSByRef<TValue> }): boolean;
}


export interface __SortedList_2$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2<TKey, TValue> = SortedList_2$instance<TKey, TValue> & __SortedList_2$views<TKey, TValue>;


export class SortedList_2_KeyList$instance<TKey, TValue> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: TKey;
    Add(key: TKey): void;
    Clear(): void;
    Contains(key: TKey): boolean;
    CopyTo(array: TKey[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<TKey>;
    IndexOf(key: TKey): int;
    Insert(index: int, value: TKey): void;
    Remove(key: TKey): boolean;
    RemoveAt(index: int): void;
}


export interface __SortedList_2_KeyList$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TKey>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TKey>;
    readonly As_IList_1: IList_1$instance<TKey>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_KeyList<TKey, TValue> = SortedList_2_KeyList$instance<TKey, TValue> & __SortedList_2_KeyList$views<TKey, TValue>;


export class SortedList_2_ValueList$instance<TKey, TValue> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: TValue;
    Add(key: TValue): void;
    Clear(): void;
    Contains(value: TValue): boolean;
    CopyTo(array: TValue[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<TValue>;
    IndexOf(value: TValue): int;
    Insert(index: int, value: TValue): void;
    Remove(value: TValue): boolean;
    RemoveAt(index: int): void;
}


export interface __SortedList_2_ValueList$views<TKey, TValue> {
    readonly As_ICollection_1: ICollection_1$instance<TValue>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<TValue>;
    readonly As_IList_1: IList_1$instance<TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_ValueList<TKey, TValue> = SortedList_2_ValueList$instance<TKey, TValue> & __SortedList_2_ValueList$views<TKey, TValue>;


export class SortedSet_1$instance<T> {
    constructor();
    constructor(comparer: IComparer_1<T>);
    constructor(collection: IEnumerable_1<T>);
    constructor(collection: IEnumerable_1<T>, comparer: IComparer_1<T>);
    readonly Comparer: IComparer_1<T>;
    readonly Count: int;
    readonly Max: T;
    readonly Min: T;
    Add(item: T): boolean;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: T[], index: int, count: int): void;
    ExceptWith(other: IEnumerable_1<T>): void;
    GetEnumerator(): SortedSet_1_Enumerator<T>;
    GetViewBetween(lowerValue: T, upperValue: T): SortedSet_1<T>;
    IntersectWith(other: IEnumerable_1<T>): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(item: T): boolean;
    RemoveWhere(match: Predicate_1<T>): int;
    Reverse(): IEnumerable_1<T>;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExceptWith(other: IEnumerable_1<T>): void;
    TryGetValue(equalValue: T, actualValue: { value: TSByRef<T> }): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
    static CreateSetComparer<T>(): IEqualityComparer_1<SortedSet_1<T>>;
    static CreateSetComparer<T>(memberEqualityComparer: IEqualityComparer_1<T>): IEqualityComparer_1<SortedSet_1<T>>;
}


export interface __SortedSet_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: ISet_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SortedSet_1<T> = SortedSet_1$instance<T> & __SortedSet_1$views<T>;


export class Stack_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    readonly Capacity: int;
    readonly Count: int;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    EnsureCapacity(capacity: int): int;
    GetEnumerator(): Stack_1_Enumerator<T>;
    Peek(): T;
    Pop(): T;
    Push(item: T): void;
    ToArray(): T[];
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryPeek(result: { value: TSByRef<T> }): boolean;
    TryPop(result: { value: TSByRef<T> }): boolean;
}


export interface __Stack_1$views<T> {
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type Stack_1<T> = Stack_1$instance<T> & __Stack_1$views<T>;


export class TreeSet_1$instance<T> extends SortedSet_1$instance<T> {
    constructor();
    constructor(comparer: IComparer_1<T>);
    Add(item: T): boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: T[], index: int, count: int): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): SortedSet_1_Enumerator<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    OnDeserialization(sender: any): void;
    UnionWith(other: IEnumerable_1<T>): void;
}


export interface __TreeSet_1$views<T> {
    readonly As_ICollection_1: ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: ISet_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TreeSet_1<T> = TreeSet_1$instance<T> & __TreeSet_1$views<T>;


export abstract class CollectionExtensions$instance {
    static AddRange<T>(list: List_1<T>, source: ReadOnlySpan_1<T>): void;
    static AsReadOnly<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): ReadOnlyDictionary_2<TKey, TValue>;
    static AsReadOnly<T>(list: IList_1<T>): ReadOnlyCollection_1<T>;
    static AsReadOnly<T>(set_: ISet_1<T>): ReadOnlySet_1<T>;
    static CopyTo<T>(list: List_1<T>, destination: Span_1<T>): void;
    static GetValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey, defaultValue: TValue): TValue;
    static GetValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey): TValue;
    static InsertRange<T>(list: List_1<T>, index: int, source: ReadOnlySpan_1<T>): void;
    static Remove<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: { value: TSByRef<TValue> }): boolean;
    static TryAdd<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
}


export type CollectionExtensions = CollectionExtensions$instance;

export abstract class KeyValuePair$instance {
    static Create<TKey, TValue>(key: TKey, value: TValue): KeyValuePair_2<TKey, TValue>;
}


export type KeyValuePair = KeyValuePair$instance;

