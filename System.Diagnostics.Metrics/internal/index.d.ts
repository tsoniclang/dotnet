// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.Metrics
// Assembly: System.Diagnostics.DiagnosticSource

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { TagList } from "../../System.Diagnostics/internal/index.js";
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, AsyncCallback, Boolean as ClrBoolean, Delegate, Func_1, IAsyncResult, ICloneable, IDisposable, Int32, IntPtr, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

export type MeasurementCallback_1<T extends unknown> = (instrument: Instrument, measurement: T, tags: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>, state: unknown) => void;


export interface IMeterFactory$instance extends IDisposable {
    create(options: MeterOptions): Meter;
    dispose(): void;
}


export interface IMeterFactory$instance extends System_Internal.IDisposable$instance {}

export type IMeterFactory = IMeterFactory$instance;

export interface Measurement_1$instance<T extends unknown> {
    readonly tags: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>;
    readonly value: T;
}


export const Measurement_1: {
    new<T extends unknown>(value: T): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: KeyValuePair_2<System_Internal.String, unknown>[]): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>): Measurement_1$instance<T>;
    new<T extends unknown>(value: T, tags: TagList): Measurement_1$instance<T>;
};


export type Measurement_1<T> = Measurement_1$instance<T>;

export interface Counter_1$instance<T extends unknown> extends Instrument_1<T> {
    add(delta: T): void;
    add(delta: T, tag: KeyValuePair_2<System_Internal.String, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>, tag3: KeyValuePair_2<System_Internal.String, unknown>): void;
    add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>): void;
    add(delta: T, ...tags: KeyValuePair_2<System_Internal.String, unknown>[]): void;
    add(delta: T, tagList: TagList): void;
}


export const Counter_1: {
    new<T extends unknown>(): Counter_1$instance<T>;
};


export type Counter_1<T> = Counter_1$instance<T>;

export interface Gauge_1$instance<T extends unknown> extends Instrument_1<T> {
    record(value: T): void;
    record(value: T, tag: KeyValuePair_2<System_Internal.String, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>, tag3: KeyValuePair_2<System_Internal.String, unknown>): void;
    record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>): void;
    record(value: T, ...tags: KeyValuePair_2<System_Internal.String, unknown>[]): void;
    record(value: T, tagList: TagList): void;
}


export const Gauge_1: {
    new<T extends unknown>(): Gauge_1$instance<T>;
};


export type Gauge_1<T> = Gauge_1$instance<T>;

export interface Histogram_1$instance<T extends unknown> extends Instrument_1<T> {
    record(value: T): void;
    record(value: T, tag: KeyValuePair_2<System_Internal.String, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>): void;
    record(value: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>, tag3: KeyValuePair_2<System_Internal.String, unknown>): void;
    record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>): void;
    record(value: T, ...tags: KeyValuePair_2<System_Internal.String, unknown>[]): void;
    record(value: T, tagList: TagList): void;
}


export const Histogram_1: {
    new<T extends unknown>(): Histogram_1$instance<T>;
};


export type Histogram_1<T> = Histogram_1$instance<T>;

export interface Instrument$instance {
    readonly description: string;
    readonly enabled: boolean;
    readonly isObservable: boolean;
    readonly meter: Meter;
    readonly name: string;
    readonly tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    readonly unit: string;
}


export const Instrument: {
};


export type Instrument = Instrument$instance;

export interface Instrument_1$instance<T extends unknown> extends Instrument {
    readonly advice: InstrumentAdvice_1<T>;
}


export const Instrument_1: {
};


export type Instrument_1<T> = Instrument_1$instance<T>;

export interface InstrumentAdvice_1$instance<T extends unknown> {
    histogramBucketBoundaries: IReadOnlyList_1<T>;
}


export const InstrumentAdvice_1: {
    new<T extends unknown>(): InstrumentAdvice_1$instance<T>;
};


export type InstrumentAdvice_1<T> = InstrumentAdvice_1$instance<T>;

export interface Meter$instance {
    readonly name: string;
    readonly scope: unknown;
    readonly tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    readonly telemetrySchemaUrl: string;
    readonly version: string;
    createCounter<T extends unknown>(name: string, unit?: string, description?: string): Counter_1<T>;
    createCounter<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): Counter_1<T>;
    createGauge<T extends unknown>(name: string): Gauge_1<T>;
    createGauge<T extends unknown>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): Gauge_1<T>;
    createHistogram<T extends unknown>(name: string): Histogram_1<T>;
    createHistogram<T extends unknown>(name: string, unit: string, description: string): Histogram_1<T>;
    createHistogram<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): Histogram_1<T>;
    createHistogram<T extends unknown>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>, advice?: InstrumentAdvice_1<T>): Histogram_1<T>;
    createObservableCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableCounter_1<T>;
    createObservableCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): ObservableCounter_1<T>;
    createObservableGauge<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableGauge_1<T>;
    createObservableGauge<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): ObservableGauge_1<T>;
    createObservableUpDownCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableUpDownCounter_1<T>;
    createObservableUpDownCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): ObservableUpDownCounter_1<T>;
    createUpDownCounter<T extends unknown>(name: string, unit?: string, description?: string): UpDownCounter_1<T>;
    createUpDownCounter<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): UpDownCounter_1<T>;
    dispose(): void;
}


export const Meter: {
    new(options: MeterOptions): Meter$instance;
    new(name: string): Meter$instance;
    new(name: string, version: string): Meter$instance;
    new(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>, scope: unknown): Meter$instance;
};


export interface __Meter$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Meter$instance extends System_Internal.IDisposable$instance {}

export type Meter = Meter$instance & __Meter$views;


export interface MeterListener$instance {
    instrumentPublished: Action_2<Instrument, MeterListener>;
    measurementsCompleted: Action_2<Instrument, unknown>;
    disableMeasurementEvents(instrument: Instrument): unknown;
    dispose(): void;
    enableMeasurementEvents(instrument: Instrument, state?: unknown): void;
    recordObservableInstruments(): void;
    setMeasurementEventCallback<T extends unknown>(measurementCallback: MeasurementCallback_1<T>): void;
    start(): void;
}


export const MeterListener: {
    new(): MeterListener$instance;
};


export interface __MeterListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MeterListener$instance extends System_Internal.IDisposable$instance {}

export type MeterListener = MeterListener$instance & __MeterListener$views;


export interface MeterOptions$instance {
    name: string;
    scope: unknown;
    tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    telemetrySchemaUrl: string;
    version: string;
}


export const MeterOptions: {
    new(name: string): MeterOptions$instance;
};


export type MeterOptions = MeterOptions$instance;

export interface ObservableCounter_1$instance<T extends unknown> extends ObservableInstrument_1<T> {
}


export const ObservableCounter_1: {
    new<T extends unknown>(): ObservableCounter_1$instance<T>;
};


export type ObservableCounter_1<T> = ObservableCounter_1$instance<T>;

export interface ObservableGauge_1$instance<T extends unknown> extends ObservableInstrument_1<T> {
}


export const ObservableGauge_1: {
    new<T extends unknown>(): ObservableGauge_1$instance<T>;
};


export type ObservableGauge_1<T> = ObservableGauge_1$instance<T>;

export interface ObservableInstrument_1$instance<T extends unknown> extends Instrument {
    readonly isObservable: boolean;
}


export const ObservableInstrument_1: {
};


export type ObservableInstrument_1<T> = ObservableInstrument_1$instance<T>;

export interface ObservableUpDownCounter_1$instance<T extends unknown> extends ObservableInstrument_1<T> {
}


export const ObservableUpDownCounter_1: {
    new<T extends unknown>(): ObservableUpDownCounter_1$instance<T>;
};


export type ObservableUpDownCounter_1<T> = ObservableUpDownCounter_1$instance<T>;

export interface UpDownCounter_1$instance<T extends unknown> extends Instrument_1<T> {
    add(delta: T): void;
    add(delta: T, tag: KeyValuePair_2<System_Internal.String, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>): void;
    add(delta: T, tag1: KeyValuePair_2<System_Internal.String, unknown>, tag2: KeyValuePair_2<System_Internal.String, unknown>, tag3: KeyValuePair_2<System_Internal.String, unknown>): void;
    add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>): void;
    add(delta: T, ...tags: KeyValuePair_2<System_Internal.String, unknown>[]): void;
    add(delta: T, tagList: TagList): void;
}


export const UpDownCounter_1: {
    new<T extends unknown>(): UpDownCounter_1$instance<T>;
};


export type UpDownCounter_1<T> = UpDownCounter_1$instance<T>;

export abstract class MeterFactoryExtensions$instance {
    static create(meterFactory: IMeterFactory, name: string, version?: string, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): Meter;
}


export type MeterFactoryExtensions = MeterFactoryExtensions$instance;

