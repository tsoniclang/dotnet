// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.Metrics
// Assembly: System.Diagnostics.DiagnosticSource

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { TagList } from "../../System.Diagnostics/internal/index.js";
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, AsyncCallback, Boolean as ClrBoolean, Delegate, Func_1, IAsyncResult, ICloneable, IDisposable, Int32, IntPtr, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IMeterFactory$instance {
    Create(options: MeterOptions): Meter;
    Dispose(): void;
}


export type IMeterFactory = IMeterFactory$instance;

export class Measurement_1$instance<T extends unknown> {
    constructor(value: T);
    constructor(value: T, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>);
    constructor(value: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]);
    constructor(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>);
    constructor(value: T, tags: ref<TagList>);
    readonly Tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly Value: T;
}


export type Measurement_1<T> = Measurement_1$instance<T>;

export class Counter_1$instance<T extends unknown> extends Instrument_1$instance<T> {
    Add(delta: T): void;
    Add(delta: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    Add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    Add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    Add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    Add(delta: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    Add(delta: T, tagList: { value: ref<TagList> }): void;
}


export type Counter_1<T> = Counter_1$instance<T>;

export class Gauge_1$instance<T extends unknown> extends Instrument_1$instance<T> {
    Record(value: T): void;
    Record(value: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    Record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    Record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    Record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    Record(value: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    Record(value: T, tagList: { value: ref<TagList> }): void;
}


export type Gauge_1<T> = Gauge_1$instance<T>;

export class Histogram_1$instance<T extends unknown> extends Instrument_1$instance<T> {
    Record(value: T): void;
    Record(value: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    Record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    Record(value: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    Record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    Record(value: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    Record(value: T, tagList: { value: ref<TagList> }): void;
}


export type Histogram_1<T> = Histogram_1$instance<T>;

export abstract class Instrument$instance {
    readonly Description: string;
    readonly Enabled: boolean;
    readonly IsObservable: boolean;
    readonly Meter: Meter;
    readonly Name: string;
    readonly Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly Unit: string;
}


export type Instrument = Instrument$instance;

export abstract class Instrument_1$instance<T extends unknown> extends Instrument$instance {
    readonly Advice: InstrumentAdvice_1<T>;
}


export type Instrument_1<T> = Instrument_1$instance<T>;

export class InstrumentAdvice_1$instance<T extends unknown> {
    constructor();
    HistogramBucketBoundaries: IReadOnlyList_1<T>;
}


export type InstrumentAdvice_1<T> = InstrumentAdvice_1$instance<T>;

export class MeasurementCallback_1$instance<T extends unknown> extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(instrument: Instrument, measurement: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>, state: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(instrument: Instrument, measurement: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>, state: unknown): void;
}


export interface __MeasurementCallback_1$views<T extends unknown> {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MeasurementCallback_1<T> = MeasurementCallback_1$instance<T> & __MeasurementCallback_1$views<T>;


export class Meter$instance {
    constructor(options: MeterOptions);
    constructor(name: string);
    constructor(name: string, version: string);
    constructor(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, scope: unknown);
    readonly Name: string;
    readonly Scope: unknown;
    readonly Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    readonly TelemetrySchemaUrl: string;
    readonly Version: string;
    CreateCounter<T extends unknown>(name: string, unit?: string, description?: string): Counter_1<T>;
    CreateCounter<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Counter_1<T>;
    CreateGauge<T extends unknown>(name: string): Gauge_1<T>;
    CreateGauge<T extends unknown>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Gauge_1<T>;
    CreateHistogram<T extends unknown>(name: string): Histogram_1<T>;
    CreateHistogram<T extends unknown>(name: string, unit: string, description: string): Histogram_1<T>;
    CreateHistogram<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Histogram_1<T>;
    CreateHistogram<T extends unknown>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>, advice?: InstrumentAdvice_1<T>): Histogram_1<T>;
    CreateObservableCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableCounter_1<T>;
    CreateObservableCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ObservableCounter_1<T>;
    CreateObservableGauge<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableGauge_1<T>;
    CreateObservableGauge<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ObservableGauge_1<T>;
    CreateObservableUpDownCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableUpDownCounter_1<T>;
    CreateObservableUpDownCounter<T extends unknown>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): ObservableUpDownCounter_1<T>;
    CreateUpDownCounter<T extends unknown>(name: string, unit?: string, description?: string): UpDownCounter_1<T>;
    CreateUpDownCounter<T extends unknown>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): UpDownCounter_1<T>;
    Dispose(): void;
}


export interface __Meter$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Meter = Meter$instance & __Meter$views;


export class MeterListener$instance {
    constructor();
    InstrumentPublished: Action_2<Instrument, MeterListener>;
    MeasurementsCompleted: Action_2<Instrument, unknown>;
    DisableMeasurementEvents(instrument: Instrument): unknown;
    Dispose(): void;
    EnableMeasurementEvents(instrument: Instrument, state?: unknown): void;
    RecordObservableInstruments(): void;
    SetMeasurementEventCallback<T extends unknown>(measurementCallback: MeasurementCallback_1<T>): void;
    Start(): void;
}


export interface __MeterListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MeterListener = MeterListener$instance & __MeterListener$views;


export class MeterOptions$instance {
    constructor(name: string);
    Name: string;
    Scope: unknown;
    Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>;
    TelemetrySchemaUrl: string;
    Version: string;
}


export type MeterOptions = MeterOptions$instance;

export class ObservableCounter_1$instance<T extends unknown> extends ObservableInstrument_1$instance<T> {
}


export type ObservableCounter_1<T> = ObservableCounter_1$instance<T>;

export class ObservableGauge_1$instance<T extends unknown> extends ObservableInstrument_1$instance<T> {
}


export type ObservableGauge_1<T> = ObservableGauge_1$instance<T>;

export abstract class ObservableInstrument_1$instance<T extends unknown> extends Instrument$instance {
    readonly IsObservable: boolean;
}


export type ObservableInstrument_1<T> = ObservableInstrument_1$instance<T>;

export class ObservableUpDownCounter_1$instance<T extends unknown> extends ObservableInstrument_1$instance<T> {
}


export type ObservableUpDownCounter_1<T> = ObservableUpDownCounter_1$instance<T>;

export class UpDownCounter_1$instance<T extends unknown> extends Instrument_1$instance<T> {
    Add(delta: T): void;
    Add(delta: T, tag: KeyValuePair_2<CLROf<string>, unknown>): void;
    Add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>): void;
    Add(delta: T, tag1: KeyValuePair_2<CLROf<string>, unknown>, tag2: KeyValuePair_2<CLROf<string>, unknown>, tag3: KeyValuePair_2<CLROf<string>, unknown>): void;
    Add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, unknown>>): void;
    Add(delta: T, tags: KeyValuePair_2<CLROf<string>, unknown>[]): void;
    Add(delta: T, tagList: { value: ref<TagList> }): void;
}


export type UpDownCounter_1<T> = UpDownCounter_1$instance<T>;

export abstract class MeterFactoryExtensions$instance {
    static Create(meterFactory: IMeterFactory, name: string, version?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, unknown>>): Meter;
}


export type MeterFactoryExtensions = MeterFactoryExtensions$instance;

