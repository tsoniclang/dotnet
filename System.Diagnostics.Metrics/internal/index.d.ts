// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.Metrics
// Assembly: System.Diagnostics.DiagnosticSource

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { TagList } from "../../System.Diagnostics/internal/index.js";
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, AsyncCallback, Boolean as ClrBoolean, Delegate, Func_1, IAsyncResult, ICloneable, IDisposable, Int32, IntPtr, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IMeterFactory$instance {
    Create(options: MeterOptions): Meter;
    Dispose(): void;
}


export type IMeterFactory = IMeterFactory$instance;

export class Measurement_1$instance<T extends any> {
    constructor(value: T);
    constructor(value: T, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>);
    constructor(value: T, tags: KeyValuePair_2<CLROf<string>, any>[]);
    constructor(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>);
    constructor(value: T, tags: TSByRef<TagList>);
    readonly tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly value: T;
}


export type Measurement_1<T> = Measurement_1$instance<T>;

export class Counter_1$instance<T extends any> extends Instrument_1$instance<T> {
    add(delta: T): void;
    add(delta: T, tag: KeyValuePair_2<CLROf<string>, any>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>, tag3: KeyValuePair_2<CLROf<string>, any>): void;
    add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>): void;
    add(delta: T, tags: KeyValuePair_2<CLROf<string>, any>[]): void;
    add(delta: T, tagList: { value: TSByRef<TagList> }): void;
}


export type Counter_1<T> = Counter_1$instance<T>;

export class Gauge_1$instance<T extends any> extends Instrument_1$instance<T> {
    record(value: T): void;
    record(value: T, tag: KeyValuePair_2<CLROf<string>, any>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>, tag3: KeyValuePair_2<CLROf<string>, any>): void;
    record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>): void;
    record(value: T, tags: KeyValuePair_2<CLROf<string>, any>[]): void;
    record(value: T, tagList: { value: TSByRef<TagList> }): void;
}


export type Gauge_1<T> = Gauge_1$instance<T>;

export class Histogram_1$instance<T extends any> extends Instrument_1$instance<T> {
    record(value: T): void;
    record(value: T, tag: KeyValuePair_2<CLROf<string>, any>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>): void;
    record(value: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>, tag3: KeyValuePair_2<CLROf<string>, any>): void;
    record(value: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>): void;
    record(value: T, tags: KeyValuePair_2<CLROf<string>, any>[]): void;
    record(value: T, tagList: { value: TSByRef<TagList> }): void;
}


export type Histogram_1<T> = Histogram_1$instance<T>;

export abstract class Instrument$instance {
    readonly description: string;
    readonly enabled: boolean;
    readonly isObservable: boolean;
    readonly meter: Meter;
    readonly name: string;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly unit: string;
}


export type Instrument = Instrument$instance;

export abstract class Instrument_1$instance<T extends any> extends Instrument$instance {
    readonly advice: InstrumentAdvice_1<T>;
}


export type Instrument_1<T> = Instrument_1$instance<T>;

export class InstrumentAdvice_1$instance<T extends any> {
    constructor();
    histogramBucketBoundaries: IReadOnlyList_1<T>;
}


export type InstrumentAdvice_1<T> = InstrumentAdvice_1$instance<T>;

export class MeasurementCallback_1$instance<T extends any> extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(instrument: Instrument, measurement: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>, state: any, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(instrument: Instrument, measurement: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>, state: any): void;
}


export interface __MeasurementCallback_1$views<T extends any> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MeasurementCallback_1<T> = MeasurementCallback_1$instance<T> & __MeasurementCallback_1$views<T>;


export class Meter$instance {
    constructor(options: MeterOptions);
    constructor(name: string);
    constructor(name: string, version: string);
    constructor(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, scope: any);
    readonly name: string;
    readonly scope: any;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly telemetrySchemaUrl: string;
    readonly version: string;
    createCounter<T extends any>(name: string, unit?: string, description?: string): Counter_1<T>;
    createCounter<T extends any>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): Counter_1<T>;
    createGauge<T extends any>(name: string): Gauge_1<T>;
    createGauge<T extends any>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): Gauge_1<T>;
    createHistogram<T extends any>(name: string): Histogram_1<T>;
    createHistogram<T extends any>(name: string, unit: string, description: string): Histogram_1<T>;
    createHistogram<T extends any>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): Histogram_1<T>;
    createHistogram<T extends any>(name: string, unit?: string, description?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, advice?: InstrumentAdvice_1<T>): Histogram_1<T>;
    createObservableCounter<T extends any>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableCounter_1<T>;
    createObservableCounter<T extends any>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): ObservableCounter_1<T>;
    createObservableGauge<T extends any>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableGauge_1<T>;
    createObservableGauge<T extends any>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): ObservableGauge_1<T>;
    createObservableUpDownCounter<T extends any>(name: string, observeValue: Func_1<T>, unit?: string, description?: string): ObservableUpDownCounter_1<T>;
    createObservableUpDownCounter<T extends any>(name: string, observeValue: Func_1<T>, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): ObservableUpDownCounter_1<T>;
    createUpDownCounter<T extends any>(name: string, unit?: string, description?: string): UpDownCounter_1<T>;
    createUpDownCounter<T extends any>(name: string, unit: string, description: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): UpDownCounter_1<T>;
    dispose(): void;
}


export interface __Meter$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Meter = Meter$instance & __Meter$views;


export class MeterListener$instance {
    constructor();
    instrumentPublished: Action_2<Instrument, MeterListener>;
    measurementsCompleted: Action_2<Instrument, any>;
    disableMeasurementEvents(instrument: Instrument): any;
    dispose(): void;
    enableMeasurementEvents(instrument: Instrument, state?: any): void;
    recordObservableInstruments(): void;
    setMeasurementEventCallback<T extends any>(measurementCallback: MeasurementCallback_1<T>): void;
    start(): void;
}


export interface __MeterListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MeterListener = MeterListener$instance & __MeterListener$views;


export class MeterOptions$instance {
    constructor(name: string);
    name: string;
    scope: any;
    tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    telemetrySchemaUrl: string;
    version: string;
}


export type MeterOptions = MeterOptions$instance;

export class ObservableCounter_1$instance<T extends any> extends ObservableInstrument_1$instance<T> {
}


export type ObservableCounter_1<T> = ObservableCounter_1$instance<T>;

export class ObservableGauge_1$instance<T extends any> extends ObservableInstrument_1$instance<T> {
}


export type ObservableGauge_1<T> = ObservableGauge_1$instance<T>;

export abstract class ObservableInstrument_1$instance<T extends any> extends Instrument$instance {
    readonly isObservable: boolean;
}


export type ObservableInstrument_1<T> = ObservableInstrument_1$instance<T>;

export class ObservableUpDownCounter_1$instance<T extends any> extends ObservableInstrument_1$instance<T> {
}


export type ObservableUpDownCounter_1<T> = ObservableUpDownCounter_1$instance<T>;

export class UpDownCounter_1$instance<T extends any> extends Instrument_1$instance<T> {
    add(delta: T): void;
    add(delta: T, tag: KeyValuePair_2<CLROf<string>, any>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>): void;
    add(delta: T, tag1: KeyValuePair_2<CLROf<string>, any>, tag2: KeyValuePair_2<CLROf<string>, any>, tag3: KeyValuePair_2<CLROf<string>, any>): void;
    add(delta: T, tags: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>): void;
    add(delta: T, tags: KeyValuePair_2<CLROf<string>, any>[]): void;
    add(delta: T, tagList: { value: TSByRef<TagList> }): void;
}


export type UpDownCounter_1<T> = UpDownCounter_1$instance<T>;

export abstract class MeterFactoryExtensions$instance {
    static Create(meterFactory: IMeterFactory, name: string, version?: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>): Meter;
}


export type MeterFactoryExtensions = MeterFactoryExtensions$instance;

