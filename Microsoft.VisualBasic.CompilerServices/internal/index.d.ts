// Generated by tsbindgen - Architecture
// Namespace: Microsoft.VisualBasic.CompilerServices
// Assembly: Microsoft.VisualBasic.Core

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { CallType, CompareMethod } from "../../Microsoft.VisualBasic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo, NumberFormatInfo } from "../../System.Globalization/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Exception, Int16, Int32, Int64, Object as ClrObject, SByte, Single, String as ClrString, Type, UInt16, UInt32, UInt64, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export class BooleanType$instance {
    static FromObject(Value: any): boolean;
    static FromString(Value: string): boolean;
}


export type BooleanType = BooleanType$instance;

export class ByteType$instance {
    static FromObject(Value: any): byte;
    static FromString(Value: string): byte;
}


export type ByteType = ByteType$instance;

export class CharArrayType$instance {
    static FromObject(Value: any): string[];
    static FromString(Value: string): string[];
}


export type CharArrayType = CharArrayType$instance;

export class CharType$instance {
    static FromObject(Value: any): string;
    static FromString(Value: string): string;
}


export type CharType = CharType$instance;

export class Conversions$instance {
    static ChangeType(Expression: any, TargetType: Type): any;
    static FallbackUserDefinedConversion(Expression: any, TargetType: Type): any;
    static FromCharAndCount(Value: string, Count: int): string;
    static FromCharArray(Value: string[]): string;
    static FromCharArraySubset(Value: string[], StartIndex: int, Length: int): string;
    static ToBoolean(Value: any): boolean;
    static ToBoolean(Value: string): boolean;
    static ToByte(Value: any): byte;
    static ToByte(Value: string): byte;
    static ToChar(Value: any): string;
    static ToChar(Value: string): string;
    static ToCharArrayRankOne(Value: any): string[];
    static ToCharArrayRankOne(Value: string): string[];
    static ToDate(Value: any): DateTime;
    static ToDate(Value: string): DateTime;
    static ToDecimal(Value: boolean): decimal;
    static ToDecimal(Value: any): decimal;
    static ToDecimal(Value: string): decimal;
    static ToDouble(Value: any): double;
    static ToDouble(Value: string): double;
    static ToGenericParameter<T>(Value: any): T;
    static ToInteger(Value: any): int;
    static ToInteger(Value: string): int;
    static ToLong(Value: any): long;
    static ToLong(Value: string): long;
    static ToSByte(Value: any): sbyte;
    static ToSByte(Value: string): sbyte;
    static ToShort(Value: any): short;
    static ToShort(Value: string): short;
    static ToSingle(Value: any): float;
    static ToSingle(Value: string): float;
    static ToString(Value: boolean): string;
    static ToString(Value: byte): string;
    static ToString(Value: string): string;
    static ToString(Value: DateTime): string;
    static ToString(Value: decimal, NumberFormat: NumberFormatInfo): string;
    static ToString(Value: decimal): string;
    static ToString(Value: double, NumberFormat: NumberFormatInfo): string;
    static ToString(Value: double): string;
    static ToString(Value: short): string;
    static ToString(Value: int): string;
    static ToString(Value: long): string;
    static ToString(Value: any): string;
    static ToString(Value: float, NumberFormat: NumberFormatInfo): string;
    static ToString(Value: float): string;
    static ToString(Value: uint): string;
    static ToString(Value: ulong): string;
    static ToUInteger(Value: any): uint;
    static ToUInteger(Value: string): uint;
    static ToULong(Value: any): ulong;
    static ToULong(Value: string): ulong;
    static ToUShort(Value: any): ushort;
    static ToUShort(Value: string): ushort;
}


export type Conversions = Conversions$instance;

export class DateType$instance {
    static FromObject(Value: any): DateTime;
    static FromString(Value: string, culture: CultureInfo): DateTime;
    static FromString(Value: string): DateTime;
}


export type DateType = DateType$instance;

export class DecimalType$instance {
    static FromBoolean(Value: boolean): decimal;
    static FromObject(Value: any, NumberFormat: NumberFormatInfo): decimal;
    static FromObject(Value: any): decimal;
    static FromString(Value: string, NumberFormat: NumberFormatInfo): decimal;
    static FromString(Value: string): decimal;
    static Parse(Value: string, NumberFormat: NumberFormatInfo): decimal;
}


export type DecimalType = DecimalType$instance;

export class DesignerGeneratedAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DesignerGeneratedAttribute = DesignerGeneratedAttribute$instance;

export class DoubleType$instance {
    static FromObject(Value: any, NumberFormat: NumberFormatInfo): double;
    static FromObject(Value: any): double;
    static FromString(Value: string, NumberFormat: NumberFormatInfo): double;
    static FromString(Value: string): double;
    static Parse(Value: string, NumberFormat: NumberFormatInfo): double;
    static Parse(Value: string): double;
}


export type DoubleType = DoubleType$instance;

export class IncompleteInitialization$instance extends System_Internal.Exception$instance {
    constructor();
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __IncompleteInitialization$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IncompleteInitialization = IncompleteInitialization$instance & __IncompleteInitialization$views;


export class IntegerType$instance {
    static FromObject(Value: any): int;
    static FromString(Value: string): int;
}


export type IntegerType = IntegerType$instance;

export class LateBinding$instance {
    static LateCall(o: any, objType: Type, name: string, args: any[], paramnames: string[], CopyBack: boolean[]): void;
    static LateGet(o: any, objType: Type, name: string, args: any[], paramnames: string[], CopyBack: boolean[]): any;
    static LateIndexGet(o: any, args: any[], paramnames: string[]): any;
    static LateIndexSet(o: any, args: any[], paramnames: string[]): void;
    static LateIndexSetComplex(o: any, args: any[], paramnames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    static LateSet(o: any, objType: Type, name: string, args: any[], paramnames: string[]): void;
    static LateSetComplex(o: any, objType: Type, name: string, args: any[], paramnames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
}


export type LateBinding = LateBinding$instance;

export class LikeOperator$instance {
    static LikeObject(Source: any, Pattern: any, CompareOption: CompareMethod): any;
    static LikeString(Source: string, Pattern: string, CompareOption: CompareMethod): boolean;
}


export type LikeOperator = LikeOperator$instance;

export class LongType$instance {
    static FromObject(Value: any): long;
    static FromString(Value: string): long;
}


export type LongType = LongType$instance;

export class NewLateBinding$instance {
    static FallbackCall(Instance: any, MemberName: string, Arguments: any[], ArgumentNames: string[], IgnoreReturn: boolean): any;
    static FallbackGet(Instance: any, MemberName: string, Arguments: any[], ArgumentNames: string[]): any;
    static FallbackIndexSet(Instance: any, Arguments: any[], ArgumentNames: string[]): void;
    static FallbackIndexSetComplex(Instance: any, Arguments: any[], ArgumentNames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    static FallbackInvokeDefault1(Instance: any, Arguments: any[], ArgumentNames: string[], ReportErrors: boolean): any;
    static FallbackInvokeDefault2(Instance: any, Arguments: any[], ArgumentNames: string[], ReportErrors: boolean): any;
    static FallbackSet(Instance: any, MemberName: string, Arguments: any[]): void;
    static FallbackSetComplex(Instance: any, MemberName: string, Arguments: any[], OptimisticSet: boolean, RValueBase: boolean): void;
    static LateCall(Instance: any, Type: Type, MemberName: string, Arguments: any[], ArgumentNames: string[], TypeArguments: Type[], CopyBack: boolean[], IgnoreReturn: boolean): any;
    static LateCallInvokeDefault(Instance: any, Arguments: any[], ArgumentNames: string[], ReportErrors: boolean): any;
    static LateGet(Instance: any, Type: Type, MemberName: string, Arguments: any[], ArgumentNames: string[], TypeArguments: Type[], CopyBack: boolean[]): any;
    static LateGetInvokeDefault(Instance: any, Arguments: any[], ArgumentNames: string[], ReportErrors: boolean): any;
    static LateIndexGet(Instance: any, Arguments: any[], ArgumentNames: string[]): any;
    static LateIndexSet(Instance: any, Arguments: any[], ArgumentNames: string[]): void;
    static LateIndexSetComplex(Instance: any, Arguments: any[], ArgumentNames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    static LateSet(Instance: any, Type: Type, MemberName: string, Arguments: any[], ArgumentNames: string[], TypeArguments: Type[], OptimisticSet: boolean, RValueBase: boolean, CallType: CallType): void;
    static LateSet(Instance: any, Type: Type, MemberName: string, Arguments: any[], ArgumentNames: string[], TypeArguments: Type[]): void;
    static LateSetComplex(Instance: any, Type: Type, MemberName: string, Arguments: any[], ArgumentNames: string[], TypeArguments: Type[], OptimisticSet: boolean, RValueBase: boolean): void;
}


export type NewLateBinding = NewLateBinding$instance;

export class ObjectFlowControl$instance {
    static CheckForSyncLockOnValueType(Expression: any): void;
}


export type ObjectFlowControl = ObjectFlowControl$instance;

export class ObjectFlowControl_ForLoopControl$instance {
    static ForLoopInitObj(Counter: any, Start: any, Limit: any, StepValue: any, LoopForResult: { value: TSByRef<any> }, CounterResult: { value: TSByRef<any> }): boolean;
    static ForNextCheckDec(count: decimal, limit: decimal, StepValue: decimal): boolean;
    static ForNextCheckObj(Counter: any, LoopObj: any, CounterResult: { value: TSByRef<any> }): boolean;
    static ForNextCheckR4(count: float, limit: float, StepValue: float): boolean;
    static ForNextCheckR8(count: double, limit: double, StepValue: double): boolean;
}


export type ObjectFlowControl_ForLoopControl = ObjectFlowControl_ForLoopControl$instance;

export class ObjectType$instance {
    constructor();
    static AddObj(o1: any, o2: any): any;
    static BitAndObj(obj1: any, obj2: any): any;
    static BitOrObj(obj1: any, obj2: any): any;
    static BitXorObj(obj1: any, obj2: any): any;
    static DivObj(o1: any, o2: any): any;
    static GetObjectValuePrimitive(o: any): any;
    static IDivObj(o1: any, o2: any): any;
    static LikeObj(vLeft: any, vRight: any, CompareOption: CompareMethod): boolean;
    static ModObj(o1: any, o2: any): any;
    static MulObj(o1: any, o2: any): any;
    static NegObj(obj: any): any;
    static NotObj(obj: any): any;
    static ObjTst(o1: any, o2: any, TextCompare: boolean): int;
    static PlusObj(obj: any): any;
    static PowObj(obj1: any, obj2: any): any;
    static ShiftLeftObj(o1: any, amount: int): any;
    static ShiftRightObj(o1: any, amount: int): any;
    static StrCatObj(vLeft: any, vRight: any): any;
    static SubObj(o1: any, o2: any): any;
    static XorObj(obj1: any, obj2: any): any;
}


export type ObjectType = ObjectType$instance;

export class Operators$instance {
    static AddObject(Left: any, Right: any): any;
    static AndObject(Left: any, Right: any): any;
    static CompareObjectEqual(Left: any, Right: any, TextCompare: boolean): any;
    static CompareObjectGreater(Left: any, Right: any, TextCompare: boolean): any;
    static CompareObjectGreaterEqual(Left: any, Right: any, TextCompare: boolean): any;
    static CompareObjectLess(Left: any, Right: any, TextCompare: boolean): any;
    static CompareObjectLessEqual(Left: any, Right: any, TextCompare: boolean): any;
    static CompareObjectNotEqual(Left: any, Right: any, TextCompare: boolean): any;
    static CompareString(Left: string, Right: string, TextCompare: boolean): int;
    static ConcatenateObject(Left: any, Right: any): any;
    static ConditionalCompareObjectEqual(Left: any, Right: any, TextCompare: boolean): boolean;
    static ConditionalCompareObjectGreater(Left: any, Right: any, TextCompare: boolean): boolean;
    static ConditionalCompareObjectGreaterEqual(Left: any, Right: any, TextCompare: boolean): boolean;
    static ConditionalCompareObjectLess(Left: any, Right: any, TextCompare: boolean): boolean;
    static ConditionalCompareObjectLessEqual(Left: any, Right: any, TextCompare: boolean): boolean;
    static ConditionalCompareObjectNotEqual(Left: any, Right: any, TextCompare: boolean): boolean;
    static DivideObject(Left: any, Right: any): any;
    static ExponentObject(Left: any, Right: any): any;
    static FallbackInvokeUserDefinedOperator(vbOp: any, arguments: any[]): any;
    static IntDivideObject(Left: any, Right: any): any;
    static LeftShiftObject(Operand: any, Amount: any): any;
    static ModObject(Left: any, Right: any): any;
    static MultiplyObject(Left: any, Right: any): any;
    static NegateObject(Operand: any): any;
    static NotObject(Operand: any): any;
    static OrObject(Left: any, Right: any): any;
    static PlusObject(Operand: any): any;
    static RightShiftObject(Operand: any, Amount: any): any;
    static SubtractObject(Left: any, Right: any): any;
    static XorObject(Left: any, Right: any): any;
}


export type Operators = Operators$instance;

export class OptionCompareAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OptionCompareAttribute = OptionCompareAttribute$instance;

export class OptionTextAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OptionTextAttribute = OptionTextAttribute$instance;

export class ProjectData$instance {
    static ClearProjectError(): void;
    static CreateProjectError(hr: int): Exception;
    static EndApp(): void;
    static SetProjectError(ex: Exception, lErl: int): void;
    static SetProjectError(ex: Exception): void;
}


export type ProjectData = ProjectData$instance;

export class ShortType$instance {
    static FromObject(Value: any): short;
    static FromString(Value: string): short;
}


export type ShortType = ShortType$instance;

export class SingleType$instance {
    static FromObject(Value: any, NumberFormat: NumberFormatInfo): float;
    static FromObject(Value: any): float;
    static FromString(Value: string, NumberFormat: NumberFormatInfo): float;
    static FromString(Value: string): float;
}


export type SingleType = SingleType$instance;

export class StandardModuleAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type StandardModuleAttribute = StandardModuleAttribute$instance;

export class StaticLocalInitFlag$instance {
    constructor();
    State: short;
}


export type StaticLocalInitFlag = StaticLocalInitFlag$instance;

export class StringType$instance {
    static FromBoolean(Value: boolean): string;
    static FromByte(Value: byte): string;
    static FromChar(Value: string): string;
    static FromDate(Value: DateTime): string;
    static FromDecimal(Value: decimal, NumberFormat: NumberFormatInfo): string;
    static FromDecimal(Value: decimal): string;
    static FromDouble(Value: double, NumberFormat: NumberFormatInfo): string;
    static FromDouble(Value: double): string;
    static FromInteger(Value: int): string;
    static FromLong(Value: long): string;
    static FromObject(Value: any): string;
    static FromShort(Value: short): string;
    static FromSingle(Value: float, NumberFormat: NumberFormatInfo): string;
    static FromSingle(Value: float): string;
    static MidStmtStr(sDest: { value: TSByRef<string> }, StartPosition: int, MaxInsertLength: int, sInsert: string): void;
    static StrCmp(sLeft: string, sRight: string, TextCompare: boolean): int;
    static StrLike(Source: string, Pattern: string, CompareOption: CompareMethod): boolean;
    static StrLikeBinary(Source: string, Pattern: string): boolean;
    static StrLikeText(Source: string, Pattern: string): boolean;
}


export type StringType = StringType$instance;

export class Utils$instance {
    static CopyArray(arySrc: ClrArray, aryDest: ClrArray): ClrArray;
    static GetResourceString(ResourceKey: string, Args: string[]): string;
}


export type Utils = Utils$instance;

export class Versioned$instance {
    static CallByName(Instance: any, MethodName: string, UseCallType: CallType, Arguments: any[]): any;
    static IsNumeric(Expression: any): boolean;
    static SystemTypeName(VbName: string): string;
    static TypeName(Expression: any): string;
    static VbTypeName(SystemName: string): string;
}


export type Versioned = Versioned$instance;

