// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography.X509Certificates
// Assembly: System.Security.Cryptography

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { SafeX509ChainHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { CollectionBase, ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { UniversalTagNumber } from "../../System.Formats.Asn1/internal/index.js";
import type { IPAddress } from "../../System.Net/internal/index.js";
import type { BigInteger } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Security_Cryptography_Internal from "../../System.Security.Cryptography/internal/index.js";
import type { AsnEncodedData, AsymmetricAlgorithm, CompositeMLDsa, CryptographicException, DSA, ECDiffieHellman, ECDsa, HashAlgorithmName, MLDsa, MLKem, Oid, OidCollection, PbeParameters, RSA, RSASignaturePadding, SlhDsa } from "../../System.Security.Cryptography/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Uri, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CertificateRequestLoadOptions {
    default_ = 0,
    skipSignatureValidation = 1,
    unsafeLoadCertificateExtensions = 2
}


export enum OpenFlags {
    readOnly = 0,
    readWrite = 1,
    maxAllowed = 2,
    openExistingOnly = 4,
    includeArchived = 8
}


export enum Pkcs12ExportPbeParameters {
    default_ = 0,
    pkcs12TripleDesSha1 = 1,
    pbes2Aes256Sha256 = 2
}


export enum StoreLocation {
    currentUser = 1,
    localMachine = 2
}


export enum StoreName {
    addressBook = 1,
    authRoot = 2,
    certificateAuthority = 3,
    disallowed = 4,
    my = 5,
    root = 6,
    trustedPeople = 7,
    trustedPublisher = 8
}


export enum X500DistinguishedNameFlags {
    none = 0,
    reversed = 1,
    useSemicolons = 16,
    doNotUsePlusSign = 32,
    doNotUseQuotes = 64,
    useCommas = 128,
    useNewLines = 256,
    useUTF8Encoding = 4096,
    useT61Encoding = 8192,
    forceUTF8Encoding = 16384
}


export enum X509ChainStatusFlags {
    noError = 0,
    notTimeValid = 1,
    notTimeNested = 2,
    revoked = 4,
    notSignatureValid = 8,
    notValidForUsage = 16,
    untrustedRoot = 32,
    revocationStatusUnknown = 64,
    cyclic = 128,
    invalidExtension = 256,
    invalidPolicyConstraints = 512,
    invalidBasicConstraints = 1024,
    invalidNameConstraints = 2048,
    hasNotSupportedNameConstraint = 4096,
    hasNotDefinedNameConstraint = 8192,
    hasNotPermittedNameConstraint = 16384,
    hasExcludedNameConstraint = 32768,
    partialChain = 65536,
    ctlNotTimeValid = 131072,
    ctlNotSignatureValid = 262144,
    ctlNotValidForUsage = 524288,
    offlineRevocation = 16777216,
    noIssuanceChainPolicy = 33554432,
    explicitDistrust = 67108864,
    hasNotSupportedCriticalExtension = 134217728,
    hasWeakSignature = 1048576
}


export enum X509ChainTrustMode {
    system = 0,
    customRootTrust = 1
}


export enum X509ContentType {
    unknown_ = 0,
    cert = 1,
    serializedCert = 2,
    pfx = 3,
    pkcs12 = 3,
    serializedStore = 4,
    pkcs7 = 5,
    authenticode = 6
}


export enum X509FindType {
    findByThumbprint = 0,
    findBySubjectName = 1,
    findBySubjectDistinguishedName = 2,
    findByIssuerName = 3,
    findByIssuerDistinguishedName = 4,
    findBySerialNumber = 5,
    findByTimeValid = 6,
    findByTimeNotYetValid = 7,
    findByTimeExpired = 8,
    findByTemplateName = 9,
    findByApplicationPolicy = 10,
    findByCertificatePolicy = 11,
    findByExtension = 12,
    findByKeyUsage = 13,
    findBySubjectKeyIdentifier = 14
}


export enum X509IncludeOption {
    none = 0,
    excludeRoot = 1,
    endCertOnly = 2,
    wholeChain = 3
}


export enum X509KeyStorageFlags {
    defaultKeySet = 0,
    userKeySet = 1,
    machineKeySet = 2,
    exportable = 4,
    userProtected = 8,
    persistKeySet = 16,
    ephemeralKeySet = 32
}


export enum X509KeyUsageFlags {
    none = 0,
    encipherOnly = 1,
    crlSign = 2,
    keyCertSign = 4,
    keyAgreement = 8,
    dataEncipherment = 16,
    keyEncipherment = 32,
    nonRepudiation = 64,
    digitalSignature = 128,
    decipherOnly = 32768
}


export enum X509NameType {
    simpleName = 0,
    emailName = 1,
    upnName = 2,
    dnsName = 3,
    dnsFromAlternativeName = 4,
    urlName = 5
}


export enum X509RevocationFlag {
    endCertificateOnly = 0,
    entireChain = 1,
    excludeRoot = 2
}


export enum X509RevocationMode {
    noCheck = 0,
    online = 1,
    offline = 2
}


export enum X509RevocationReason {
    unspecified = 0,
    keyCompromise = 1,
    caCompromise = 2,
    affiliationChanged = 3,
    superseded = 4,
    cessationOfOperation = 5,
    certificateHold = 6,
    removeFromCrl = 8,
    privilegeWithdrawn = 9,
    aaCompromise = 10,
    weakAlgorithmOrKey = 11
}


export enum X509SubjectKeyIdentifierHashAlgorithm {
    sha1 = 0,
    shortSha1 = 1,
    capiSha1 = 2,
    sha256 = 3,
    sha384 = 4,
    sha512 = 5,
    shortSha256 = 6,
    shortSha384 = 7,
    shortSha512 = 8
}


export enum X509VerificationFlags {
    noFlag = 0,
    ignoreNotTimeValid = 1,
    ignoreCtlNotTimeValid = 2,
    ignoreNotTimeNested = 4,
    ignoreInvalidBasicConstraints = 8,
    allowUnknownCertificateAuthority = 16,
    ignoreWrongUsage = 32,
    ignoreInvalidName = 64,
    ignoreInvalidPolicy = 128,
    ignoreEndRevocationUnknown = 256,
    ignoreCtlSignerRevocationUnknown = 512,
    ignoreCertificateAuthorityRevocationUnknown = 1024,
    ignoreRootRevocationUnknown = 2048,
    allFlags = 4095
}


export class X509ChainStatus$instance {
    status: X509ChainStatusFlags;
    statusInformation: string;
}


export type X509ChainStatus = X509ChainStatus$instance;

export class CertificateRequest$instance {
    constructor(subjectName: string, key: ECDsa, hashAlgorithm: HashAlgorithmName);
    constructor(subjectName: X500DistinguishedName, key: ECDsa, hashAlgorithm: HashAlgorithmName);
    constructor(subjectName: string, key: RSA, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding);
    constructor(subjectName: X500DistinguishedName, key: RSA, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding);
    constructor(subjectName: string, key: MLDsa);
    constructor(subjectName: X500DistinguishedName, key: MLDsa);
    constructor(subjectName: string, key: SlhDsa);
    constructor(subjectName: X500DistinguishedName, key: SlhDsa);
    constructor(subjectName: string, key: CompositeMLDsa);
    constructor(subjectName: X500DistinguishedName, key: CompositeMLDsa);
    constructor(subjectName: X500DistinguishedName, publicKey: PublicKey, hashAlgorithm: HashAlgorithmName);
    constructor(subjectName: X500DistinguishedName, publicKey: PublicKey, hashAlgorithm: HashAlgorithmName, rsaSignaturePadding: RSASignaturePadding);
    readonly certificateExtensions: Collection_1<X509Extension>;
    readonly hashAlgorithm: HashAlgorithmName;
    readonly otherRequestAttributes: Collection_1<AsnEncodedData>;
    readonly publicKey: PublicKey;
    readonly subjectName: X500DistinguishedName;
    create(issuerCertificate: X509Certificate2, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: byte[]): X509Certificate2;
    create(issuerCertificate: X509Certificate2, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2;
    create(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: byte[]): X509Certificate2;
    create(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2;
    createSelfSigned(notBefore: DateTimeOffset, notAfter: DateTimeOffset): X509Certificate2;
    createSigningRequest(): byte[];
    createSigningRequest(signatureGenerator: X509SignatureGenerator): byte[];
    createSigningRequestPem(): string;
    createSigningRequestPem(signatureGenerator: X509SignatureGenerator): string;
    static LoadSigningRequest(pkcs10: byte[], signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    static LoadSigningRequest(pkcs10: ReadOnlySpan_1<CLROf<byte>>, signerHashAlgorithm: HashAlgorithmName, bytesConsumed: { value: TSByRef<int> }, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    static LoadSigningRequestPem(pkcs10Pem: ReadOnlySpan_1<CLROf<string>>, signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    static LoadSigningRequestPem(pkcs10Pem: string, signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
}


export type CertificateRequest = CertificateRequest$instance;

export class CertificateRevocationListBuilder$instance {
    constructor();
    addEntry(certificate: X509Certificate2, revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    addEntry(serialNumber: byte[], revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    addEntry(serialNumber: ReadOnlySpan_1<CLROf<byte>>, revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    build(issuerCertificate: X509Certificate2, crlNumber: BigInteger, nextUpdate: DateTimeOffset, hashAlgorithm: HashAlgorithmName, rsaSignaturePadding?: RSASignaturePadding, thisUpdate?: Nullable_1<DateTimeOffset>): byte[];
    build(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, crlNumber: BigInteger, nextUpdate: DateTimeOffset, hashAlgorithm: HashAlgorithmName, authorityKeyIdentifier: X509AuthorityKeyIdentifierExtension, thisUpdate?: Nullable_1<DateTimeOffset>): byte[];
    removeEntry(serialNumber: byte[]): boolean;
    removeEntry(serialNumber: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static BuildCrlDistributionPointExtension(uris: IEnumerable_1<CLROf<string>>, critical?: boolean): X509Extension;
    static Load(currentCrl: byte[], currentCrlNumber: { value: TSByRef<BigInteger> }): CertificateRevocationListBuilder;
    static Load(currentCrl: ReadOnlySpan_1<CLROf<byte>>, currentCrlNumber: { value: TSByRef<BigInteger> }, bytesConsumed: { value: TSByRef<int> }): CertificateRevocationListBuilder;
    static LoadPem(currentCrl: ReadOnlySpan_1<CLROf<string>>, currentCrlNumber: { value: TSByRef<BigInteger> }): CertificateRevocationListBuilder;
    static LoadPem(currentCrl: string, currentCrlNumber: { value: TSByRef<BigInteger> }): CertificateRevocationListBuilder;
}


export type CertificateRevocationListBuilder = CertificateRevocationListBuilder$instance;

export class Pkcs12LoaderLimits$instance {
    constructor();
    constructor(copyFrom: Pkcs12LoaderLimits);
    allowDuplicateAttributes: boolean;
    ignoreEncryptedAuthSafes: boolean;
    ignorePrivateKeys: boolean;
    individualKdfIterationLimit: Nullable_1<CLROf<int>>;
    readonly isReadOnly: boolean;
    macIterationLimit: Nullable_1<CLROf<int>>;
    maxCertificates: Nullable_1<CLROf<int>>;
    maxKeys: Nullable_1<CLROf<int>>;
    preserveCertificateAlias: boolean;
    preserveKeyName: boolean;
    preserveStorageProvider: boolean;
    preserveUnknownAttributes: boolean;
    totalKdfIterationLimit: Nullable_1<CLROf<int>>;
    makeReadOnly(): void;
    static readonly Defaults: Pkcs12LoaderLimits;
    static readonly DangerousNoLimits: Pkcs12LoaderLimits;
}


export type Pkcs12LoaderLimits = Pkcs12LoaderLimits$instance;

export class Pkcs12LoadLimitExceededException$instance extends System_Security_Cryptography_Internal.CryptographicException$instance {
    constructor(propertyName: string);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __Pkcs12LoadLimitExceededException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Pkcs12LoadLimitExceededException = Pkcs12LoadLimitExceededException$instance & __Pkcs12LoadLimitExceededException$views;


export class PublicKey$instance {
    constructor(oid: Oid, parameters: AsnEncodedData, keyValue: AsnEncodedData);
    constructor(key: AsymmetricAlgorithm);
    constructor(key: MLKem);
    constructor(key: MLDsa);
    constructor(key: SlhDsa);
    constructor(key: CompositeMLDsa);
    readonly encodedKeyValue: AsnEncodedData;
    readonly encodedParameters: AsnEncodedData;
    readonly key: AsymmetricAlgorithm;
    readonly oid: Oid;
    exportSubjectPublicKeyInfo(): byte[];
    getCompositeMLDsaPublicKey(): CompositeMLDsa;
    getDSAPublicKey(): DSA;
    getECDiffieHellmanPublicKey(): ECDiffieHellman;
    getECDsaPublicKey(): ECDsa;
    getMLDsaPublicKey(): MLDsa;
    getMLKemPublicKey(): MLKem;
    getRSAPublicKey(): RSA;
    getSlhDsaPublicKey(): SlhDsa;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static CreateFromSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: TSByRef<int> }): PublicKey;
}


export type PublicKey = PublicKey$instance;

export class SubjectAlternativeNameBuilder$instance {
    constructor();
    addDnsName(dnsName: string): void;
    addEmailAddress(emailAddress: string): void;
    addIpAddress(ipAddress: IPAddress): void;
    addUri(uri: Uri): void;
    addUserPrincipalName(upn: string): void;
    build(critical?: boolean): X509Extension;
}


export type SubjectAlternativeNameBuilder = SubjectAlternativeNameBuilder$instance;

export class X500DistinguishedName$instance extends System_Security_Cryptography_Internal.AsnEncodedData$instance {
    constructor(encodedDistinguishedName: byte[]);
    constructor(encodedDistinguishedName: ReadOnlySpan_1<CLROf<byte>>);
    constructor(encodedDistinguishedName: AsnEncodedData);
    constructor(distinguishedName: X500DistinguishedName);
    constructor(distinguishedName: string);
    constructor(distinguishedName: string, flag: X500DistinguishedNameFlags);
    readonly name: string;
    decode(flag: X500DistinguishedNameFlags): string;
    enumerateRelativeDistinguishedNames(reversed?: boolean): IEnumerable_1<X500RelativeDistinguishedName>;
    format(multiLine: boolean): string;
}


export type X500DistinguishedName = X500DistinguishedName$instance;

export class X500DistinguishedNameBuilder$instance {
    constructor();
    add(oidValue: string, value: string, stringEncodingType?: Nullable_1<UniversalTagNumber>): void;
    add(oid: Oid, value: string, stringEncodingType?: Nullable_1<UniversalTagNumber>): void;
    addCommonName(commonName: string): void;
    addCountryOrRegion(twoLetterCode: string): void;
    addDomainComponent(domainComponent: string): void;
    addEmailAddress(emailAddress: string): void;
    addLocalityName(localityName: string): void;
    addOrganizationalUnitName(organizationalUnitName: string): void;
    addOrganizationName(organizationName: string): void;
    addStateOrProvinceName(stateOrProvinceName: string): void;
    build(): X500DistinguishedName;
}


export type X500DistinguishedNameBuilder = X500DistinguishedNameBuilder$instance;

export class X500RelativeDistinguishedName$instance {
    readonly hasMultipleElements: boolean;
    readonly rawData: ReadOnlyMemory_1<CLROf<byte>>;
    getSingleElementType(): Oid;
    getSingleElementValue(): string;
}


export type X500RelativeDistinguishedName = X500RelativeDistinguishedName$instance;

export class X509AuthorityInformationAccessExtension$instance extends X509Extension$instance {
    constructor();
    constructor(rawData: byte[], critical: boolean);
    constructor(rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean);
    constructor(ocspUris: IEnumerable_1<CLROf<string>>, caIssuersUris: IEnumerable_1<CLROf<string>>, critical: boolean);
    copyFrom(asnEncodedData: AsnEncodedData): void;
    enumerateCAIssuersUris(): IEnumerable_1<CLROf<string>>;
    enumerateOcspUris(): IEnumerable_1<CLROf<string>>;
    enumerateUris(accessMethodOid: string): IEnumerable_1<CLROf<string>>;
    enumerateUris(accessMethodOid: Oid): IEnumerable_1<CLROf<string>>;
}


export type X509AuthorityInformationAccessExtension = X509AuthorityInformationAccessExtension$instance;

export class X509AuthorityKeyIdentifierExtension$instance extends X509Extension$instance {
    constructor();
    constructor(rawData: byte[], critical: boolean);
    constructor(rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean);
    readonly keyIdentifier: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    readonly namedIssuer: X500DistinguishedName;
    readonly rawIssuer: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    readonly serialNumber: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    copyFrom(asnEncodedData: AsnEncodedData): void;
    static Create(keyIdentifier: byte[], issuerName: X500DistinguishedName, serialNumber: byte[]): X509AuthorityKeyIdentifierExtension;
    static Create(keyIdentifier: ReadOnlySpan_1<CLROf<byte>>, issuerName: X500DistinguishedName, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509AuthorityKeyIdentifierExtension;
    static CreateFromCertificate(certificate: X509Certificate2, includeKeyIdentifier: boolean, includeIssuerAndSerial: boolean): X509AuthorityKeyIdentifierExtension;
    static CreateFromIssuerNameAndSerialNumber(issuerName: X500DistinguishedName, serialNumber: byte[]): X509AuthorityKeyIdentifierExtension;
    static CreateFromIssuerNameAndSerialNumber(issuerName: X500DistinguishedName, serialNumber: ReadOnlySpan_1<CLROf<byte>>): X509AuthorityKeyIdentifierExtension;
    static CreateFromSubjectKeyIdentifier(subjectKeyIdentifier: byte[]): X509AuthorityKeyIdentifierExtension;
    static CreateFromSubjectKeyIdentifier(subjectKeyIdentifier: ReadOnlySpan_1<CLROf<byte>>): X509AuthorityKeyIdentifierExtension;
    static CreateFromSubjectKeyIdentifier(subjectKeyIdentifier: X509SubjectKeyIdentifierExtension): X509AuthorityKeyIdentifierExtension;
}


export type X509AuthorityKeyIdentifierExtension = X509AuthorityKeyIdentifierExtension$instance;

export class X509BasicConstraintsExtension$instance extends X509Extension$instance {
    constructor();
    constructor(certificateAuthority: boolean, hasPathLengthConstraint: boolean, pathLengthConstraint: int, critical: boolean);
    constructor(encodedBasicConstraints: AsnEncodedData, critical: boolean);
    readonly certificateAuthority: boolean;
    readonly hasPathLengthConstraint: boolean;
    readonly pathLengthConstraint: int;
    copyFrom(asnEncodedData: AsnEncodedData): void;
    static CreateForCertificateAuthority(pathLengthConstraint?: Nullable_1<CLROf<int>>): X509BasicConstraintsExtension;
    static CreateForEndEntity(critical?: boolean): X509BasicConstraintsExtension;
}


export type X509BasicConstraintsExtension = X509BasicConstraintsExtension$instance;

export class X509Certificate$instance {
    constructor();
    constructor(data: byte[]);
    constructor(rawData: byte[], password: string);
    constructor(rawData: byte[], password: SecureString);
    constructor(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags);
    constructor(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags);
    constructor(handle: nint);
    constructor(fileName: string);
    constructor(fileName: string, password: string);
    constructor(fileName: string, password: SecureString);
    constructor(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags);
    constructor(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags);
    constructor(cert: X509Certificate);
    constructor(info: SerializationInfo, context: StreamingContext);
    readonly handle: nint;
    readonly issuer: string;
    readonly serialNumberBytes: ReadOnlyMemory_1<CLROf<byte>>;
    readonly subject: string;
    dispose(): void;
    equals(obj: any): boolean;
    equals(other: X509Certificate): boolean;
    export_(contentType: X509ContentType): byte[];
    export_(contentType: X509ContentType, password: string): byte[];
    export_(contentType: X509ContentType, password: SecureString): byte[];
    exportPkcs12(exportParameters: Pkcs12ExportPbeParameters, password: string): byte[];
    exportPkcs12(exportParameters: PbeParameters, password: string): byte[];
    getCertHash(): byte[];
    getCertHash(hashAlgorithm: HashAlgorithmName): byte[];
    getCertHashString(): string;
    getCertHashString(hashAlgorithm: HashAlgorithmName): string;
    getEffectiveDateString(): string;
    getExpirationDateString(): string;
    getFormat(): string;
    getHashCode(): int;
    getIssuerName(): string;
    getKeyAlgorithm(): string;
    getKeyAlgorithmParameters(): byte[];
    getKeyAlgorithmParametersString(): string;
    getName(): string;
    getPublicKey(): byte[];
    getPublicKeyString(): string;
    getRawCertData(): byte[];
    getRawCertDataString(): string;
    getSerialNumber(): byte[];
    getSerialNumberString(): string;
    import_(rawData: byte[]): void;
    import_(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string): void;
    import_(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    reset(): void;
    toString(): string;
    toString(fVerbose: boolean): string;
    tryGetCertHash(hashAlgorithm: HashAlgorithmName, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static CreateFromCertFile(filename: string): X509Certificate;
    static CreateFromSignedFile(filename: string): X509Certificate;
}


export interface __X509Certificate$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type X509Certificate = X509Certificate$instance & __X509Certificate$views;


export class X509Certificate2$instance extends X509Certificate$instance {
    constructor();
    constructor(rawData: byte[]);
    constructor(rawData: byte[], password: string);
    constructor(rawData: byte[], password: SecureString);
    constructor(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags);
    constructor(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags);
    constructor(rawData: ReadOnlySpan_1<CLROf<byte>>);
    constructor(rawData: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags: X509KeyStorageFlags);
    constructor(handle: nint);
    constructor(fileName: string);
    constructor(fileName: string, password: string);
    constructor(fileName: string, password: SecureString);
    constructor(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags);
    constructor(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags);
    constructor(fileName: string, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags: X509KeyStorageFlags);
    constructor(certificate: X509Certificate);
    archived: boolean;
    readonly extensions: X509ExtensionCollection;
    friendlyName: string;
    readonly hasPrivateKey: boolean;
    readonly issuerName: X500DistinguishedName;
    readonly notAfter: DateTime;
    readonly notBefore: DateTime;
    privateKey: AsymmetricAlgorithm;
    readonly publicKey: PublicKey;
    readonly rawData: byte[];
    readonly rawDataMemory: ReadOnlyMemory_1<CLROf<byte>>;
    readonly serialNumber: string;
    readonly signatureAlgorithm: Oid;
    readonly subjectName: X500DistinguishedName;
    readonly thumbprint: string;
    readonly version: int;
    copyWithPrivateKey(privateKey: ECDiffieHellman): X509Certificate2;
    copyWithPrivateKey(privateKey: MLKem): X509Certificate2;
    copyWithPrivateKey(privateKey: MLDsa): X509Certificate2;
    copyWithPrivateKey(privateKey: SlhDsa): X509Certificate2;
    copyWithPrivateKey(privateKey: CompositeMLDsa): X509Certificate2;
    dispose(): void;
    exportCertificatePem(): string;
    getCompositeMLDsaPrivateKey(): CompositeMLDsa;
    getCompositeMLDsaPublicKey(): CompositeMLDsa;
    getECDiffieHellmanPrivateKey(): ECDiffieHellman;
    getECDiffieHellmanPublicKey(): ECDiffieHellman;
    getMLDsaPrivateKey(): MLDsa;
    getMLDsaPublicKey(): MLDsa;
    getMLKemPrivateKey(): MLKem;
    getMLKemPublicKey(): MLKem;
    getNameInfo(nameType: X509NameType, forIssuer: boolean): string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getSlhDsaPrivateKey(): SlhDsa;
    getSlhDsaPublicKey(): SlhDsa;
    import_(rawData: byte[]): void;
    import_(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string): void;
    import_(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): void;
    import_(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    matchesHostname(hostname: string, allowWildcards?: boolean, allowCommonName?: boolean): boolean;
    onDeserialization(sender: any): void;
    reset(): void;
    toString(): string;
    toString(verbose: boolean): string;
    tryExportCertificatePem(destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    verify(): boolean;
    static CreateFromEncryptedPem(certPem: ReadOnlySpan_1<CLROf<string>>, keyPem: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): X509Certificate2;
    static CreateFromEncryptedPemFile(certPemFilePath: string, password: ReadOnlySpan_1<CLROf<string>>, keyPemFilePath?: string): X509Certificate2;
    static CreateFromPem(certPem: ReadOnlySpan_1<CLROf<string>>, keyPem: ReadOnlySpan_1<CLROf<string>>): X509Certificate2;
    static CreateFromPem(certPem: ReadOnlySpan_1<CLROf<string>>): X509Certificate2;
    static CreateFromPemFile(certPemFilePath: string, keyPemFilePath?: string): X509Certificate2;
    static GetCertContentType(rawData: byte[]): X509ContentType;
    static GetCertContentType(rawData: ReadOnlySpan_1<CLROf<byte>>): X509ContentType;
    static GetCertContentType(fileName: string): X509ContentType;
}


export interface __X509Certificate2$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type X509Certificate2 = X509Certificate2$instance & __X509Certificate2$views;


export class X509Certificate2Collection$instance extends X509CertificateCollection$instance {
    constructor();
    constructor(certificate: X509Certificate2);
    constructor(certificates: X509Certificate2[]);
    constructor(certificates: X509Certificate2Collection);
    add(value: X509Certificate): int;
    add(value: any): int;
    addRange(value: X509Certificate[]): void;
    addRange(value: X509CertificateCollection): void;
    clear(): void;
    contains(value: X509Certificate): boolean;
    contains(value: any): boolean;
    copyTo(array: X509Certificate[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    export_(contentType: X509ContentType): byte[];
    export_(contentType: X509ContentType, password: string): byte[];
    exportCertificatePems(): string;
    exportPkcs12(exportParameters: Pkcs12ExportPbeParameters, password: string): byte[];
    exportPkcs12(exportParameters: PbeParameters, password: string): byte[];
    exportPkcs7Pem(): string;
    find(findType: X509FindType, findValue: any, validOnly: boolean): X509Certificate2Collection;
    findByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintHex: string): X509Certificate2Collection;
    findByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintHex: ReadOnlySpan_1<CLROf<string>>): X509Certificate2Collection;
    findByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintBytes: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2Collection;
    getEnumerator(): X509CertificateCollection_X509CertificateEnumerator;
    getEnumerator(): IEnumerator;
    import_(rawData: byte[]): void;
    import_(rawData: ReadOnlySpan_1<CLROf<byte>>): void;
    import_(rawData: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(rawData: ReadOnlySpan_1<CLROf<byte>>, password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(rawData: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(fileName: string): void;
    import_(fileName: string, password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    import_(fileName: string, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags?: X509KeyStorageFlags): void;
    importFromPem(certPem: ReadOnlySpan_1<CLROf<string>>): void;
    importFromPemFile(certPemFilePath: string): void;
    indexOf(value: X509Certificate): int;
    insert(index: int, value: X509Certificate): void;
    insert(index: int, value: any): void;
    remove(value: X509Certificate): void;
    remove(value: any): void;
    removeAt(index: int): void;
    removeRange(certificates: X509Certificate2[]): void;
    removeRange(certificates: X509Certificate2Collection): void;
    tryExportCertificatePems(destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    tryExportPkcs7Pem(destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
}


export interface __X509Certificate2Collection$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<X509Certificate2>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type X509Certificate2Collection = X509Certificate2Collection$instance & __X509Certificate2Collection$views;


export class X509Certificate2Enumerator$instance {
    readonly current: X509Certificate2;
    moveNext(): boolean;
    reset(): void;
}


export interface __X509Certificate2Enumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<X509Certificate2>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type X509Certificate2Enumerator = X509Certificate2Enumerator$instance & __X509Certificate2Enumerator$views;


export class X509CertificateCollection$instance extends System_Collections_Internal.CollectionBase$instance {
    constructor();
    constructor(value: X509Certificate[]);
    constructor(value: X509CertificateCollection);
    item: X509Certificate | X509Certificate2;
    add(value: any): int;
    addRange(value: X509Certificate[]): void;
    addRange(value: X509CertificateCollection): void;
    clear(): void;
    contains(value: any): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    getHashCode(): int;
    indexOf(value: X509Certificate): int;
    insert(index: int, value: any): void;
    remove(value: any): void;
    removeAt(index: int): void;
}


export interface __X509CertificateCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type X509CertificateCollection = X509CertificateCollection$instance & __X509CertificateCollection$views;


export class X509CertificateCollection_X509CertificateEnumerator$instance {
    constructor(mappings: X509CertificateCollection);
    readonly current: any | X509Certificate;
    moveNext(): boolean;
    reset(): void;
}


export interface __X509CertificateCollection_X509CertificateEnumerator$views {
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type X509CertificateCollection_X509CertificateEnumerator = X509CertificateCollection_X509CertificateEnumerator$instance & __X509CertificateCollection_X509CertificateEnumerator$views;


export class X509Chain$instance {
    constructor();
    constructor(useMachineContext: boolean);
    constructor(chainContext: nint);
    readonly chainContext: nint;
    readonly chainElements: X509ChainElementCollection;
    chainPolicy: X509ChainPolicy;
    readonly chainStatus: X509ChainStatus[];
    readonly safeHandle: SafeX509ChainHandle;
    build(certificate: X509Certificate2): boolean;
    dispose(): void;
    reset(): void;
    static Create(): X509Chain;
}


export interface __X509Chain$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type X509Chain = X509Chain$instance & __X509Chain$views;


export class X509ChainElement$instance {
    readonly certificate: X509Certificate2;
    readonly chainElementStatus: X509ChainStatus[];
    readonly information: string;
}


export type X509ChainElement = X509ChainElement$instance;

export class X509ChainElementCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: X509ChainElement;
    readonly syncRoot: any;
    copyTo(array: X509ChainElement[], index: int): void;
    getEnumerator(): X509ChainElementEnumerator;
}


export interface __X509ChainElementCollection$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<X509ChainElement>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type X509ChainElementCollection = X509ChainElementCollection$instance & __X509ChainElementCollection$views;


export class X509ChainElementEnumerator$instance {
    readonly current: X509ChainElement;
    moveNext(): boolean;
    reset(): void;
}


export interface __X509ChainElementEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<X509ChainElement>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type X509ChainElementEnumerator = X509ChainElementEnumerator$instance & __X509ChainElementEnumerator$views;


export class X509ChainPolicy$instance {
    constructor();
    readonly applicationPolicy: OidCollection;
    readonly certificatePolicy: OidCollection;
    readonly customTrustStore: X509Certificate2Collection;
    disableCertificateDownloads: boolean;
    readonly extraStore: X509Certificate2Collection;
    revocationFlag: X509RevocationFlag;
    revocationMode: X509RevocationMode;
    trustMode: X509ChainTrustMode;
    urlRetrievalTimeout: TimeSpan;
    verificationFlags: X509VerificationFlags;
    verificationTime: DateTime;
    verificationTimeIgnored: boolean;
    clone(): X509ChainPolicy;
    reset(): void;
}


export type X509ChainPolicy = X509ChainPolicy$instance;

export class X509EnhancedKeyUsageExtension$instance extends X509Extension$instance {
    constructor();
    constructor(encodedEnhancedKeyUsages: AsnEncodedData, critical: boolean);
    constructor(enhancedKeyUsages: OidCollection, critical: boolean);
    readonly enhancedKeyUsages: OidCollection;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export type X509EnhancedKeyUsageExtension = X509EnhancedKeyUsageExtension$instance;

export class X509Extension$instance extends System_Security_Cryptography_Internal.AsnEncodedData$instance {
    constructor(encodedExtension: AsnEncodedData, critical: boolean);
    constructor(oid: Oid, rawData: byte[], critical: boolean);
    constructor(oid: Oid, rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean);
    constructor(oid: string, rawData: byte[], critical: boolean);
    constructor(oid: string, rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean);
    critical: boolean;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export type X509Extension = X509Extension$instance;

export class X509ExtensionCollection$instance {
    constructor();
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: any;
    add(extension: X509Extension): int;
    copyTo(array: X509Extension[], index: int): void;
    get_Item(index: int): X509Extension;
    get_Item(oid: string): X509Extension;
    getEnumerator(): X509ExtensionEnumerator;
}


export interface __X509ExtensionCollection$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<X509Extension>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type X509ExtensionCollection = X509ExtensionCollection$instance & __X509ExtensionCollection$views;


export class X509ExtensionEnumerator$instance {
    readonly current: X509Extension;
    moveNext(): boolean;
    reset(): void;
}


export interface __X509ExtensionEnumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<X509Extension>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type X509ExtensionEnumerator = X509ExtensionEnumerator$instance & __X509ExtensionEnumerator$views;


export class X509KeyUsageExtension$instance extends X509Extension$instance {
    constructor();
    constructor(encodedKeyUsage: AsnEncodedData, critical: boolean);
    constructor(keyUsages: X509KeyUsageFlags, critical: boolean);
    readonly keyUsages: X509KeyUsageFlags;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export type X509KeyUsageExtension = X509KeyUsageExtension$instance;

export abstract class X509SignatureGenerator$instance {
    readonly publicKey: PublicKey;
    abstract getSignatureAlgorithmIdentifier(hashAlgorithm: HashAlgorithmName): byte[];
    abstract signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    static CreateForCompositeMLDsa(key: CompositeMLDsa): X509SignatureGenerator;
    static CreateForECDsa(key: ECDsa): X509SignatureGenerator;
    static CreateForMLDsa(key: MLDsa): X509SignatureGenerator;
    static CreateForRSA(key: RSA, signaturePadding: RSASignaturePadding): X509SignatureGenerator;
    static CreateForSlhDsa(key: SlhDsa): X509SignatureGenerator;
}


export type X509SignatureGenerator = X509SignatureGenerator$instance;

export class X509Store$instance {
    constructor();
    constructor(storeName: string);
    constructor(storeName: StoreName);
    constructor(storeLocation: StoreLocation);
    constructor(storeName: StoreName, storeLocation: StoreLocation);
    constructor(storeName: StoreName, storeLocation: StoreLocation, flags: OpenFlags);
    constructor(storeName: string, storeLocation: StoreLocation);
    constructor(storeName: string, storeLocation: StoreLocation, flags: OpenFlags);
    constructor(storeHandle: nint);
    readonly certificates: X509Certificate2Collection;
    readonly isOpen: boolean;
    readonly location: StoreLocation;
    readonly name: string;
    readonly storeHandle: nint;
    add(certificate: X509Certificate2): void;
    addRange(certificates: X509Certificate2Collection): void;
    close(): void;
    dispose(): void;
    open(flags: OpenFlags): void;
    remove(certificate: X509Certificate2): void;
    removeRange(certificates: X509Certificate2Collection): void;
}


export interface __X509Store$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type X509Store = X509Store$instance & __X509Store$views;


export class X509SubjectAlternativeNameExtension$instance extends X509Extension$instance {
    constructor();
    constructor(rawData: byte[], critical: boolean);
    constructor(rawData: ReadOnlySpan_1<CLROf<byte>>, critical: boolean);
    copyFrom(asnEncodedData: AsnEncodedData): void;
    enumerateDnsNames(): IEnumerable_1<CLROf<string>>;
    enumerateIPAddresses(): IEnumerable_1<IPAddress>;
}


export type X509SubjectAlternativeNameExtension = X509SubjectAlternativeNameExtension$instance;

export class X509SubjectKeyIdentifierExtension$instance extends X509Extension$instance {
    constructor();
    constructor(encodedSubjectKeyIdentifier: AsnEncodedData, critical: boolean);
    constructor(subjectKeyIdentifier: byte[], critical: boolean);
    constructor(subjectKeyIdentifier: ReadOnlySpan_1<CLROf<byte>>, critical: boolean);
    constructor(key: PublicKey, critical: boolean);
    constructor(key: PublicKey, algorithm: X509SubjectKeyIdentifierHashAlgorithm, critical: boolean);
    constructor(subjectKeyIdentifier: string, critical: boolean);
    readonly subjectKeyIdentifier: string;
    readonly subjectKeyIdentifierBytes: ReadOnlyMemory_1<CLROf<byte>>;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export type X509SubjectKeyIdentifierExtension = X509SubjectKeyIdentifierExtension$instance;

export abstract class DSACertificateExtensions$instance {
    static CopyWithPrivateKey(certificate: X509Certificate2, privateKey: DSA): X509Certificate2;
    static GetDSAPrivateKey(certificate: X509Certificate2): DSA;
    static GetDSAPublicKey(certificate: X509Certificate2): DSA;
}


export type DSACertificateExtensions = DSACertificateExtensions$instance;

export abstract class ECDsaCertificateExtensions$instance {
    static CopyWithPrivateKey(certificate: X509Certificate2, privateKey: ECDsa): X509Certificate2;
    static GetECDsaPrivateKey(certificate: X509Certificate2): ECDsa;
    static GetECDsaPublicKey(certificate: X509Certificate2): ECDsa;
}


export type ECDsaCertificateExtensions = ECDsaCertificateExtensions$instance;

export abstract class RSACertificateExtensions$instance {
    static CopyWithPrivateKey(certificate: X509Certificate2, privateKey: RSA): X509Certificate2;
    static GetRSAPrivateKey(certificate: X509Certificate2): RSA;
    static GetRSAPublicKey(certificate: X509Certificate2): RSA;
}


export type RSACertificateExtensions = RSACertificateExtensions$instance;

export abstract class X509CertificateLoader$instance {
    static LoadCertificate(data: byte[]): X509Certificate2;
    static LoadCertificate(data: ReadOnlySpan_1<CLROf<byte>>): X509Certificate2;
    static LoadCertificateFromFile(path: string): X509Certificate2;
    static LoadPkcs12(data: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static LoadPkcs12(data: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static LoadPkcs12Collection(data: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12Collection(data: ReadOnlySpan_1<CLROf<byte>>, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12CollectionFromFile(path: string, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12CollectionFromFile(path: string, password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12FromFile(path: string, password: ReadOnlySpan_1<CLROf<string>>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static LoadPkcs12FromFile(path: string, password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
}


export type X509CertificateLoader = X509CertificateLoader$instance;

