// Generated by tsbindgen - Architecture
// Namespace: System.Reflection.Metadata.Ecma335
// Assembly: System.Reflection.Metadata

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1 } from "../../System.Collections.Immutable/internal/index.js";
import type { AssemblyDefinitionHandle, AssemblyFileHandle, AssemblyReferenceHandle, Blob, BlobBuilder, BlobContentId, BlobHandle, BlobReader, ConstantHandle, CustomAttributeHandle, CustomDebugInformationHandle, DeclarativeSecurityAttributeHandle, DocumentHandle, DocumentNameBlobHandle, EntityHandle, EventDefinitionHandle, ExceptionRegionKind, ExportedType, ExportedTypeHandle, FieldDefinitionHandle, GenericParameterConstraintHandle, GenericParameterHandle, GuidHandle, Handle, HandleKind, ILOpCode, ImportScopeHandle, InterfaceImplementationHandle, ISignatureTypeProvider_2, LocalConstantHandle, LocalScopeHandle, LocalVariableAttributes, LocalVariableHandle, ManifestResourceHandle, MemberReferenceHandle, MetadataReader, MethodDebugInformationHandle, MethodDefinitionHandle, MethodImplementationHandle, MethodSignature_1, MethodSpecificationHandle, ModuleDefinitionHandle, ModuleReferenceHandle, ParameterHandle, PrimitiveSerializationTypeCode, PrimitiveTypeCode, PropertyDefinitionHandle, ReservedBlob_1, SignatureCallingConvention, SignatureTypeKind, StandaloneSignatureHandle, StringHandle, TypeDefinitionHandle, TypeReferenceHandle, TypeSpecificationHandle, UserStringHandle } from "../../System.Reflection.Metadata/internal/index.js";
import type { AssemblyFlags, AssemblyHashAlgorithm, DeclarativeSecurityAction, EventAttributes, FieldAttributes, GenericParameterAttributes, ManifestResourceAttributes, MethodAttributes, MethodImplAttributes, MethodImportAttributes, MethodSemanticsAttributes, ParameterAttributes, PropertyAttributes, TypeAttributes } from "../../System.Reflection/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Boolean as ClrBoolean, Byte, Double, Enum, Func_2, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, UInt16, UInt32, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum EditAndContinueOperation {
    default_ = 0,
    addMethod = 1,
    addField = 2,
    addParameter = 3,
    addProperty = 4,
    addEvent = 5
}


export enum FunctionPointerAttributes {
    none = 0,
    hasThis = 32,
    hasExplicitThis = 96
}


export enum HeapIndex {
    userString = 0,
    string_ = 1,
    blob = 2,
    guid = 3
}


export enum MethodBodyAttributes {
    none = 0,
    initLocals = 1
}


export enum TableIndex {
    module_ = 0,
    typeRef = 1,
    typeDef = 2,
    fieldPtr = 3,
    field = 4,
    methodPtr = 5,
    methodDef = 6,
    paramPtr = 7,
    param = 8,
    interfaceImpl = 9,
    memberRef = 10,
    constant = 11,
    customAttribute = 12,
    fieldMarshal = 13,
    declSecurity = 14,
    classLayout = 15,
    fieldLayout = 16,
    standAloneSig = 17,
    eventMap = 18,
    eventPtr = 19,
    event = 20,
    propertyMap = 21,
    propertyPtr = 22,
    property = 23,
    methodSemantics = 24,
    methodImpl = 25,
    moduleRef = 26,
    typeSpec = 27,
    implMap = 28,
    fieldRva = 29,
    encLog = 30,
    encMap = 31,
    assembly = 32,
    assemblyProcessor = 33,
    assemblyOS = 34,
    assemblyRef = 35,
    assemblyRefProcessor = 36,
    assemblyRefOS = 37,
    file = 38,
    exportedType = 39,
    manifestResource = 40,
    nestedClass = 41,
    genericParam = 42,
    methodSpec = 43,
    genericParamConstraint = 44,
    document = 48,
    methodDebugInformation = 49,
    localScope = 50,
    localVariable = 51,
    localConstant = 52,
    importScope = 53,
    stateMachineMethod = 54,
    customDebugInformation = 55
}


export class ArrayShapeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    shape(rank: int, sizes: ImmutableArray_1<CLROf<int>>, lowerBounds: ImmutableArray_1<CLROf<int>>): void;
}


export type ArrayShapeEncoder = ArrayShapeEncoder$instance;

export class BlobEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    customAttributeSignature(fixedArguments: { value: TSByRef<FixedArgumentsEncoder> }, namedArguments: { value: TSByRef<CustomAttributeNamedArgumentsEncoder> }): void;
    customAttributeSignature(fixedArguments: Action_1<FixedArgumentsEncoder>, namedArguments: Action_1<CustomAttributeNamedArgumentsEncoder>): void;
    field(): FieldTypeEncoder;
    fieldSignature(): SignatureTypeEncoder;
    localVariableSignature(variableCount: int): LocalVariablesEncoder;
    methodSignature(convention?: SignatureCallingConvention, genericParameterCount?: int, isInstanceMethod?: boolean): MethodSignatureEncoder;
    methodSpecificationSignature(genericArgumentCount: int): GenericTypeArgumentsEncoder;
    permissionSetArguments(argumentCount: int): NamedArgumentsEncoder;
    permissionSetBlob(attributeCount: int): PermissionSetEncoder;
    propertySignature(isInstanceProperty?: boolean): MethodSignatureEncoder;
    typeSpecificationSignature(): SignatureTypeEncoder;
}


export type BlobEncoder = BlobEncoder$instance;

export class CustomAttributeArrayTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    elementType(): CustomAttributeElementTypeEncoder;
    objectArray(): void;
}


export type CustomAttributeArrayTypeEncoder = CustomAttributeArrayTypeEncoder$instance;

export class CustomAttributeElementTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    boolean_(): void;
    byte(): void;
    char(): void;
    double(): void;
    enum_(enumTypeName: string): void;
    int16(): void;
    int32(): void;
    int64(): void;
    primitiveType(type_: PrimitiveSerializationTypeCode): void;
    sByte(): void;
    single(): void;
    string_(): void;
    systemType(): void;
    uInt16(): void;
    uInt32(): void;
    uInt64(): void;
}


export type CustomAttributeElementTypeEncoder = CustomAttributeElementTypeEncoder$instance;

export class CustomAttributeNamedArgumentsEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    count(count: int): NamedArgumentsEncoder;
}


export type CustomAttributeNamedArgumentsEncoder = CustomAttributeNamedArgumentsEncoder$instance;

export class CustomModifiersEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addModifier(type_: EntityHandle, isOptional: boolean): CustomModifiersEncoder;
}


export type CustomModifiersEncoder = CustomModifiersEncoder$instance;

export class EditAndContinueLogEntry$instance {
    constructor(handle: EntityHandle, operation: EditAndContinueOperation);
    readonly handle: EntityHandle;
    readonly operation: EditAndContinueOperation;
    equals(obj: any): boolean;
    equals(other: EditAndContinueLogEntry): boolean;
    getHashCode(): int;
}


export interface __EditAndContinueLogEntry$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<EditAndContinueLogEntry>;

    // Structural method bridges for numeric interface constraints
    Equals(other: EditAndContinueLogEntry): boolean;
}

export type EditAndContinueLogEntry = EditAndContinueLogEntry$instance & __EditAndContinueLogEntry$views;


export class ExceptionRegionEncoder$instance {
    readonly builder: BlobBuilder;
    readonly hasSmallFormat: boolean;
    add(kind: ExceptionRegionKind, tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, catchType?: EntityHandle, filterOffset?: int): ExceptionRegionEncoder;
    addCatch(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, catchType: EntityHandle): ExceptionRegionEncoder;
    addFault(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int): ExceptionRegionEncoder;
    addFilter(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, filterOffset: int): ExceptionRegionEncoder;
    addFinally(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int): ExceptionRegionEncoder;
    static IsSmallExceptionRegion(startOffset: int, length: int): boolean;
    static IsSmallRegionCount(exceptionRegionCount: int): boolean;
}


export type ExceptionRegionEncoder = ExceptionRegionEncoder$instance;

export class FieldTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean): SignatureTypeEncoder;
    typedReference(): void;
}


export type FieldTypeEncoder = FieldTypeEncoder$instance;

export class FixedArgumentsEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addArgument(): LiteralEncoder;
}


export type FixedArgumentsEncoder = FixedArgumentsEncoder$instance;

export class GenericTypeArgumentsEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addArgument(): SignatureTypeEncoder;
}


export type GenericTypeArgumentsEncoder = GenericTypeArgumentsEncoder$instance;

export class InstructionEncoder$instance {
    constructor(codeBuilder: BlobBuilder, controlFlowBuilder: ControlFlowBuilder);
    readonly codeBuilder: BlobBuilder;
    readonly controlFlowBuilder: ControlFlowBuilder;
    readonly offset: int;
    branch(code: ILOpCode, label: LabelHandle): void;
    call(methodHandle: EntityHandle): void;
    call(methodHandle: MethodDefinitionHandle): void;
    call(methodHandle: MethodSpecificationHandle): void;
    call(methodHandle: MemberReferenceHandle): void;
    callIndirect(signature: StandaloneSignatureHandle): void;
    defineLabel(): LabelHandle;
    loadArgument(argumentIndex: int): void;
    loadArgumentAddress(argumentIndex: int): void;
    loadConstantI4(value: int): void;
    loadConstantI8(value: long): void;
    loadConstantR4(value: float): void;
    loadConstantR8(value: double): void;
    loadLocal(slotIndex: int): void;
    loadLocalAddress(slotIndex: int): void;
    loadString(handle: UserStringHandle): void;
    markLabel(label: LabelHandle): void;
    opCode(code: ILOpCode): void;
    storeArgument(argumentIndex: int): void;
    storeLocal(slotIndex: int): void;
    switch_(branchCount: int): SwitchInstructionEncoder;
    token(handle: EntityHandle): void;
    token(token: int): void;
}


export type InstructionEncoder = InstructionEncoder$instance;

export class LabelHandle$instance {
    readonly id: int;
    readonly isNil: boolean;
    equals(other: LabelHandle): boolean;
    equals(obj: any): boolean;
    getHashCode(): int;
}


export interface __LabelHandle$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<LabelHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LabelHandle): boolean;
}

export type LabelHandle = LabelHandle$instance & __LabelHandle$views;


export class LiteralEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    scalar(): ScalarEncoder;
    taggedScalar(type_: { value: TSByRef<CustomAttributeElementTypeEncoder> }, scalar: { value: TSByRef<ScalarEncoder> }): void;
    taggedScalar(type_: Action_1<CustomAttributeElementTypeEncoder>, scalar: Action_1<ScalarEncoder>): void;
    taggedVector(arrayType: { value: TSByRef<CustomAttributeArrayTypeEncoder> }, vector: { value: TSByRef<VectorEncoder> }): void;
    taggedVector(arrayType: Action_1<CustomAttributeArrayTypeEncoder>, vector: Action_1<VectorEncoder>): void;
    vector(): VectorEncoder;
}


export type LiteralEncoder = LiteralEncoder$instance;

export class LiteralsEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addLiteral(): LiteralEncoder;
}


export type LiteralsEncoder = LiteralsEncoder$instance;

export class LocalVariablesEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addVariable(): LocalVariableTypeEncoder;
}


export type LocalVariablesEncoder = LocalVariablesEncoder$instance;

export class LocalVariableTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean, isPinned?: boolean): SignatureTypeEncoder;
    typedReference(): void;
}


export type LocalVariableTypeEncoder = LocalVariableTypeEncoder$instance;

export class MethodBodyStreamEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addMethodBody(codeSize: int, maxStack: int, exceptionRegionCount: int, hasSmallExceptionRegions: boolean, localVariablesSignature: StandaloneSignatureHandle, attributes: MethodBodyAttributes): MethodBodyStreamEncoder_MethodBody;
    addMethodBody(codeSize: int, maxStack?: int, exceptionRegionCount?: int, hasSmallExceptionRegions?: boolean, localVariablesSignature?: StandaloneSignatureHandle, attributes?: MethodBodyAttributes, hasDynamicStackAllocation?: boolean): MethodBodyStreamEncoder_MethodBody;
    addMethodBody(instructionEncoder: InstructionEncoder, maxStack: int, localVariablesSignature: StandaloneSignatureHandle, attributes: MethodBodyAttributes): int;
    addMethodBody(instructionEncoder: InstructionEncoder, maxStack?: int, localVariablesSignature?: StandaloneSignatureHandle, attributes?: MethodBodyAttributes, hasDynamicStackAllocation?: boolean): int;
}


export type MethodBodyStreamEncoder = MethodBodyStreamEncoder$instance;

export class MethodBodyStreamEncoder_MethodBody$instance {
    readonly exceptionRegions: ExceptionRegionEncoder;
    readonly instructions: Blob;
    readonly offset: int;
}


export type MethodBodyStreamEncoder_MethodBody = MethodBodyStreamEncoder_MethodBody$instance;

export class MethodSignatureEncoder$instance {
    constructor(builder: BlobBuilder, hasVarArgs: boolean);
    readonly builder: BlobBuilder;
    readonly hasVarArgs: boolean;
    parameters(parameterCount: int, returnType: { value: TSByRef<ReturnTypeEncoder> }, parameters: { value: TSByRef<ParametersEncoder> }): void;
    parameters(parameterCount: int, returnType: Action_1<ReturnTypeEncoder>, parameters: Action_1<ParametersEncoder>): void;
}


export type MethodSignatureEncoder = MethodSignatureEncoder$instance;

export class NamedArgumentsEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addArgument(isField: boolean, type_: { value: TSByRef<NamedArgumentTypeEncoder> }, name: { value: TSByRef<NameEncoder> }, literal: { value: TSByRef<LiteralEncoder> }): void;
    addArgument(isField: boolean, type_: Action_1<NamedArgumentTypeEncoder>, name: Action_1<NameEncoder>, literal: Action_1<LiteralEncoder>): void;
}


export type NamedArgumentsEncoder = NamedArgumentsEncoder$instance;

export class NamedArgumentTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    object_(): void;
    scalarType(): CustomAttributeElementTypeEncoder;
    szArray(): CustomAttributeArrayTypeEncoder;
}


export type NamedArgumentTypeEncoder = NamedArgumentTypeEncoder$instance;

export class NameEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    name(name: string): void;
}


export type NameEncoder = NameEncoder$instance;

export class ParametersEncoder$instance {
    constructor(builder: BlobBuilder, hasVarArgs: boolean);
    readonly builder: BlobBuilder;
    readonly hasVarArgs: boolean;
    addParameter(): ParameterTypeEncoder;
    startVarArgs(): ParametersEncoder;
}


export type ParametersEncoder = ParametersEncoder$instance;

export class ParameterTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean): SignatureTypeEncoder;
    typedReference(): void;
}


export type ParameterTypeEncoder = ParameterTypeEncoder$instance;

export class PermissionSetEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    addPermission(typeName: string, encodedArguments: ImmutableArray_1<CLROf<byte>>): PermissionSetEncoder;
    addPermission(typeName: string, encodedArguments: BlobBuilder): PermissionSetEncoder;
}


export type PermissionSetEncoder = PermissionSetEncoder$instance;

export class ReturnTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    customModifiers(): CustomModifiersEncoder;
    type_(isByRef?: boolean): SignatureTypeEncoder;
    typedReference(): void;
    void_(): void;
}


export type ReturnTypeEncoder = ReturnTypeEncoder$instance;

export class ScalarEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    constant(value: any): void;
    nullArray(): void;
    systemType(serializedTypeName: string): void;
}


export type ScalarEncoder = ScalarEncoder$instance;

export class SignatureDecoder_2$instance<TType, TGenericContext> {
    constructor(provider: ISignatureTypeProvider_2<TType, TGenericContext>, metadataReader: MetadataReader, genericContext: TGenericContext);
    decodeFieldSignature(blobReader: { value: TSByRef<BlobReader> }): TType;
    decodeLocalSignature(blobReader: { value: TSByRef<BlobReader> }): ImmutableArray_1<TType>;
    decodeMethodSignature(blobReader: { value: TSByRef<BlobReader> }): MethodSignature_1<TType>;
    decodeMethodSpecificationSignature(blobReader: { value: TSByRef<BlobReader> }): ImmutableArray_1<TType>;
    decodeType(blobReader: { value: TSByRef<BlobReader> }, allowTypeSpecifications?: boolean): TType;
}


export type SignatureDecoder_2<TType, TGenericContext> = SignatureDecoder_2$instance<TType, TGenericContext>;

export class SignatureTypeEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    array(elementType: { value: TSByRef<SignatureTypeEncoder> }, arrayShape: { value: TSByRef<ArrayShapeEncoder> }): void;
    array(elementType: Action_1<SignatureTypeEncoder>, arrayShape: Action_1<ArrayShapeEncoder>): void;
    boolean_(): void;
    byte(): void;
    char(): void;
    customModifiers(): CustomModifiersEncoder;
    double(): void;
    functionPointer(convention?: SignatureCallingConvention, attributes?: FunctionPointerAttributes, genericParameterCount?: int): MethodSignatureEncoder;
    genericInstantiation(genericType: EntityHandle, genericArgumentCount: int, isValueType: boolean): GenericTypeArgumentsEncoder;
    genericMethodTypeParameter(parameterIndex: int): void;
    genericTypeParameter(parameterIndex: int): void;
    int16(): void;
    int32(): void;
    int64(): void;
    intPtr(): void;
    object_(): void;
    pointer(): SignatureTypeEncoder;
    primitiveType(type_: PrimitiveTypeCode): void;
    sByte(): void;
    single(): void;
    string_(): void;
    szArray(): SignatureTypeEncoder;
    type_(type_: EntityHandle, isValueType: boolean): void;
    typedReference(): void;
    uInt16(): void;
    uInt32(): void;
    uInt64(): void;
    uIntPtr(): void;
    voidPointer(): void;
}


export type SignatureTypeEncoder = SignatureTypeEncoder$instance;

export class SwitchInstructionEncoder$instance {
    branch(label: LabelHandle): void;
}


export type SwitchInstructionEncoder = SwitchInstructionEncoder$instance;

export class VectorEncoder$instance {
    constructor(builder: BlobBuilder);
    readonly builder: BlobBuilder;
    count(count: int): LiteralsEncoder;
}


export type VectorEncoder = VectorEncoder$instance;

export class ControlFlowBuilder$instance {
    constructor();
    addCatchRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle, catchType: EntityHandle): void;
    addFaultRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle): void;
    addFilterRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle, filterStart: LabelHandle): void;
    addFinallyRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle): void;
    clear(): void;
}


export type ControlFlowBuilder = ControlFlowBuilder$instance;

export class MetadataAggregator$instance {
    constructor(baseReader: MetadataReader, deltaReaders: IReadOnlyList_1<MetadataReader>);
    constructor(baseTableRowCounts: IReadOnlyList_1<CLROf<int>>, baseHeapSizes: IReadOnlyList_1<CLROf<int>>, deltaReaders: IReadOnlyList_1<MetadataReader>);
    getGenerationHandle(handle: Handle, generation: { value: TSByRef<int> }): Handle;
}


export type MetadataAggregator = MetadataAggregator$instance;

export class MetadataBuilder$instance {
    constructor(userStringHeapStartOffset: int, stringHeapStartOffset: int, blobHeapStartOffset: int, guidHeapStartOffset: int);
    addAssembly(name: StringHandle, version: Version, culture: StringHandle, publicKey: BlobHandle, flags: AssemblyFlags, hashAlgorithm: AssemblyHashAlgorithm): AssemblyDefinitionHandle;
    addAssemblyFile(name: StringHandle, hashValue: BlobHandle, containsMetadata: boolean): AssemblyFileHandle;
    addAssemblyReference(name: StringHandle, version: Version, culture: StringHandle, publicKeyOrToken: BlobHandle, flags: AssemblyFlags, hashValue: BlobHandle): AssemblyReferenceHandle;
    addConstant(parent: EntityHandle, value: any): ConstantHandle;
    addCustomAttribute(parent: EntityHandle, constructor_: EntityHandle, value: BlobHandle): CustomAttributeHandle;
    addCustomDebugInformation(parent: EntityHandle, kind: GuidHandle, value: BlobHandle): CustomDebugInformationHandle;
    addDeclarativeSecurityAttribute(parent: EntityHandle, action: DeclarativeSecurityAction, permissionSet: BlobHandle): DeclarativeSecurityAttributeHandle;
    addDocument(name: BlobHandle, hashAlgorithm: GuidHandle, hash: BlobHandle, language: GuidHandle): DocumentHandle;
    addEncLogEntry(entity: EntityHandle, code: EditAndContinueOperation): void;
    addEncMapEntry(entity: EntityHandle): void;
    addEvent(attributes: EventAttributes, name: StringHandle, type_: EntityHandle): EventDefinitionHandle;
    addEventMap(declaringType: TypeDefinitionHandle, eventList: EventDefinitionHandle): void;
    addExportedType(attributes: TypeAttributes, namespace_: StringHandle, name: StringHandle, implementation: EntityHandle, typeDefinitionId: int): ExportedTypeHandle;
    addFieldDefinition(attributes: FieldAttributes, name: StringHandle, signature: BlobHandle): FieldDefinitionHandle;
    addFieldLayout(field: FieldDefinitionHandle, offset: int): void;
    addFieldRelativeVirtualAddress(field: FieldDefinitionHandle, offset: int): void;
    addGenericParameter(parent: EntityHandle, attributes: GenericParameterAttributes, name: StringHandle, index: int): GenericParameterHandle;
    addGenericParameterConstraint(genericParameter: GenericParameterHandle, constraint: EntityHandle): GenericParameterConstraintHandle;
    addImportScope(parentScope: ImportScopeHandle, imports: BlobHandle): ImportScopeHandle;
    addInterfaceImplementation(type_: TypeDefinitionHandle, implementedInterface: EntityHandle): InterfaceImplementationHandle;
    addLocalConstant(name: StringHandle, signature: BlobHandle): LocalConstantHandle;
    addLocalScope(method: MethodDefinitionHandle, importScope: ImportScopeHandle, variableList: LocalVariableHandle, constantList: LocalConstantHandle, startOffset: int, length: int): LocalScopeHandle;
    addLocalVariable(attributes: LocalVariableAttributes, index: int, name: StringHandle): LocalVariableHandle;
    addManifestResource(attributes: ManifestResourceAttributes, name: StringHandle, implementation: EntityHandle, offset: uint): ManifestResourceHandle;
    addMarshallingDescriptor(parent: EntityHandle, descriptor: BlobHandle): void;
    addMemberReference(parent: EntityHandle, name: StringHandle, signature: BlobHandle): MemberReferenceHandle;
    addMethodDebugInformation(document: DocumentHandle, sequencePoints: BlobHandle): MethodDebugInformationHandle;
    addMethodDefinition(attributes: MethodAttributes, implAttributes: MethodImplAttributes, name: StringHandle, signature: BlobHandle, bodyOffset: int, parameterList: ParameterHandle): MethodDefinitionHandle;
    addMethodImplementation(type_: TypeDefinitionHandle, methodBody: EntityHandle, methodDeclaration: EntityHandle): MethodImplementationHandle;
    addMethodImport(method: MethodDefinitionHandle, attributes: MethodImportAttributes, name: StringHandle, module_: ModuleReferenceHandle): void;
    addMethodSemantics(association: EntityHandle, semantics: MethodSemanticsAttributes, methodDefinition: MethodDefinitionHandle): void;
    addMethodSpecification(method: EntityHandle, instantiation: BlobHandle): MethodSpecificationHandle;
    addModule(generation: int, moduleName: StringHandle, mvid: GuidHandle, encId: GuidHandle, encBaseId: GuidHandle): ModuleDefinitionHandle;
    addModuleReference(moduleName: StringHandle): ModuleReferenceHandle;
    addNestedType(type_: TypeDefinitionHandle, enclosingType: TypeDefinitionHandle): void;
    addParameter(attributes: ParameterAttributes, name: StringHandle, sequenceNumber: int): ParameterHandle;
    addProperty(attributes: PropertyAttributes, name: StringHandle, signature: BlobHandle): PropertyDefinitionHandle;
    addPropertyMap(declaringType: TypeDefinitionHandle, propertyList: PropertyDefinitionHandle): void;
    addStandaloneSignature(signature: BlobHandle): StandaloneSignatureHandle;
    addStateMachineMethod(moveNextMethod: MethodDefinitionHandle, kickoffMethod: MethodDefinitionHandle): void;
    addTypeDefinition(attributes: TypeAttributes, namespace_: StringHandle, name: StringHandle, baseType: EntityHandle, fieldList: FieldDefinitionHandle, methodList: MethodDefinitionHandle): TypeDefinitionHandle;
    addTypeLayout(type_: TypeDefinitionHandle, packingSize: ushort, size: uint): void;
    addTypeReference(resolutionScope: EntityHandle, namespace_: StringHandle, name: StringHandle): TypeReferenceHandle;
    addTypeSpecification(signature: BlobHandle): TypeSpecificationHandle;
    getOrAddBlob(value: BlobBuilder): BlobHandle;
    getOrAddBlob(value: byte[]): BlobHandle;
    getOrAddBlob(value: ImmutableArray_1<CLROf<byte>>): BlobHandle;
    getOrAddBlobUTF16(value: string): BlobHandle;
    getOrAddBlobUTF8(value: string, allowUnpairedSurrogates?: boolean): BlobHandle;
    getOrAddConstantBlob(value: any): BlobHandle;
    getOrAddDocumentName(value: string): BlobHandle;
    getOrAddGuid(guid: Guid): GuidHandle;
    getOrAddString(value: string): StringHandle;
    getOrAddUserString(value: string): UserStringHandle;
    getRowCount(table: TableIndex): int;
    getRowCounts(): ImmutableArray_1<CLROf<int>>;
    reserveGuid(): ReservedBlob_1<GuidHandle>;
    reserveUserString(length: int): ReservedBlob_1<UserStringHandle>;
    setCapacity(table: TableIndex, rowCount: int): void;
    setCapacity(heap: HeapIndex, byteCount: int): void;
}


export type MetadataBuilder = MetadataBuilder$instance;

export class MetadataRootBuilder$instance {
    constructor(tablesAndHeaps: MetadataBuilder, metadataVersion: string, suppressValidation: boolean);
    readonly metadataVersion: string;
    readonly sizes: MetadataSizes;
    readonly suppressValidation: boolean;
    serialize(builder: BlobBuilder, methodBodyStreamRva: int, mappedFieldDataStreamRva: int): void;
}


export type MetadataRootBuilder = MetadataRootBuilder$instance;

export class MetadataSizes$instance {
    readonly externalRowCounts: ImmutableArray_1<CLROf<int>>;
    readonly heapSizes: ImmutableArray_1<CLROf<int>>;
    readonly rowCounts: ImmutableArray_1<CLROf<int>>;
    getAlignedHeapSize(index: HeapIndex): int;
}


export type MetadataSizes = MetadataSizes$instance;

export class PortablePdbBuilder$instance {
    constructor(tablesAndHeaps: MetadataBuilder, typeSystemRowCounts: ImmutableArray_1<CLROf<int>>, entryPoint: MethodDefinitionHandle, idProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>);
    readonly formatVersion: ushort;
    readonly idProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>;
    readonly metadataVersion: string;
    serialize(builder: BlobBuilder): BlobContentId;
}


export type PortablePdbBuilder = PortablePdbBuilder$instance;

export abstract class CodedIndex$instance {
    static CustomAttributeType(handle: EntityHandle): int;
    static HasConstant(handle: EntityHandle): int;
    static HasCustomAttribute(handle: EntityHandle): int;
    static HasCustomDebugInformation(handle: EntityHandle): int;
    static HasDeclSecurity(handle: EntityHandle): int;
    static HasFieldMarshal(handle: EntityHandle): int;
    static HasSemantics(handle: EntityHandle): int;
    static Implementation(handle: EntityHandle): int;
    static MemberForwarded(handle: EntityHandle): int;
    static MemberRefParent(handle: EntityHandle): int;
    static MethodDefOrRef(handle: EntityHandle): int;
    static ResolutionScope(handle: EntityHandle): int;
    static TypeDefOrRef(handle: EntityHandle): int;
    static TypeDefOrRefOrSpec(handle: EntityHandle): int;
    static TypeOrMethodDef(handle: EntityHandle): int;
}


export type CodedIndex = CodedIndex$instance;

export abstract class ExportedTypeExtensions$instance {
    static GetTypeDefinitionId(exportedType: ExportedType): int;
}


export type ExportedTypeExtensions = ExportedTypeExtensions$instance;

export abstract class MetadataReaderExtensions$instance {
    static GetEditAndContinueLogEntries(reader: MetadataReader): IEnumerable_1<EditAndContinueLogEntry>;
    static GetEditAndContinueMapEntries(reader: MetadataReader): IEnumerable_1<EntityHandle>;
    static GetHeapMetadataOffset(reader: MetadataReader, heapIndex: HeapIndex): int;
    static GetHeapSize(reader: MetadataReader, heapIndex: HeapIndex): int;
    static GetNextHandle(reader: MetadataReader, handle: BlobHandle): BlobHandle;
    static GetNextHandle(reader: MetadataReader, handle: StringHandle): StringHandle;
    static GetNextHandle(reader: MetadataReader, handle: UserStringHandle): UserStringHandle;
    static GetTableMetadataOffset(reader: MetadataReader, tableIndex: TableIndex): int;
    static GetTableRowCount(reader: MetadataReader, tableIndex: TableIndex): int;
    static GetTableRowSize(reader: MetadataReader, tableIndex: TableIndex): int;
    static GetTypesWithEvents(reader: MetadataReader): IEnumerable_1<TypeDefinitionHandle>;
    static GetTypesWithProperties(reader: MetadataReader): IEnumerable_1<TypeDefinitionHandle>;
    static ResolveSignatureTypeKind(reader: MetadataReader, typeHandle: EntityHandle, rawTypeKind: byte): SignatureTypeKind;
}


export type MetadataReaderExtensions = MetadataReaderExtensions$instance;

export abstract class MetadataTokens$instance {
    static readonly tableCount: int;
    static readonly heapCount: int;
    static AssemblyFileHandle(rowNumber: int): AssemblyFileHandle;
    static AssemblyReferenceHandle(rowNumber: int): AssemblyReferenceHandle;
    static BlobHandle(offset: int): BlobHandle;
    static ConstantHandle(rowNumber: int): ConstantHandle;
    static CustomAttributeHandle(rowNumber: int): CustomAttributeHandle;
    static CustomDebugInformationHandle(rowNumber: int): CustomDebugInformationHandle;
    static DeclarativeSecurityAttributeHandle(rowNumber: int): DeclarativeSecurityAttributeHandle;
    static DocumentHandle(rowNumber: int): DocumentHandle;
    static DocumentNameBlobHandle(offset: int): DocumentNameBlobHandle;
    static EntityHandle(token: int): EntityHandle;
    static EntityHandle(tableIndex: TableIndex, rowNumber: int): EntityHandle;
    static EventDefinitionHandle(rowNumber: int): EventDefinitionHandle;
    static ExportedTypeHandle(rowNumber: int): ExportedTypeHandle;
    static FieldDefinitionHandle(rowNumber: int): FieldDefinitionHandle;
    static GenericParameterConstraintHandle(rowNumber: int): GenericParameterConstraintHandle;
    static GenericParameterHandle(rowNumber: int): GenericParameterHandle;
    static GetHeapOffset(handle: BlobHandle): int;
    static GetHeapOffset(handle: GuidHandle): int;
    static GetHeapOffset(handle: Handle): int;
    static GetHeapOffset(reader: MetadataReader, handle: Handle): int;
    static GetHeapOffset(handle: StringHandle): int;
    static GetHeapOffset(handle: UserStringHandle): int;
    static GetRowNumber(handle: EntityHandle): int;
    static GetRowNumber(reader: MetadataReader, handle: EntityHandle): int;
    static GetToken(handle: EntityHandle): int;
    static GetToken(handle: Handle): int;
    static GetToken(reader: MetadataReader, handle: EntityHandle): int;
    static GetToken(reader: MetadataReader, handle: Handle): int;
    static GuidHandle(offset: int): GuidHandle;
    static Handle(token: int): Handle;
    static Handle(tableIndex: TableIndex, rowNumber: int): EntityHandle;
    static ImportScopeHandle(rowNumber: int): ImportScopeHandle;
    static InterfaceImplementationHandle(rowNumber: int): InterfaceImplementationHandle;
    static LocalConstantHandle(rowNumber: int): LocalConstantHandle;
    static LocalScopeHandle(rowNumber: int): LocalScopeHandle;
    static LocalVariableHandle(rowNumber: int): LocalVariableHandle;
    static ManifestResourceHandle(rowNumber: int): ManifestResourceHandle;
    static MemberReferenceHandle(rowNumber: int): MemberReferenceHandle;
    static MethodDebugInformationHandle(rowNumber: int): MethodDebugInformationHandle;
    static MethodDefinitionHandle(rowNumber: int): MethodDefinitionHandle;
    static MethodImplementationHandle(rowNumber: int): MethodImplementationHandle;
    static MethodSpecificationHandle(rowNumber: int): MethodSpecificationHandle;
    static ModuleReferenceHandle(rowNumber: int): ModuleReferenceHandle;
    static ParameterHandle(rowNumber: int): ParameterHandle;
    static PropertyDefinitionHandle(rowNumber: int): PropertyDefinitionHandle;
    static StandaloneSignatureHandle(rowNumber: int): StandaloneSignatureHandle;
    static StringHandle(offset: int): StringHandle;
    static TryGetHeapIndex(type_: HandleKind, index: { value: TSByRef<HeapIndex> }): boolean;
    static TryGetTableIndex(type_: HandleKind, index: { value: TSByRef<TableIndex> }): boolean;
    static TypeDefinitionHandle(rowNumber: int): TypeDefinitionHandle;
    static TypeReferenceHandle(rowNumber: int): TypeReferenceHandle;
    static TypeSpecificationHandle(rowNumber: int): TypeSpecificationHandle;
    static UserStringHandle(offset: int): UserStringHandle;
}


export type MetadataTokens = MetadataTokens$instance;

