// Generated by tsbindgen - Architecture
// Namespace: System.Transactions
// Assembly: System.Transactions.Local

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Delegate, Enum, EventArgs, Exception, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DependentCloneOption {
    BlockCommitUntilComplete = 0,
    RollbackIfNotComplete = 1
}


export enum EnlistmentOptions {
    None = 0,
    EnlistDuringPrepareRequired = 1
}


export enum EnterpriseServicesInteropOption {
    None = 0,
    Automatic = 1,
    Full = 2
}


export enum IsolationLevel {
    Serializable = 0,
    RepeatableRead = 1,
    ReadCommitted = 2,
    ReadUncommitted = 3,
    Snapshot = 4,
    Chaos = 5,
    Unspecified = 6
}


export enum TransactionScopeAsyncFlowOption {
    Suppress = 0,
    Enabled = 1
}


export enum TransactionScopeOption {
    Required = 0,
    RequiresNew = 1,
    Suppress = 2
}


export enum TransactionStatus {
    Active = 0,
    Committed = 1,
    Aborted = 2,
    InDoubt = 3
}


export interface IDtcTransaction$instance {
    Abort(reason: nint, retaining: int, async_: int): void;
    Commit(retaining: int, commitType: int, reserved: int): void;
    GetTransactionInfo(transactionInformation: nint): void;
}


export type IDtcTransaction = IDtcTransaction$instance;

export interface IEnlistmentNotification$instance {
    Commit(enlistment: Enlistment): void;
    Prepare(preparingEnlistment: PreparingEnlistment): void;
}


export type IEnlistmentNotification = IEnlistmentNotification$instance;

export interface IPromotableSinglePhaseNotification$instance {
    Initialize(): void;
    Promote(): byte[];
    SinglePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export type IPromotableSinglePhaseNotification = IPromotableSinglePhaseNotification$instance;

export interface ISimpleTransactionSuperior$instance {
    Promote(): byte[];
    Rollback(): void;
}


export type ISimpleTransactionSuperior = ISimpleTransactionSuperior$instance;

export interface ISinglePhaseNotification$instance {
    Commit(enlistment: Enlistment): void;
    Prepare(preparingEnlistment: PreparingEnlistment): void;
    SinglePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export type ISinglePhaseNotification = ISinglePhaseNotification$instance;

export interface ITransactionPromoter$instance {
    Promote(): byte[];
}


export type ITransactionPromoter = ITransactionPromoter$instance;

export class TransactionOptions$instance {
    IsolationLevel: IsolationLevel;
    Timeout: TimeSpan;
    Equals(obj: any): boolean;
    Equals(other: TransactionOptions): boolean;
    GetHashCode(): int;
}


export interface __TransactionOptions$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<TransactionOptions>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TransactionOptions): boolean;
}

export type TransactionOptions = TransactionOptions$instance & __TransactionOptions$views;


export class CommittableTransaction$instance extends Transaction$instance {
    constructor();
    constructor(timeout: TimeSpan);
    constructor(options: TransactionOptions);
    BeginCommit(asyncCallback: AsyncCallback, asyncState: any): IAsyncResult;
    Commit(): void;
    Dispose(): void;
    EndCommit(asyncResult: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CommittableTransaction$views {
    readonly As_IAsyncResult: System_Internal.IAsyncResult$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CommittableTransaction = CommittableTransaction$instance & __CommittableTransaction$views;


export class DependentTransaction$instance extends Transaction$instance {
    Complete(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DependentTransaction$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DependentTransaction = DependentTransaction$instance & __DependentTransaction$views;


export class Enlistment$instance {
    Done(): void;
}


export type Enlistment = Enlistment$instance;

export class HostCurrentTransactionCallback$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): Transaction;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(): Transaction;
}


export interface __HostCurrentTransactionCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HostCurrentTransactionCallback = HostCurrentTransactionCallback$instance & __HostCurrentTransactionCallback$views;


export class PreparingEnlistment$instance extends Enlistment$instance {
    ForceRollback(): void;
    ForceRollback(e: Exception): void;
    Prepared(): void;
    RecoveryInformation(): byte[];
}


export type PreparingEnlistment = PreparingEnlistment$instance;

export class SinglePhaseEnlistment$instance extends Enlistment$instance {
    Aborted(): void;
    Aborted(e: Exception): void;
    Committed(): void;
    InDoubt(): void;
    InDoubt(e: Exception): void;
}


export type SinglePhaseEnlistment = SinglePhaseEnlistment$instance;

export class SubordinateTransaction$instance extends Transaction$instance {
    constructor(isoLevel: IsolationLevel, superior: ISimpleTransactionSuperior);
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SubordinateTransaction$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SubordinateTransaction = SubordinateTransaction$instance & __SubordinateTransaction$views;


export class Transaction$instance {
    readonly IsolationLevel: IsolationLevel;
    readonly PromoterType: Guid;
    readonly TransactionInformation: TransactionInformation;
    Clone(): Transaction;
    DependentClone(cloneOption: DependentCloneOption): DependentTransaction;
    Dispose(): void;
    EnlistDurable(resourceManagerIdentifier: Guid, enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistDurable(resourceManagerIdentifier: Guid, singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification): boolean;
    EnlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification, promoterType: Guid): boolean;
    EnlistVolatile(enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistVolatile(singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    GetPromotedToken(): byte[];
    PromoteAndEnlistDurable(resourceManagerIdentifier: Guid, promotableNotification: IPromotableSinglePhaseNotification, enlistmentNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    Rollback(): void;
    Rollback(e: Exception): void;
    SetDistributedTransactionIdentifier(promotableNotification: IPromotableSinglePhaseNotification, distributedTransactionIdentifier: Guid): void;
    static Current: Transaction;
}


export interface __Transaction$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Transaction = Transaction$instance & __Transaction$views;


export class TransactionAbortedException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionAbortedException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionAbortedException = TransactionAbortedException$instance & __TransactionAbortedException$views;


export class TransactionCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: TransactionEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: TransactionEventArgs): void;
}


export interface __TransactionCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionCompletedEventHandler = TransactionCompletedEventHandler$instance & __TransactionCompletedEventHandler$views;


export class TransactionEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    readonly Transaction: Transaction;
}


export type TransactionEventArgs = TransactionEventArgs$instance;

export class TransactionException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionException = TransactionException$instance & __TransactionException$views;


export class TransactionInDoubtException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionInDoubtException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionInDoubtException = TransactionInDoubtException$instance & __TransactionInDoubtException$views;


export class TransactionInformation$instance {
    readonly CreationTime: DateTime;
    readonly DistributedIdentifier: Guid;
    readonly LocalIdentifier: string;
    readonly Status: TransactionStatus;
}


export type TransactionInformation = TransactionInformation$instance;

export class TransactionManagerCommunicationException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionManagerCommunicationException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionManagerCommunicationException = TransactionManagerCommunicationException$instance & __TransactionManagerCommunicationException$views;


export class TransactionPromotionException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionPromotionException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionPromotionException = TransactionPromotionException$instance & __TransactionPromotionException$views;


export class TransactionScope$instance {
    constructor();
    constructor(scopeOption: TransactionScopeOption);
    constructor(asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan);
    constructor(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions);
    constructor(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, interopOption: EnterpriseServicesInteropOption);
    constructor(transactionToUse: Transaction);
    constructor(transactionToUse: Transaction, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(transactionToUse: Transaction, scopeTimeout: TimeSpan);
    constructor(transactionToUse: Transaction, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(transactionToUse: Transaction, scopeTimeout: TimeSpan, interopOption: EnterpriseServicesInteropOption);
    Complete(): void;
    Dispose(): void;
}


export interface __TransactionScope$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TransactionScope = TransactionScope$instance & __TransactionScope$views;


export class TransactionStartedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: TransactionEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: TransactionEventArgs): void;
}


export interface __TransactionStartedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionStartedEventHandler = TransactionStartedEventHandler$instance & __TransactionStartedEventHandler$views;


export abstract class TransactionInterop$instance {
    static readonly PromoterTypeDtc: Guid;
    static GetDtcTransaction(transaction: Transaction): IDtcTransaction;
    static GetExportCookie(transaction: Transaction, whereabouts: byte[]): byte[];
    static GetTransactionFromDtcTransaction(transactionNative: IDtcTransaction): Transaction;
    static GetTransactionFromExportCookie(cookie: byte[]): Transaction;
    static GetTransactionFromTransmitterPropagationToken(propagationToken: byte[]): Transaction;
    static GetTransmitterPropagationToken(transaction: Transaction): byte[];
    static GetWhereabouts(): byte[];
}


export type TransactionInterop = TransactionInterop$instance;

export abstract class TransactionManager$instance {
    static HostCurrentCallback: HostCurrentTransactionCallback;
    static DefaultTimeout: TimeSpan;
    static MaximumTimeout: TimeSpan;
    static ImplicitDistributedTransactions: boolean;
    static RecoveryComplete(resourceManagerIdentifier: Guid): void;
    static Reenlist(resourceManagerIdentifier: Guid, recoveryInformation: byte[], enlistmentNotification: IEnlistmentNotification): Enlistment;
}


export type TransactionManager = TransactionManager$instance;

