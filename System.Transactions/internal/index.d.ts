// Generated by tsbindgen - Architecture
// Namespace: System.Transactions
// Assembly: System.Transactions.Local

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Delegate, Enum, EventArgs, Exception, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DependentCloneOption {
    blockCommitUntilComplete = 0,
    rollbackIfNotComplete = 1
}


export enum EnlistmentOptions {
    none = 0,
    enlistDuringPrepareRequired = 1
}


export enum EnterpriseServicesInteropOption {
    none = 0,
    automatic = 1,
    full = 2
}


export enum IsolationLevel {
    serializable = 0,
    repeatableRead = 1,
    readCommitted = 2,
    readUncommitted = 3,
    snapshot = 4,
    chaos = 5,
    unspecified = 6
}


export enum TransactionScopeAsyncFlowOption {
    suppress = 0,
    enabled = 1
}


export enum TransactionScopeOption {
    required = 0,
    requiresNew = 1,
    suppress = 2
}


export enum TransactionStatus {
    active = 0,
    committed = 1,
    aborted = 2,
    inDoubt = 3
}


export interface IDtcTransaction$instance {
    abort(reason: nint, retaining: int, async_: int): void;
    commit(retaining: int, commitType: int, reserved: int): void;
    getTransactionInfo(transactionInformation: nint): void;
}


export type IDtcTransaction = IDtcTransaction$instance;

export interface IEnlistmentNotification$instance {
    commit(enlistment: Enlistment): void;
    prepare(preparingEnlistment: PreparingEnlistment): void;
}


export type IEnlistmentNotification = IEnlistmentNotification$instance;

export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter {
    initialize(): void;
    promote(): byte[];
    singlePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter$instance {}

export type IPromotableSinglePhaseNotification = IPromotableSinglePhaseNotification$instance;

export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter {
    promote(): byte[];
    rollback(): void;
}


export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter$instance {}

export type ISimpleTransactionSuperior = ISimpleTransactionSuperior$instance;

export interface ISinglePhaseNotification$instance extends IEnlistmentNotification {
    commit(enlistment: Enlistment): void;
    prepare(preparingEnlistment: PreparingEnlistment): void;
    singlePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface ISinglePhaseNotification$instance extends IEnlistmentNotification$instance {}

export type ISinglePhaseNotification = ISinglePhaseNotification$instance;

export interface ITransactionPromoter$instance {
    promote(): byte[];
}


export type ITransactionPromoter = ITransactionPromoter$instance;

export class TransactionOptions$instance {
    isolationLevel: IsolationLevel;
    timeout: TimeSpan;
    equals(obj: unknown): boolean;
    equals(other: TransactionOptions): boolean;
    getHashCode(): int;
}


export interface __TransactionOptions$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TransactionOptions>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TransactionOptions): boolean;
}

export type TransactionOptions = TransactionOptions$instance & __TransactionOptions$views;


export class CommittableTransaction$instance extends Transaction$instance {
    constructor();
    constructor(timeout: TimeSpan);
    constructor(options: TransactionOptions);
    beginCommit(asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    commit(): void;
    dispose(): void;
    endCommit(asyncResult: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CommittableTransaction$views {
    As_IAsyncResult(): System_Internal.IAsyncResult$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CommittableTransaction$instance extends System_Internal.IAsyncResult$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CommittableTransaction = CommittableTransaction$instance & __CommittableTransaction$views;


export class DependentTransaction$instance extends Transaction$instance {
    complete(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DependentTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DependentTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DependentTransaction = DependentTransaction$instance & __DependentTransaction$views;


export class Enlistment$instance {
    done(): void;
}


export type Enlistment = Enlistment$instance;

export class HostCurrentTransactionCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): Transaction;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(): Transaction;
}


export interface __HostCurrentTransactionCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HostCurrentTransactionCallback = HostCurrentTransactionCallback$instance & __HostCurrentTransactionCallback$views;


export class PreparingEnlistment$instance extends Enlistment$instance {
    forceRollback(): void;
    forceRollback(e: Exception): void;
    prepared(): void;
    recoveryInformation(): byte[];
}


export type PreparingEnlistment = PreparingEnlistment$instance;

export class SinglePhaseEnlistment$instance extends Enlistment$instance {
    aborted(): void;
    aborted(e: Exception): void;
    committed(): void;
    inDoubt(): void;
    inDoubt(e: Exception): void;
}


export type SinglePhaseEnlistment = SinglePhaseEnlistment$instance;

export class SubordinateTransaction$instance extends Transaction$instance {
    constructor(isoLevel: IsolationLevel, superior: ISimpleTransactionSuperior);
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SubordinateTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SubordinateTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SubordinateTransaction = SubordinateTransaction$instance & __SubordinateTransaction$views;


export class Transaction$instance {
    readonly isolationLevel: IsolationLevel;
    readonly promoterType: Guid;
    readonly transactionInformation: TransactionInformation;
    clone(): Transaction;
    dependentClone(cloneOption: DependentCloneOption): DependentTransaction;
    dispose(): void;
    enlistDurable(resourceManagerIdentifier: Guid, enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    enlistDurable(resourceManagerIdentifier: Guid, singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    enlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification): boolean;
    enlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification, promoterType: Guid): boolean;
    enlistVolatile(enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    enlistVolatile(singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getPromotedToken(): byte[];
    promoteAndEnlistDurable(resourceManagerIdentifier: Guid, promotableNotification: IPromotableSinglePhaseNotification, enlistmentNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    rollback(): void;
    rollback(e: Exception): void;
    setDistributedTransactionIdentifier(promotableNotification: IPromotableSinglePhaseNotification, distributedTransactionIdentifier: Guid): void;
    static current: Transaction;
}


export interface __Transaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Transaction$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Transaction = Transaction$instance & __Transaction$views;


export class TransactionAbortedException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionAbortedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionAbortedException = TransactionAbortedException$instance & __TransactionAbortedException$views;


export class TransactionCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: TransactionEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: TransactionEventArgs): void;
}


export interface __TransactionCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionCompletedEventHandler = TransactionCompletedEventHandler$instance & __TransactionCompletedEventHandler$views;


export class TransactionEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    readonly transaction: Transaction;
}


export type TransactionEventArgs = TransactionEventArgs$instance;

export class TransactionException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionException = TransactionException$instance & __TransactionException$views;


export class TransactionInDoubtException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionInDoubtException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionInDoubtException = TransactionInDoubtException$instance & __TransactionInDoubtException$views;


export class TransactionInformation$instance {
    readonly creationTime: DateTime;
    readonly distributedIdentifier: Guid;
    readonly localIdentifier: string;
    readonly status: TransactionStatus;
}


export type TransactionInformation = TransactionInformation$instance;

export class TransactionManagerCommunicationException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionManagerCommunicationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionManagerCommunicationException = TransactionManagerCommunicationException$instance & __TransactionManagerCommunicationException$views;


export class TransactionPromotionException$instance extends TransactionException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TransactionPromotionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionPromotionException = TransactionPromotionException$instance & __TransactionPromotionException$views;


export class TransactionScope$instance {
    constructor();
    constructor(scopeOption: TransactionScopeOption);
    constructor(asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan);
    constructor(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions);
    constructor(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, interopOption: EnterpriseServicesInteropOption);
    constructor(transactionToUse: Transaction);
    constructor(transactionToUse: Transaction, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(transactionToUse: Transaction, scopeTimeout: TimeSpan);
    constructor(transactionToUse: Transaction, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption);
    constructor(transactionToUse: Transaction, scopeTimeout: TimeSpan, interopOption: EnterpriseServicesInteropOption);
    complete(): void;
    dispose(): void;
}


export interface __TransactionScope$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TransactionScope$instance extends System_Internal.IDisposable$instance {}

export type TransactionScope = TransactionScope$instance & __TransactionScope$views;


export class TransactionStartedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: TransactionEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: TransactionEventArgs): void;
}


export interface __TransactionStartedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionStartedEventHandler = TransactionStartedEventHandler$instance & __TransactionStartedEventHandler$views;


export abstract class TransactionInterop$instance {
    static readonly promoterTypeDtc: Guid;
    static getDtcTransaction(transaction: Transaction): IDtcTransaction;
    static getExportCookie(transaction: Transaction, whereabouts: byte[]): byte[];
    static getTransactionFromDtcTransaction(transactionNative: IDtcTransaction): Transaction;
    static getTransactionFromExportCookie(cookie: byte[]): Transaction;
    static getTransactionFromTransmitterPropagationToken(propagationToken: byte[]): Transaction;
    static getTransmitterPropagationToken(transaction: Transaction): byte[];
    static getWhereabouts(): byte[];
}


export type TransactionInterop = TransactionInterop$instance;

export abstract class TransactionManager$instance {
    static hostCurrentCallback: HostCurrentTransactionCallback;
    static defaultTimeout: TimeSpan;
    static maximumTimeout: TimeSpan;
    static implicitDistributedTransactions: boolean;
    static recoveryComplete(resourceManagerIdentifier: Guid): void;
    static reenlist(resourceManagerIdentifier: Guid, recoveryInformation: byte[], enlistmentNotification: IEnlistmentNotification): Enlistment;
}


export type TransactionManager = TransactionManager$instance;

