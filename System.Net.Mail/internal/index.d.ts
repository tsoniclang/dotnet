// Generated by tsbindgen - Architecture
// Namespace: System.Net.Mail
// Assembly: System.Net.Mail

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { NameValueCollection } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { AsyncCompletedEventArgs } from "../../System.ComponentModel/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { ContentDisposition, ContentType, TransferEncoding } from "../../System.Net.Mime/internal/index.js";
import type { ICredentialsByHost, ServicePoint } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { X509CertificateCollection } from "../../System.Security.Cryptography.X509Certificates/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Delegate, Enum, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, Type, TypeCode, Uri, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DeliveryNotificationOptions {
    none = 0,
    onSuccess = 1,
    onFailure = 2,
    delay = 4,
    never_ = 134217728
}


export enum MailPriority {
    normal = 0,
    low = 1,
    high = 2
}


export enum SmtpDeliveryFormat {
    sevenBit = 0,
    international = 1
}


export enum SmtpDeliveryMethod {
    network = 0,
    specifiedPickupDirectory = 1,
    pickupDirectoryFromIis = 2
}


export enum SmtpStatusCode {
    systemStatus = 211,
    helpMessage = 214,
    serviceReady = 220,
    serviceClosingTransmissionChannel = 221,
    ok = 250,
    userNotLocalWillForward = 251,
    cannotVerifyUserWillAttemptDelivery = 252,
    startMailInput = 354,
    serviceNotAvailable = 421,
    mailboxBusy = 450,
    localErrorInProcessing = 451,
    insufficientStorage = 452,
    clientNotPermitted = 454,
    commandUnrecognized = 500,
    syntaxError = 501,
    commandNotImplemented = 502,
    badCommandSequence = 503,
    mustIssueStartTlsFirst = 530,
    commandParameterNotImplemented = 504,
    mailboxUnavailable = 550,
    userNotLocalTryAlternatePath = 551,
    exceededStorageAllocation = 552,
    mailboxNameNotAllowed = 553,
    transactionFailed = 554,
    generalFailure = -1
}


export class AlternateView$instance extends AttachmentBase$instance {
    constructor(fileName: string);
    constructor(fileName: string, mediaType: string);
    constructor(fileName: string, contentType: ContentType);
    constructor(contentStream: Stream);
    constructor(contentStream: Stream, mediaType: string);
    constructor(contentStream: Stream, contentType: ContentType);
    baseUri: Uri;
    readonly linkedResources: LinkedResourceCollection;
    dispose(): void;
    static CreateAlternateViewFromString(content: string, contentType: ContentType): AlternateView;
    static CreateAlternateViewFromString(content: string, contentEncoding: Encoding, mediaType: string): AlternateView;
    static CreateAlternateViewFromString(content: string): AlternateView;
}


export interface __AlternateView$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AlternateView = AlternateView$instance & __AlternateView$views;


export class AlternateViewCollection$instance extends System_Collections_ObjectModel_Internal.Collection_1$instance<AlternateView> {
    add(item: AlternateView): void;
    add(value: any): int;
    clear(): void;
    contains(item: AlternateView): boolean;
    contains(value: any): boolean;
    copyTo(array: AlternateView[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    dispose(): void;
    getEnumerator(): IEnumerator_1<AlternateView>;
    getEnumerator(): IEnumerator;
    indexOf(item: AlternateView): int;
    insert(index: int, item: AlternateView): void;
    insert(index: int, value: any): void;
    remove(item: AlternateView): boolean;
    remove(value: any): void;
    removeAt(index: int): void;
}


export interface __AlternateViewCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<AlternateView>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<AlternateView>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<AlternateView>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<AlternateView>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AlternateViewCollection = AlternateViewCollection$instance & __AlternateViewCollection$views;


export class Attachment$instance extends AttachmentBase$instance {
    constructor(fileName: string);
    constructor(fileName: string, mediaType: string);
    constructor(fileName: string, contentType: ContentType);
    constructor(contentStream: Stream, name: string);
    constructor(contentStream: Stream, name: string, mediaType: string);
    constructor(contentStream: Stream, contentType: ContentType);
    readonly contentDisposition: ContentDisposition;
    name: string;
    nameEncoding: Encoding;
    dispose(): void;
    static CreateAttachmentFromString(content: string, contentType: ContentType): Attachment;
    static CreateAttachmentFromString(content: string, name: string, contentEncoding: Encoding, mediaType: string): Attachment;
    static CreateAttachmentFromString(content: string, name: string): Attachment;
}


export interface __Attachment$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Attachment = Attachment$instance & __Attachment$views;


export abstract class AttachmentBase$instance {
    contentId: string;
    readonly contentStream: Stream;
    contentType: ContentType;
    transferEncoding: TransferEncoding;
    dispose(): void;
}


export interface __AttachmentBase$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AttachmentBase = AttachmentBase$instance & __AttachmentBase$views;


export class AttachmentCollection$instance extends System_Collections_ObjectModel_Internal.Collection_1$instance<Attachment> {
    add(item: Attachment): void;
    add(value: any): int;
    clear(): void;
    contains(item: Attachment): boolean;
    contains(value: any): boolean;
    copyTo(array: Attachment[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    dispose(): void;
    getEnumerator(): IEnumerator_1<Attachment>;
    getEnumerator(): IEnumerator;
    indexOf(item: Attachment): int;
    insert(index: int, item: Attachment): void;
    insert(index: int, value: any): void;
    remove(item: Attachment): boolean;
    remove(value: any): void;
    removeAt(index: int): void;
}


export interface __AttachmentCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<Attachment>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<Attachment>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<Attachment>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Attachment>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AttachmentCollection = AttachmentCollection$instance & __AttachmentCollection$views;


export class LinkedResource$instance extends AttachmentBase$instance {
    constructor(fileName: string);
    constructor(fileName: string, mediaType: string);
    constructor(fileName: string, contentType: ContentType);
    constructor(contentStream: Stream);
    constructor(contentStream: Stream, mediaType: string);
    constructor(contentStream: Stream, contentType: ContentType);
    contentLink: Uri;
    dispose(): void;
    static CreateLinkedResourceFromString(content: string, contentType: ContentType): LinkedResource;
    static CreateLinkedResourceFromString(content: string, contentEncoding: Encoding, mediaType: string): LinkedResource;
    static CreateLinkedResourceFromString(content: string): LinkedResource;
}


export interface __LinkedResource$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type LinkedResource = LinkedResource$instance & __LinkedResource$views;


export class LinkedResourceCollection$instance extends System_Collections_ObjectModel_Internal.Collection_1$instance<LinkedResource> {
    add(item: LinkedResource): void;
    add(value: any): int;
    clear(): void;
    contains(item: LinkedResource): boolean;
    contains(value: any): boolean;
    copyTo(array: LinkedResource[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    dispose(): void;
    getEnumerator(): IEnumerator_1<LinkedResource>;
    getEnumerator(): IEnumerator;
    indexOf(item: LinkedResource): int;
    insert(index: int, item: LinkedResource): void;
    insert(index: int, value: any): void;
    remove(item: LinkedResource): boolean;
    remove(value: any): void;
    removeAt(index: int): void;
}


export interface __LinkedResourceCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<LinkedResource>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<LinkedResource>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<LinkedResource>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<LinkedResource>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type LinkedResourceCollection = LinkedResourceCollection$instance & __LinkedResourceCollection$views;


export class MailAddress$instance {
    constructor(address: string);
    constructor(address: string, displayName: string);
    constructor(address: string, displayName: string, displayNameEncoding: Encoding);
    readonly address: string;
    readonly displayName: string;
    readonly host: string;
    readonly user: string;
    equals(value: any): boolean;
    getHashCode(): int;
    toString(): string;
    static TryCreate(address: string, result: { value: ref<MailAddress> }): boolean;
    static TryCreate(address: string, displayName: string, result: { value: ref<MailAddress> }): boolean;
    static TryCreate(address: string, displayName: string, displayNameEncoding: Encoding, result: { value: ref<MailAddress> }): boolean;
}


export type MailAddress = MailAddress$instance;

export class MailAddressCollection$instance extends System_Collections_ObjectModel_Internal.Collection_1$instance<MailAddress> {
    constructor();
    add(item: MailAddress): void;
    add(value: any): int;
    clear(): void;
    contains(item: MailAddress): boolean;
    contains(value: any): boolean;
    copyTo(array: MailAddress[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<MailAddress>;
    getEnumerator(): IEnumerator;
    indexOf(item: MailAddress): int;
    insert(index: int, item: MailAddress): void;
    insert(index: int, value: any): void;
    remove(item: MailAddress): boolean;
    remove(value: any): void;
    removeAt(index: int): void;
    toString(): string;
}


export interface __MailAddressCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<MailAddress>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<MailAddress>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<MailAddress>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<MailAddress>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type MailAddressCollection = MailAddressCollection$instance & __MailAddressCollection$views;


export class MailMessage$instance {
    constructor();
    constructor(from_: string, to: string);
    constructor(from_: string, to: string, subject: string, body: string);
    constructor(from_: MailAddress, to: MailAddress);
    readonly alternateViews: AlternateViewCollection;
    readonly attachments: AttachmentCollection;
    readonly bcc: MailAddressCollection;
    body: string;
    bodyEncoding: Encoding;
    bodyTransferEncoding: TransferEncoding;
    readonly cc: MailAddressCollection;
    deliveryNotificationOptions: DeliveryNotificationOptions;
    from_: MailAddress;
    readonly headers: NameValueCollection;
    headersEncoding: Encoding;
    isBodyHtml: boolean;
    priority: MailPriority;
    replyTo: MailAddress;
    readonly replyToList: MailAddressCollection;
    sender: MailAddress;
    subject: string;
    subjectEncoding: Encoding;
    readonly to: MailAddressCollection;
    dispose(): void;
}


export interface __MailMessage$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MailMessage = MailMessage$instance & __MailMessage$views;


export class SendCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: AsyncCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: AsyncCompletedEventArgs): void;
}


export interface __SendCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SendCompletedEventHandler = SendCompletedEventHandler$instance & __SendCompletedEventHandler$views;


export class SmtpClient$instance {
    constructor();
    constructor(host: string);
    constructor(host: string, port: int);
    readonly clientCertificates: X509CertificateCollection;
    credentials: ICredentialsByHost;
    deliveryFormat: SmtpDeliveryFormat;
    deliveryMethod: SmtpDeliveryMethod;
    enableSsl: boolean;
    host: string;
    pickupDirectoryLocation: string;
    port: int;
    readonly servicePoint: ServicePoint;
    targetName: string;
    timeout: int;
    useDefaultCredentials: boolean;
    dispose(): void;
    send(from_: string, recipients: string, subject: string, body: string): void;
    send(message: MailMessage): void;
    sendAsync(from_: string, recipients: string, subject: string, body: string, userToken: any): void;
    sendAsync(message: MailMessage, userToken: any): void;
    sendAsyncCancel(): void;
    sendMailAsync(from_: string, recipients: string, subject: string, body: string): Task;
    sendMailAsync(message: MailMessage): Task;
    sendMailAsync(from_: string, recipients: string, subject: string, body: string, cancellationToken: CancellationToken): Task;
    sendMailAsync(message: MailMessage, cancellationToken: CancellationToken): Task;
}


export interface __SmtpClient$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SmtpClient = SmtpClient$instance & __SmtpClient$views;


export class SmtpException$instance extends System_Internal.Exception$instance {
    constructor(statusCode: SmtpStatusCode);
    constructor(statusCode: SmtpStatusCode, message: string);
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    statusCode: SmtpStatusCode;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __SmtpException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SmtpException = SmtpException$instance & __SmtpException$views;


export class SmtpFailedRecipientException$instance extends SmtpException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(statusCode: SmtpStatusCode, failedRecipient: string);
    constructor(statusCode: SmtpStatusCode, failedRecipient: string, serverResponse: string);
    constructor(message: string, failedRecipient: string, innerException: Exception);
    readonly failedRecipient: string;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __SmtpFailedRecipientException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SmtpFailedRecipientException = SmtpFailedRecipientException$instance & __SmtpFailedRecipientException$views;


export class SmtpFailedRecipientsException$instance extends SmtpFailedRecipientException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerExceptions: SmtpFailedRecipientException[]);
    readonly innerExceptions: SmtpFailedRecipientException[];
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __SmtpFailedRecipientsException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SmtpFailedRecipientsException = SmtpFailedRecipientsException$instance & __SmtpFailedRecipientsException$views;


