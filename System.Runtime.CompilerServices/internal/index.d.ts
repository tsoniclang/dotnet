// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.CompilerServices
// Assembly: System.Linq.Expressions, System.Private.CoreLib, System.Runtime.CompilerServices.VisualC, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { ContractFailureKind } from "../../System.Diagnostics.Contracts/internal/index.js";
import type { ExpandoObject } from "../../System.Dynamic/internal/index.js";
import type { DebugInfoExpression, Expression, LabelTarget, LambdaExpression, ParameterExpression } from "../../System.Linq.Expressions/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Enum, Exception, FormattableString, Func_2, Func_3, IAsyncResult, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, ModuleHandle, MulticastDelegate, Object as ClrObject, Range, ReadOnlySpan_1, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, Type, TypeCode, UInt32, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CompilationRelaxations {
    noStringInterning = 8
}


export enum LoadHint {
    default_ = 0,
    always = 1,
    sometimes = 2
}


export enum MethodCodeType {
    il = 0,
    native = 1,
    optil = 2,
    runtime = 3
}


export enum MethodImplOptions {
    unmanaged = 4,
    noInlining = 8,
    forwardRef = 16,
    synchronized = 32,
    noOptimization = 64,
    preserveSig = 128,
    aggressiveInlining = 256,
    aggressiveOptimization = 512,
    async_ = 8192,
    internalCall = 4096
}


export enum UnsafeAccessorKind {
    constructor_ = 0,
    method = 1,
    staticMethod = 2,
    field = 3,
    staticField = 4
}


export interface IAsyncStateMachine$instance {
    moveNext(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
}


export type IAsyncStateMachine = IAsyncStateMachine$instance;

export interface ICriticalNotifyCompletion$instance extends INotifyCompletion {
    unsafeOnCompleted(continuation: Action): void;
}


export interface ICriticalNotifyCompletion$instance extends INotifyCompletion$instance {}

export type ICriticalNotifyCompletion = ICriticalNotifyCompletion$instance;

export interface INotifyCompletion$instance {
    onCompleted(continuation: Action): void;
}


export type INotifyCompletion = INotifyCompletion$instance;

export interface IRuntimeVariables$instance {
    readonly count: int;
    item: unknown;
}


export type IRuntimeVariables = IRuntimeVariables$instance;

export interface IStrongBox$instance {
    value: unknown;
}


export type IStrongBox = IStrongBox$instance;

export interface ITuple$instance {
    readonly length: int;
    readonly item: unknown;
}


export type ITuple = ITuple$instance;

export class AsyncIteratorMethodBuilder$instance {
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    complete(): void;
    moveNext<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create(): AsyncIteratorMethodBuilder;
}


export type AsyncIteratorMethodBuilder = AsyncIteratorMethodBuilder$instance;

export class AsyncTaskMethodBuilder$instance {
    readonly task: Task;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create(): AsyncTaskMethodBuilder;
}


export type AsyncTaskMethodBuilder = AsyncTaskMethodBuilder$instance;

export class AsyncTaskMethodBuilder_1$instance<TResult> {
    readonly task: Task_1<TResult>;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(result: TResult): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create<TResult>(): AsyncTaskMethodBuilder_1<TResult>;
}


export type AsyncTaskMethodBuilder_1<TResult> = AsyncTaskMethodBuilder_1$instance<TResult>;

export class AsyncValueTaskMethodBuilder$instance {
    readonly task: ValueTask;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create(): AsyncValueTaskMethodBuilder;
}


export type AsyncValueTaskMethodBuilder = AsyncValueTaskMethodBuilder$instance;

export class AsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly task: ValueTask_1<TResult>;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(result: TResult): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create<TResult>(): AsyncValueTaskMethodBuilder_1<TResult>;
}


export type AsyncValueTaskMethodBuilder_1<TResult> = AsyncValueTaskMethodBuilder_1$instance<TResult>;

export class AsyncVoidMethodBuilder$instance {
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create(): AsyncVoidMethodBuilder;
}


export type AsyncVoidMethodBuilder = AsyncVoidMethodBuilder$instance;

export class ConfiguredAsyncDisposable$instance {
    disposeAsync(): ConfiguredValueTaskAwaitable;
}


export type ConfiguredAsyncDisposable = ConfiguredAsyncDisposable$instance;

export class ConfiguredCancelableAsyncEnumerable_1$instance<T> {
    configureAwait(continueOnCapturedContext: boolean): ConfiguredCancelableAsyncEnumerable_1<T>;
    getAsyncEnumerator(): ConfiguredCancelableAsyncEnumerable_1_Enumerator<T>;
    withCancellation(cancellationToken: CancellationToken): ConfiguredCancelableAsyncEnumerable_1<T>;
}


export type ConfiguredCancelableAsyncEnumerable_1<T> = ConfiguredCancelableAsyncEnumerable_1$instance<T>;

export class ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T> {
    readonly current: T;
    disposeAsync(): ConfiguredValueTaskAwaitable;
    moveNextAsync(): ConfiguredValueTaskAwaitable_1<CLROf<boolean>>;
}


export type ConfiguredCancelableAsyncEnumerable_1_Enumerator<T> = ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T>;

export class ConfiguredTaskAwaitable$instance {
    getAwaiter(): ConfiguredTaskAwaitable_ConfiguredTaskAwaiter;
}


export type ConfiguredTaskAwaitable = ConfiguredTaskAwaitable$instance;

export class ConfiguredTaskAwaitable_1$instance<TResult> {
    getAwaiter(): ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult>;
}


export type ConfiguredTaskAwaitable_1<TResult> = ConfiguredTaskAwaitable_1$instance<TResult>;

export class ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult> = ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> & __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult>;


export class ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_ConfiguredTaskAwaiter = ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance & __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views;


export class ConfiguredValueTaskAwaitable$instance {
    getAwaiter(): ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter;
}


export type ConfiguredValueTaskAwaitable = ConfiguredValueTaskAwaitable$instance;

export class ConfiguredValueTaskAwaitable_1$instance<TResult> {
    getAwaiter(): ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult>;
}


export type ConfiguredValueTaskAwaitable_1<TResult> = ConfiguredValueTaskAwaitable_1$instance<TResult>;

export class ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult> = ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> & __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult>;


export class ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter = ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance & __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views;


export class DefaultInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int);
    constructor(literalLength: int, formattedCount: int, provider: IFormatProvider);
    constructor(literalLength: int, formattedCount: int, provider: IFormatProvider, initialBuffer: Span_1<CLROf<char>>);
    readonly text: ReadOnlySpan_1<CLROf<char>>;
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: unknown, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
    clear(): void;
    toString(): string;
    toStringAndClear(): string;
}


export type DefaultInterpolatedStringHandler = DefaultInterpolatedStringHandler$instance;

export class InlineArray10_1$instance<T> {
}


export type InlineArray10_1<T> = InlineArray10_1$instance<T>;

export class InlineArray11_1$instance<T> {
}


export type InlineArray11_1<T> = InlineArray11_1$instance<T>;

export class InlineArray12_1$instance<T> {
}


export type InlineArray12_1<T> = InlineArray12_1$instance<T>;

export class InlineArray13_1$instance<T> {
}


export type InlineArray13_1<T> = InlineArray13_1$instance<T>;

export class InlineArray14_1$instance<T> {
}


export type InlineArray14_1<T> = InlineArray14_1$instance<T>;

export class InlineArray15_1$instance<T> {
}


export type InlineArray15_1<T> = InlineArray15_1$instance<T>;

export class InlineArray16_1$instance<T> {
}


export type InlineArray16_1<T> = InlineArray16_1$instance<T>;

export class InlineArray2_1$instance<T> {
}


export type InlineArray2_1<T> = InlineArray2_1$instance<T>;

export class InlineArray3_1$instance<T> {
}


export type InlineArray3_1<T> = InlineArray3_1$instance<T>;

export class InlineArray4_1$instance<T> {
}


export type InlineArray4_1<T> = InlineArray4_1$instance<T>;

export class InlineArray5_1$instance<T> {
}


export type InlineArray5_1<T> = InlineArray5_1$instance<T>;

export class InlineArray6_1$instance<T> {
}


export type InlineArray6_1<T> = InlineArray6_1$instance<T>;

export class InlineArray7_1$instance<T> {
}


export type InlineArray7_1<T> = InlineArray7_1$instance<T>;

export class InlineArray8_1$instance<T> {
}


export type InlineArray8_1<T> = InlineArray8_1$instance<T>;

export class InlineArray9_1$instance<T> {
}


export type InlineArray9_1<T> = InlineArray9_1$instance<T>;

export class PoolingAsyncValueTaskMethodBuilder$instance {
    readonly task: ValueTask;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create(): PoolingAsyncValueTaskMethodBuilder;
}


export type PoolingAsyncValueTaskMethodBuilder = PoolingAsyncValueTaskMethodBuilder$instance;

export class PoolingAsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly task: ValueTask_1<TResult>;
    awaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    awaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    setException(exception: Exception): void;
    setResult(result: TResult): void;
    setStateMachine(stateMachine: IAsyncStateMachine): void;
    start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static create<TResult>(): PoolingAsyncValueTaskMethodBuilder_1<TResult>;
}


export type PoolingAsyncValueTaskMethodBuilder_1<TResult> = PoolingAsyncValueTaskMethodBuilder_1$instance<TResult>;

export class TaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __TaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter = TaskAwaiter$instance & __TaskAwaiter$views;


export class TaskAwaiter_1$instance<TResult> implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __TaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter_1<TResult> = TaskAwaiter_1$instance<TResult> & __TaskAwaiter_1$views<TResult>;


export class ValueTaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __ValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter = ValueTaskAwaiter$instance & __ValueTaskAwaiter$views;


export class ValueTaskAwaiter_1$instance<TResult> implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): TResult;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __ValueTaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter_1<TResult> = ValueTaskAwaiter_1$instance<TResult> & __ValueTaskAwaiter_1$views<TResult>;


export class YieldAwaitable$instance {
    getAwaiter(): YieldAwaitable_YieldAwaiter;
}


export type YieldAwaitable = YieldAwaitable$instance;

export class YieldAwaitable_YieldAwaiter$instance implements ICriticalNotifyCompletion {
    readonly isCompleted: boolean;
    getResult(): void;
    onCompleted(continuation: Action): void;
    unsafeOnCompleted(continuation: Action): void;
}


export interface __YieldAwaitable_YieldAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface YieldAwaitable_YieldAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type YieldAwaitable_YieldAwaiter = YieldAwaitable_YieldAwaiter$instance & __YieldAwaitable_YieldAwaiter$views;


export class AccessedThroughPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(propertyName: string);
    readonly propertyName: string;
}


export type AccessedThroughPropertyAttribute = AccessedThroughPropertyAttribute$instance;

export class AsyncIteratorStateMachineAttribute$instance extends StateMachineAttribute$instance {
    constructor(stateMachineType: Type);
}


export type AsyncIteratorStateMachineAttribute = AsyncIteratorStateMachineAttribute$instance;

export class AsyncMethodBuilderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(builderType: Type);
    readonly builderType: Type;
}


export type AsyncMethodBuilderAttribute = AsyncMethodBuilderAttribute$instance;

export class AsyncStateMachineAttribute$instance extends StateMachineAttribute$instance {
    constructor(stateMachineType: Type);
}


export type AsyncStateMachineAttribute = AsyncStateMachineAttribute$instance;

export class CallConvCdecl$instance {
    constructor();
}


export type CallConvCdecl = CallConvCdecl$instance;

export class CallConvFastcall$instance {
    constructor();
}


export type CallConvFastcall = CallConvFastcall$instance;

export class CallConvMemberFunction$instance {
    constructor();
}


export type CallConvMemberFunction = CallConvMemberFunction$instance;

export class CallConvStdcall$instance {
    constructor();
}


export type CallConvStdcall = CallConvStdcall$instance;

export class CallConvSuppressGCTransition$instance {
    constructor();
}


export type CallConvSuppressGCTransition = CallConvSuppressGCTransition$instance;

export class CallConvSwift$instance {
    constructor();
}


export type CallConvSwift = CallConvSwift$instance;

export class CallConvThiscall$instance {
    constructor();
}


export type CallConvThiscall = CallConvThiscall$instance;

export class CallerArgumentExpressionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(parameterName: string);
    readonly parameterName: string;
}


export type CallerArgumentExpressionAttribute = CallerArgumentExpressionAttribute$instance;

export class CallerFilePathAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CallerFilePathAttribute = CallerFilePathAttribute$instance;

export class CallerLineNumberAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CallerLineNumberAttribute = CallerLineNumberAttribute$instance;

export class CallerMemberNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CallerMemberNameAttribute = CallerMemberNameAttribute$instance;

export class CallSite$instance {
    readonly binder: CallSiteBinder;
    static create(delegateType: Type, binder: CallSiteBinder): CallSite;
}


export type CallSite = CallSite$instance;

export class CallSite_1$instance<T> extends CallSite$instance {
    target: T;
    readonly update: T;
}


export type CallSite_1<T> = CallSite_1$instance<T>;

export abstract class CallSiteBinder$instance {
    abstract bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    bindDelegate<T>(site: CallSite_1<T>, args: unknown[]): T;
    static readonly updateLabel: LabelTarget;
}


export type CallSiteBinder = CallSiteBinder$instance;

export class Closure$instance {
    constructor(constants: unknown[], locals: unknown[]);
    readonly constants: unknown[];
    readonly locals: unknown[];
}


export type Closure = Closure$instance;

export class CollectionBuilderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(builderType: Type, methodName: string);
    readonly builderType: Type;
    readonly methodName: string;
}


export type CollectionBuilderAttribute = CollectionBuilderAttribute$instance;

export class CompilationRelaxationsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(relaxations: int);
    constructor(relaxations: CompilationRelaxations);
    readonly compilationRelaxations: int;
}


export type CompilationRelaxationsAttribute = CompilationRelaxationsAttribute$instance;

export class CompilerFeatureRequiredAttribute$instance extends System_Internal.Attribute$instance {
    constructor(featureName: string);
    readonly featureName: string;
    isOptional: boolean;
    static readonly refStructs: string;
    static readonly requiredMembers: string;
}


export type CompilerFeatureRequiredAttribute = CompilerFeatureRequiredAttribute$instance;

export class CompilerGeneratedAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CompilerGeneratedAttribute = CompilerGeneratedAttribute$instance;

export class CompilerGlobalScopeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CompilerGlobalScopeAttribute = CompilerGlobalScopeAttribute$instance;

export class CompilerLoweringPreserveAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CompilerLoweringPreserveAttribute = CompilerLoweringPreserveAttribute$instance;

export class ConditionalWeakTable_2$instance<TKey, TValue> {
    constructor();
    add(key: TKey, value: TValue): void;
    addOrUpdate(key: TKey, value: TValue): void;
    clear(): void;
    getOrAdd(key: TKey, value: TValue): TValue;
    getOrAdd(key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    getOrAdd<TArg>(key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateValue(key: TKey): TValue;
    getValue(key: TKey, createValueCallback: ConditionalWeakTable_2_CreateValueCallback<TKey, TValue>): TValue;
    remove(key: TKey): boolean;
    remove(key: TKey, value: { value: ref<TValue> }): boolean;
    tryAdd(key: TKey, value: TValue): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export interface __ConditionalWeakTable_2$views<TKey, TValue> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ConditionalWeakTable_2$instance<TKey, TValue> extends System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>> {}

export type ConditionalWeakTable_2<TKey, TValue> = ConditionalWeakTable_2$instance<TKey, TValue> & __ConditionalWeakTable_2$views<TKey, TValue>;


export class ConditionalWeakTable_2_CreateValueCallback$instance<TKey, TValue> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(key: TKey, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TValue;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(key: TKey): TValue;
}


export interface __ConditionalWeakTable_2_CreateValueCallback$views<TKey, TValue> {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ConditionalWeakTable_2_CreateValueCallback<TKey, TValue> = ConditionalWeakTable_2_CreateValueCallback$instance<TKey, TValue> & __ConditionalWeakTable_2_CreateValueCallback$views<TKey, TValue>;


export class CppInlineNamespaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dottedName: string);
}


export type CppInlineNamespaceAttribute = CppInlineNamespaceAttribute$instance;

export class CreateNewOnMetadataUpdateAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CreateNewOnMetadataUpdateAttribute = CreateNewOnMetadataUpdateAttribute$instance;

export abstract class CustomConstantAttribute$instance extends System_Internal.Attribute$instance {
    readonly value: unknown;
}


export type CustomConstantAttribute = CustomConstantAttribute$instance;

export class DateTimeConstantAttribute$instance extends CustomConstantAttribute$instance {
    constructor(ticks: long);
    readonly value: unknown;
}


export type DateTimeConstantAttribute = DateTimeConstantAttribute$instance;

export abstract class DebugInfoGenerator$instance {
    abstract markSequencePoint(method: LambdaExpression, ilOffset: int, sequencePoint: DebugInfoExpression): void;
    static createPdbGenerator(): DebugInfoGenerator;
}


export type DebugInfoGenerator = DebugInfoGenerator$instance;

export class DecimalConstantAttribute$instance extends System_Internal.Attribute$instance {
    constructor(scale: byte, sign: byte, hi: uint, mid: uint, low: uint);
    constructor(scale: byte, sign: byte, hi: int, mid: int, low: int);
    readonly value: decimal;
}


export type DecimalConstantAttribute = DecimalConstantAttribute$instance;

export class DefaultDependencyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(loadHintArgument: LoadHint);
    readonly loadHint: LoadHint;
}


export type DefaultDependencyAttribute = DefaultDependencyAttribute$instance;

export class DependencyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dependentAssemblyArgument: string, loadHintArgument: LoadHint);
    readonly dependentAssembly: string;
    readonly loadHint: LoadHint;
}


export type DependencyAttribute = DependencyAttribute$instance;

export class DisablePrivateReflectionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DisablePrivateReflectionAttribute = DisablePrivateReflectionAttribute$instance;

export class DisableRuntimeMarshallingAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DisableRuntimeMarshallingAttribute = DisableRuntimeMarshallingAttribute$instance;

export class DiscardableAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DiscardableAttribute = DiscardableAttribute$instance;

export class DynamicAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(transformFlags: boolean[]);
    readonly transformFlags: IList_1<CLROf<boolean>>;
}


export type DynamicAttribute = DynamicAttribute$instance;

export class EnumeratorCancellationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type EnumeratorCancellationAttribute = EnumeratorCancellationAttribute$instance;

export class ExtensionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ExtensionAttribute = ExtensionAttribute$instance;

export class ExtensionMarkerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly name: string;
}


export type ExtensionMarkerAttribute = ExtensionMarkerAttribute$instance;

export class FixedAddressValueTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type FixedAddressValueTypeAttribute = FixedAddressValueTypeAttribute$instance;

export class FixedBufferAttribute$instance extends System_Internal.Attribute$instance {
    constructor(elementType: Type, length: int);
    readonly elementType: Type;
    readonly length: int;
}


export type FixedBufferAttribute = FixedBufferAttribute$instance;

export class HasCopySemanticsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type HasCopySemanticsAttribute = HasCopySemanticsAttribute$instance;

export class IDispatchConstantAttribute$instance extends CustomConstantAttribute$instance {
    constructor();
    readonly value: unknown;
}


export type IDispatchConstantAttribute = IDispatchConstantAttribute$instance;

export class IndexerNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(indexerName: string);
}


export type IndexerNameAttribute = IndexerNameAttribute$instance;

export class InlineArrayAttribute$instance extends System_Internal.Attribute$instance {
    constructor(length: int);
    readonly length: int;
}


export type InlineArrayAttribute = InlineArrayAttribute$instance;

export class InternalsVisibleToAttribute$instance extends System_Internal.Attribute$instance {
    constructor(assemblyName: string);
    allInternalsVisible: boolean;
    readonly assemblyName: string;
}


export type InternalsVisibleToAttribute = InternalsVisibleToAttribute$instance;

export class InterpolatedStringHandlerArgumentAttribute$instance extends System_Internal.Attribute$instance {
    constructor(argument: string);
    constructor(arguments: string[]);
    readonly arguments: string[];
}


export type InterpolatedStringHandlerArgumentAttribute = InterpolatedStringHandlerArgumentAttribute$instance;

export class InterpolatedStringHandlerAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type InterpolatedStringHandlerAttribute = InterpolatedStringHandlerAttribute$instance;

export class IsByRefLikeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type IsByRefLikeAttribute = IsByRefLikeAttribute$instance;

export class IsReadOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type IsReadOnlyAttribute = IsReadOnlyAttribute$instance;

export class IsUnmanagedAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type IsUnmanagedAttribute = IsUnmanagedAttribute$instance;

export class IteratorStateMachineAttribute$instance extends StateMachineAttribute$instance {
    constructor(stateMachineType: Type);
}


export type IteratorStateMachineAttribute = IteratorStateMachineAttribute$instance;

export class IUnknownConstantAttribute$instance extends CustomConstantAttribute$instance {
    constructor();
    readonly value: unknown;
}


export type IUnknownConstantAttribute = IUnknownConstantAttribute$instance;

export class MetadataUpdateOriginalTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(originalType: Type);
    readonly originalType: Type;
}


export type MetadataUpdateOriginalTypeAttribute = MetadataUpdateOriginalTypeAttribute$instance;

export class MethodImplAttribute$instance extends System_Internal.Attribute$instance {
    constructor(methodImplOptions: MethodImplOptions);
    constructor(value: short);
    constructor();
    methodCodeType: MethodCodeType;
    readonly value: MethodImplOptions;
}


export type MethodImplAttribute = MethodImplAttribute$instance;

export class ModuleInitializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ModuleInitializerAttribute = ModuleInitializerAttribute$instance;

export class NativeCppClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type NativeCppClassAttribute = NativeCppClassAttribute$instance;

export class NullableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: byte);
    constructor(value: byte[]);
    readonly nullableFlags: byte[];
}


export type NullableAttribute = NullableAttribute$instance;

export class NullableContextAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: byte);
    readonly flag: byte;
}


export type NullableContextAttribute = NullableContextAttribute$instance;

export class NullablePublicOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: boolean);
    readonly includesInternals: boolean;
}


export type NullablePublicOnlyAttribute = NullablePublicOnlyAttribute$instance;

export class OverloadResolutionPriorityAttribute$instance extends System_Internal.Attribute$instance {
    constructor(priority: int);
    readonly priority: int;
}


export type OverloadResolutionPriorityAttribute = OverloadResolutionPriorityAttribute$instance;

export class ParamCollectionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ParamCollectionAttribute = ParamCollectionAttribute$instance;

export class PreserveBaseOverridesAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type PreserveBaseOverridesAttribute = PreserveBaseOverridesAttribute$instance;

export class ReadOnlyCollectionBuilder_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    capacity: int;
    readonly count: int;
    item: T;
    add(item: T): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(item: T): int;
    insert(index: int, item: T): void;
    remove(item: T): boolean;
    removeAt(index: int): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    toArray(): T[];
    toReadOnlyCollection(): ReadOnlyCollection_1<T>;
}


export interface __ReadOnlyCollectionBuilder_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ReadOnlyCollectionBuilder_1<T> = ReadOnlyCollectionBuilder_1$instance<T> & __ReadOnlyCollectionBuilder_1$views<T>;


export class ReferenceAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(description: string);
    readonly description: string;
}


export type ReferenceAssemblyAttribute = ReferenceAssemblyAttribute$instance;

export class RefSafetyRulesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(version: int);
    readonly version: int;
}


export type RefSafetyRulesAttribute = RefSafetyRulesAttribute$instance;

export class RequiredAttributeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(requiredContract: Type);
    readonly requiredContract: Type;
}


export type RequiredAttributeAttribute = RequiredAttributeAttribute$instance;

export class RequiredMemberAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type RequiredMemberAttribute = RequiredMemberAttribute$instance;

export class RequiresLocationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type RequiresLocationAttribute = RequiresLocationAttribute$instance;

export class RuleCache_1$instance<T> {
}


export type RuleCache_1<T> = RuleCache_1$instance<T>;

export class RuntimeCompatibilityAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    wrapNonExceptionThrows: boolean;
}


export type RuntimeCompatibilityAttribute = RuntimeCompatibilityAttribute$instance;

export class RuntimeHelpers_CleanupCode$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(userData: unknown, exceptionThrown: boolean, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(userData: unknown, exceptionThrown: boolean): void;
}


export interface __RuntimeHelpers_CleanupCode$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeHelpers_CleanupCode = RuntimeHelpers_CleanupCode$instance & __RuntimeHelpers_CleanupCode$views;


export class RuntimeHelpers_TryCode$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(userData: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(userData: unknown): void;
}


export interface __RuntimeHelpers_TryCode$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeHelpers_TryCode = RuntimeHelpers_TryCode$instance & __RuntimeHelpers_TryCode$views;


export class RuntimeWrappedException$instance extends System_Internal.Exception$instance {
    constructor(thrownObject: unknown);
    readonly wrappedException: unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __RuntimeWrappedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeWrappedException = RuntimeWrappedException$instance & __RuntimeWrappedException$views;


export class ScopedRefAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ScopedRefAttribute = ScopedRefAttribute$instance;

export class ScopelessEnumAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ScopelessEnumAttribute = ScopelessEnumAttribute$instance;

export class SkipLocalsInitAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SkipLocalsInitAttribute = SkipLocalsInitAttribute$instance;

export class SpecialNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SpecialNameAttribute = SpecialNameAttribute$instance;

export class StateMachineAttribute$instance extends System_Internal.Attribute$instance {
    constructor(stateMachineType: Type);
    readonly stateMachineType: Type;
}


export type StateMachineAttribute = StateMachineAttribute$instance;

export class StringFreezingAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type StringFreezingAttribute = StringFreezingAttribute$instance;

export class StrongBox_1$instance<T> {
    constructor();
    constructor(value: T);
    value: T;
}


export interface __StrongBox_1$views<T> {
    As_IStrongBox(): IStrongBox$instance;
}

export interface StrongBox_1$instance<T> extends IStrongBox$instance {}

export type StrongBox_1<T> = StrongBox_1$instance<T> & __StrongBox_1$views<T>;


export class SuppressIldasmAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SuppressIldasmAttribute = SuppressIldasmAttribute$instance;

export class SwitchExpressionException$instance extends System_Internal.InvalidOperationException$instance {
    constructor();
    constructor(innerException: Exception);
    constructor(unmatchedValue: unknown);
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly message: string;
    readonly unmatchedValue: unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SwitchExpressionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SwitchExpressionException = SwitchExpressionException$instance & __SwitchExpressionException$views;


export class TupleElementNamesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(transformNames: string[]);
    readonly transformNames: IList_1<CLROf<string>>;
}


export type TupleElementNamesAttribute = TupleElementNamesAttribute$instance;

export class TypeForwardedFromAttribute$instance extends System_Internal.Attribute$instance {
    constructor(assemblyFullName: string);
    readonly assemblyFullName: string;
}


export type TypeForwardedFromAttribute = TypeForwardedFromAttribute$instance;

export class TypeForwardedToAttribute$instance extends System_Internal.Attribute$instance {
    constructor(destination: Type);
    readonly destination: Type;
}


export type TypeForwardedToAttribute = TypeForwardedToAttribute$instance;

export class UnsafeAccessorAttribute$instance extends System_Internal.Attribute$instance {
    constructor(kind: UnsafeAccessorKind);
    readonly kind: UnsafeAccessorKind;
    name: string;
}


export type UnsafeAccessorAttribute = UnsafeAccessorAttribute$instance;

export class UnsafeAccessorTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(typeName: string);
    readonly typeName: string;
}


export type UnsafeAccessorTypeAttribute = UnsafeAccessorTypeAttribute$instance;

export class UnsafeValueTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type UnsafeValueTypeAttribute = UnsafeValueTypeAttribute$instance;

export abstract class AsyncHelpers$instance {
    static await_7<T>(configuredAwaitable: ConfiguredTaskAwaitable_1<T>): T;
    static await_7<T>(configuredAwaitable: ConfiguredValueTaskAwaitable_1<T>): T;
    static await_7(configuredAwaitable: ConfiguredTaskAwaitable): void;
    static await_7(configuredAwaitable: ConfiguredValueTaskAwaitable): void;
    static await_7(task: Task): void;
    static await_7(task: ValueTask): void;
    static await_7<T>(task: Task_1<T>): T;
    static await_7<T>(task: ValueTask_1<T>): T;
    static awaitAwaiter<TAwaiter extends INotifyCompletion>(awaiter: TAwaiter): void;
    static unsafeAwaitAwaiter<TAwaiter extends ICriticalNotifyCompletion>(awaiter: TAwaiter): void;
}


export type AsyncHelpers = AsyncHelpers$instance;

export abstract class CallSiteHelpers$instance {
    static isInternalFrame(mb: MethodBase): boolean;
}


export type CallSiteHelpers = CallSiteHelpers$instance;

export abstract class CallSiteOps$instance {
    static addRule<T>(site: CallSite_1<T>, rule: T): void;
    static bind<T>(binder: CallSiteBinder, site: CallSite_1<T>, args: unknown[]): T;
    static clearMatch(site: CallSite): void;
    static createMatchmaker<T>(site: CallSite_1<T>): CallSite_1<T>;
    static getCachedRules<T>(cache: RuleCache_1<T>): T[];
    static getMatch(site: CallSite): boolean;
    static getRuleCache<T>(site: CallSite_1<T>): RuleCache_1<T>;
    static getRules<T>(site: CallSite_1<T>): T[];
    static moveRule<T>(cache: RuleCache_1<T>, rule: T, i: int): void;
    static setNotMatched(site: CallSite): boolean;
    static updateRules<T>(this_: CallSite_1<T>, matched: int): void;
}


export type CallSiteOps = CallSiteOps$instance;

export abstract class CompilerMarshalOverride$instance {
}


export type CompilerMarshalOverride = CompilerMarshalOverride$instance;

export abstract class ContractHelper$instance {
    static raiseContractFailedEvent(failureKind: ContractFailureKind, userMessage: string, conditionText: string, innerException: Exception): string;
    static triggerFailure(kind: ContractFailureKind, displayMessage: string, userMessage: string, conditionText: string, innerException: Exception): void;
}


export type ContractHelper = ContractHelper$instance;

export abstract class FormattableStringFactory$instance {
    static create(format: string, arguments: unknown[]): FormattableString;
}


export type FormattableStringFactory = FormattableStringFactory$instance;

export abstract class IsBoxed$instance {
}


export type IsBoxed = IsBoxed$instance;

export abstract class IsByValue$instance {
}


export type IsByValue = IsByValue$instance;

export abstract class IsConst$instance {
}


export type IsConst = IsConst$instance;

export abstract class IsCopyConstructed$instance {
}


export type IsCopyConstructed = IsCopyConstructed$instance;

export abstract class IsExplicitlyDereferenced$instance {
}


export type IsExplicitlyDereferenced = IsExplicitlyDereferenced$instance;

export abstract class IsExternalInit$instance {
}


export type IsExternalInit = IsExternalInit$instance;

export abstract class IsImplicitlyDereferenced$instance {
}


export type IsImplicitlyDereferenced = IsImplicitlyDereferenced$instance;

export abstract class IsJitIntrinsic$instance {
}


export type IsJitIntrinsic = IsJitIntrinsic$instance;

export abstract class IsLong$instance {
}


export type IsLong = IsLong$instance;

export abstract class IsPinned$instance {
}


export type IsPinned = IsPinned$instance;

export abstract class IsSignUnspecifiedByte$instance {
}


export type IsSignUnspecifiedByte = IsSignUnspecifiedByte$instance;

export abstract class IsUdtReturn$instance {
}


export type IsUdtReturn = IsUdtReturn$instance;

export abstract class IsVolatile$instance {
}


export type IsVolatile = IsVolatile$instance;

export abstract class RuntimeFeature$instance {
    static readonly portablePdb: string;
    static readonly defaultImplementationsOfInterfaces: string;
    static readonly unmanagedSignatureCallingConvention: string;
    static readonly covariantReturnsOfClasses: string;
    static readonly byRefFields: string;
    static readonly byRefLikeGenerics: string;
    static readonly virtualStaticsInInterfaces: string;
    static readonly numericIntPtr: string;
    static readonly isDynamicCodeSupported: boolean;
    static readonly isDynamicCodeCompiled: boolean;
    static isSupported(feature: string): boolean;
}


export type RuntimeFeature = RuntimeFeature$instance;

export abstract class RuntimeHelpers$instance {
    static readonly offsetToStringData: int;
    static allocateTypeAssociatedMemory(type_: Type, size: int): nint;
    static box(target: { value: ref<byte> }, type_: RuntimeTypeHandle): unknown;
    static createSpan<T>(fldHandle: RuntimeFieldHandle): ReadOnlySpan_1<T>;
    static ensureSufficientExecutionStack(): void;
    static equals(o1: unknown, o2: unknown): boolean;
    static executeCodeWithGuaranteedCleanup(code: RuntimeHelpers_TryCode, backoutCode: RuntimeHelpers_CleanupCode, userData: unknown): void;
    static getHashCode(o: unknown): int;
    static getObjectValue(obj: unknown): unknown;
    static getSubArray<T>(array: T[], range: Range): T[];
    static getUninitializedObject(type_: Type): unknown;
    static initializeArray(array: ClrArray, fldHandle: RuntimeFieldHandle): void;
    static isReferenceOrContainsReferences<T>(): boolean;
    static prepareConstrainedRegions(): void;
    static prepareConstrainedRegionsNoOP(): void;
    static prepareContractedDelegate(d: Function): void;
    static prepareDelegate(d: Function): void;
    static prepareMethod2(method: RuntimeMethodHandle, instantiation: RuntimeTypeHandle[]): void;
    static prepareMethod2(method: RuntimeMethodHandle): void;
    static probeForSufficientStack(): void;
    static runClassConstructor(type_: RuntimeTypeHandle): void;
    static runModuleConstructor(module_: ModuleHandle): void;
    static sizeOf(type_: RuntimeTypeHandle): int;
    static tryEnsureSufficientExecutionStack(): boolean;
}


export type RuntimeHelpers = RuntimeHelpers$instance;

export abstract class RuntimeOps$instance {
    static createRuntimeVariables2(): IRuntimeVariables;
    static createRuntimeVariables2(data: unknown[], indexes: long[]): IRuntimeVariables;
    static expandoCheckVersion(expando: ExpandoObject, version: unknown): boolean;
    static expandoPromoteClass(expando: ExpandoObject, oldClass: unknown, newClass: unknown): void;
    static expandoTryDeleteValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean): boolean;
    static expandoTryGetValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean, value: { value: ref<unknown> }): boolean;
    static expandoTrySetValue(expando: ExpandoObject, indexClass: unknown, index: int, value: unknown, name: string, ignoreCase: boolean): unknown;
    static mergeRuntimeVariables(first: IRuntimeVariables, second: IRuntimeVariables, indexes: int[]): IRuntimeVariables;
    static quote(expression: Expression, hoistedLocals: unknown, locals: unknown[]): Expression;
}


export type RuntimeOps = RuntimeOps$instance;

export abstract class Unsafe$instance {
    static add3<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static add3<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static add3<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static add3<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static addByteOffset2<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static addByteOffset2<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static areSame<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static as_<T>(o: unknown): T;
    static as_<TFrom, TTo>(source: { value: ref<TFrom> }): ref<TTo>;
    static asPointer<T>(value: { value: ref<T> }): ptr<void>;
    static asRef<T>(source: ptr<void>): ref<T>;
    static asRef<T>(source: { value: ref<T> }): ref<T>;
    static bitCast<TFrom, TTo>(source: TFrom): TTo;
    static byteOffset<T>(origin: { value: ref<T> }, target: { value: ref<T> }): nint;
    static copy<T>(destination: ptr<void>, source: { value: ref<T> }): void;
    static copy<T>(destination: { value: ref<T> }, source: ptr<void>): void;
    static copyBlock2(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static copyBlock2(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static copyBlockUnaligned2(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static copyBlockUnaligned2(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static initBlock2(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static initBlock2(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static initBlockUnaligned2(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static initBlockUnaligned2(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static isAddressGreaterThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isAddressGreaterThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isAddressLessThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isAddressLessThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static isNullRef<T>(source: { value: ref<T> }): boolean;
    static nullRef<T>(): ref<T>;
    static read<T>(source: ptr<void>): T;
    static readUnaligned2<T>(source: { value: ref<byte> }): T;
    static readUnaligned2<T>(source: ptr<void>): T;
    static sizeOf<T>(): int;
    static skipInit<T>(value: { value: ref<T> }): void;
    static subtract2<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static subtract2<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static subtract2<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static subtract2<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static subtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static subtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static unbox<T extends unknown>(box: unknown): ref<T>;
    static write<T>(destination: ptr<void>, value: T): void;
    static writeUnaligned2<T>(destination: { value: ref<byte> }, value: T): void;
    static writeUnaligned2<T>(destination: ptr<void>, value: T): void;
}


export type Unsafe = Unsafe$instance;

