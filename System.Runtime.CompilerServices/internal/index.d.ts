// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.CompilerServices
// Assembly: System.Linq.Expressions, System.Private.CoreLib, System.Runtime.CompilerServices.VisualC, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { ContractFailureKind } from "../../System.Diagnostics.Contracts/internal/index.js";
import type { ExpandoObject } from "../../System.Dynamic/internal/index.js";
import type { DebugInfoExpression, Expression, LabelTarget, LambdaExpression, ParameterExpression } from "../../System.Linq.Expressions/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Enum, Exception, FormattableString, Func_2, Func_3, IAsyncResult, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, ModuleHandle, MulticastDelegate, Object as ClrObject, Range, ReadOnlySpan_1, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, Type, TypeCode, UInt32, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CompilationRelaxations {
    NoStringInterning = 8
}


export enum LoadHint {
    Default = 0,
    Always = 1,
    Sometimes = 2
}


export enum MethodCodeType {
    IL = 0,
    Native = 1,
    OPTIL = 2,
    Runtime = 3
}


export enum MethodImplOptions {
    Unmanaged = 4,
    NoInlining = 8,
    ForwardRef = 16,
    Synchronized = 32,
    NoOptimization = 64,
    PreserveSig = 128,
    AggressiveInlining = 256,
    AggressiveOptimization = 512,
    Async = 8192,
    InternalCall = 4096
}


export enum UnsafeAccessorKind {
    Constructor = 0,
    Method = 1,
    StaticMethod = 2,
    Field = 3,
    StaticField = 4
}


export interface IAsyncStateMachine$instance {
    MoveNext(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
}


export type IAsyncStateMachine = IAsyncStateMachine$instance;

export interface ICriticalNotifyCompletion$instance extends INotifyCompletion {
    UnsafeOnCompleted(continuation: Action): void;
}


export interface ICriticalNotifyCompletion$instance extends INotifyCompletion$instance {}

export type ICriticalNotifyCompletion = ICriticalNotifyCompletion$instance;

export interface INotifyCompletion$instance {
    OnCompleted(continuation: Action): void;
}


export type INotifyCompletion = INotifyCompletion$instance;

export interface IRuntimeVariables$instance {
    readonly Count: int;
    Item: unknown;
}


export type IRuntimeVariables = IRuntimeVariables$instance;

export interface IStrongBox$instance {
    Value: unknown;
}


export type IStrongBox = IStrongBox$instance;

export interface ITuple$instance {
    readonly Length: int;
    readonly Item: unknown;
}


export type ITuple = ITuple$instance;

export class AsyncIteratorMethodBuilder$instance {
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    Complete(): void;
    MoveNext<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create(): AsyncIteratorMethodBuilder;
}


export type AsyncIteratorMethodBuilder = AsyncIteratorMethodBuilder$instance;

export class AsyncTaskMethodBuilder$instance {
    readonly Task: Task;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create(): AsyncTaskMethodBuilder;
}


export type AsyncTaskMethodBuilder = AsyncTaskMethodBuilder$instance;

export class AsyncTaskMethodBuilder_1$instance<TResult> {
    readonly Task: Task_1<TResult>;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(result: TResult): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create<TResult>(): AsyncTaskMethodBuilder_1<TResult>;
}


export type AsyncTaskMethodBuilder_1<TResult> = AsyncTaskMethodBuilder_1$instance<TResult>;

export class AsyncValueTaskMethodBuilder$instance {
    readonly Task: ValueTask;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create(): AsyncValueTaskMethodBuilder;
}


export type AsyncValueTaskMethodBuilder = AsyncValueTaskMethodBuilder$instance;

export class AsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly Task: ValueTask_1<TResult>;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(result: TResult): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create<TResult>(): AsyncValueTaskMethodBuilder_1<TResult>;
}


export type AsyncValueTaskMethodBuilder_1<TResult> = AsyncValueTaskMethodBuilder_1$instance<TResult>;

export class AsyncVoidMethodBuilder$instance {
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create(): AsyncVoidMethodBuilder;
}


export type AsyncVoidMethodBuilder = AsyncVoidMethodBuilder$instance;

export class ConfiguredAsyncDisposable$instance {
    DisposeAsync(): ConfiguredValueTaskAwaitable;
}


export type ConfiguredAsyncDisposable = ConfiguredAsyncDisposable$instance;

export class ConfiguredCancelableAsyncEnumerable_1$instance<T> {
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredCancelableAsyncEnumerable_1<T>;
    GetAsyncEnumerator(): ConfiguredCancelableAsyncEnumerable_1_Enumerator<T>;
    WithCancellation(cancellationToken: CancellationToken): ConfiguredCancelableAsyncEnumerable_1<T>;
}


export type ConfiguredCancelableAsyncEnumerable_1<T> = ConfiguredCancelableAsyncEnumerable_1$instance<T>;

export class ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T> {
    readonly Current: T;
    DisposeAsync(): ConfiguredValueTaskAwaitable;
    MoveNextAsync(): ConfiguredValueTaskAwaitable_1<CLROf<boolean>>;
}


export type ConfiguredCancelableAsyncEnumerable_1_Enumerator<T> = ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T>;

export class ConfiguredTaskAwaitable$instance {
    GetAwaiter(): ConfiguredTaskAwaitable_ConfiguredTaskAwaiter;
}


export type ConfiguredTaskAwaitable = ConfiguredTaskAwaitable$instance;

export class ConfiguredTaskAwaitable_1$instance<TResult> {
    GetAwaiter(): ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult>;
}


export type ConfiguredTaskAwaitable_1<TResult> = ConfiguredTaskAwaitable_1$instance<TResult>;

export class ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult> = ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> & __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult>;


export class ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_ConfiguredTaskAwaiter = ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance & __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views;


export class ConfiguredValueTaskAwaitable$instance {
    GetAwaiter(): ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter;
}


export type ConfiguredValueTaskAwaitable = ConfiguredValueTaskAwaitable$instance;

export class ConfiguredValueTaskAwaitable_1$instance<TResult> {
    GetAwaiter(): ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult>;
}


export type ConfiguredValueTaskAwaitable_1<TResult> = ConfiguredValueTaskAwaitable_1$instance<TResult>;

export class ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult> = ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> & __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult>;


export class ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter = ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance & __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views;


export class DefaultInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int);
    constructor(literalLength: int, formattedCount: int, provider: IFormatProvider);
    constructor(literalLength: int, formattedCount: int, provider: IFormatProvider, initialBuffer: Span_1<CLROf<char>>);
    readonly Text: ReadOnlySpan_1<CLROf<char>>;
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: unknown, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
    Clear(): void;
    ToString(): string;
    ToStringAndClear(): string;
}


export type DefaultInterpolatedStringHandler = DefaultInterpolatedStringHandler$instance;

export class InlineArray10_1$instance<T> {
}


export type InlineArray10_1<T> = InlineArray10_1$instance<T>;

export class InlineArray11_1$instance<T> {
}


export type InlineArray11_1<T> = InlineArray11_1$instance<T>;

export class InlineArray12_1$instance<T> {
}


export type InlineArray12_1<T> = InlineArray12_1$instance<T>;

export class InlineArray13_1$instance<T> {
}


export type InlineArray13_1<T> = InlineArray13_1$instance<T>;

export class InlineArray14_1$instance<T> {
}


export type InlineArray14_1<T> = InlineArray14_1$instance<T>;

export class InlineArray15_1$instance<T> {
}


export type InlineArray15_1<T> = InlineArray15_1$instance<T>;

export class InlineArray16_1$instance<T> {
}


export type InlineArray16_1<T> = InlineArray16_1$instance<T>;

export class InlineArray2_1$instance<T> {
}


export type InlineArray2_1<T> = InlineArray2_1$instance<T>;

export class InlineArray3_1$instance<T> {
}


export type InlineArray3_1<T> = InlineArray3_1$instance<T>;

export class InlineArray4_1$instance<T> {
}


export type InlineArray4_1<T> = InlineArray4_1$instance<T>;

export class InlineArray5_1$instance<T> {
}


export type InlineArray5_1<T> = InlineArray5_1$instance<T>;

export class InlineArray6_1$instance<T> {
}


export type InlineArray6_1<T> = InlineArray6_1$instance<T>;

export class InlineArray7_1$instance<T> {
}


export type InlineArray7_1<T> = InlineArray7_1$instance<T>;

export class InlineArray8_1$instance<T> {
}


export type InlineArray8_1<T> = InlineArray8_1$instance<T>;

export class InlineArray9_1$instance<T> {
}


export type InlineArray9_1<T> = InlineArray9_1$instance<T>;

export class PoolingAsyncValueTaskMethodBuilder$instance {
    readonly Task: ValueTask;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create(): PoolingAsyncValueTaskMethodBuilder;
}


export type PoolingAsyncValueTaskMethodBuilder = PoolingAsyncValueTaskMethodBuilder$instance;

export class PoolingAsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly Task: ValueTask_1<TResult>;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(result: TResult): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
    static Create<TResult>(): PoolingAsyncValueTaskMethodBuilder_1<TResult>;
}


export type PoolingAsyncValueTaskMethodBuilder_1<TResult> = PoolingAsyncValueTaskMethodBuilder_1$instance<TResult>;

export class TaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __TaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter = TaskAwaiter$instance & __TaskAwaiter$views;


export class TaskAwaiter_1$instance<TResult> implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __TaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter_1<TResult> = TaskAwaiter_1$instance<TResult> & __TaskAwaiter_1$views<TResult>;


export class ValueTaskAwaiter$instance implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __ValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter = ValueTaskAwaiter$instance & __ValueTaskAwaiter$views;


export class ValueTaskAwaiter_1$instance<TResult> implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __ValueTaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter_1<TResult> = ValueTaskAwaiter_1$instance<TResult> & __ValueTaskAwaiter_1$views<TResult>;


export class YieldAwaitable$instance {
    GetAwaiter(): YieldAwaitable_YieldAwaiter;
}


export type YieldAwaitable = YieldAwaitable$instance;

export class YieldAwaitable_YieldAwaiter$instance implements ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export interface __YieldAwaitable_YieldAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface YieldAwaitable_YieldAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type YieldAwaitable_YieldAwaiter = YieldAwaitable_YieldAwaiter$instance & __YieldAwaitable_YieldAwaiter$views;


export class AccessedThroughPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(propertyName: string);
    readonly PropertyName: string;
}


export type AccessedThroughPropertyAttribute = AccessedThroughPropertyAttribute$instance;

export class AsyncIteratorStateMachineAttribute$instance extends StateMachineAttribute$instance {
    constructor(stateMachineType: Type);
}


export type AsyncIteratorStateMachineAttribute = AsyncIteratorStateMachineAttribute$instance;

export class AsyncMethodBuilderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(builderType: Type);
    readonly BuilderType: Type;
}


export type AsyncMethodBuilderAttribute = AsyncMethodBuilderAttribute$instance;

export class AsyncStateMachineAttribute$instance extends StateMachineAttribute$instance {
    constructor(stateMachineType: Type);
}


export type AsyncStateMachineAttribute = AsyncStateMachineAttribute$instance;

export class CallConvCdecl$instance {
    constructor();
}


export type CallConvCdecl = CallConvCdecl$instance;

export class CallConvFastcall$instance {
    constructor();
}


export type CallConvFastcall = CallConvFastcall$instance;

export class CallConvMemberFunction$instance {
    constructor();
}


export type CallConvMemberFunction = CallConvMemberFunction$instance;

export class CallConvStdcall$instance {
    constructor();
}


export type CallConvStdcall = CallConvStdcall$instance;

export class CallConvSuppressGCTransition$instance {
    constructor();
}


export type CallConvSuppressGCTransition = CallConvSuppressGCTransition$instance;

export class CallConvSwift$instance {
    constructor();
}


export type CallConvSwift = CallConvSwift$instance;

export class CallConvThiscall$instance {
    constructor();
}


export type CallConvThiscall = CallConvThiscall$instance;

export class CallerArgumentExpressionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(parameterName: string);
    readonly ParameterName: string;
}


export type CallerArgumentExpressionAttribute = CallerArgumentExpressionAttribute$instance;

export class CallerFilePathAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CallerFilePathAttribute = CallerFilePathAttribute$instance;

export class CallerLineNumberAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CallerLineNumberAttribute = CallerLineNumberAttribute$instance;

export class CallerMemberNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CallerMemberNameAttribute = CallerMemberNameAttribute$instance;

export class CallSite$instance {
    readonly Binder: CallSiteBinder;
    static Create(delegateType: Type, binder: CallSiteBinder): CallSite;
}


export type CallSite = CallSite$instance;

export class CallSite_1$instance<T> extends CallSite$instance {
    Target: T;
    readonly Update: T;
}


export type CallSite_1<T> = CallSite_1$instance<T>;

export abstract class CallSiteBinder$instance {
    abstract Bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    BindDelegate<T>(site: CallSite_1<T>, args: unknown[]): T;
    static readonly UpdateLabel: LabelTarget;
}


export type CallSiteBinder = CallSiteBinder$instance;

export class Closure$instance {
    constructor(constants: unknown[], locals: unknown[]);
    readonly Constants: unknown[];
    readonly Locals: unknown[];
}


export type Closure = Closure$instance;

export class CollectionBuilderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(builderType: Type, methodName: string);
    readonly BuilderType: Type;
    readonly MethodName: string;
}


export type CollectionBuilderAttribute = CollectionBuilderAttribute$instance;

export class CompilationRelaxationsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(relaxations: int);
    constructor(relaxations: CompilationRelaxations);
    readonly CompilationRelaxations: int;
}


export type CompilationRelaxationsAttribute = CompilationRelaxationsAttribute$instance;

export class CompilerFeatureRequiredAttribute$instance extends System_Internal.Attribute$instance {
    constructor(featureName: string);
    readonly FeatureName: string;
    IsOptional: boolean;
    static readonly RefStructs: string;
    static readonly RequiredMembers: string;
}


export type CompilerFeatureRequiredAttribute = CompilerFeatureRequiredAttribute$instance;

export class CompilerGeneratedAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CompilerGeneratedAttribute = CompilerGeneratedAttribute$instance;

export class CompilerGlobalScopeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CompilerGlobalScopeAttribute = CompilerGlobalScopeAttribute$instance;

export class CompilerLoweringPreserveAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CompilerLoweringPreserveAttribute = CompilerLoweringPreserveAttribute$instance;

export class ConditionalWeakTable_2$instance<TKey, TValue> {
    constructor();
    Add(key: TKey, value: TValue): void;
    AddOrUpdate(key: TKey, value: TValue): void;
    Clear(): void;
    GetOrAdd(key: TKey, value: TValue): TValue;
    GetOrAdd(key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    GetOrAdd<TArg>(key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateValue(key: TKey): TValue;
    GetValue(key: TKey, createValueCallback: ConditionalWeakTable_2_CreateValueCallback<TKey, TValue>): TValue;
    Remove(key: TKey): boolean;
    Remove(key: TKey, value: { value: ref<TValue> }): boolean;
    TryAdd(key: TKey, value: TValue): boolean;
    TryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export interface __ConditionalWeakTable_2$views<TKey, TValue> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ConditionalWeakTable_2$instance<TKey, TValue> extends System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>> {}

export type ConditionalWeakTable_2<TKey, TValue> = ConditionalWeakTable_2$instance<TKey, TValue> & __ConditionalWeakTable_2$views<TKey, TValue>;


export class ConditionalWeakTable_2_CreateValueCallback$instance<TKey, TValue> extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(key: TKey, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): TValue;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(key: TKey): TValue;
}


export interface __ConditionalWeakTable_2_CreateValueCallback$views<TKey, TValue> {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ConditionalWeakTable_2_CreateValueCallback<TKey, TValue> = ConditionalWeakTable_2_CreateValueCallback$instance<TKey, TValue> & __ConditionalWeakTable_2_CreateValueCallback$views<TKey, TValue>;


export class CppInlineNamespaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dottedName: string);
}


export type CppInlineNamespaceAttribute = CppInlineNamespaceAttribute$instance;

export class CreateNewOnMetadataUpdateAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type CreateNewOnMetadataUpdateAttribute = CreateNewOnMetadataUpdateAttribute$instance;

export abstract class CustomConstantAttribute$instance extends System_Internal.Attribute$instance {
    readonly Value: unknown;
}


export type CustomConstantAttribute = CustomConstantAttribute$instance;

export class DateTimeConstantAttribute$instance extends CustomConstantAttribute$instance {
    constructor(ticks: long);
    readonly Value: unknown;
}


export type DateTimeConstantAttribute = DateTimeConstantAttribute$instance;

export abstract class DebugInfoGenerator$instance {
    abstract MarkSequencePoint(method: LambdaExpression, ilOffset: int, sequencePoint: DebugInfoExpression): void;
    static CreatePdbGenerator(): DebugInfoGenerator;
}


export type DebugInfoGenerator = DebugInfoGenerator$instance;

export class DecimalConstantAttribute$instance extends System_Internal.Attribute$instance {
    constructor(scale: byte, sign: byte, hi: uint, mid: uint, low: uint);
    constructor(scale: byte, sign: byte, hi: int, mid: int, low: int);
    readonly Value: decimal;
}


export type DecimalConstantAttribute = DecimalConstantAttribute$instance;

export class DefaultDependencyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(loadHintArgument: LoadHint);
    readonly LoadHint: LoadHint;
}


export type DefaultDependencyAttribute = DefaultDependencyAttribute$instance;

export class DependencyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(dependentAssemblyArgument: string, loadHintArgument: LoadHint);
    readonly DependentAssembly: string;
    readonly LoadHint: LoadHint;
}


export type DependencyAttribute = DependencyAttribute$instance;

export class DisablePrivateReflectionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DisablePrivateReflectionAttribute = DisablePrivateReflectionAttribute$instance;

export class DisableRuntimeMarshallingAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DisableRuntimeMarshallingAttribute = DisableRuntimeMarshallingAttribute$instance;

export class DiscardableAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DiscardableAttribute = DiscardableAttribute$instance;

export class DynamicAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(transformFlags: boolean[]);
    readonly TransformFlags: IList_1<CLROf<boolean>>;
}


export type DynamicAttribute = DynamicAttribute$instance;

export class EnumeratorCancellationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type EnumeratorCancellationAttribute = EnumeratorCancellationAttribute$instance;

export class ExtensionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ExtensionAttribute = ExtensionAttribute$instance;

export class ExtensionMarkerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly Name: string;
}


export type ExtensionMarkerAttribute = ExtensionMarkerAttribute$instance;

export class FixedAddressValueTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type FixedAddressValueTypeAttribute = FixedAddressValueTypeAttribute$instance;

export class FixedBufferAttribute$instance extends System_Internal.Attribute$instance {
    constructor(elementType: Type, length: int);
    readonly ElementType: Type;
    readonly Length: int;
}


export type FixedBufferAttribute = FixedBufferAttribute$instance;

export class HasCopySemanticsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type HasCopySemanticsAttribute = HasCopySemanticsAttribute$instance;

export class IDispatchConstantAttribute$instance extends CustomConstantAttribute$instance {
    constructor();
    readonly Value: unknown;
}


export type IDispatchConstantAttribute = IDispatchConstantAttribute$instance;

export class IndexerNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(indexerName: string);
}


export type IndexerNameAttribute = IndexerNameAttribute$instance;

export class InlineArrayAttribute$instance extends System_Internal.Attribute$instance {
    constructor(length: int);
    readonly Length: int;
}


export type InlineArrayAttribute = InlineArrayAttribute$instance;

export class InternalsVisibleToAttribute$instance extends System_Internal.Attribute$instance {
    constructor(assemblyName: string);
    AllInternalsVisible: boolean;
    readonly AssemblyName: string;
}


export type InternalsVisibleToAttribute = InternalsVisibleToAttribute$instance;

export class InterpolatedStringHandlerArgumentAttribute$instance extends System_Internal.Attribute$instance {
    constructor(argument: string);
    constructor(arguments: string[]);
    readonly Arguments: string[];
}


export type InterpolatedStringHandlerArgumentAttribute = InterpolatedStringHandlerArgumentAttribute$instance;

export class InterpolatedStringHandlerAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type InterpolatedStringHandlerAttribute = InterpolatedStringHandlerAttribute$instance;

export class IsByRefLikeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type IsByRefLikeAttribute = IsByRefLikeAttribute$instance;

export class IsReadOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type IsReadOnlyAttribute = IsReadOnlyAttribute$instance;

export class IsUnmanagedAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type IsUnmanagedAttribute = IsUnmanagedAttribute$instance;

export class IteratorStateMachineAttribute$instance extends StateMachineAttribute$instance {
    constructor(stateMachineType: Type);
}


export type IteratorStateMachineAttribute = IteratorStateMachineAttribute$instance;

export class IUnknownConstantAttribute$instance extends CustomConstantAttribute$instance {
    constructor();
    readonly Value: unknown;
}


export type IUnknownConstantAttribute = IUnknownConstantAttribute$instance;

export class MetadataUpdateOriginalTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(originalType: Type);
    readonly OriginalType: Type;
}


export type MetadataUpdateOriginalTypeAttribute = MetadataUpdateOriginalTypeAttribute$instance;

export class MethodImplAttribute$instance extends System_Internal.Attribute$instance {
    constructor(methodImplOptions: MethodImplOptions);
    constructor(value: short);
    constructor();
    MethodCodeType: MethodCodeType;
    readonly Value: MethodImplOptions;
}


export type MethodImplAttribute = MethodImplAttribute$instance;

export class ModuleInitializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ModuleInitializerAttribute = ModuleInitializerAttribute$instance;

export class NativeCppClassAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type NativeCppClassAttribute = NativeCppClassAttribute$instance;

export class NullableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: byte);
    constructor(value: byte[]);
    readonly NullableFlags: byte[];
}


export type NullableAttribute = NullableAttribute$instance;

export class NullableContextAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: byte);
    readonly Flag: byte;
}


export type NullableContextAttribute = NullableContextAttribute$instance;

export class NullablePublicOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: boolean);
    readonly IncludesInternals: boolean;
}


export type NullablePublicOnlyAttribute = NullablePublicOnlyAttribute$instance;

export class OverloadResolutionPriorityAttribute$instance extends System_Internal.Attribute$instance {
    constructor(priority: int);
    readonly Priority: int;
}


export type OverloadResolutionPriorityAttribute = OverloadResolutionPriorityAttribute$instance;

export class ParamCollectionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ParamCollectionAttribute = ParamCollectionAttribute$instance;

export class PreserveBaseOverridesAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type PreserveBaseOverridesAttribute = PreserveBaseOverridesAttribute$instance;

export class ReadOnlyCollectionBuilder_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(collection: IEnumerable_1<T>);
    Capacity: int;
    readonly Count: int;
    Item: T;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    IndexOf(item: T): int;
    Insert(index: int, item: T): void;
    Remove(item: T): boolean;
    RemoveAt(index: int): void;
    Reverse(): void;
    Reverse(index: int, count: int): void;
    ToArray(): T[];
    ToReadOnlyCollection(): ReadOnlyCollection_1<T>;
}


export interface __ReadOnlyCollectionBuilder_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ReadOnlyCollectionBuilder_1<T> = ReadOnlyCollectionBuilder_1$instance<T> & __ReadOnlyCollectionBuilder_1$views<T>;


export class ReferenceAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(description: string);
    readonly Description: string;
}


export type ReferenceAssemblyAttribute = ReferenceAssemblyAttribute$instance;

export class RefSafetyRulesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(version: int);
    readonly Version: int;
}


export type RefSafetyRulesAttribute = RefSafetyRulesAttribute$instance;

export class RequiredAttributeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(requiredContract: Type);
    readonly RequiredContract: Type;
}


export type RequiredAttributeAttribute = RequiredAttributeAttribute$instance;

export class RequiredMemberAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type RequiredMemberAttribute = RequiredMemberAttribute$instance;

export class RequiresLocationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type RequiresLocationAttribute = RequiresLocationAttribute$instance;

export class RuleCache_1$instance<T> {
}


export type RuleCache_1<T> = RuleCache_1$instance<T>;

export class RuntimeCompatibilityAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    WrapNonExceptionThrows: boolean;
}


export type RuntimeCompatibilityAttribute = RuntimeCompatibilityAttribute$instance;

export class RuntimeHelpers_CleanupCode$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(userData: unknown, exceptionThrown: boolean, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(userData: unknown, exceptionThrown: boolean): void;
}


export interface __RuntimeHelpers_CleanupCode$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeHelpers_CleanupCode = RuntimeHelpers_CleanupCode$instance & __RuntimeHelpers_CleanupCode$views;


export class RuntimeHelpers_TryCode$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(userData: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(userData: unknown): void;
}


export interface __RuntimeHelpers_TryCode$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeHelpers_TryCode = RuntimeHelpers_TryCode$instance & __RuntimeHelpers_TryCode$views;


export class RuntimeWrappedException$instance extends System_Internal.Exception$instance {
    constructor(thrownObject: unknown);
    readonly WrappedException: unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __RuntimeWrappedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeWrappedException = RuntimeWrappedException$instance & __RuntimeWrappedException$views;


export class ScopedRefAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ScopedRefAttribute = ScopedRefAttribute$instance;

export class ScopelessEnumAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type ScopelessEnumAttribute = ScopelessEnumAttribute$instance;

export class SkipLocalsInitAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SkipLocalsInitAttribute = SkipLocalsInitAttribute$instance;

export class SpecialNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SpecialNameAttribute = SpecialNameAttribute$instance;

export class StateMachineAttribute$instance extends System_Internal.Attribute$instance {
    constructor(stateMachineType: Type);
    readonly StateMachineType: Type;
}


export type StateMachineAttribute = StateMachineAttribute$instance;

export class StringFreezingAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type StringFreezingAttribute = StringFreezingAttribute$instance;

export class StrongBox_1$instance<T> {
    constructor();
    constructor(value: T);
    Value: T;
}


export interface __StrongBox_1$views<T> {
    As_IStrongBox(): IStrongBox$instance;
}

export interface StrongBox_1$instance<T> extends IStrongBox$instance {}

export type StrongBox_1<T> = StrongBox_1$instance<T> & __StrongBox_1$views<T>;


export class SuppressIldasmAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SuppressIldasmAttribute = SuppressIldasmAttribute$instance;

export class SwitchExpressionException$instance extends System_Internal.InvalidOperationException$instance {
    constructor();
    constructor(innerException: Exception);
    constructor(unmatchedValue: unknown);
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly Message: string;
    readonly UnmatchedValue: unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SwitchExpressionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SwitchExpressionException = SwitchExpressionException$instance & __SwitchExpressionException$views;


export class TupleElementNamesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(transformNames: string[]);
    readonly TransformNames: IList_1<CLROf<string>>;
}


export type TupleElementNamesAttribute = TupleElementNamesAttribute$instance;

export class TypeForwardedFromAttribute$instance extends System_Internal.Attribute$instance {
    constructor(assemblyFullName: string);
    readonly AssemblyFullName: string;
}


export type TypeForwardedFromAttribute = TypeForwardedFromAttribute$instance;

export class TypeForwardedToAttribute$instance extends System_Internal.Attribute$instance {
    constructor(destination: Type);
    readonly Destination: Type;
}


export type TypeForwardedToAttribute = TypeForwardedToAttribute$instance;

export class UnsafeAccessorAttribute$instance extends System_Internal.Attribute$instance {
    constructor(kind: UnsafeAccessorKind);
    readonly Kind: UnsafeAccessorKind;
    Name: string;
}


export type UnsafeAccessorAttribute = UnsafeAccessorAttribute$instance;

export class UnsafeAccessorTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(typeName: string);
    readonly TypeName: string;
}


export type UnsafeAccessorTypeAttribute = UnsafeAccessorTypeAttribute$instance;

export class UnsafeValueTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type UnsafeValueTypeAttribute = UnsafeValueTypeAttribute$instance;

export abstract class AsyncHelpers$instance {
    static Await<T>(configuredAwaitable: ConfiguredTaskAwaitable_1<T>): T;
    static Await<T>(configuredAwaitable: ConfiguredValueTaskAwaitable_1<T>): T;
    static Await(configuredAwaitable: ConfiguredTaskAwaitable): void;
    static Await(configuredAwaitable: ConfiguredValueTaskAwaitable): void;
    static Await(task: Task): void;
    static Await(task: ValueTask): void;
    static Await<T>(task: Task_1<T>): T;
    static Await<T>(task: ValueTask_1<T>): T;
    static AwaitAwaiter<TAwaiter extends INotifyCompletion>(awaiter: TAwaiter): void;
    static UnsafeAwaitAwaiter<TAwaiter extends ICriticalNotifyCompletion>(awaiter: TAwaiter): void;
}


export type AsyncHelpers = AsyncHelpers$instance;

export abstract class CallSiteHelpers$instance {
    static IsInternalFrame(mb: MethodBase): boolean;
}


export type CallSiteHelpers = CallSiteHelpers$instance;

export abstract class CallSiteOps$instance {
    static AddRule<T>(site: CallSite_1<T>, rule: T): void;
    static Bind<T>(binder: CallSiteBinder, site: CallSite_1<T>, args: unknown[]): T;
    static ClearMatch(site: CallSite): void;
    static CreateMatchmaker<T>(site: CallSite_1<T>): CallSite_1<T>;
    static GetCachedRules<T>(cache: RuleCache_1<T>): T[];
    static GetMatch(site: CallSite): boolean;
    static GetRuleCache<T>(site: CallSite_1<T>): RuleCache_1<T>;
    static GetRules<T>(site: CallSite_1<T>): T[];
    static MoveRule<T>(cache: RuleCache_1<T>, rule: T, i: int): void;
    static SetNotMatched(site: CallSite): boolean;
    static UpdateRules<T>(this_: CallSite_1<T>, matched: int): void;
}


export type CallSiteOps = CallSiteOps$instance;

export abstract class CompilerMarshalOverride$instance {
}


export type CompilerMarshalOverride = CompilerMarshalOverride$instance;

export abstract class ContractHelper$instance {
    static RaiseContractFailedEvent(failureKind: ContractFailureKind, userMessage: string, conditionText: string, innerException: Exception): string;
    static TriggerFailure(kind: ContractFailureKind, displayMessage: string, userMessage: string, conditionText: string, innerException: Exception): void;
}


export type ContractHelper = ContractHelper$instance;

export abstract class FormattableStringFactory$instance {
    static Create(format: string, arguments: unknown[]): FormattableString;
}


export type FormattableStringFactory = FormattableStringFactory$instance;

export abstract class IsBoxed$instance {
}


export type IsBoxed = IsBoxed$instance;

export abstract class IsByValue$instance {
}


export type IsByValue = IsByValue$instance;

export abstract class IsConst$instance {
}


export type IsConst = IsConst$instance;

export abstract class IsCopyConstructed$instance {
}


export type IsCopyConstructed = IsCopyConstructed$instance;

export abstract class IsExplicitlyDereferenced$instance {
}


export type IsExplicitlyDereferenced = IsExplicitlyDereferenced$instance;

export abstract class IsExternalInit$instance {
}


export type IsExternalInit = IsExternalInit$instance;

export abstract class IsImplicitlyDereferenced$instance {
}


export type IsImplicitlyDereferenced = IsImplicitlyDereferenced$instance;

export abstract class IsJitIntrinsic$instance {
}


export type IsJitIntrinsic = IsJitIntrinsic$instance;

export abstract class IsLong$instance {
}


export type IsLong = IsLong$instance;

export abstract class IsPinned$instance {
}


export type IsPinned = IsPinned$instance;

export abstract class IsSignUnspecifiedByte$instance {
}


export type IsSignUnspecifiedByte = IsSignUnspecifiedByte$instance;

export abstract class IsUdtReturn$instance {
}


export type IsUdtReturn = IsUdtReturn$instance;

export abstract class IsVolatile$instance {
}


export type IsVolatile = IsVolatile$instance;

export abstract class RuntimeFeature$instance {
    static readonly PortablePdb: string;
    static readonly DefaultImplementationsOfInterfaces: string;
    static readonly UnmanagedSignatureCallingConvention: string;
    static readonly CovariantReturnsOfClasses: string;
    static readonly ByRefFields: string;
    static readonly ByRefLikeGenerics: string;
    static readonly VirtualStaticsInInterfaces: string;
    static readonly NumericIntPtr: string;
    static readonly IsDynamicCodeSupported: boolean;
    static readonly IsDynamicCodeCompiled: boolean;
    static IsSupported(feature: string): boolean;
}


export type RuntimeFeature = RuntimeFeature$instance;

export abstract class RuntimeHelpers$instance {
    static readonly OffsetToStringData: int;
    static AllocateTypeAssociatedMemory(type_: Type, size: int): nint;
    static Box(target: { value: ref<byte> }, type_: RuntimeTypeHandle): unknown;
    static CreateSpan<T>(fldHandle: RuntimeFieldHandle): ReadOnlySpan_1<T>;
    static EnsureSufficientExecutionStack(): void;
    static Equals(o1: unknown, o2: unknown): boolean;
    static ExecuteCodeWithGuaranteedCleanup(code: RuntimeHelpers_TryCode, backoutCode: RuntimeHelpers_CleanupCode, userData: unknown): void;
    static GetHashCode(o: unknown): int;
    static GetObjectValue(obj: unknown): unknown;
    static GetSubArray<T>(array: T[], range: Range): T[];
    static GetUninitializedObject(type_: Type): unknown;
    static InitializeArray(array: ClrArray, fldHandle: RuntimeFieldHandle): void;
    static IsReferenceOrContainsReferences<T>(): boolean;
    static PrepareConstrainedRegions(): void;
    static PrepareConstrainedRegionsNoOP(): void;
    static PrepareContractedDelegate(d: Function): void;
    static PrepareDelegate(d: Function): void;
    static PrepareMethod(method: RuntimeMethodHandle, instantiation: RuntimeTypeHandle[]): void;
    static PrepareMethod(method: RuntimeMethodHandle): void;
    static ProbeForSufficientStack(): void;
    static RunClassConstructor(type_: RuntimeTypeHandle): void;
    static RunModuleConstructor(module_: ModuleHandle): void;
    static SizeOf(type_: RuntimeTypeHandle): int;
    static TryEnsureSufficientExecutionStack(): boolean;
}


export type RuntimeHelpers = RuntimeHelpers$instance;

export abstract class RuntimeOps$instance {
    static CreateRuntimeVariables(): IRuntimeVariables;
    static CreateRuntimeVariables(data: unknown[], indexes: long[]): IRuntimeVariables;
    static ExpandoCheckVersion(expando: ExpandoObject, version: unknown): boolean;
    static ExpandoPromoteClass(expando: ExpandoObject, oldClass: unknown, newClass: unknown): void;
    static ExpandoTryDeleteValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean): boolean;
    static ExpandoTryGetValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean, value: { value: ref<unknown> }): boolean;
    static ExpandoTrySetValue(expando: ExpandoObject, indexClass: unknown, index: int, value: unknown, name: string, ignoreCase: boolean): unknown;
    static MergeRuntimeVariables(first: IRuntimeVariables, second: IRuntimeVariables, indexes: int[]): IRuntimeVariables;
    static Quote(expression: Expression, hoistedLocals: unknown, locals: unknown[]): Expression;
}


export type RuntimeOps = RuntimeOps$instance;

export abstract class Unsafe$instance {
    static Add<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static Add<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static Add<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static Add<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static AddByteOffset<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static AddByteOffset<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static AreSame<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static As<T>(o: unknown): T;
    static As<TFrom, TTo>(source: { value: ref<TFrom> }): ref<TTo>;
    static AsPointer<T>(value: { value: ref<T> }): ptr<void>;
    static AsRef<T>(source: ptr<void>): ref<T>;
    static AsRef<T>(source: { value: ref<T> }): ref<T>;
    static BitCast<TFrom, TTo>(source: TFrom): TTo;
    static ByteOffset<T>(origin: { value: ref<T> }, target: { value: ref<T> }): nint;
    static Copy<T>(destination: ptr<void>, source: { value: ref<T> }): void;
    static Copy<T>(destination: { value: ref<T> }, source: ptr<void>): void;
    static CopyBlock(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static CopyBlock(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static CopyBlockUnaligned(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static CopyBlockUnaligned(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static InitBlock(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static InitBlock(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static InitBlockUnaligned(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static InitBlockUnaligned(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static IsAddressGreaterThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsAddressGreaterThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsAddressLessThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsAddressLessThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsNullRef<T>(source: { value: ref<T> }): boolean;
    static NullRef<T>(): ref<T>;
    static Read<T>(source: ptr<void>): T;
    static ReadUnaligned<T>(source: { value: ref<byte> }): T;
    static ReadUnaligned<T>(source: ptr<void>): T;
    static SizeOf<T>(): int;
    static SkipInit<T>(value: { value: ref<T> }): void;
    static Subtract<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static Subtract<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static Subtract<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static Subtract<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static SubtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static SubtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static Unbox<T extends unknown>(box: unknown): ref<T>;
    static Write<T>(destination: ptr<void>, value: T): void;
    static WriteUnaligned<T>(destination: { value: ref<byte> }, value: T): void;
    static WriteUnaligned<T>(destination: ptr<void>, value: T): void;
}


export type Unsafe = Unsafe$instance;

