// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography
// Assembly: System.Private.CoreLib, System.Security.Cryptography

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeNCryptKeyHandle, SafeNCryptProviderHandle, SafeNCryptSecretHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString, SecurityElement } from "../../System.Security/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, Nullable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CipherMode {
    CBC = 1,
    ECB = 2,
    OFB = 3,
    CFB = 4,
    CTS = 5
}


export enum CngExportPolicies {
    None = 0,
    AllowExport = 1,
    AllowPlaintextExport = 2,
    AllowArchiving = 4,
    AllowPlaintextArchiving = 8
}


export enum CngKeyCreationOptions {
    None = 0,
    MachineKey = 32,
    OverwriteExistingKey = 128,
    PreferVbs = 65536,
    RequireVbs = 131072,
    UsePerBootKey = 262144
}


export enum CngKeyHandleOpenOptions {
    None = 0,
    EphemeralKey = 1
}


export enum CngKeyOpenOptions {
    None = 0,
    UserKey = 0,
    MachineKey = 32,
    Silent = 64
}


export enum CngKeyUsages {
    None = 0,
    Decryption = 1,
    Signing = 2,
    KeyAgreement = 4,
    AllUsages = 16777215
}


export enum CngPropertyOptions {
    None = 0,
    CustomProperty = 1073741824,
    Persist = -2147483648
}


export enum CngUIProtectionLevels {
    None = 0,
    ProtectKey = 1,
    ForceHighProtection = 2
}


export enum CryptoStreamMode {
    Read = 0,
    Write = 1
}


export enum CspProviderFlags {
    NoFlags = 0,
    UseMachineKeyStore = 1,
    UseDefaultKeyContainer = 2,
    UseNonExportableKey = 4,
    UseExistingKey = 8,
    UseArchivableKey = 16,
    UseUserProtectedKey = 32,
    NoPrompt = 64,
    CreateEphemeralKey = 128
}


export enum DSASignatureFormat {
    IeeeP1363FixedFieldConcatenation = 0,
    Rfc3279DerSequence = 1
}


export enum ECCurve_ECCurveType {
    Implicit = 0,
    PrimeShortWeierstrass = 1,
    PrimeTwistedEdwards = 2,
    PrimeMontgomery = 3,
    Characteristic2 = 4,
    Named = 5
}


export enum ECDiffieHellmanKeyDerivationFunction {
    Hash = 0,
    Hmac = 1,
    Tls = 2
}


export enum ECKeyXmlFormat {
    Rfc4050 = 0
}


export enum FromBase64TransformMode {
    IgnoreWhiteSpaces = 0,
    DoNotIgnoreWhiteSpaces = 1
}


export enum KeyNumber {
    Exchange = 1,
    Signature = 2
}


export enum OidGroup {
    All = 0,
    HashAlgorithm = 1,
    EncryptionAlgorithm = 2,
    PublicKeyAlgorithm = 3,
    SignatureAlgorithm = 4,
    Attribute = 5,
    ExtensionOrAttribute = 6,
    EnhancedKeyUsage = 7,
    Policy = 8,
    Template = 9,
    KeyDerivationFunction = 10
}


export enum PaddingMode {
    None = 1,
    PKCS7 = 2,
    Zeros = 3,
    ANSIX923 = 4,
    ISO10126 = 5
}


export enum PbeEncryptionAlgorithm {
    Unknown = 0,
    Aes128Cbc = 1,
    Aes192Cbc = 2,
    Aes256Cbc = 3,
    TripleDes3KeyPkcs12 = 4
}


export enum RSAEncryptionPaddingMode {
    Pkcs1 = 0,
    Oaep = 1
}


export enum RSASignaturePaddingMode {
    Pkcs1 = 0,
    Pss = 1
}


export interface ICryptoTransform$instance {
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    readonly CanTransformMultipleBlocks: boolean;
    readonly CanReuseTransform: boolean;
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export type ICryptoTransform = ICryptoTransform$instance;

export interface ICspAsymmetricAlgorithm$instance {
    readonly CspKeyContainerInfo: CspKeyContainerInfo;
    ExportCspBlob(includePrivateParameters: boolean): byte[];
    ImportCspBlob(rawData: byte[]): void;
}


export type ICspAsymmetricAlgorithm = ICspAsymmetricAlgorithm$instance;

export class CngProperty$instance {
    constructor(name: string, value: byte[], options: CngPropertyOptions);
    readonly Name: string;
    readonly Options: CngPropertyOptions;
    Equals(obj: any): boolean;
    Equals(other: CngProperty): boolean;
    GetHashCode(): int;
    GetValue(): byte[];
}


export interface __CngProperty$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CngProperty>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngProperty): boolean;
}

export type CngProperty = CngProperty$instance & __CngProperty$views;


export class DSAParameters$instance {
    P: byte[];
    Q: byte[];
    G: byte[];
    Y: byte[];
    J: byte[];
    X: byte[];
    Seed: byte[];
    Counter: int;
}


export type DSAParameters = DSAParameters$instance;

export class ECCurve$instance {
    A: byte[];
    B: byte[];
    G: ECPoint;
    Order: byte[];
    Cofactor: byte[];
    Seed: byte[];
    CurveType: ECCurve_ECCurveType;
    Hash: Nullable_1<HashAlgorithmName>;
    Polynomial: byte[];
    Prime: byte[];
    readonly IsCharacteristic2: boolean;
    readonly IsExplicit: boolean;
    readonly IsNamed: boolean;
    readonly IsPrime: boolean;
    readonly Oid: Oid;
    Validate(): void;
    static CreateFromFriendlyName(oidFriendlyName: string): ECCurve;
    static CreateFromOid(curveOid: Oid): ECCurve;
    static CreateFromValue(oidValue: string): ECCurve;
}


export type ECCurve = ECCurve$instance;

export class ECParameters$instance {
    Q: ECPoint;
    D: byte[];
    Curve: ECCurve;
    Validate(): void;
}


export type ECParameters = ECParameters$instance;

export class ECPoint$instance {
    X: byte[];
    Y: byte[];
}


export type ECPoint = ECPoint$instance;

export class HashAlgorithmName$instance {
    constructor(name: string);
    readonly Name: string;
    Equals(obj: any): boolean;
    Equals(other: HashAlgorithmName): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly MD5: HashAlgorithmName;
    static readonly SHA1: HashAlgorithmName;
    static readonly SHA256: HashAlgorithmName;
    static readonly SHA384: HashAlgorithmName;
    static readonly SHA512: HashAlgorithmName;
    static readonly SHA3_256: HashAlgorithmName;
    static readonly SHA3_384: HashAlgorithmName;
    static readonly SHA3_512: HashAlgorithmName;
    static FromOid(oidValue: string): HashAlgorithmName;
    static TryFromOid(oidValue: string, value: { value: ref<HashAlgorithmName> }): boolean;
}


export interface __HashAlgorithmName$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<HashAlgorithmName>;

    // Structural method bridges for numeric interface constraints
    Equals(other: HashAlgorithmName): boolean;
}

export type HashAlgorithmName = HashAlgorithmName$instance & __HashAlgorithmName$views;


export class PemFields$instance {
    readonly Base64Data: Range;
    readonly DecodedDataLength: int;
    readonly Label: Range;
    readonly Location: Range;
}


export type PemFields = PemFields$instance;

export class RSAParameters$instance {
    D: byte[];
    DP: byte[];
    DQ: byte[];
    Exponent: byte[];
    InverseQ: byte[];
    Modulus: byte[];
    P: byte[];
    Q: byte[];
}


export type RSAParameters = RSAParameters$instance;

export abstract class Aes$instance extends SymmetricAlgorithm$instance {
    DecryptKeyWrapPadded(ciphertext: byte[]): byte[];
    DecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    DecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    Dispose(): void;
    EncryptKeyWrapPadded(plaintext: byte[]): byte[];
    EncryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    EncryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    TryDecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static GetKeyWrapPaddedLength(plaintextLengthInBytes: int): int;
}


export interface __Aes$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Aes = Aes$instance & __Aes$views;


export class AesCcm$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>);
    constructor(key: byte[]);
    Decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    Decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    Dispose(): void;
    Encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    Encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    static readonly NonceByteSizes: KeySizes;
    static readonly TagByteSizes: KeySizes;
    static readonly IsSupported: boolean;
}


export interface __AesCcm$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AesCcm = AesCcm$instance & __AesCcm$views;


export class AesCng$instance extends Aes$instance {
    constructor();
    constructor(keyName: string);
    constructor(keyName: string, provider: CngProvider);
    constructor(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions);
    constructor(key: CngKey);
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateDecryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __AesCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AesCng = AesCng$instance & __AesCng$views;


export class AesCryptoServiceProvider$instance extends Aes$instance {
    constructor();
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __AesCryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AesCryptoServiceProvider = AesCryptoServiceProvider$instance & __AesCryptoServiceProvider$views;


export class AesGcm$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, tagSizeInBytes: int);
    constructor(key: byte[], tagSizeInBytes: int);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>);
    constructor(key: byte[]);
    readonly TagSizeInBytes: Nullable_1<CLROf<int>>;
    Decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    Decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    Dispose(): void;
    Encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    Encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    static readonly NonceByteSizes: KeySizes;
    static readonly TagByteSizes: KeySizes;
    static readonly IsSupported: boolean;
}


export interface __AesGcm$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AesGcm = AesGcm$instance & __AesGcm$views;


export class AesManaged$instance extends Aes$instance {
    constructor();
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __AesManaged$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AesManaged = AesManaged$instance & __AesManaged$views;


export class AsnEncodedData$instance {
    constructor(rawData: byte[]);
    constructor(rawData: ReadOnlySpan_1<CLROf<byte>>);
    constructor(asnEncodedData: AsnEncodedData);
    constructor(oid: Oid, rawData: byte[]);
    constructor(oid: string, rawData: byte[]);
    constructor(oid: Oid, rawData: ReadOnlySpan_1<CLROf<byte>>);
    constructor(oid: string, rawData: ReadOnlySpan_1<CLROf<byte>>);
    Oid: Oid;
    RawData: byte[];
    CopyFrom(asnEncodedData: AsnEncodedData): void;
    Format(multiLine: boolean): string;
}


export type AsnEncodedData = AsnEncodedData$instance;

export class AsnEncodedDataCollection$instance {
    constructor();
    constructor(asnEncodedData: AsnEncodedData);
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly Item: AsnEncodedData;
    readonly SyncRoot: any;
    Add(asnEncodedData: AsnEncodedData): int;
    CopyTo(array: AsnEncodedData[], index: int): void;
    GetEnumerator(): AsnEncodedDataEnumerator;
    Remove(asnEncodedData: AsnEncodedData): void;
}


export interface __AsnEncodedDataCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type AsnEncodedDataCollection = AsnEncodedDataCollection$instance & __AsnEncodedDataCollection$views;


export class AsnEncodedDataEnumerator$instance {
    readonly Current: any | AsnEncodedData;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __AsnEncodedDataEnumerator$views {
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type AsnEncodedDataEnumerator = AsnEncodedDataEnumerator$instance & __AsnEncodedDataEnumerator$views;


export abstract class AsymmetricAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    readonly SignatureAlgorithm: string;
    Clear(): void;
    Dispose(): void;
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    FromXmlString(xmlString: string): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<string>>): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ToXmlString(includePrivateParameters: boolean): string;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKeyPem(destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfoPem(destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    static Create(): AsymmetricAlgorithm;
    static Create(algName: string): AsymmetricAlgorithm;
}


export interface __AsymmetricAlgorithm$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AsymmetricAlgorithm = AsymmetricAlgorithm$instance & __AsymmetricAlgorithm$views;


export abstract class AsymmetricKeyExchangeDeformatter$instance {
    Parameters: string;
    abstract DecryptKeyExchange(rgb: byte[]): byte[];
    abstract SetKey(key: AsymmetricAlgorithm): void;
}


export type AsymmetricKeyExchangeDeformatter = AsymmetricKeyExchangeDeformatter$instance;

export abstract class AsymmetricKeyExchangeFormatter$instance {
    readonly Parameters: string;
    abstract CreateKeyExchange(data: byte[]): byte[];
    abstract CreateKeyExchange(data: byte[], symAlgType: Type): byte[];
    abstract SetKey(key: AsymmetricAlgorithm): void;
}


export type AsymmetricKeyExchangeFormatter = AsymmetricKeyExchangeFormatter$instance;

export abstract class AsymmetricSignatureDeformatter$instance {
    abstract SetHashAlgorithm(strName: string): void;
    abstract SetKey(key: AsymmetricAlgorithm): void;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
}


export type AsymmetricSignatureDeformatter = AsymmetricSignatureDeformatter$instance;

export abstract class AsymmetricSignatureFormatter$instance {
    CreateSignature(hash: HashAlgorithm): byte[];
    CreateSignature(rgbHash: byte[]): byte[];
    abstract SetHashAlgorithm(strName: string): void;
    abstract SetKey(key: AsymmetricAlgorithm): void;
}


export type AsymmetricSignatureFormatter = AsymmetricSignatureFormatter$instance;

export class AuthenticationTagMismatchException$instance extends CryptographicException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AuthenticationTagMismatchException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AuthenticationTagMismatchException = AuthenticationTagMismatchException$instance & __AuthenticationTagMismatchException$views;


export class ChaCha20Poly1305$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>);
    constructor(key: byte[]);
    Decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    Decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    Dispose(): void;
    Encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    Encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    static readonly IsSupported: boolean;
}


export interface __ChaCha20Poly1305$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ChaCha20Poly1305 = ChaCha20Poly1305$instance & __ChaCha20Poly1305$views;


export class CngAlgorithm$instance {
    constructor(algorithm: string);
    readonly Algorithm: string;
    Equals(obj: any): boolean;
    Equals(other: CngAlgorithm): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly Rsa: CngAlgorithm;
    static readonly ECDiffieHellman: CngAlgorithm;
    static readonly ECDiffieHellmanP256: CngAlgorithm;
    static readonly ECDiffieHellmanP384: CngAlgorithm;
    static readonly ECDiffieHellmanP521: CngAlgorithm;
    static readonly ECDsa: CngAlgorithm;
    static readonly ECDsaP256: CngAlgorithm;
    static readonly ECDsaP384: CngAlgorithm;
    static readonly ECDsaP521: CngAlgorithm;
    static readonly MD5: CngAlgorithm;
    static readonly Sha1: CngAlgorithm;
    static readonly Sha256: CngAlgorithm;
    static readonly Sha384: CngAlgorithm;
    static readonly Sha512: CngAlgorithm;
    static readonly MLDsa: CngAlgorithm;
    static readonly MLKem: CngAlgorithm;
    static readonly SlhDsa: CngAlgorithm;
}


export interface __CngAlgorithm$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CngAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngAlgorithm): boolean;
}

export type CngAlgorithm = CngAlgorithm$instance & __CngAlgorithm$views;


export class CngAlgorithmGroup$instance {
    constructor(algorithmGroup: string);
    readonly AlgorithmGroup: string;
    Equals(obj: any): boolean;
    Equals(other: CngAlgorithmGroup): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly DiffieHellman: CngAlgorithmGroup;
    static readonly Dsa: CngAlgorithmGroup;
    static readonly ECDiffieHellman: CngAlgorithmGroup;
    static readonly ECDsa: CngAlgorithmGroup;
    static readonly Rsa: CngAlgorithmGroup;
    static readonly MLDsa: CngAlgorithmGroup;
    static readonly MLKem: CngAlgorithmGroup;
    static readonly SlhDsa: CngAlgorithmGroup;
}


export interface __CngAlgorithmGroup$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CngAlgorithmGroup>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngAlgorithmGroup): boolean;
}

export type CngAlgorithmGroup = CngAlgorithmGroup$instance & __CngAlgorithmGroup$views;


export class CngKey$instance {
    readonly Algorithm: CngAlgorithm;
    readonly AlgorithmGroup: CngAlgorithmGroup;
    readonly ExportPolicy: CngExportPolicies;
    readonly Handle: SafeNCryptKeyHandle;
    readonly IsEphemeral: boolean;
    readonly IsMachineKey: boolean;
    readonly KeyName: string;
    readonly KeySize: int;
    readonly KeyUsage: CngKeyUsages;
    ParentWindowHandle: nint;
    readonly Provider: CngProvider;
    readonly ProviderHandle: SafeNCryptProviderHandle;
    readonly UIPolicy: CngUIPolicy;
    readonly UniqueName: string;
    Delete(): void;
    Dispose(): void;
    Export(format: CngKeyBlobFormat): byte[];
    GetProperty(name: string, options: CngPropertyOptions): CngProperty;
    HasProperty(name: string, options: CngPropertyOptions): boolean;
    SetProperty(property: CngProperty): void;
    static Create(algorithm: CngAlgorithm, keyName: string, creationParameters: CngKeyCreationParameters): CngKey;
    static Create(algorithm: CngAlgorithm, keyName: string): CngKey;
    static Create(algorithm: CngAlgorithm): CngKey;
    static Exists(keyName: string, provider: CngProvider, options: CngKeyOpenOptions): boolean;
    static Exists(keyName: string, provider: CngProvider): boolean;
    static Exists(keyName: string): boolean;
    static Import(keyBlob: byte[], format: CngKeyBlobFormat, provider: CngProvider): CngKey;
    static Import(keyBlob: byte[], format: CngKeyBlobFormat): CngKey;
    static Open(keyHandle: SafeNCryptKeyHandle, keyHandleOpenOptions: CngKeyHandleOpenOptions): CngKey;
    static Open(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): CngKey;
    static Open(keyName: string, provider: CngProvider): CngKey;
    static Open(keyName: string): CngKey;
}


export interface __CngKey$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type CngKey = CngKey$instance & __CngKey$views;


export class CngKeyBlobFormat$instance {
    constructor(format: string);
    readonly Format: string;
    Equals(obj: any): boolean;
    Equals(other: CngKeyBlobFormat): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly EccPrivateBlob: CngKeyBlobFormat;
    static readonly EccPublicBlob: CngKeyBlobFormat;
    static readonly EccFullPrivateBlob: CngKeyBlobFormat;
    static readonly EccFullPublicBlob: CngKeyBlobFormat;
    static readonly GenericPrivateBlob: CngKeyBlobFormat;
    static readonly GenericPublicBlob: CngKeyBlobFormat;
    static readonly PQDsaPublicBlob: CngKeyBlobFormat;
    static readonly PQDsaPrivateBlob: CngKeyBlobFormat;
    static readonly PQDsaPrivateSeedBlob: CngKeyBlobFormat;
    static readonly MLKemPublicBlob: CngKeyBlobFormat;
    static readonly MLKemPrivateBlob: CngKeyBlobFormat;
    static readonly MLKemPrivateSeedBlob: CngKeyBlobFormat;
    static readonly OpaqueTransportBlob: CngKeyBlobFormat;
    static readonly Pkcs8PrivateBlob: CngKeyBlobFormat;
}


export interface __CngKeyBlobFormat$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CngKeyBlobFormat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngKeyBlobFormat): boolean;
}

export type CngKeyBlobFormat = CngKeyBlobFormat$instance & __CngKeyBlobFormat$views;


export class CngKeyCreationParameters$instance {
    constructor();
    ExportPolicy: Nullable_1<CngExportPolicies>;
    KeyCreationOptions: CngKeyCreationOptions;
    KeyUsage: Nullable_1<CngKeyUsages>;
    readonly Parameters: CngPropertyCollection;
    ParentWindowHandle: nint;
    Provider: CngProvider;
    UIPolicy: CngUIPolicy;
}


export type CngKeyCreationParameters = CngKeyCreationParameters$instance;

export class CngPropertyCollection$instance extends System_Collections_ObjectModel_Internal.Collection_1$instance<CngProperty> {
    constructor();
    Add(item: CngProperty): void;
    Add(value: any): int;
    Clear(): void;
    Contains(item: CngProperty): boolean;
    Contains(value: any): boolean;
    CopyTo(array: CngProperty[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator_1<CngProperty>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: CngProperty): int;
    Insert(index: int, item: CngProperty): void;
    Insert(index: int, value: any): void;
    Remove(item: CngProperty): boolean;
    Remove(value: any): void;
    RemoveAt(index: int): void;
}


export interface __CngPropertyCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<CngProperty>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<CngProperty>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<CngProperty>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CngProperty>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type CngPropertyCollection = CngPropertyCollection$instance & __CngPropertyCollection$views;


export class CngProvider$instance {
    constructor(provider: string);
    readonly Provider: string;
    Equals(obj: any): boolean;
    Equals(other: CngProvider): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly MicrosoftPlatformCryptoProvider: CngProvider;
    static readonly MicrosoftSmartCardKeyStorageProvider: CngProvider;
    static readonly MicrosoftSoftwareKeyStorageProvider: CngProvider;
}


export interface __CngProvider$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CngProvider>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngProvider): boolean;
}

export type CngProvider = CngProvider$instance & __CngProvider$views;


export class CngUIPolicy$instance {
    constructor(protectionLevel: CngUIProtectionLevels);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string, creationTitle: string);
    readonly CreationTitle: string;
    readonly Description: string;
    readonly FriendlyName: string;
    readonly ProtectionLevel: CngUIProtectionLevels;
    readonly UseContext: string;
}


export type CngUIPolicy = CngUIPolicy$instance;

export abstract class CompositeMLDsa$instance {
    readonly Algorithm: CompositeMLDsaAlgorithm;
    Dispose(): void;
    ExportCompositeMLDsaPrivateKey(): byte[];
    ExportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): int;
    ExportCompositeMLDsaPublicKey(): byte[];
    ExportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>): int;
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    SignData(data: byte[], context?: byte[]): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): int;
    TryExportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static readonly IsSupported: boolean;
    static GenerateKey(algorithm: CompositeMLDsaAlgorithm): CompositeMLDsa;
    static ImportCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    static ImportCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static ImportCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    static ImportCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): CompositeMLDsa;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): CompositeMLDsa;
    static ImportFromEncryptedPem(source: string, passwordBytes: byte[]): CompositeMLDsa;
    static ImportFromEncryptedPem(source: string, password: string): CompositeMLDsa;
    static ImportFromPem(source: ReadOnlySpan_1<CLROf<string>>): CompositeMLDsa;
    static ImportFromPem(source: string): CompositeMLDsa;
    static ImportPkcs8PrivateKey(source: byte[]): CompositeMLDsa;
    static ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static ImportSubjectPublicKeyInfo(source: byte[]): CompositeMLDsa;
    static ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static IsAlgorithmSupported(algorithm: CompositeMLDsaAlgorithm): boolean;
}


export interface __CompositeMLDsa$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type CompositeMLDsa = CompositeMLDsa$instance & __CompositeMLDsa$views;


export class CompositeMLDsaAlgorithm$instance {
    readonly MaxSignatureSizeInBytes: int;
    readonly Name: string;
    Equals(other: CompositeMLDsaAlgorithm): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly MLDsa44WithRSA2048Pss: CompositeMLDsaAlgorithm;
    static readonly MLDsa44WithRSA2048Pkcs15: CompositeMLDsaAlgorithm;
    static readonly MLDsa44WithEd25519: CompositeMLDsaAlgorithm;
    static readonly MLDsa44WithECDsaP256: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithRSA3072Pss: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithRSA3072Pkcs15: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithRSA4096Pss: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithRSA4096Pkcs15: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithECDsaP256: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithECDsaP384: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithECDsaBrainpoolP256r1: CompositeMLDsaAlgorithm;
    static readonly MLDsa65WithEd25519: CompositeMLDsaAlgorithm;
    static readonly MLDsa87WithECDsaP384: CompositeMLDsaAlgorithm;
    static readonly MLDsa87WithECDsaBrainpoolP384r1: CompositeMLDsaAlgorithm;
    static readonly MLDsa87WithEd448: CompositeMLDsaAlgorithm;
    static readonly MLDsa87WithRSA3072Pss: CompositeMLDsaAlgorithm;
    static readonly MLDsa87WithRSA4096Pss: CompositeMLDsaAlgorithm;
    static readonly MLDsa87WithECDsaP521: CompositeMLDsaAlgorithm;
}


export interface __CompositeMLDsaAlgorithm$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CompositeMLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CompositeMLDsaAlgorithm): boolean;
}

export type CompositeMLDsaAlgorithm = CompositeMLDsaAlgorithm$instance & __CompositeMLDsaAlgorithm$views;


export class CompositeMLDsaCng$instance extends CompositeMLDsa$instance {
    constructor(key: CngKey);
    Dispose(): void;
    GetKey(): CngKey;
}


export interface __CompositeMLDsaCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type CompositeMLDsaCng = CompositeMLDsaCng$instance & __CompositeMLDsaCng$views;


export class CryptoConfig$instance {
    constructor();
    static readonly AllowOnlyFipsAlgorithms: boolean;
    static AddAlgorithm(algorithm: Type, names: string[]): void;
    static AddOID(oid: string, names: string[]): void;
    static CreateFromName(name: string, args: any[]): any;
    static CreateFromName(name: string): any;
    static EncodeOID(str: string): byte[];
    static MapNameToOID(name: string): string;
}


export type CryptoConfig = CryptoConfig$instance;

export class CryptographicException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(hr: int);
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(format: string, insert: string);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CryptographicException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CryptographicException = CryptographicException$instance & __CryptographicException$views;


export class CryptographicUnexpectedOperationException$instance extends CryptographicException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(format: string, insert: string);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CryptographicUnexpectedOperationException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CryptographicUnexpectedOperationException = CryptographicUnexpectedOperationException$instance & __CryptographicUnexpectedOperationException$views;


export class CryptoStream$instance extends System_IO_Internal.Stream$instance {
    constructor(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode);
    constructor(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode, leaveOpen: boolean);
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly HasFlushedFinalBlock: boolean;
    readonly Length: long;
    Position: long;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    Clear(): void;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    FlushFinalBlock(): void;
    FlushFinalBlockAsync(cancellationToken?: CancellationToken): ValueTask;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export interface __CryptoStream$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type CryptoStream = CryptoStream$instance & __CryptoStream$views;


export class CspKeyContainerInfo$instance {
    constructor(parameters: CspParameters);
    readonly Accessible: boolean;
    readonly Exportable: boolean;
    readonly HardwareDevice: boolean;
    readonly KeyContainerName: string;
    readonly KeyNumber: KeyNumber;
    readonly MachineKeyStore: boolean;
    readonly Protected: boolean;
    readonly ProviderName: string;
    readonly ProviderType: int;
    readonly RandomlyGenerated: boolean;
    readonly Removable: boolean;
    readonly UniqueKeyContainerName: string;
}


export type CspKeyContainerInfo = CspKeyContainerInfo$instance;

export class CspParameters$instance {
    constructor();
    constructor(dwTypeIn: int);
    constructor(dwTypeIn: int, strProviderNameIn: string);
    constructor(dwTypeIn: int, strProviderNameIn: string, strContainerNameIn: string);
    ProviderType: int;
    ProviderName: string;
    KeyContainerName: string;
    KeyNumber: int;
    Flags: CspProviderFlags;
    KeyPassword: SecureString;
    ParentWindowHandle: nint;
}


export type CspParameters = CspParameters$instance;

export abstract class DeriveBytes$instance {
    Dispose(): void;
    abstract GetBytes(cb: int): byte[];
    abstract Reset(): void;
}


export interface __DeriveBytes$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DeriveBytes = DeriveBytes$instance & __DeriveBytes$views;


export abstract class DES$instance extends SymmetricAlgorithm$instance {
    Key: byte[];
    Dispose(): void;
    static IsSemiWeakKey(rgbKey: byte[]): boolean;
    static IsWeakKey(rgbKey: byte[]): boolean;
}


export interface __DES$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DES = DES$instance & __DES$views;


export class DESCryptoServiceProvider$instance extends DES$instance {
    constructor();
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __DESCryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DESCryptoServiceProvider = DESCryptoServiceProvider$instance & __DESCryptoServiceProvider$views;


export abstract class DSA$instance extends AsymmetricAlgorithm$instance {
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    abstract ExportParameters(includePrivateParameters: boolean): DSAParameters;
    FromXmlString(xmlString: string): void;
    GetMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<string>>): void;
    abstract ImportParameters(parameters: DSAParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    ToXmlString(includePrivateParameters: boolean): string;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __DSA$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DSA = DSA$instance & __DSA$views;


export class DSACng$instance extends DSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    readonly Key: CngKey;
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    ExportParameters(includePrivateParameters: boolean): DSAParameters;
    ImportParameters(parameters: DSAParameters): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __DSACng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DSACng = DSACng$instance & __DSACng$views;


export class DSACryptoServiceProvider$instance extends DSA$instance {
    constructor();
    constructor(dwKeySize: int);
    constructor(dwKeySize: int, parameters: CspParameters);
    constructor(parameters: CspParameters);
    readonly CspKeyContainerInfo: CspKeyContainerInfo;
    readonly KeyExchangeAlgorithm: string;
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    PersistKeyInCsp: boolean;
    readonly PublicOnly: boolean;
    readonly SignatureAlgorithm: string;
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    ExportCspBlob(includePrivateParameters: boolean): byte[];
    ExportParameters(includePrivateParameters: boolean): DSAParameters;
    FromXmlString(xmlString: string): void;
    ImportCspBlob(keyBlob: byte[]): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: DSAParameters): void;
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignHash(rgbHash: byte[], str: string): byte[];
    ToXmlString(includePrivateParameters: boolean): string;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(rgbHash: byte[], str: string, rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
    static UseMachineKeyStore: boolean;
}


export interface __DSACryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICspAsymmetricAlgorithm: ICspAsymmetricAlgorithm$instance;
}

export type DSACryptoServiceProvider = DSACryptoServiceProvider$instance & __DSACryptoServiceProvider$views;


export class DSAOpenSsl$instance extends DSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(parameters: DSAParameters);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    constructor(handle: nint);
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    ExportParameters(includePrivateParameters: boolean): DSAParameters;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: DSAParameters): void;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __DSAOpenSsl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DSAOpenSsl = DSAOpenSsl$instance & __DSAOpenSsl$views;


export class DSASignatureDeformatter$instance extends AsymmetricSignatureDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export type DSASignatureDeformatter = DSASignatureDeformatter$instance;

export class DSASignatureFormatter$instance extends AsymmetricSignatureFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(hash: HashAlgorithm): byte[];
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
}


export type DSASignatureFormatter = DSASignatureFormatter$instance;

export abstract class ECAlgorithm$instance extends AsymmetricAlgorithm$instance {
    Dispose(): void;
    ExportECPrivateKey(): byte[];
    ExportECPrivateKeyPem(): string;
    ExportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    ExportParameters(includePrivateParameters: boolean): ECParameters;
    GenerateKey(curve: ECCurve): void;
    ImportECPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<string>>): void;
    ImportParameters(parameters: ECParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    TryExportECPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportECPrivateKeyPem(destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __ECAlgorithm$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECAlgorithm = ECAlgorithm$instance & __ECAlgorithm$views;


export abstract class ECDiffieHellman$instance extends ECAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    readonly PublicKey: ECDiffieHellmanPublicKey;
    readonly SignatureAlgorithm: string;
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    DeriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    DeriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    ToXmlString(includePrivateParameters: boolean): string;
    static Create(): ECDiffieHellman;
    static Create(curve: ECCurve): ECDiffieHellman;
    static Create(parameters: ECParameters): ECDiffieHellman;
    static Create(algorithm: string): ECDiffieHellman;
}


export interface __ECDiffieHellman$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDiffieHellman = ECDiffieHellman$instance & __ECDiffieHellman$views;


export class ECDiffieHellmanCng$instance extends ECDiffieHellman$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    constructor(curve: ECCurve);
    HashAlgorithm: CngAlgorithm;
    HmacKey: byte[];
    readonly Key: CngKey;
    KeyDerivationFunction: ECDiffieHellmanKeyDerivationFunction;
    Label: byte[];
    readonly PublicKey: ECDiffieHellmanPublicKey;
    SecretAppend: byte[];
    SecretPrepend: byte[];
    Seed: byte[];
    readonly UseSecretAgreementAsHmacKey: boolean;
    DeriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    DeriveSecretAgreementHandle(otherPartyPublicKey: CngKey): SafeNCryptSecretHandle;
    DeriveSecretAgreementHandle(otherPartyPublicKey: ECDiffieHellmanPublicKey): SafeNCryptSecretHandle;
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    ToXmlString(includePrivateParameters: boolean): string;
}


export interface __ECDiffieHellmanCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanCng = ECDiffieHellmanCng$instance & __ECDiffieHellmanCng$views;


export class ECDiffieHellmanCngPublicKey$instance extends ECDiffieHellmanPublicKey$instance {
    readonly BlobFormat: CngKeyBlobFormat;
    Dispose(): void;
    Import(): CngKey;
    ToXmlString(): string;
    static FromByteArray(publicKeyBlob: byte[], format: CngKeyBlobFormat): ECDiffieHellmanPublicKey;
    static FromXmlString(xml: string): ECDiffieHellmanCngPublicKey;
}


export interface __ECDiffieHellmanCngPublicKey$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanCngPublicKey = ECDiffieHellmanCngPublicKey$instance & __ECDiffieHellmanCngPublicKey$views;


export class ECDiffieHellmanOpenSsl$instance extends ECDiffieHellman$instance {
    constructor(curve: ECCurve);
    constructor();
    constructor(keySize: int);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    constructor(handle: nint);
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    readonly PublicKey: ECDiffieHellmanPublicKey;
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    DeriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    DeriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    DeriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    ExportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    ExportParameters(includePrivateParameters: boolean): ECParameters;
    GenerateKey(curve: ECCurve): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: ECParameters): void;
}


export interface __ECDiffieHellmanOpenSsl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanOpenSsl = ECDiffieHellmanOpenSsl$instance & __ECDiffieHellmanOpenSsl$views;


export abstract class ECDiffieHellmanPublicKey$instance {
    Dispose(): void;
    ExportExplicitParameters(): ECParameters;
    ExportParameters(): ECParameters;
    ExportSubjectPublicKeyInfo(): byte[];
    ToByteArray(): byte[];
    ToXmlString(): string;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __ECDiffieHellmanPublicKey$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanPublicKey = ECDiffieHellmanPublicKey$instance & __ECDiffieHellmanPublicKey$views;


export abstract class ECDsa$instance extends ECAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    readonly SignatureAlgorithm: string;
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    GetMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    SignHash(hash: byte[]): byte[];
    ToXmlString(includePrivateParameters: boolean): string;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: byte[], signature: byte[]): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
    static Create(): ECDsa;
    static Create(curve: ECCurve): ECDsa;
    static Create(parameters: ECParameters): ECDsa;
    static Create(algorithm: string): ECDsa;
}


export interface __ECDsa$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDsa = ECDsa$instance & __ECDsa$views;


export class ECDsaCng$instance extends ECDsa$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    constructor(curve: ECCurve);
    HashAlgorithm: CngAlgorithm;
    readonly Key: CngKey;
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    SignHash(hash: byte[]): byte[];
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    ToXmlString(includePrivateParameters: boolean): string;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: byte[], signature: byte[]): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __ECDsaCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDsaCng = ECDsaCng$instance & __ECDsaCng$views;


export class ECDsaOpenSsl$instance extends ECDsa$instance {
    constructor(curve: ECCurve);
    constructor();
    constructor(keySize: int);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    constructor(handle: nint);
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    ExportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    ExportParameters(includePrivateParameters: boolean): ECParameters;
    GenerateKey(curve: ECCurve): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: ECParameters): void;
    SignHash(hash: byte[]): byte[];
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyHash(hash: byte[], signature: byte[]): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __ECDsaOpenSsl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ECDsaOpenSsl = ECDsaOpenSsl$instance & __ECDsaOpenSsl$views;


export class FromBase64Transform$instance {
    constructor();
    constructor(whitespaces: FromBase64TransformMode);
    readonly CanReuseTransform: boolean;
    readonly CanTransformMultipleBlocks: boolean;
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    Clear(): void;
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __FromBase64Transform$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type FromBase64Transform = FromBase64Transform$instance & __FromBase64Transform$views;


export abstract class HashAlgorithm$instance {
    readonly CanReuseTransform: boolean;
    readonly CanTransformMultipleBlocks: boolean;
    readonly Hash: byte[];
    readonly HashSize: int;
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    Clear(): void;
    ComputeHash(buffer: byte[]): byte[];
    ComputeHash(buffer: byte[], offset: int, count: int): byte[];
    ComputeHash(inputStream: Stream): byte[];
    ComputeHashAsync(inputStream: Stream, cancellationToken?: CancellationToken): Task_1<byte[]>;
    Dispose(): void;
    abstract Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    TryComputeHash(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static Create(): HashAlgorithm;
    static Create(hashName: string): HashAlgorithm;
}


export interface __HashAlgorithm$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HashAlgorithm = HashAlgorithm$instance & __HashAlgorithm$views;


export abstract class HMAC$instance extends KeyedHashAlgorithm$instance {
    HashName: string;
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __HMAC$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMAC = HMAC$instance & __HMAC$views;


export class HMACMD5$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACMD5$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACMD5 = HMACMD5$instance & __HMACMD5$views;


export class HMACSHA1$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    constructor(key: byte[], useManagedSha1: boolean);
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA1$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACSHA1 = HMACSHA1$instance & __HMACSHA1$views;


export class HMACSHA256$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA256$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACSHA256 = HMACSHA256$instance & __HMACSHA256$views;


export class HMACSHA3_256$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static readonly IsSupported: boolean;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA3_256$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACSHA3_256 = HMACSHA3_256$instance & __HMACSHA3_256$views;


export class HMACSHA3_384$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static readonly IsSupported: boolean;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA3_384$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACSHA3_384 = HMACSHA3_384$instance & __HMACSHA3_384$views;


export class HMACSHA3_512$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static readonly IsSupported: boolean;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA3_512$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACSHA3_512 = HMACSHA3_512$instance & __HMACSHA3_512$views;


export class HMACSHA384$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    Key: byte[];
    ProduceLegacyHmacValues: boolean;
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA384$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACSHA384 = HMACSHA384$instance & __HMACSHA384$views;


export class HMACSHA512$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    Key: byte[];
    ProduceLegacyHmacValues: boolean;
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(key: byte[], source: byte[]): byte[];
    static HashData(key: byte[], source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA512$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type HMACSHA512 = HMACSHA512$instance & __HMACSHA512$views;


export class IncrementalHash$instance {
    readonly AlgorithmName: HashAlgorithmName;
    readonly HashLengthInBytes: int;
    AppendData(data: byte[]): void;
    AppendData(data: byte[], offset: int, count: int): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): IncrementalHash;
    Dispose(): void;
    GetCurrentHash(): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): int;
    GetHashAndReset(): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): int;
    TryGetCurrentHash(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryGetHashAndReset(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static CreateHash(hashAlgorithm: HashAlgorithmName): IncrementalHash;
    static CreateHMAC(hashAlgorithm: HashAlgorithmName, key: byte[]): IncrementalHash;
    static CreateHMAC(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>): IncrementalHash;
}


export interface __IncrementalHash$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type IncrementalHash = IncrementalHash$instance & __IncrementalHash$views;


export abstract class KeyedHashAlgorithm$instance extends HashAlgorithm$instance {
    Key: byte[];
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __KeyedHashAlgorithm$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type KeyedHashAlgorithm = KeyedHashAlgorithm$instance & __KeyedHashAlgorithm$views;


export class KeySizes$instance {
    constructor(minSize: int, maxSize: int, skipSize: int);
    readonly MaxSize: int;
    readonly MinSize: int;
    readonly SkipSize: int;
}


export type KeySizes = KeySizes$instance;

export class Kmac128$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Kmac128;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly IsSupported: boolean;
    static HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Kmac128$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Kmac128 = Kmac128$instance & __Kmac128$views;


export class Kmac256$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Kmac256;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly IsSupported: boolean;
    static HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Kmac256$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Kmac256 = Kmac256$instance & __Kmac256$views;


export class KmacXof128$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): KmacXof128;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly IsSupported: boolean;
    static HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __KmacXof128$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type KmacXof128 = KmacXof128$instance & __KmacXof128$views;


export class KmacXof256$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): KmacXof256;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly IsSupported: boolean;
    static HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __KmacXof256$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type KmacXof256 = KmacXof256$instance & __KmacXof256$views;


export abstract class MaskGenerationMethod$instance {
    abstract GenerateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export type MaskGenerationMethod = MaskGenerationMethod$instance;

export abstract class MD5$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __MD5$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type MD5 = MD5$instance & __MD5$views;


export class MD5CryptoServiceProvider$instance extends MD5$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __MD5CryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type MD5CryptoServiceProvider = MD5CryptoServiceProvider$instance & __MD5CryptoServiceProvider$views;


export abstract class MLDsa$instance {
    readonly Algorithm: MLDsaAlgorithm;
    Dispose(): void;
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportMLDsaPrivateKey(): byte[];
    ExportMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    ExportMLDsaPrivateSeed(): byte[];
    ExportMLDsaPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    ExportMLDsaPublicKey(): byte[];
    ExportMLDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignData(data: byte[], context?: byte[]): byte[];
    SignMu(externalMu: byte[]): byte[];
    SignMu(externalMu: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    SignPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    VerifyMu(externalMu: byte[], signature: byte[]): boolean;
    VerifyMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
    static readonly IsSupported: boolean;
    static GenerateKey(algorithm: MLDsaAlgorithm): MLDsa;
    static ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLDsa;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): MLDsa;
    static ImportFromEncryptedPem(source: string, passwordBytes: byte[]): MLDsa;
    static ImportFromEncryptedPem(source: string, password: string): MLDsa;
    static ImportFromPem(source: ReadOnlySpan_1<CLROf<string>>): MLDsa;
    static ImportFromPem(source: string): MLDsa;
    static ImportMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    static ImportMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static ImportMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    static ImportMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static ImportMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    static ImportMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static ImportPkcs8PrivateKey(source: byte[]): MLDsa;
    static ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static ImportSubjectPublicKeyInfo(source: byte[]): MLDsa;
    static ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
}


export interface __MLDsa$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MLDsa = MLDsa$instance & __MLDsa$views;


export class MLDsaAlgorithm$instance {
    readonly MuSizeInBytes: int;
    readonly Name: string;
    readonly PrivateKeySizeInBytes: int;
    readonly PrivateSeedSizeInBytes: int;
    readonly PublicKeySizeInBytes: int;
    readonly SignatureSizeInBytes: int;
    Equals(other: MLDsaAlgorithm): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly MLDsa44: MLDsaAlgorithm;
    static readonly MLDsa65: MLDsaAlgorithm;
    static readonly MLDsa87: MLDsaAlgorithm;
}


export interface __MLDsaAlgorithm$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<MLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MLDsaAlgorithm): boolean;
}

export type MLDsaAlgorithm = MLDsaAlgorithm$instance & __MLDsaAlgorithm$views;


export class MLDsaCng$instance extends MLDsa$instance {
    constructor(key: CngKey);
    Dispose(): void;
    GetKey(): CngKey;
}


export interface __MLDsaCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MLDsaCng = MLDsaCng$instance & __MLDsaCng$views;


export class MLDsaOpenSsl$instance extends MLDsa$instance {
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
}


export interface __MLDsaOpenSsl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MLDsaOpenSsl = MLDsaOpenSsl$instance & __MLDsaOpenSsl$views;


export abstract class MLKem$instance {
    readonly Algorithm: MLKemAlgorithm;
    Decapsulate(ciphertext: ReadOnlySpan_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    Decapsulate(ciphertext: byte[]): byte[];
    Dispose(): void;
    Encapsulate(ciphertext: Span_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    Encapsulate(ciphertext: { value: ref<byte[]> }, sharedSecret: { value: ref<byte[]> }): void;
    ExportDecapsulationKey(destination: Span_1<CLROf<byte>>): void;
    ExportDecapsulationKey(): byte[];
    ExportEncapsulationKey(destination: Span_1<CLROf<byte>>): void;
    ExportEncapsulationKey(): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    ExportPrivateSeed(): byte[];
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static readonly IsSupported: boolean;
    static GenerateKey(algorithm: MLKemAlgorithm): MLKem;
    static ImportDecapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    static ImportDecapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static ImportEncapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    static ImportEncapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLKem;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): MLKem;
    static ImportFromEncryptedPem(source: string, passwordBytes: byte[]): MLKem;
    static ImportFromEncryptedPem(source: string, password: string): MLKem;
    static ImportFromPem(source: ReadOnlySpan_1<CLROf<string>>): MLKem;
    static ImportFromPem(source: string): MLKem;
    static ImportPkcs8PrivateKey(source: byte[]): MLKem;
    static ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static ImportPrivateSeed(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    static ImportPrivateSeed(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static ImportSubjectPublicKeyInfo(source: byte[]): MLKem;
    static ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
}


export interface __MLKem$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MLKem = MLKem$instance & __MLKem$views;


export class MLKemAlgorithm$instance {
    readonly CiphertextSizeInBytes: int;
    readonly DecapsulationKeySizeInBytes: int;
    readonly EncapsulationKeySizeInBytes: int;
    readonly Name: string;
    readonly PrivateSeedSizeInBytes: int;
    readonly SharedSecretSizeInBytes: int;
    Equals(other: MLKemAlgorithm): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly MLKem512: MLKemAlgorithm;
    static readonly MLKem768: MLKemAlgorithm;
    static readonly MLKem1024: MLKemAlgorithm;
}


export interface __MLKemAlgorithm$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<MLKemAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MLKemAlgorithm): boolean;
}

export type MLKemAlgorithm = MLKemAlgorithm$instance & __MLKemAlgorithm$views;


export class MLKemCng$instance extends MLKem$instance {
    constructor(key: CngKey);
    Dispose(): void;
    GetKey(): CngKey;
}


export interface __MLKemCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MLKemCng = MLKemCng$instance & __MLKemCng$views;


export class MLKemOpenSsl$instance extends MLKem$instance {
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
}


export interface __MLKemOpenSsl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MLKemOpenSsl = MLKemOpenSsl$instance & __MLKemOpenSsl$views;


export class Oid$instance {
    constructor();
    constructor(oid: string);
    constructor(value: string, friendlyName: string);
    constructor(oid: Oid);
    FriendlyName: string;
    Value: string;
    static FromFriendlyName(friendlyName: string, group: OidGroup): Oid;
    static FromOidValue(oidValue: string, group: OidGroup): Oid;
}


export type Oid = Oid$instance;

export class OidCollection$instance {
    constructor();
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: any;
    Add(oid: Oid): int;
    CopyTo(array: Oid[], index: int): void;
    get_Item(index: int): Oid;
    get_Item(oid: string): Oid;
    GetEnumerator(): OidEnumerator;
}


export interface __OidCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type OidCollection = OidCollection$instance & __OidCollection$views;


export class OidEnumerator$instance {
    readonly Current: any | Oid;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __OidEnumerator$views {
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type OidEnumerator = OidEnumerator$instance & __OidEnumerator$views;


export class PasswordDeriveBytes$instance extends DeriveBytes$instance {
    constructor(strPassword: string, rgbSalt: byte[]);
    constructor(password: byte[], salt: byte[]);
    constructor(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int);
    constructor(password: byte[], salt: byte[], hashName: string, iterations: int);
    constructor(strPassword: string, rgbSalt: byte[], cspParams: CspParameters);
    constructor(password: byte[], salt: byte[], cspParams: CspParameters);
    constructor(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int, cspParams: CspParameters);
    constructor(password: byte[], salt: byte[], hashName: string, iterations: int, cspParams: CspParameters);
    HashName: string;
    IterationCount: int;
    Salt: byte[];
    CryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    Dispose(): void;
    GetBytes(cb: int): byte[];
    Reset(): void;
}


export interface __PasswordDeriveBytes$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type PasswordDeriveBytes = PasswordDeriveBytes$instance & __PasswordDeriveBytes$views;


export class PbeParameters$instance {
    constructor(encryptionAlgorithm: PbeEncryptionAlgorithm, hashAlgorithm: HashAlgorithmName, iterationCount: int);
    readonly EncryptionAlgorithm: PbeEncryptionAlgorithm;
    readonly HashAlgorithm: HashAlgorithmName;
    readonly IterationCount: int;
}


export type PbeParameters = PbeParameters$instance;

export class PKCS1MaskGenerationMethod$instance extends MaskGenerationMethod$instance {
    constructor();
    HashName: string;
    GenerateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export type PKCS1MaskGenerationMethod = PKCS1MaskGenerationMethod$instance;

export abstract class RandomNumberGenerator$instance {
    Dispose(): void;
    GetBytes(data: byte[]): void;
    GetBytes(data: byte[], offset: int, count: int): void;
    GetBytes(data: Span_1<CLROf<byte>>): void;
    GetNonZeroBytes(data: byte[]): void;
    GetNonZeroBytes(data: Span_1<CLROf<byte>>): void;
    static Create(): RandomNumberGenerator;
    static Create(rngName: string): RandomNumberGenerator;
    static Fill(data: Span_1<CLROf<byte>>): void;
    static GetBytes(count: int): byte[];
    static GetHexString(stringLength: int, lowercase?: boolean): string;
    static GetHexString(destination: Span_1<CLROf<string>>, lowercase?: boolean): void;
    static GetInt32(fromInclusive: int, toExclusive: int): int;
    static GetInt32(toExclusive: int): int;
    static GetItems<T>(choices: ReadOnlySpan_1<T>, destination: Span_1<T>): void;
    static GetItems<T>(choices: ReadOnlySpan_1<T>, length: int): T[];
    static GetString(choices: ReadOnlySpan_1<CLROf<string>>, length: int): string;
    static Shuffle<T>(values: Span_1<T>): void;
}


export interface __RandomNumberGenerator$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RandomNumberGenerator = RandomNumberGenerator$instance & __RandomNumberGenerator$views;


export abstract class RC2$instance extends SymmetricAlgorithm$instance {
    EffectiveKeySize: int;
    KeySize: int;
    Dispose(): void;
}


export interface __RC2$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RC2 = RC2$instance & __RC2$views;


export class RC2CryptoServiceProvider$instance extends RC2$instance {
    constructor();
    BlockSize: int;
    EffectiveKeySize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    UseSalt: boolean;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __RC2CryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RC2CryptoServiceProvider = RC2CryptoServiceProvider$instance & __RC2CryptoServiceProvider$views;


export class Rfc2898DeriveBytes$instance extends DeriveBytes$instance {
    constructor(password: byte[], salt: byte[], iterations: int);
    constructor(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName);
    constructor(password: string, salt: byte[]);
    constructor(password: string, salt: byte[], iterations: int);
    constructor(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName);
    constructor(password: string, saltSize: int);
    constructor(password: string, saltSize: int, iterations: int);
    constructor(password: string, saltSize: int, iterations: int, hashAlgorithm: HashAlgorithmName);
    readonly HashAlgorithm: HashAlgorithmName;
    IterationCount: int;
    Salt: byte[];
    CryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    Dispose(): void;
    GetBytes(cb: int): byte[];
    Reset(): void;
    static Pbkdf2(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    static Pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    static Pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    static Pbkdf2(password: ReadOnlySpan_1<CLROf<string>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    static Pbkdf2(password: ReadOnlySpan_1<CLROf<string>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    static Pbkdf2(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
}


export interface __Rfc2898DeriveBytes$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Rfc2898DeriveBytes = Rfc2898DeriveBytes$instance & __Rfc2898DeriveBytes$views;


export abstract class Rijndael$instance extends SymmetricAlgorithm$instance {
    Dispose(): void;
}


export interface __Rijndael$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Rijndael = Rijndael$instance & __Rijndael$views;


export class RijndaelManaged$instance extends Rijndael$instance {
    constructor();
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __RijndaelManaged$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RijndaelManaged = RijndaelManaged$instance & __RijndaelManaged$views;


export class RNGCryptoServiceProvider$instance extends RandomNumberGenerator$instance {
    constructor();
    constructor(str: string);
    constructor(rgb: byte[]);
    constructor(cspParams: CspParameters);
    Dispose(): void;
    GetBytes(data: byte[]): void;
    GetBytes(data: byte[], offset: int, count: int): void;
    GetBytes(data: Span_1<CLROf<byte>>): void;
    GetBytes(data: Span_1<CLROf<byte>>): void;
    GetNonZeroBytes(data: byte[]): void;
    GetNonZeroBytes(data: Span_1<CLROf<byte>>): void;
    GetNonZeroBytes(data: Span_1<CLROf<byte>>): void;
}


export interface __RNGCryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RNGCryptoServiceProvider = RNGCryptoServiceProvider$instance & __RNGCryptoServiceProvider$views;


export abstract class RSA$instance extends AsymmetricAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    readonly SignatureAlgorithm: string;
    Decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    DecryptValue(rgb: byte[]): byte[];
    Dispose(): void;
    Encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    EncryptValue(rgb: byte[]): byte[];
    abstract ExportParameters(includePrivateParameters: boolean): RSAParameters;
    ExportRSAPrivateKey(): byte[];
    ExportRSAPrivateKeyPem(): string;
    ExportRSAPublicKey(): byte[];
    ExportRSAPublicKeyPem(): string;
    FromXmlString(xmlString: string): void;
    GetMaxOutputSize(): int;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<string>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<string>>): void;
    abstract ImportParameters(parameters: RSAParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    SignHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    ToXmlString(includePrivateParameters: boolean): string;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKeyPem(destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKeyPem(destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export interface __RSA$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RSA = RSA$instance & __RSA$views;


export class RSACng$instance extends RSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    readonly Key: CngKey;
    Dispose(): void;
    ExportParameters(includePrivateParameters: boolean): RSAParameters;
    ImportParameters(parameters: RSAParameters): void;
}


export interface __RSACng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RSACng = RSACng$instance & __RSACng$views;


export class RSACryptoServiceProvider$instance extends RSA$instance {
    constructor();
    constructor(dwKeySize: int);
    constructor(dwKeySize: int, parameters: CspParameters);
    constructor(parameters: CspParameters);
    readonly CspKeyContainerInfo: CspKeyContainerInfo;
    readonly KeyExchangeAlgorithm: string;
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    PersistKeyInCsp: boolean;
    readonly PublicOnly: boolean;
    readonly SignatureAlgorithm: string;
    Decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    Dispose(): void;
    Encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    ExportCspBlob(includePrivateParameters: boolean): byte[];
    ExportParameters(includePrivateParameters: boolean): RSAParameters;
    FromXmlString(xmlString: string): void;
    ImportCspBlob(keyBlob: byte[]): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: RSAParameters): void;
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    SignHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    ToXmlString(includePrivateParameters: boolean): string;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    static UseMachineKeyStore: boolean;
}


export interface __RSACryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICspAsymmetricAlgorithm: ICspAsymmetricAlgorithm$instance;
}

export type RSACryptoServiceProvider = RSACryptoServiceProvider$instance & __RSACryptoServiceProvider$views;


export class RSAEncryptionPadding$instance {
    readonly Mode: RSAEncryptionPaddingMode;
    readonly OaepHashAlgorithm: HashAlgorithmName;
    Equals(obj: any): boolean;
    Equals(other: RSAEncryptionPadding): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly Pkcs1: RSAEncryptionPadding;
    static readonly OaepSHA1: RSAEncryptionPadding;
    static readonly OaepSHA256: RSAEncryptionPadding;
    static readonly OaepSHA384: RSAEncryptionPadding;
    static readonly OaepSHA512: RSAEncryptionPadding;
    static readonly OaepSHA3_256: RSAEncryptionPadding;
    static readonly OaepSHA3_384: RSAEncryptionPadding;
    static readonly OaepSHA3_512: RSAEncryptionPadding;
    static CreateOaep(hashAlgorithm: HashAlgorithmName): RSAEncryptionPadding;
}


export interface __RSAEncryptionPadding$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<RSAEncryptionPadding>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RSAEncryptionPadding): boolean;
}

export type RSAEncryptionPadding = RSAEncryptionPadding$instance & __RSAEncryptionPadding$views;


export class RSAOAEPKeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    Parameters: string;
    DecryptKeyExchange(rgbData: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export type RSAOAEPKeyExchangeDeformatter = RSAOAEPKeyExchangeDeformatter$instance;

export class RSAOAEPKeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    Parameter: byte[];
    readonly Parameters: string;
    Rng: RandomNumberGenerator;
    CreateKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    CreateKeyExchange(rgbData: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export type RSAOAEPKeyExchangeFormatter = RSAOAEPKeyExchangeFormatter$instance;

export class RSAOpenSsl$instance extends RSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(parameters: RSAParameters);
    constructor(handle: nint);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    Decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    Encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    ExportParameters(includePrivateParameters: boolean): RSAParameters;
    ExportPkcs8PrivateKey(): byte[];
    ExportRSAPrivateKey(): byte[];
    ExportRSAPublicKey(): byte[];
    ExportSubjectPublicKeyInfo(): byte[];
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: RSAParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    SignHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    VerifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export interface __RSAOpenSsl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type RSAOpenSsl = RSAOpenSsl$instance & __RSAOpenSsl$views;


export class RSAPKCS1KeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    Parameters: string;
    RNG: RandomNumberGenerator;
    DecryptKeyExchange(rgbIn: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export type RSAPKCS1KeyExchangeDeformatter = RSAPKCS1KeyExchangeDeformatter$instance;

export class RSAPKCS1KeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    readonly Parameters: string;
    Rng: RandomNumberGenerator;
    CreateKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    CreateKeyExchange(rgbData: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export type RSAPKCS1KeyExchangeFormatter = RSAPKCS1KeyExchangeFormatter$instance;

export class RSAPKCS1SignatureDeformatter$instance extends AsymmetricSignatureDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export type RSAPKCS1SignatureDeformatter = RSAPKCS1SignatureDeformatter$instance;

export class RSAPKCS1SignatureFormatter$instance extends AsymmetricSignatureFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(hash: HashAlgorithm): byte[];
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
}


export type RSAPKCS1SignatureFormatter = RSAPKCS1SignatureFormatter$instance;

export class RSASignaturePadding$instance {
    readonly Mode: RSASignaturePaddingMode;
    Equals(obj: any): boolean;
    Equals(other: RSASignaturePadding): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly Pkcs1: RSASignaturePadding;
    static readonly Pss: RSASignaturePadding;
}


export interface __RSASignaturePadding$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<RSASignaturePadding>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RSASignaturePadding): boolean;
}

export type RSASignaturePadding = RSASignaturePadding$instance & __RSASignaturePadding$views;


export class SafeEvpPKeyHandle$instance extends System_Runtime_InteropServices_Internal.SafeHandle$instance {
    constructor();
    constructor(handle: nint, ownsHandle: boolean);
    readonly IsInvalid: boolean;
    Dispose(): void;
    DuplicateHandle(): SafeEvpPKeyHandle;
    static readonly OpenSslVersion: long;
    static OpenKeyFromProvider(providerName: string, keyUri: string): SafeEvpPKeyHandle;
    static OpenPrivateKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
    static OpenPublicKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
}


export interface __SafeEvpPKeyHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SafeEvpPKeyHandle = SafeEvpPKeyHandle$instance & __SafeEvpPKeyHandle$views;


export abstract class SHA1$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA1$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA1 = SHA1$instance & __SHA1$views;


export class SHA1CryptoServiceProvider$instance extends SHA1$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA1CryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA1CryptoServiceProvider = SHA1CryptoServiceProvider$instance & __SHA1CryptoServiceProvider$views;


export class SHA1Managed$instance extends SHA1$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA1Managed$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA1Managed = SHA1Managed$instance & __SHA1Managed$views;


export abstract class SHA256$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA256$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA256 = SHA256$instance & __SHA256$views;


export class SHA256CryptoServiceProvider$instance extends SHA256$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA256CryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA256CryptoServiceProvider = SHA256CryptoServiceProvider$instance & __SHA256CryptoServiceProvider$views;


export class SHA256Managed$instance extends SHA256$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA256Managed$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA256Managed = SHA256Managed$instance & __SHA256Managed$views;


export abstract class SHA3_256$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static readonly IsSupported: boolean;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA3_256$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA3_256 = SHA3_256$instance & __SHA3_256$views;


export abstract class SHA3_384$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static readonly IsSupported: boolean;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA3_384$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA3_384 = SHA3_384$instance & __SHA3_384$views;


export abstract class SHA3_512$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static readonly IsSupported: boolean;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA3_512$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA3_512 = SHA3_512$instance & __SHA3_512$views;


export abstract class SHA384$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA384$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA384 = SHA384$instance & __SHA384$views;


export class SHA384CryptoServiceProvider$instance extends SHA384$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA384CryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA384CryptoServiceProvider = SHA384CryptoServiceProvider$instance & __SHA384CryptoServiceProvider$views;


export class SHA384Managed$instance extends SHA384$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA384Managed$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA384Managed = SHA384Managed$instance & __SHA384Managed$views;


export abstract class SHA512$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly HashSizeInBits: int;
    static readonly HashSizeInBytes: int;
    static HashData(source: byte[]): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: Stream): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA512$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA512 = SHA512$instance & __SHA512$views;


export class SHA512CryptoServiceProvider$instance extends SHA512$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA512CryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA512CryptoServiceProvider = SHA512CryptoServiceProvider$instance & __SHA512CryptoServiceProvider$views;


export class SHA512Managed$instance extends SHA512$instance {
    constructor();
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA512Managed$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type SHA512Managed = SHA512Managed$instance & __SHA512Managed$views;


export class Shake128$instance {
    constructor();
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Shake128;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    Read(outputLength: int): byte[];
    Read(destination: Span_1<CLROf<byte>>): void;
    Reset(): void;
    static readonly IsSupported: boolean;
    static HashData(source: byte[], outputLength: int): byte[];
    static HashData(source: Stream, outputLength: int): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    static HashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Shake128$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Shake128 = Shake128$instance & __Shake128$views;


export class Shake256$instance {
    constructor();
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Shake256;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    Read(outputLength: int): byte[];
    Read(destination: Span_1<CLROf<byte>>): void;
    Reset(): void;
    static readonly IsSupported: boolean;
    static HashData(source: byte[], outputLength: int): byte[];
    static HashData(source: Stream, outputLength: int): byte[];
    static HashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    static HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    static HashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Shake256$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Shake256 = Shake256$instance & __Shake256$views;


export class SignatureDescription$instance {
    constructor();
    constructor(el: SecurityElement);
    DeformatterAlgorithm: string;
    DigestAlgorithm: string;
    FormatterAlgorithm: string;
    KeyAlgorithm: string;
    CreateDeformatter(key: AsymmetricAlgorithm): AsymmetricSignatureDeformatter;
    CreateDigest(): HashAlgorithm;
    CreateFormatter(key: AsymmetricAlgorithm): AsymmetricSignatureFormatter;
}


export type SignatureDescription = SignatureDescription$instance;

export abstract class SlhDsa$instance {
    readonly Algorithm: SlhDsaAlgorithm;
    Dispose(): void;
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSlhDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    ExportSlhDsaPrivateKey(): byte[];
    ExportSlhDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    ExportSlhDsaPublicKey(): byte[];
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignData(data: byte[], context?: byte[]): byte[];
    SignPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    VerifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
    static readonly IsSupported: boolean;
    static GenerateKey(algorithm: SlhDsaAlgorithm): SlhDsa;
    static ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<string>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): SlhDsa;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<string>>, password: ReadOnlySpan_1<CLROf<string>>): SlhDsa;
    static ImportFromEncryptedPem(source: string, passwordBytes: byte[]): SlhDsa;
    static ImportFromEncryptedPem(source: string, password: string): SlhDsa;
    static ImportFromPem(source: ReadOnlySpan_1<CLROf<string>>): SlhDsa;
    static ImportFromPem(source: string): SlhDsa;
    static ImportPkcs8PrivateKey(source: byte[]): SlhDsa;
    static ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static ImportSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    static ImportSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static ImportSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    static ImportSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static ImportSubjectPublicKeyInfo(source: byte[]): SlhDsa;
    static ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
}


export interface __SlhDsa$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SlhDsa = SlhDsa$instance & __SlhDsa$views;


export class SlhDsaAlgorithm$instance {
    readonly Name: string;
    readonly PrivateKeySizeInBytes: int;
    readonly PublicKeySizeInBytes: int;
    readonly SignatureSizeInBytes: int;
    Equals(other: SlhDsaAlgorithm): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly SlhDsaSha2_128s: SlhDsaAlgorithm;
    static readonly SlhDsaShake128s: SlhDsaAlgorithm;
    static readonly SlhDsaSha2_128f: SlhDsaAlgorithm;
    static readonly SlhDsaShake128f: SlhDsaAlgorithm;
    static readonly SlhDsaSha2_192s: SlhDsaAlgorithm;
    static readonly SlhDsaShake192s: SlhDsaAlgorithm;
    static readonly SlhDsaSha2_192f: SlhDsaAlgorithm;
    static readonly SlhDsaShake192f: SlhDsaAlgorithm;
    static readonly SlhDsaSha2_256s: SlhDsaAlgorithm;
    static readonly SlhDsaShake256s: SlhDsaAlgorithm;
    static readonly SlhDsaSha2_256f: SlhDsaAlgorithm;
    static readonly SlhDsaShake256f: SlhDsaAlgorithm;
}


export interface __SlhDsaAlgorithm$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SlhDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SlhDsaAlgorithm): boolean;
}

export type SlhDsaAlgorithm = SlhDsaAlgorithm$instance & __SlhDsaAlgorithm$views;


export class SlhDsaCng$instance extends SlhDsa$instance {
    constructor(key: CngKey);
    Dispose(): void;
    GetKey(): CngKey;
}


export interface __SlhDsaCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SlhDsaCng = SlhDsaCng$instance & __SlhDsaCng$views;


export class SlhDsaOpenSsl$instance extends SlhDsa$instance {
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
}


export interface __SlhDsaOpenSsl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SlhDsaOpenSsl = SlhDsaOpenSsl$instance & __SlhDsaOpenSsl$views;


export class SP800108HmacCounterKdf$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName);
    constructor(key: byte[], hashAlgorithm: HashAlgorithmName);
    DeriveKey(label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    DeriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    DeriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    DeriveKey(label: ReadOnlySpan_1<CLROf<string>>, context: ReadOnlySpan_1<CLROf<string>>, derivedKeyLengthInBytes: int): byte[];
    DeriveKey(label: ReadOnlySpan_1<CLROf<string>>, context: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>): void;
    DeriveKey(label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    Dispose(): void;
    static DeriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    static DeriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    static DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    static DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    static DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<string>>, context: ReadOnlySpan_1<CLROf<string>>, derivedKeyLengthInBytes: int): byte[];
    static DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<string>>, context: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>): void;
}


export interface __SP800108HmacCounterKdf$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SP800108HmacCounterKdf = SP800108HmacCounterKdf$instance & __SP800108HmacCounterKdf$views;


export abstract class SymmetricAlgorithm$instance {
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    Clear(): void;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    DecryptCbc(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    DecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    DecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    DecryptCfb(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    DecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    DecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    DecryptEcb(ciphertext: byte[], paddingMode: PaddingMode): byte[];
    DecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    DecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    Dispose(): void;
    EncryptCbc(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    EncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    EncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    EncryptCfb(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    EncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    EncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    EncryptEcb(plaintext: byte[], paddingMode: PaddingMode): byte[];
    EncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    EncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    abstract GenerateIV(): void;
    abstract GenerateKey(): void;
    GetCiphertextLengthCbc(plaintextLength: int, paddingMode?: PaddingMode): int;
    GetCiphertextLengthCfb(plaintextLength: int, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    GetCiphertextLengthEcb(plaintextLength: int, paddingMode: PaddingMode): int;
    SetKey(key: ReadOnlySpan_1<CLROf<byte>>): void;
    TryDecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    TryDecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    TryDecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    TryEncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    TryEncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    TryEncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    ValidKeySize(bitLength: int): boolean;
    static Create(): SymmetricAlgorithm;
    static Create(algName: string): SymmetricAlgorithm;
}


export interface __SymmetricAlgorithm$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SymmetricAlgorithm = SymmetricAlgorithm$instance & __SymmetricAlgorithm$views;


export class ToBase64Transform$instance {
    constructor();
    readonly CanReuseTransform: boolean;
    readonly CanTransformMultipleBlocks: boolean;
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    Clear(): void;
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __ToBase64Transform$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ICryptoTransform: ICryptoTransform$instance;
}

export type ToBase64Transform = ToBase64Transform$instance & __ToBase64Transform$views;


export abstract class TripleDES$instance extends SymmetricAlgorithm$instance {
    Key: byte[];
    Dispose(): void;
    static IsWeakKey(rgbKey: byte[]): boolean;
}


export interface __TripleDES$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TripleDES = TripleDES$instance & __TripleDES$views;


export class TripleDESCng$instance extends TripleDES$instance {
    constructor();
    constructor(keyName: string);
    constructor(keyName: string, provider: CngProvider);
    constructor(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions);
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateDecryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __TripleDESCng$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TripleDESCng = TripleDESCng$instance & __TripleDESCng$views;


export class TripleDESCryptoServiceProvider$instance extends TripleDES$instance {
    constructor();
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export interface __TripleDESCryptoServiceProvider$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TripleDESCryptoServiceProvider = TripleDESCryptoServiceProvider$instance & __TripleDESCryptoServiceProvider$views;


export abstract class CryptographicOperations$instance {
    static FixedTimeEquals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static HashData(hashAlgorithm: HashAlgorithmName, source: byte[]): byte[];
    static HashData(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(hashAlgorithm: HashAlgorithmName, source: Stream): byte[];
    static HashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: byte[]): byte[];
    static HmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream): byte[];
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HmacDataAsync(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static TryHmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static ZeroMemory(buffer: Span_1<CLROf<byte>>): void;
}


export type CryptographicOperations = CryptographicOperations$instance;

export abstract class ECCurve_NamedCurves$instance {
    static readonly brainpoolP160r1: ECCurve;
    static readonly brainpoolP160t1: ECCurve;
    static readonly brainpoolP192r1: ECCurve;
    static readonly brainpoolP192t1: ECCurve;
    static readonly brainpoolP224r1: ECCurve;
    static readonly brainpoolP224t1: ECCurve;
    static readonly brainpoolP256r1: ECCurve;
    static readonly brainpoolP256t1: ECCurve;
    static readonly brainpoolP320r1: ECCurve;
    static readonly brainpoolP320t1: ECCurve;
    static readonly brainpoolP384r1: ECCurve;
    static readonly brainpoolP384t1: ECCurve;
    static readonly brainpoolP512r1: ECCurve;
    static readonly brainpoolP512t1: ECCurve;
    static readonly nistP256: ECCurve;
    static readonly nistP384: ECCurve;
    static readonly nistP521: ECCurve;
}


export type ECCurve_NamedCurves = ECCurve_NamedCurves$instance;

export abstract class HKDF$instance {
    static DeriveKey(hashAlgorithmName: HashAlgorithmName, ikm: byte[], outputLength: int, salt?: byte[], info?: byte[]): byte[];
    static DeriveKey(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static Expand(hashAlgorithmName: HashAlgorithmName, prk: byte[], outputLength: int, info?: byte[]): byte[];
    static Expand(hashAlgorithmName: HashAlgorithmName, prk: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static Extract(hashAlgorithmName: HashAlgorithmName, ikm: byte[], salt?: byte[]): byte[];
    static Extract(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, prk: Span_1<CLROf<byte>>): int;
}


export type HKDF = HKDF$instance;

export abstract class PemEncoding$instance {
    static Find(pemData: ReadOnlySpan_1<CLROf<string>>): PemFields;
    static FindUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>): PemFields;
    static GetEncodedSize(labelLength: int, dataLength: int): int;
    static TryFind(pemData: ReadOnlySpan_1<CLROf<string>>, fields: { value: ref<PemFields> }): boolean;
    static TryFindUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>, fields: { value: ref<PemFields> }): boolean;
    static TryWrite(label: ReadOnlySpan_1<CLROf<string>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    static TryWriteUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static Write(label: ReadOnlySpan_1<CLROf<string>>, data: ReadOnlySpan_1<CLROf<byte>>): string[];
    static WriteString(label: ReadOnlySpan_1<CLROf<string>>, data: ReadOnlySpan_1<CLROf<byte>>): string;
    static WriteUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>): byte[];
}


export type PemEncoding = PemEncoding$instance;

