// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography
// Assembly: System.Private.CoreLib, System.Security.Cryptography

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeNCryptKeyHandle, SafeNCryptProviderHandle, SafeNCryptSecretHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString, SecurityElement } from "../../System.Security/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, Nullable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CipherMode {
    cbc = 1,
    ecb = 2,
    ofb = 3,
    cfb = 4,
    cts = 5
}


export enum CngExportPolicies {
    none = 0,
    allowExport = 1,
    allowPlaintextExport = 2,
    allowArchiving = 4,
    allowPlaintextArchiving = 8
}


export enum CngKeyCreationOptions {
    none = 0,
    machineKey = 32,
    overwriteExistingKey = 128,
    preferVbs = 65536,
    requireVbs = 131072,
    usePerBootKey = 262144
}


export enum CngKeyHandleOpenOptions {
    none = 0,
    ephemeralKey = 1
}


export enum CngKeyOpenOptions {
    none = 0,
    userKey = 0,
    machineKey = 32,
    silent = 64
}


export enum CngKeyUsages {
    none = 0,
    decryption = 1,
    signing = 2,
    keyAgreement = 4,
    allUsages = 16777215
}


export enum CngPropertyOptions {
    none = 0,
    customProperty = 1073741824,
    persist = -2147483648
}


export enum CngUIProtectionLevels {
    none = 0,
    protectKey = 1,
    forceHighProtection = 2
}


export enum CryptoStreamMode {
    read = 0,
    write = 1
}


export enum CspProviderFlags {
    noFlags = 0,
    useMachineKeyStore = 1,
    useDefaultKeyContainer = 2,
    useNonExportableKey = 4,
    useExistingKey = 8,
    useArchivableKey = 16,
    useUserProtectedKey = 32,
    noPrompt = 64,
    createEphemeralKey = 128
}


export enum DSASignatureFormat {
    ieeeP1363FixedFieldConcatenation = 0,
    rfc3279DerSequence = 1
}


export enum ECCurve_ECCurveType {
    implicit = 0,
    primeShortWeierstrass = 1,
    primeTwistedEdwards = 2,
    primeMontgomery = 3,
    characteristic2 = 4,
    named = 5
}


export enum ECDiffieHellmanKeyDerivationFunction {
    hash = 0,
    hmac = 1,
    tls = 2
}


export enum ECKeyXmlFormat {
    rfc4050 = 0
}


export enum FromBase64TransformMode {
    ignoreWhiteSpaces = 0,
    doNotIgnoreWhiteSpaces = 1
}


export enum KeyNumber {
    exchange = 1,
    signature = 2
}


export enum OidGroup {
    all = 0,
    hashAlgorithm = 1,
    encryptionAlgorithm = 2,
    publicKeyAlgorithm = 3,
    signatureAlgorithm = 4,
    attribute = 5,
    extensionOrAttribute = 6,
    enhancedKeyUsage = 7,
    policy = 8,
    template = 9,
    keyDerivationFunction = 10
}


export enum PaddingMode {
    none = 1,
    pkcs7 = 2,
    zeros = 3,
    ansix923 = 4,
    iso10126 = 5
}


export enum PbeEncryptionAlgorithm {
    unknown_ = 0,
    aes128Cbc = 1,
    aes192Cbc = 2,
    aes256Cbc = 3,
    tripleDes3KeyPkcs12 = 4
}


export enum RSAEncryptionPaddingMode {
    pkcs1 = 0,
    oaep = 1
}


export enum RSASignaturePaddingMode {
    pkcs1 = 0,
    pss = 1
}


export interface ICryptoTransform$instance extends IDisposable {
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    readonly canTransformMultipleBlocks: boolean;
    readonly canReuseTransform: boolean;
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface ICryptoTransform$instance extends System_Internal.IDisposable$instance {}

export type ICryptoTransform = ICryptoTransform$instance;

export interface ICspAsymmetricAlgorithm$instance {
    readonly cspKeyContainerInfo: CspKeyContainerInfo;
    exportCspBlob(includePrivateParameters: boolean): byte[];
    importCspBlob(rawData: byte[]): void;
}


export type ICspAsymmetricAlgorithm = ICspAsymmetricAlgorithm$instance;

export class CngProperty$instance {
    constructor(name: string, value: byte[], options: CngPropertyOptions);
    readonly name: string;
    readonly options: CngPropertyOptions;
    equals(obj: unknown): boolean;
    equals(other: CngProperty): boolean;
    getHashCode(): int;
    getValue(): byte[];
}


export interface __CngProperty$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngProperty>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngProperty): boolean;
}

export type CngProperty = CngProperty$instance & __CngProperty$views;


export class DSAParameters$instance {
    p: byte[];
    q: byte[];
    g: byte[];
    y: byte[];
    j: byte[];
    x: byte[];
    seed: byte[];
    counter: int;
}


export type DSAParameters = DSAParameters$instance;

export class ECCurve$instance {
    a: byte[];
    b: byte[];
    g: ECPoint;
    order: byte[];
    cofactor: byte[];
    seed: byte[];
    curveType: ECCurve_ECCurveType;
    hash: Nullable_1<HashAlgorithmName>;
    polynomial: byte[];
    prime: byte[];
    readonly isCharacteristic2: boolean;
    readonly isExplicit: boolean;
    readonly isNamed: boolean;
    readonly isPrime: boolean;
    readonly oid: Oid;
    validate(): void;
    static createFromFriendlyName(oidFriendlyName: string): ECCurve;
    static createFromOid(curveOid: Oid): ECCurve;
    static createFromValue(oidValue: string): ECCurve;
}


export type ECCurve = ECCurve$instance;

export class ECParameters$instance {
    q: ECPoint;
    d: byte[];
    curve: ECCurve;
    validate(): void;
}


export type ECParameters = ECParameters$instance;

export class ECPoint$instance {
    x: byte[];
    y: byte[];
}


export type ECPoint = ECPoint$instance;

export class HashAlgorithmName$instance {
    constructor(name: string);
    readonly name: string;
    equals(obj: unknown): boolean;
    equals(other: HashAlgorithmName): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly md5: HashAlgorithmName;
    static readonly sha1: HashAlgorithmName;
    static readonly sha256: HashAlgorithmName;
    static readonly sha384: HashAlgorithmName;
    static readonly sha512: HashAlgorithmName;
    static readonly sha3_256: HashAlgorithmName;
    static readonly sha3_384: HashAlgorithmName;
    static readonly sha3_512: HashAlgorithmName;
    static fromOid(oidValue: string): HashAlgorithmName;
    static tryFromOid(oidValue: string, value: { value: ref<HashAlgorithmName> }): boolean;
}


export interface __HashAlgorithmName$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<HashAlgorithmName>;

    // Structural method bridges for numeric interface constraints
    Equals(other: HashAlgorithmName): boolean;
}

export type HashAlgorithmName = HashAlgorithmName$instance & __HashAlgorithmName$views;


export class PemFields$instance {
    readonly base64Data: Range;
    readonly decodedDataLength: int;
    readonly label: Range;
    readonly location: Range;
}


export type PemFields = PemFields$instance;

export class RSAParameters$instance {
    d: byte[];
    dp: byte[];
    dq: byte[];
    exponent: byte[];
    inverseQ: byte[];
    modulus: byte[];
    p: byte[];
    q: byte[];
}


export type RSAParameters = RSAParameters$instance;

export abstract class Aes$instance extends SymmetricAlgorithm$instance {
    decryptKeyWrapPadded(ciphertext: byte[]): byte[];
    decryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    decryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    Dispose(): void;
    encryptKeyWrapPadded(plaintext: byte[]): byte[];
    encryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    encryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    tryDecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static getKeyWrapPaddedLength(plaintextLengthInBytes: int): int;
}


export interface __Aes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Aes$instance extends System_Internal.IDisposable$instance {}

export type Aes = Aes$instance & __Aes$views;


export class AesCcm$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>);
    constructor(key: byte[]);
    decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    dispose(): void;
    encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    static readonly nonceByteSizes: KeySizes;
    static readonly tagByteSizes: KeySizes;
    static readonly isSupported: boolean;
}


export interface __AesCcm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesCcm$instance extends System_Internal.IDisposable$instance {}

export type AesCcm = AesCcm$instance & __AesCcm$views;


export class AesCng$instance extends Aes$instance {
    constructor();
    constructor(keyName: string);
    constructor(keyName: string, provider: CngProvider);
    constructor(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions);
    constructor(key: CngKey);
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateDecryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __AesCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesCng$instance extends System_Internal.IDisposable$instance {}

export type AesCng = AesCng$instance & __AesCng$views;


export class AesCryptoServiceProvider$instance extends Aes$instance {
    constructor();
    blockSize: int;
    feedbackSize: int;
    iv: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __AesCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesCryptoServiceProvider$instance extends System_Internal.IDisposable$instance {}

export type AesCryptoServiceProvider = AesCryptoServiceProvider$instance & __AesCryptoServiceProvider$views;


export class AesGcm$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, tagSizeInBytes: int);
    constructor(key: byte[], tagSizeInBytes: int);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>);
    constructor(key: byte[]);
    readonly tagSizeInBytes: Nullable_1<CLROf<int>>;
    decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    dispose(): void;
    encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    static readonly nonceByteSizes: KeySizes;
    static readonly tagByteSizes: KeySizes;
    static readonly isSupported: boolean;
}


export interface __AesGcm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesGcm$instance extends System_Internal.IDisposable$instance {}

export type AesGcm = AesGcm$instance & __AesGcm$views;


export class AesManaged$instance extends Aes$instance {
    constructor();
    blockSize: int;
    feedbackSize: int;
    iv: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __AesManaged$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesManaged$instance extends System_Internal.IDisposable$instance {}

export type AesManaged = AesManaged$instance & __AesManaged$views;


export class AsnEncodedData$instance {
    constructor(rawData: byte[]);
    constructor(rawData: ReadOnlySpan_1<CLROf<byte>>);
    constructor(asnEncodedData: AsnEncodedData);
    constructor(oid: Oid, rawData: byte[]);
    constructor(oid: string, rawData: byte[]);
    constructor(oid: Oid, rawData: ReadOnlySpan_1<CLROf<byte>>);
    constructor(oid: string, rawData: ReadOnlySpan_1<CLROf<byte>>);
    oid: Oid;
    rawData: byte[];
    copyFrom(asnEncodedData: AsnEncodedData): void;
    format(multiLine: boolean): string;
}


export type AsnEncodedData = AsnEncodedData$instance;

export class AsnEncodedDataCollection$instance {
    constructor();
    constructor(asnEncodedData: AsnEncodedData);
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: AsnEncodedData;
    readonly syncRoot: unknown;
    add(asnEncodedData: AsnEncodedData): int;
    copyTo(array: AsnEncodedData[], index: int): void;
    getEnumerator(): AsnEncodedDataEnumerator;
    remove(asnEncodedData: AsnEncodedData): void;
}


export interface __AsnEncodedDataCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AsnEncodedDataCollection = AsnEncodedDataCollection$instance & __AsnEncodedDataCollection$views;


export class AsnEncodedDataEnumerator$instance {
    readonly current: AsnEncodedData | unknown;
    moveNext(): boolean;
    reset(): void;
}


export interface __AsnEncodedDataEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type AsnEncodedDataEnumerator = AsnEncodedDataEnumerator$instance & __AsnEncodedDataEnumerator$views;


export abstract class AsymmetricAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    readonly signatureAlgorithm: string;
    clear(): void;
    dispose(): void;
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    fromXmlString(xmlString: string): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    toXmlString(includePrivateParameters: boolean): string;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfoPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static create(): AsymmetricAlgorithm;
    static create(algName: string): AsymmetricAlgorithm;
}


export interface __AsymmetricAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AsymmetricAlgorithm$instance extends System_Internal.IDisposable$instance {}

export type AsymmetricAlgorithm = AsymmetricAlgorithm$instance & __AsymmetricAlgorithm$views;


export abstract class AsymmetricKeyExchangeDeformatter$instance {
    parameters: string;
    abstract decryptKeyExchange(rgb: byte[]): byte[];
    abstract setKey(key: AsymmetricAlgorithm): void;
}


export type AsymmetricKeyExchangeDeformatter = AsymmetricKeyExchangeDeformatter$instance;

export abstract class AsymmetricKeyExchangeFormatter$instance {
    readonly parameters: string;
    abstract createKeyExchange(data: byte[]): byte[];
    abstract createKeyExchange(data: byte[], symAlgType: Type): byte[];
    abstract setKey(key: AsymmetricAlgorithm): void;
}


export type AsymmetricKeyExchangeFormatter = AsymmetricKeyExchangeFormatter$instance;

export abstract class AsymmetricSignatureDeformatter$instance {
    abstract setHashAlgorithm(strName: string): void;
    abstract setKey(key: AsymmetricAlgorithm): void;
    verifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
}


export type AsymmetricSignatureDeformatter = AsymmetricSignatureDeformatter$instance;

export abstract class AsymmetricSignatureFormatter$instance {
    createSignature(hash: HashAlgorithm): byte[];
    createSignature(rgbHash: byte[]): byte[];
    abstract setHashAlgorithm(strName: string): void;
    abstract setKey(key: AsymmetricAlgorithm): void;
}


export type AsymmetricSignatureFormatter = AsymmetricSignatureFormatter$instance;

export class AuthenticationTagMismatchException$instance extends CryptographicException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AuthenticationTagMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface AuthenticationTagMismatchException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type AuthenticationTagMismatchException = AuthenticationTagMismatchException$instance & __AuthenticationTagMismatchException$views;


export class ChaCha20Poly1305$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>);
    constructor(key: byte[]);
    decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    dispose(): void;
    encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    static readonly isSupported: boolean;
}


export interface __ChaCha20Poly1305$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ChaCha20Poly1305$instance extends System_Internal.IDisposable$instance {}

export type ChaCha20Poly1305 = ChaCha20Poly1305$instance & __ChaCha20Poly1305$views;


export class CngAlgorithm$instance {
    constructor(algorithm: string);
    readonly algorithm: string;
    equals(obj: unknown): boolean;
    equals(other: CngAlgorithm): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly rsa: CngAlgorithm;
    static readonly ecDiffieHellman: CngAlgorithm;
    static readonly ecDiffieHellmanP256: CngAlgorithm;
    static readonly ecDiffieHellmanP384: CngAlgorithm;
    static readonly ecDiffieHellmanP521: CngAlgorithm;
    static readonly ecDsa: CngAlgorithm;
    static readonly ecDsaP256: CngAlgorithm;
    static readonly ecDsaP384: CngAlgorithm;
    static readonly ecDsaP521: CngAlgorithm;
    static readonly md5: CngAlgorithm;
    static readonly sha1: CngAlgorithm;
    static readonly sha256: CngAlgorithm;
    static readonly sha384: CngAlgorithm;
    static readonly sha512: CngAlgorithm;
    static readonly mlDsa: CngAlgorithm;
    static readonly mlKem: CngAlgorithm;
    static readonly slhDsa: CngAlgorithm;
}


export interface __CngAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngAlgorithm): boolean;
}

export type CngAlgorithm = CngAlgorithm$instance & __CngAlgorithm$views;


export class CngAlgorithmGroup$instance {
    constructor(algorithmGroup: string);
    readonly algorithmGroup: string;
    equals(obj: unknown): boolean;
    equals(other: CngAlgorithmGroup): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly diffieHellman: CngAlgorithmGroup;
    static readonly dsa: CngAlgorithmGroup;
    static readonly ecDiffieHellman: CngAlgorithmGroup;
    static readonly ecDsa: CngAlgorithmGroup;
    static readonly rsa: CngAlgorithmGroup;
    static readonly mlDsa: CngAlgorithmGroup;
    static readonly mlKem: CngAlgorithmGroup;
    static readonly slhDsa: CngAlgorithmGroup;
}


export interface __CngAlgorithmGroup$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngAlgorithmGroup>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngAlgorithmGroup): boolean;
}

export type CngAlgorithmGroup = CngAlgorithmGroup$instance & __CngAlgorithmGroup$views;


export class CngKey$instance {
    readonly algorithm: CngAlgorithm;
    readonly algorithmGroup: CngAlgorithmGroup;
    readonly exportPolicy: CngExportPolicies;
    readonly handle: SafeNCryptKeyHandle;
    readonly isEphemeral: boolean;
    readonly isMachineKey: boolean;
    readonly keyName: string;
    readonly keySize: int;
    readonly keyUsage: CngKeyUsages;
    parentWindowHandle: nint;
    readonly provider: CngProvider;
    readonly providerHandle: SafeNCryptProviderHandle;
    readonly uiPolicy: CngUIPolicy;
    readonly uniqueName: string;
    delete_(): void;
    dispose(): void;
    export_(format: CngKeyBlobFormat): byte[];
    getProperty(name: string, options: CngPropertyOptions): CngProperty;
    hasProperty(name: string, options: CngPropertyOptions): boolean;
    setProperty(property: CngProperty): void;
    static create(algorithm: CngAlgorithm, keyName: string, creationParameters: CngKeyCreationParameters): CngKey;
    static create(algorithm: CngAlgorithm, keyName: string): CngKey;
    static create(algorithm: CngAlgorithm): CngKey;
    static exists(keyName: string, provider: CngProvider, options: CngKeyOpenOptions): boolean;
    static exists(keyName: string, provider: CngProvider): boolean;
    static exists(keyName: string): boolean;
    static import(keyBlob: byte[], format: CngKeyBlobFormat, provider: CngProvider): CngKey;
    static import(keyBlob: byte[], format: CngKeyBlobFormat): CngKey;
    static open(keyHandle: SafeNCryptKeyHandle, keyHandleOpenOptions: CngKeyHandleOpenOptions): CngKey;
    static open(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): CngKey;
    static open(keyName: string, provider: CngProvider): CngKey;
    static open(keyName: string): CngKey;
}


export interface __CngKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CngKey$instance extends System_Internal.IDisposable$instance {}

export type CngKey = CngKey$instance & __CngKey$views;


export class CngKeyBlobFormat$instance {
    constructor(format: string);
    readonly format: string;
    equals(obj: unknown): boolean;
    equals(other: CngKeyBlobFormat): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly eccPrivateBlob: CngKeyBlobFormat;
    static readonly eccPublicBlob: CngKeyBlobFormat;
    static readonly eccFullPrivateBlob: CngKeyBlobFormat;
    static readonly eccFullPublicBlob: CngKeyBlobFormat;
    static readonly genericPrivateBlob: CngKeyBlobFormat;
    static readonly genericPublicBlob: CngKeyBlobFormat;
    static readonly pqDsaPublicBlob: CngKeyBlobFormat;
    static readonly pqDsaPrivateBlob: CngKeyBlobFormat;
    static readonly pqDsaPrivateSeedBlob: CngKeyBlobFormat;
    static readonly mlKemPublicBlob: CngKeyBlobFormat;
    static readonly mlKemPrivateBlob: CngKeyBlobFormat;
    static readonly mlKemPrivateSeedBlob: CngKeyBlobFormat;
    static readonly opaqueTransportBlob: CngKeyBlobFormat;
    static readonly pkcs8PrivateBlob: CngKeyBlobFormat;
}


export interface __CngKeyBlobFormat$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngKeyBlobFormat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngKeyBlobFormat): boolean;
}

export type CngKeyBlobFormat = CngKeyBlobFormat$instance & __CngKeyBlobFormat$views;


export class CngKeyCreationParameters$instance {
    constructor();
    exportPolicy: Nullable_1<CngExportPolicies>;
    keyCreationOptions: CngKeyCreationOptions;
    keyUsage: Nullable_1<CngKeyUsages>;
    readonly parameters: CngPropertyCollection;
    parentWindowHandle: nint;
    provider: CngProvider;
    uiPolicy: CngUIPolicy;
}


export type CngKeyCreationParameters = CngKeyCreationParameters$instance;

export class CngPropertyCollection$instance extends System_Collections_ObjectModel_Internal.Collection_1$instance<CngProperty> {
    constructor();
    Add(item: CngProperty): void;
    Add(value: unknown): int;
    Clear(): void;
    Contains(item: CngProperty): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: CngProperty[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator_1<CngProperty>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: CngProperty): int;
    Insert(index: int, item: CngProperty): void;
    Insert(index: int, value: unknown): void;
    Remove(item: CngProperty): boolean;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export interface __CngPropertyCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<CngProperty>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CngProperty>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<CngProperty>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CngProperty>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type CngPropertyCollection = CngPropertyCollection$instance & __CngPropertyCollection$views;


export class CngProvider$instance {
    constructor(provider: string);
    readonly provider: string;
    equals(obj: unknown): boolean;
    equals(other: CngProvider): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly microsoftPlatformCryptoProvider: CngProvider;
    static readonly microsoftSmartCardKeyStorageProvider: CngProvider;
    static readonly microsoftSoftwareKeyStorageProvider: CngProvider;
}


export interface __CngProvider$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngProvider>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CngProvider): boolean;
}

export type CngProvider = CngProvider$instance & __CngProvider$views;


export class CngUIPolicy$instance {
    constructor(protectionLevel: CngUIProtectionLevels);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string);
    constructor(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string, creationTitle: string);
    readonly creationTitle: string;
    readonly description: string;
    readonly friendlyName: string;
    readonly protectionLevel: CngUIProtectionLevels;
    readonly useContext: string;
}


export type CngUIPolicy = CngUIPolicy$instance;

export abstract class CompositeMLDsa$instance {
    readonly algorithm: CompositeMLDsaAlgorithm;
    dispose(): void;
    exportCompositeMLDsaPrivateKey(): byte[];
    exportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): int;
    exportCompositeMLDsaPublicKey(): byte[];
    exportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>): int;
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    signData(data: byte[], context?: byte[]): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): int;
    tryExportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static readonly isSupported: boolean;
    static generateKey(algorithm: CompositeMLDsaAlgorithm): CompositeMLDsa;
    static importCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    static importCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static importCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    static importCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static importEncryptedPkcs8PrivateKey(password: string, source: byte[]): CompositeMLDsa;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): CompositeMLDsa;
    static importFromEncryptedPem(source: string, passwordBytes: byte[]): CompositeMLDsa;
    static importFromEncryptedPem(source: string, password: string): CompositeMLDsa;
    static importFromPem(source: ReadOnlySpan_1<CLROf<char>>): CompositeMLDsa;
    static importFromPem(source: string): CompositeMLDsa;
    static importPkcs8PrivateKey(source: byte[]): CompositeMLDsa;
    static importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static importSubjectPublicKeyInfo(source: byte[]): CompositeMLDsa;
    static importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    static isAlgorithmSupported(algorithm: CompositeMLDsaAlgorithm): boolean;
}


export interface __CompositeMLDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CompositeMLDsa$instance extends System_Internal.IDisposable$instance {}

export type CompositeMLDsa = CompositeMLDsa$instance & __CompositeMLDsa$views;


export class CompositeMLDsaAlgorithm$instance {
    readonly maxSignatureSizeInBytes: int;
    readonly name: string;
    equals(other: CompositeMLDsaAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly mlDsa44WithRSA2048Pss: CompositeMLDsaAlgorithm;
    static readonly mlDsa44WithRSA2048Pkcs15: CompositeMLDsaAlgorithm;
    static readonly mlDsa44WithEd25519: CompositeMLDsaAlgorithm;
    static readonly mlDsa44WithECDsaP256: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithRSA3072Pss: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithRSA3072Pkcs15: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithRSA4096Pss: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithRSA4096Pkcs15: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithECDsaP256: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithECDsaP384: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithECDsaBrainpoolP256r1: CompositeMLDsaAlgorithm;
    static readonly mlDsa65WithEd25519: CompositeMLDsaAlgorithm;
    static readonly mlDsa87WithECDsaP384: CompositeMLDsaAlgorithm;
    static readonly mlDsa87WithECDsaBrainpoolP384r1: CompositeMLDsaAlgorithm;
    static readonly mlDsa87WithEd448: CompositeMLDsaAlgorithm;
    static readonly mlDsa87WithRSA3072Pss: CompositeMLDsaAlgorithm;
    static readonly mlDsa87WithRSA4096Pss: CompositeMLDsaAlgorithm;
    static readonly mlDsa87WithECDsaP521: CompositeMLDsaAlgorithm;
}


export interface __CompositeMLDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CompositeMLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CompositeMLDsaAlgorithm): boolean;
}

export type CompositeMLDsaAlgorithm = CompositeMLDsaAlgorithm$instance & __CompositeMLDsaAlgorithm$views;


export class CompositeMLDsaCng$instance extends CompositeMLDsa$instance {
    constructor(key: CngKey);
    Dispose(): void;
    getKey(): CngKey;
}


export interface __CompositeMLDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CompositeMLDsaCng$instance extends System_Internal.IDisposable$instance {}

export type CompositeMLDsaCng = CompositeMLDsaCng$instance & __CompositeMLDsaCng$views;


export class CryptoConfig$instance {
    constructor();
    static readonly allowOnlyFipsAlgorithms: boolean;
    static addAlgorithm(algorithm: Type, names: string[]): void;
    static addOID(oid: string, names: string[]): void;
    static createFromName(name: string, args: unknown[]): unknown;
    static createFromName(name: string): unknown;
    static encodeOID(str: string): byte[];
    static mapNameToOID(name: string): string;
}


export type CryptoConfig = CryptoConfig$instance;

export class CryptographicException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(hr: int);
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(format: string, insert: string);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CryptographicException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CryptographicException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CryptographicException = CryptographicException$instance & __CryptographicException$views;


export class CryptographicUnexpectedOperationException$instance extends CryptographicException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(format: string, insert: string);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CryptographicUnexpectedOperationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CryptographicUnexpectedOperationException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CryptographicUnexpectedOperationException = CryptographicUnexpectedOperationException$instance & __CryptographicUnexpectedOperationException$views;


export class CryptoStream$instance extends System_IO_Internal.Stream$instance {
    constructor(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode);
    constructor(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode, leaveOpen: boolean);
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly hasFlushedFinalBlock: boolean;
    readonly length: long;
    position: long;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    clear(): void;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    flushFinalBlock(): void;
    flushFinalBlockAsync(cancellationToken?: CancellationToken): ValueTask;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export interface __CryptoStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CryptoStream$instance extends System_Internal.IDisposable$instance {}

export type CryptoStream = CryptoStream$instance & __CryptoStream$views;


export class CspKeyContainerInfo$instance {
    constructor(parameters: CspParameters);
    readonly accessible: boolean;
    readonly exportable: boolean;
    readonly hardwareDevice: boolean;
    readonly keyContainerName: string;
    readonly keyNumber: KeyNumber;
    readonly machineKeyStore: boolean;
    readonly protected_: boolean;
    readonly providerName: string;
    readonly providerType: int;
    readonly randomlyGenerated: boolean;
    readonly removable: boolean;
    readonly uniqueKeyContainerName: string;
}


export type CspKeyContainerInfo = CspKeyContainerInfo$instance;

export class CspParameters$instance {
    constructor();
    constructor(dwTypeIn: int);
    constructor(dwTypeIn: int, strProviderNameIn: string);
    constructor(dwTypeIn: int, strProviderNameIn: string, strContainerNameIn: string);
    providerType: int;
    providerName: string;
    keyContainerName: string;
    keyNumber: int;
    flags: CspProviderFlags;
    keyPassword: SecureString;
    parentWindowHandle: nint;
}


export type CspParameters = CspParameters$instance;

export abstract class DeriveBytes$instance {
    dispose(): void;
    abstract getBytes(cb: int): byte[];
    abstract reset(): void;
}


export interface __DeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DeriveBytes$instance extends System_Internal.IDisposable$instance {}

export type DeriveBytes = DeriveBytes$instance & __DeriveBytes$views;


export abstract class DES$instance extends SymmetricAlgorithm$instance {
    key: byte[];
    Dispose(): void;
    static isSemiWeakKey(rgbKey: byte[]): boolean;
    static isWeakKey(rgbKey: byte[]): boolean;
}


export interface __DES$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DES$instance extends System_Internal.IDisposable$instance {}

export type DES = DES$instance & __DES$views;


export class DESCryptoServiceProvider$instance extends DES$instance {
    constructor();
    blockSize: int;
    feedbackSize: int;
    iv: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __DESCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DESCryptoServiceProvider$instance extends System_Internal.IDisposable$instance {}

export type DESCryptoServiceProvider = DESCryptoServiceProvider$instance & __DESCryptoServiceProvider$views;


export abstract class DSA$instance extends AsymmetricAlgorithm$instance {
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    abstract exportParameters(includePrivateParameters: boolean): DSAParameters;
    fromXmlString(xmlString: string): void;
    getMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    abstract importParameters(parameters: DSAParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    toXmlString(includePrivateParameters: boolean): string;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __DSA$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DSA$instance extends System_Internal.IDisposable$instance {}

export type DSA = DSA$instance & __DSA$views;


export class DSACng$instance extends DSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    readonly key: CngKey;
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    exportParameters(includePrivateParameters: boolean): DSAParameters;
    importParameters(parameters: DSAParameters): void;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __DSACng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DSACng$instance extends System_Internal.IDisposable$instance {}

export type DSACng = DSACng$instance & __DSACng$views;


export class DSACryptoServiceProvider$instance extends DSA$instance {
    constructor();
    constructor(dwKeySize: int);
    constructor(dwKeySize: int, parameters: CspParameters);
    constructor(parameters: CspParameters);
    readonly cspKeyContainerInfo: CspKeyContainerInfo;
    readonly keyExchangeAlgorithm: string;
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    persistKeyInCsp: boolean;
    readonly publicOnly: boolean;
    readonly signatureAlgorithm: string;
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    exportCspBlob(includePrivateParameters: boolean): byte[];
    exportParameters(includePrivateParameters: boolean): DSAParameters;
    fromXmlString(xmlString: string): void;
    importCspBlob(keyBlob: byte[]): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: DSAParameters): void;
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signHash(rgbHash: byte[], str: string): byte[];
    toXmlString(includePrivateParameters: boolean): string;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyHash(rgbHash: byte[], str: string, rgbSignature: byte[]): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
    static useMachineKeyStore: boolean;
}


export interface __DSACryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICspAsymmetricAlgorithm(): ICspAsymmetricAlgorithm$instance;
}

export interface DSACryptoServiceProvider$instance extends System_Internal.IDisposable$instance, ICspAsymmetricAlgorithm$instance {}

export type DSACryptoServiceProvider = DSACryptoServiceProvider$instance & __DSACryptoServiceProvider$views;


export class DSAOpenSsl$instance extends DSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(parameters: DSAParameters);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    constructor(handle: nint);
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    createSignature(rgbHash: byte[]): byte[];
    createSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    exportParameters(includePrivateParameters: boolean): DSAParameters;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: DSAParameters): void;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __DSAOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DSAOpenSsl$instance extends System_Internal.IDisposable$instance {}

export type DSAOpenSsl = DSAOpenSsl$instance & __DSAOpenSsl$views;


export class DSASignatureDeformatter$instance extends AsymmetricSignatureDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export type DSASignatureDeformatter = DSASignatureDeformatter$instance;

export class DSASignatureFormatter$instance extends AsymmetricSignatureFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(hash: HashAlgorithm): byte[];
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
}


export type DSASignatureFormatter = DSASignatureFormatter$instance;

export abstract class ECAlgorithm$instance extends AsymmetricAlgorithm$instance {
    Dispose(): void;
    exportECPrivateKey(): byte[];
    exportECPrivateKeyPem(): string;
    exportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    exportParameters(includePrivateParameters: boolean): ECParameters;
    generateKey(curve: ECCurve): void;
    importECPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importParameters(parameters: ECParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    tryExportECPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportECPrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __ECAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECAlgorithm$instance extends System_Internal.IDisposable$instance {}

export type ECAlgorithm = ECAlgorithm$instance & __ECAlgorithm$views;


export abstract class ECDiffieHellman$instance extends ECAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    readonly publicKey: ECDiffieHellmanPublicKey;
    readonly signatureAlgorithm: string;
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    deriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    deriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    Dispose(): void;
    fromXmlString(xmlString: string): void;
    toXmlString(includePrivateParameters: boolean): string;
    static create(): ECDiffieHellman;
    static create(curve: ECCurve): ECDiffieHellman;
    static create(parameters: ECParameters): ECDiffieHellman;
    static create(algorithm: string): ECDiffieHellman;
}


export interface __ECDiffieHellman$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDiffieHellman$instance extends System_Internal.IDisposable$instance {}

export type ECDiffieHellman = ECDiffieHellman$instance & __ECDiffieHellman$views;


export class ECDiffieHellmanCng$instance extends ECDiffieHellman$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    constructor(curve: ECCurve);
    hashAlgorithm: CngAlgorithm;
    hmacKey: byte[];
    readonly key: CngKey;
    keyDerivationFunction: ECDiffieHellmanKeyDerivationFunction;
    label: byte[];
    readonly publicKey: ECDiffieHellmanPublicKey;
    secretAppend: byte[];
    secretPrepend: byte[];
    seed: byte[];
    readonly useSecretAgreementAsHmacKey: boolean;
    deriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    deriveSecretAgreementHandle(otherPartyPublicKey: CngKey): SafeNCryptSecretHandle;
    deriveSecretAgreementHandle(otherPartyPublicKey: ECDiffieHellmanPublicKey): SafeNCryptSecretHandle;
    Dispose(): void;
    fromXmlString(xmlString: string): void;
    toXmlString(includePrivateParameters: boolean): string;
}


export interface __ECDiffieHellmanCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDiffieHellmanCng$instance extends System_Internal.IDisposable$instance {}

export type ECDiffieHellmanCng = ECDiffieHellmanCng$instance & __ECDiffieHellmanCng$views;


export class ECDiffieHellmanCngPublicKey$instance extends ECDiffieHellmanPublicKey$instance {
    readonly blobFormat: CngKeyBlobFormat;
    Dispose(): void;
    import_(): CngKey;
    toXmlString(): string;
    static fromByteArray(publicKeyBlob: byte[], format: CngKeyBlobFormat): ECDiffieHellmanPublicKey;
    static fromXmlString(xml: string): ECDiffieHellmanCngPublicKey;
}


export interface __ECDiffieHellmanCngPublicKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDiffieHellmanCngPublicKey$instance extends System_Internal.IDisposable$instance {}

export type ECDiffieHellmanCngPublicKey = ECDiffieHellmanCngPublicKey$instance & __ECDiffieHellmanCngPublicKey$views;


export class ECDiffieHellmanOpenSsl$instance extends ECDiffieHellman$instance {
    constructor(curve: ECCurve);
    constructor();
    constructor(keySize: int);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    constructor(handle: nint);
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    readonly publicKey: ECDiffieHellmanPublicKey;
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    deriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    deriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    deriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    deriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    Dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    exportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    exportParameters(includePrivateParameters: boolean): ECParameters;
    generateKey(curve: ECCurve): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: ECParameters): void;
}


export interface __ECDiffieHellmanOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDiffieHellmanOpenSsl$instance extends System_Internal.IDisposable$instance {}

export type ECDiffieHellmanOpenSsl = ECDiffieHellmanOpenSsl$instance & __ECDiffieHellmanOpenSsl$views;


export abstract class ECDiffieHellmanPublicKey$instance {
    dispose(): void;
    exportExplicitParameters(): ECParameters;
    exportParameters(): ECParameters;
    exportSubjectPublicKeyInfo(): byte[];
    toByteArray(): byte[];
    toXmlString(): string;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __ECDiffieHellmanPublicKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDiffieHellmanPublicKey$instance extends System_Internal.IDisposable$instance {}

export type ECDiffieHellmanPublicKey = ECDiffieHellmanPublicKey$instance & __ECDiffieHellmanPublicKey$views;


export abstract class ECDsa$instance extends ECAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    readonly signatureAlgorithm: string;
    Dispose(): void;
    fromXmlString(xmlString: string): void;
    getMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    signHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    signHash(hash: byte[]): byte[];
    toXmlString(includePrivateParameters: boolean): string;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: byte[], signature: byte[]): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
    static create(): ECDsa;
    static create(curve: ECCurve): ECDsa;
    static create(parameters: ECParameters): ECDsa;
    static create(algorithm: string): ECDsa;
}


export interface __ECDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDsa$instance extends System_Internal.IDisposable$instance {}

export type ECDsa = ECDsa$instance & __ECDsa$views;


export class ECDsaCng$instance extends ECDsa$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    constructor(curve: ECCurve);
    hashAlgorithm: CngAlgorithm;
    readonly key: CngKey;
    Dispose(): void;
    fromXmlString(xmlString: string): void;
    signData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    SignHash(hash: byte[]): byte[];
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    toXmlString(includePrivateParameters: boolean): string;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: byte[], signature: byte[]): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __ECDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDsaCng$instance extends System_Internal.IDisposable$instance {}

export type ECDsaCng = ECDsaCng$instance & __ECDsaCng$views;


export class ECDsaOpenSsl$instance extends ECDsa$instance {
    constructor(curve: ECCurve);
    constructor();
    constructor(keySize: int);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    constructor(handle: nint);
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    Dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    exportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    exportParameters(includePrivateParameters: boolean): ECParameters;
    generateKey(curve: ECCurve): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: ECParameters): void;
    SignHash(hash: byte[]): byte[];
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    verifyHash(hash: byte[], signature: byte[]): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export interface __ECDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDsaOpenSsl$instance extends System_Internal.IDisposable$instance {}

export type ECDsaOpenSsl = ECDsaOpenSsl$instance & __ECDsaOpenSsl$views;


export class FromBase64Transform$instance {
    constructor();
    constructor(whitespaces: FromBase64TransformMode);
    readonly canReuseTransform: boolean;
    readonly canTransformMultipleBlocks: boolean;
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    clear(): void;
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __FromBase64Transform$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type FromBase64Transform = FromBase64Transform$instance & __FromBase64Transform$views;


export abstract class HashAlgorithm$instance {
    readonly canReuseTransform: boolean;
    readonly canTransformMultipleBlocks: boolean;
    readonly hash: byte[];
    readonly hashSize: int;
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    clear(): void;
    computeHash(buffer: byte[]): byte[];
    computeHash(buffer: byte[], offset: int, count: int): byte[];
    computeHash(inputStream: Stream): byte[];
    computeHashAsync(inputStream: Stream, cancellationToken?: CancellationToken): Task_1<byte[]>;
    dispose(): void;
    abstract initialize(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    tryComputeHash(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static create(): HashAlgorithm;
    static create(hashName: string): HashAlgorithm;
}


export interface __HashAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HashAlgorithm = HashAlgorithm$instance & __HashAlgorithm$views;


export abstract class HMAC$instance extends KeyedHashAlgorithm$instance {
    hashName: string;
    key: byte[];
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __HMAC$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMAC = HMAC$instance & __HMAC$views;


export class HMACMD5$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    key: byte[];
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACMD5$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACMD5 = HMACMD5$instance & __HMACMD5$views;


export class HMACSHA1$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    constructor(key: byte[], useManagedSha1: boolean);
    key: byte[];
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA1$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA1 = HMACSHA1$instance & __HMACSHA1$views;


export class HMACSHA256$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    key: byte[];
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA256 = HMACSHA256$instance & __HMACSHA256$views;


export class HMACSHA3_256$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    key: byte[];
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static readonly isSupported: boolean;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA3_256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_256 = HMACSHA3_256$instance & __HMACSHA3_256$views;


export class HMACSHA3_384$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    key: byte[];
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static readonly isSupported: boolean;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA3_384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_384 = HMACSHA3_384$instance & __HMACSHA3_384$views;


export class HMACSHA3_512$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    key: byte[];
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static readonly isSupported: boolean;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA3_512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_512 = HMACSHA3_512$instance & __HMACSHA3_512$views;


export class HMACSHA384$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    key: byte[];
    produceLegacyHmacValues: boolean;
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA384 = HMACSHA384$instance & __HMACSHA384$views;


export class HMACSHA512$instance extends HMAC$instance {
    constructor();
    constructor(key: byte[]);
    key: byte[];
    produceLegacyHmacValues: boolean;
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(key: byte[], source: byte[]): byte[];
    static hashData(key: byte[], source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __HMACSHA512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA512 = HMACSHA512$instance & __HMACSHA512$views;


export class IncrementalHash$instance {
    readonly algorithmName: HashAlgorithmName;
    readonly hashLengthInBytes: int;
    appendData(data: byte[]): void;
    appendData(data: byte[], offset: int, count: int): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): IncrementalHash;
    dispose(): void;
    getCurrentHash(): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): int;
    getHashAndReset(): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): int;
    tryGetCurrentHash(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryGetHashAndReset(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static createHash(hashAlgorithm: HashAlgorithmName): IncrementalHash;
    static createHMAC(hashAlgorithm: HashAlgorithmName, key: byte[]): IncrementalHash;
    static createHMAC(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>): IncrementalHash;
}


export interface __IncrementalHash$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface IncrementalHash$instance extends System_Internal.IDisposable$instance {}

export type IncrementalHash = IncrementalHash$instance & __IncrementalHash$views;


export abstract class KeyedHashAlgorithm$instance extends HashAlgorithm$instance {
    key: byte[];
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __KeyedHashAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type KeyedHashAlgorithm = KeyedHashAlgorithm$instance & __KeyedHashAlgorithm$views;


export class KeySizes$instance {
    constructor(minSize: int, maxSize: int, skipSize: int);
    readonly maxSize: int;
    readonly minSize: int;
    readonly skipSize: int;
}


export type KeySizes = KeySizes$instance;

export class Kmac128$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Kmac128;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly isSupported: boolean;
    static hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Kmac128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Kmac128$instance extends System_Internal.IDisposable$instance {}

export type Kmac128 = Kmac128$instance & __Kmac128$views;


export class Kmac256$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Kmac256;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly isSupported: boolean;
    static hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Kmac256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Kmac256$instance extends System_Internal.IDisposable$instance {}

export type Kmac256 = Kmac256$instance & __Kmac256$views;


export class KmacXof128$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): KmacXof128;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly isSupported: boolean;
    static hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __KmacXof128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface KmacXof128$instance extends System_Internal.IDisposable$instance {}

export type KmacXof128 = KmacXof128$instance & __KmacXof128$views;


export class KmacXof256$instance {
    constructor(key: byte[], customizationString: byte[]);
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>);
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): KmacXof256;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    static readonly isSupported: boolean;
    static hashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    static hashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __KmacXof256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface KmacXof256$instance extends System_Internal.IDisposable$instance {}

export type KmacXof256 = KmacXof256$instance & __KmacXof256$views;


export abstract class MaskGenerationMethod$instance {
    abstract generateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export type MaskGenerationMethod = MaskGenerationMethod$instance;

export abstract class MD5$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __MD5$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type MD5 = MD5$instance & __MD5$views;


export class MD5CryptoServiceProvider$instance extends MD5$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __MD5CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type MD5CryptoServiceProvider = MD5CryptoServiceProvider$instance & __MD5CryptoServiceProvider$views;


export abstract class MLDsa$instance {
    readonly algorithm: MLDsaAlgorithm;
    dispose(): void;
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportMLDsaPrivateKey(): byte[];
    exportMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    exportMLDsaPrivateSeed(): byte[];
    exportMLDsaPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    exportMLDsaPublicKey(): byte[];
    exportMLDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signData(data: byte[], context?: byte[]): byte[];
    signMu(externalMu: byte[]): byte[];
    signMu(externalMu: ReadOnlySpan_1<CLROf<byte>>): byte[];
    signMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    signPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    verifyMu(externalMu: byte[], signature: byte[]): boolean;
    verifyMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
    static readonly isSupported: boolean;
    static generateKey(algorithm: MLDsaAlgorithm): MLDsa;
    static importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static importEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLDsa;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): MLDsa;
    static importFromEncryptedPem(source: string, passwordBytes: byte[]): MLDsa;
    static importFromEncryptedPem(source: string, password: string): MLDsa;
    static importFromPem(source: ReadOnlySpan_1<CLROf<char>>): MLDsa;
    static importFromPem(source: string): MLDsa;
    static importMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    static importMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static importMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    static importMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static importMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    static importMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static importPkcs8PrivateKey(source: byte[]): MLDsa;
    static importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    static importSubjectPublicKeyInfo(source: byte[]): MLDsa;
    static importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
}


export interface __MLDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLDsa$instance extends System_Internal.IDisposable$instance {}

export type MLDsa = MLDsa$instance & __MLDsa$views;


export class MLDsaAlgorithm$instance {
    readonly muSizeInBytes: int;
    readonly name: string;
    readonly privateKeySizeInBytes: int;
    readonly privateSeedSizeInBytes: int;
    readonly publicKeySizeInBytes: int;
    readonly signatureSizeInBytes: int;
    equals(other: MLDsaAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly mlDsa44: MLDsaAlgorithm;
    static readonly mlDsa65: MLDsaAlgorithm;
    static readonly mlDsa87: MLDsaAlgorithm;
}


export interface __MLDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MLDsaAlgorithm): boolean;
}

export type MLDsaAlgorithm = MLDsaAlgorithm$instance & __MLDsaAlgorithm$views;


export class MLDsaCng$instance extends MLDsa$instance {
    constructor(key: CngKey);
    Dispose(): void;
    getKey(): CngKey;
}


export interface __MLDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLDsaCng$instance extends System_Internal.IDisposable$instance {}

export type MLDsaCng = MLDsaCng$instance & __MLDsaCng$views;


export class MLDsaOpenSsl$instance extends MLDsa$instance {
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    Dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
}


export interface __MLDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLDsaOpenSsl$instance extends System_Internal.IDisposable$instance {}

export type MLDsaOpenSsl = MLDsaOpenSsl$instance & __MLDsaOpenSsl$views;


export abstract class MLKem$instance {
    readonly algorithm: MLKemAlgorithm;
    decapsulate(ciphertext: ReadOnlySpan_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    decapsulate(ciphertext: byte[]): byte[];
    dispose(): void;
    encapsulate(ciphertext: Span_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    encapsulate(ciphertext: { value: ref<byte[]> }, sharedSecret: { value: ref<byte[]> }): void;
    exportDecapsulationKey(destination: Span_1<CLROf<byte>>): void;
    exportDecapsulationKey(): byte[];
    exportEncapsulationKey(destination: Span_1<CLROf<byte>>): void;
    exportEncapsulationKey(): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    exportPrivateSeed(): byte[];
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static readonly isSupported: boolean;
    static generateKey(algorithm: MLKemAlgorithm): MLKem;
    static importDecapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    static importDecapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static importEncapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    static importEncapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static importEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLKem;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): MLKem;
    static importFromEncryptedPem(source: string, passwordBytes: byte[]): MLKem;
    static importFromEncryptedPem(source: string, password: string): MLKem;
    static importFromPem(source: ReadOnlySpan_1<CLROf<char>>): MLKem;
    static importFromPem(source: string): MLKem;
    static importPkcs8PrivateKey(source: byte[]): MLKem;
    static importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static importPrivateSeed(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    static importPrivateSeed(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    static importSubjectPublicKeyInfo(source: byte[]): MLKem;
    static importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
}


export interface __MLKem$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLKem$instance extends System_Internal.IDisposable$instance {}

export type MLKem = MLKem$instance & __MLKem$views;


export class MLKemAlgorithm$instance {
    readonly ciphertextSizeInBytes: int;
    readonly decapsulationKeySizeInBytes: int;
    readonly encapsulationKeySizeInBytes: int;
    readonly name: string;
    readonly privateSeedSizeInBytes: int;
    readonly sharedSecretSizeInBytes: int;
    equals(other: MLKemAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly mlKem512: MLKemAlgorithm;
    static readonly mlKem768: MLKemAlgorithm;
    static readonly mlKem1024: MLKemAlgorithm;
}


export interface __MLKemAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MLKemAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MLKemAlgorithm): boolean;
}

export type MLKemAlgorithm = MLKemAlgorithm$instance & __MLKemAlgorithm$views;


export class MLKemCng$instance extends MLKem$instance {
    constructor(key: CngKey);
    Dispose(): void;
    getKey(): CngKey;
}


export interface __MLKemCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLKemCng$instance extends System_Internal.IDisposable$instance {}

export type MLKemCng = MLKemCng$instance & __MLKemCng$views;


export class MLKemOpenSsl$instance extends MLKem$instance {
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    Dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
}


export interface __MLKemOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLKemOpenSsl$instance extends System_Internal.IDisposable$instance {}

export type MLKemOpenSsl = MLKemOpenSsl$instance & __MLKemOpenSsl$views;


export class Oid$instance {
    constructor();
    constructor(oid: string);
    constructor(value: string, friendlyName: string);
    constructor(oid: Oid);
    friendlyName: string;
    value: string;
    static fromFriendlyName(friendlyName: string, group: OidGroup): Oid;
    static fromOidValue(oidValue: string, group: OidGroup): Oid;
}


export type Oid = Oid$instance;

export class OidCollection$instance {
    constructor();
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    add(oid: Oid): int;
    copyTo(array: Oid[], index: int): void;
    get_Item(index: int): Oid;
    get_Item(oid: string): Oid;
    getEnumerator(): OidEnumerator;
}


export interface __OidCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type OidCollection = OidCollection$instance & __OidCollection$views;


export class OidEnumerator$instance {
    readonly current: Oid | unknown;
    moveNext(): boolean;
    reset(): void;
}


export interface __OidEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OidEnumerator = OidEnumerator$instance & __OidEnumerator$views;


export class PasswordDeriveBytes$instance extends DeriveBytes$instance {
    constructor(strPassword: string, rgbSalt: byte[]);
    constructor(password: byte[], salt: byte[]);
    constructor(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int);
    constructor(password: byte[], salt: byte[], hashName: string, iterations: int);
    constructor(strPassword: string, rgbSalt: byte[], cspParams: CspParameters);
    constructor(password: byte[], salt: byte[], cspParams: CspParameters);
    constructor(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int, cspParams: CspParameters);
    constructor(password: byte[], salt: byte[], hashName: string, iterations: int, cspParams: CspParameters);
    hashName: string;
    iterationCount: int;
    salt: byte[];
    cryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    Dispose(): void;
    getBytes(cb: int): byte[];
    reset(): void;
}


export interface __PasswordDeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PasswordDeriveBytes$instance extends System_Internal.IDisposable$instance {}

export type PasswordDeriveBytes = PasswordDeriveBytes$instance & __PasswordDeriveBytes$views;


export class PbeParameters$instance {
    constructor(encryptionAlgorithm: PbeEncryptionAlgorithm, hashAlgorithm: HashAlgorithmName, iterationCount: int);
    readonly encryptionAlgorithm: PbeEncryptionAlgorithm;
    readonly hashAlgorithm: HashAlgorithmName;
    readonly iterationCount: int;
}


export type PbeParameters = PbeParameters$instance;

export class PKCS1MaskGenerationMethod$instance extends MaskGenerationMethod$instance {
    constructor();
    hashName: string;
    generateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export type PKCS1MaskGenerationMethod = PKCS1MaskGenerationMethod$instance;

export abstract class RandomNumberGenerator$instance {
    dispose(): void;
    getBytes(data: byte[]): void;
    getBytes(data: byte[], offset: int, count: int): void;
    getBytes(data: Span_1<CLROf<byte>>): void;
    getNonZeroBytes(data: byte[]): void;
    getNonZeroBytes(data: Span_1<CLROf<byte>>): void;
    static create(): RandomNumberGenerator;
    static create(rngName: string): RandomNumberGenerator;
    static fill(data: Span_1<CLROf<byte>>): void;
    static getBytes(count: int): byte[];
    static getHexString(stringLength: int, lowercase?: boolean): string;
    static getHexString(destination: Span_1<CLROf<char>>, lowercase?: boolean): void;
    static getInt32(fromInclusive: int, toExclusive: int): int;
    static getInt32(toExclusive: int): int;
    static getItems<T>(choices: ReadOnlySpan_1<T>, destination: Span_1<T>): void;
    static getItems<T>(choices: ReadOnlySpan_1<T>, length: int): T[];
    static getString(choices: ReadOnlySpan_1<CLROf<char>>, length: int): string;
    static shuffle<T>(values: Span_1<T>): void;
}


export interface __RandomNumberGenerator$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RandomNumberGenerator$instance extends System_Internal.IDisposable$instance {}

export type RandomNumberGenerator = RandomNumberGenerator$instance & __RandomNumberGenerator$views;


export abstract class RC2$instance extends SymmetricAlgorithm$instance {
    effectiveKeySize: int;
    keySize: int;
    Dispose(): void;
}


export interface __RC2$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RC2$instance extends System_Internal.IDisposable$instance {}

export type RC2 = RC2$instance & __RC2$views;


export class RC2CryptoServiceProvider$instance extends RC2$instance {
    constructor();
    blockSize: int;
    effectiveKeySize: int;
    feedbackSize: int;
    iv: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    useSalt: boolean;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __RC2CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RC2CryptoServiceProvider$instance extends System_Internal.IDisposable$instance {}

export type RC2CryptoServiceProvider = RC2CryptoServiceProvider$instance & __RC2CryptoServiceProvider$views;


export class Rfc2898DeriveBytes$instance extends DeriveBytes$instance {
    constructor(password: byte[], salt: byte[], iterations: int);
    constructor(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName);
    constructor(password: string, salt: byte[]);
    constructor(password: string, salt: byte[], iterations: int);
    constructor(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName);
    constructor(password: string, saltSize: int);
    constructor(password: string, saltSize: int, iterations: int);
    constructor(password: string, saltSize: int, iterations: int, hashAlgorithm: HashAlgorithmName);
    readonly hashAlgorithm: HashAlgorithmName;
    iterationCount: int;
    salt: byte[];
    cryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    Dispose(): void;
    getBytes(cb: int): byte[];
    reset(): void;
    static pbkdf2(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    static pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    static pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    static pbkdf2(password: ReadOnlySpan_1<CLROf<char>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    static pbkdf2(password: ReadOnlySpan_1<CLROf<char>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    static pbkdf2(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
}


export interface __Rfc2898DeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Rfc2898DeriveBytes$instance extends System_Internal.IDisposable$instance {}

export type Rfc2898DeriveBytes = Rfc2898DeriveBytes$instance & __Rfc2898DeriveBytes$views;


export abstract class Rijndael$instance extends SymmetricAlgorithm$instance {
    Dispose(): void;
}


export interface __Rijndael$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Rijndael$instance extends System_Internal.IDisposable$instance {}

export type Rijndael = Rijndael$instance & __Rijndael$views;


export class RijndaelManaged$instance extends Rijndael$instance {
    constructor();
    blockSize: int;
    feedbackSize: int;
    iv: byte[];
    key: byte[];
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __RijndaelManaged$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RijndaelManaged$instance extends System_Internal.IDisposable$instance {}

export type RijndaelManaged = RijndaelManaged$instance & __RijndaelManaged$views;


export class RNGCryptoServiceProvider$instance extends RandomNumberGenerator$instance {
    constructor();
    constructor(str: string);
    constructor(rgb: byte[]);
    constructor(cspParams: CspParameters);
    Dispose(): void;
    getBytes(data: byte[]): void;
    getBytes(data: byte[], offset: int, count: int): void;
    getBytes(data: Span_1<CLROf<byte>>): void;
    getBytes(data: Span_1<CLROf<byte>>): void;
    getNonZeroBytes(data: byte[]): void;
    getNonZeroBytes(data: Span_1<CLROf<byte>>): void;
    getNonZeroBytes(data: Span_1<CLROf<byte>>): void;
}


export interface __RNGCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RNGCryptoServiceProvider$instance extends System_Internal.IDisposable$instance {}

export type RNGCryptoServiceProvider = RNGCryptoServiceProvider$instance & __RNGCryptoServiceProvider$views;


export abstract class RSA$instance extends AsymmetricAlgorithm$instance {
    readonly keyExchangeAlgorithm: string;
    readonly signatureAlgorithm: string;
    decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    decryptValue(rgb: byte[]): byte[];
    Dispose(): void;
    encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    encryptValue(rgb: byte[]): byte[];
    abstract exportParameters(includePrivateParameters: boolean): RSAParameters;
    exportRSAPrivateKey(): byte[];
    exportRSAPrivateKeyPem(): string;
    exportRSAPublicKey(): byte[];
    exportRSAPublicKeyPem(): string;
    fromXmlString(xmlString: string): void;
    getMaxOutputSize(): int;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    importFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    importFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    abstract importParameters(parameters: RSAParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    signHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    toXmlString(includePrivateParameters: boolean): string;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export interface __RSA$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RSA$instance extends System_Internal.IDisposable$instance {}

export type RSA = RSA$instance & __RSA$views;


export class RSACng$instance extends RSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(key: CngKey);
    readonly key: CngKey;
    Dispose(): void;
    exportParameters(includePrivateParameters: boolean): RSAParameters;
    importParameters(parameters: RSAParameters): void;
}


export interface __RSACng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RSACng$instance extends System_Internal.IDisposable$instance {}

export type RSACng = RSACng$instance & __RSACng$views;


export class RSACryptoServiceProvider$instance extends RSA$instance {
    constructor();
    constructor(dwKeySize: int);
    constructor(dwKeySize: int, parameters: CspParameters);
    constructor(parameters: CspParameters);
    readonly cspKeyContainerInfo: CspKeyContainerInfo;
    readonly keyExchangeAlgorithm: string;
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    persistKeyInCsp: boolean;
    readonly publicOnly: boolean;
    readonly signatureAlgorithm: string;
    decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    Dispose(): void;
    encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    exportCspBlob(includePrivateParameters: boolean): byte[];
    exportParameters(includePrivateParameters: boolean): RSAParameters;
    fromXmlString(xmlString: string): void;
    importCspBlob(keyBlob: byte[]): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: RSAParameters): void;
    signData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    signHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    toXmlString(includePrivateParameters: boolean): string;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    static useMachineKeyStore: boolean;
}


export interface __RSACryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICspAsymmetricAlgorithm(): ICspAsymmetricAlgorithm$instance;
}

export interface RSACryptoServiceProvider$instance extends System_Internal.IDisposable$instance, ICspAsymmetricAlgorithm$instance {}

export type RSACryptoServiceProvider = RSACryptoServiceProvider$instance & __RSACryptoServiceProvider$views;


export class RSAEncryptionPadding$instance {
    readonly mode: RSAEncryptionPaddingMode;
    readonly oaepHashAlgorithm: HashAlgorithmName;
    equals(obj: unknown): boolean;
    equals(other: RSAEncryptionPadding): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly pkcs1: RSAEncryptionPadding;
    static readonly oaepSHA1: RSAEncryptionPadding;
    static readonly oaepSHA256: RSAEncryptionPadding;
    static readonly oaepSHA384: RSAEncryptionPadding;
    static readonly oaepSHA512: RSAEncryptionPadding;
    static readonly oaepSHA3_256: RSAEncryptionPadding;
    static readonly oaepSHA3_384: RSAEncryptionPadding;
    static readonly oaepSHA3_512: RSAEncryptionPadding;
    static createOaep(hashAlgorithm: HashAlgorithmName): RSAEncryptionPadding;
}


export interface __RSAEncryptionPadding$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RSAEncryptionPadding>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RSAEncryptionPadding): boolean;
}

export type RSAEncryptionPadding = RSAEncryptionPadding$instance & __RSAEncryptionPadding$views;


export class RSAOAEPKeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    parameters: string;
    decryptKeyExchange(rgbData: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export type RSAOAEPKeyExchangeDeformatter = RSAOAEPKeyExchangeDeformatter$instance;

export class RSAOAEPKeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    parameter: byte[];
    readonly parameters: string;
    rng: RandomNumberGenerator;
    createKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    createKeyExchange(rgbData: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export type RSAOAEPKeyExchangeFormatter = RSAOAEPKeyExchangeFormatter$instance;

export class RSAOpenSsl$instance extends RSA$instance {
    constructor();
    constructor(keySize: int);
    constructor(parameters: RSAParameters);
    constructor(handle: nint);
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    keySize: int;
    readonly legalKeySizes: KeySizes[];
    decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    Dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
    encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    exportParameters(includePrivateParameters: boolean): RSAParameters;
    exportPkcs8PrivateKey(): byte[];
    exportRSAPrivateKey(): byte[];
    exportRSAPublicKey(): byte[];
    exportSubjectPublicKeyInfo(): byte[];
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importParameters(parameters: RSAParameters): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    signHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    signHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    trySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    verifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    verifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export interface __RSAOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RSAOpenSsl$instance extends System_Internal.IDisposable$instance {}

export type RSAOpenSsl = RSAOpenSsl$instance & __RSAOpenSsl$views;


export class RSAPKCS1KeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    parameters: string;
    rng: RandomNumberGenerator;
    decryptKeyExchange(rgbIn: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export type RSAPKCS1KeyExchangeDeformatter = RSAPKCS1KeyExchangeDeformatter$instance;

export class RSAPKCS1KeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    readonly parameters: string;
    rng: RandomNumberGenerator;
    createKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    createKeyExchange(rgbData: byte[]): byte[];
    setKey(key: AsymmetricAlgorithm): void;
}


export type RSAPKCS1KeyExchangeFormatter = RSAPKCS1KeyExchangeFormatter$instance;

export class RSAPKCS1SignatureDeformatter$instance extends AsymmetricSignatureDeformatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export type RSAPKCS1SignatureDeformatter = RSAPKCS1SignatureDeformatter$instance;

export class RSAPKCS1SignatureFormatter$instance extends AsymmetricSignatureFormatter$instance {
    constructor();
    constructor(key: AsymmetricAlgorithm);
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(hash: HashAlgorithm): byte[];
    setHashAlgorithm(strName: string): void;
    setKey(key: AsymmetricAlgorithm): void;
}


export type RSAPKCS1SignatureFormatter = RSAPKCS1SignatureFormatter$instance;

export class RSASignaturePadding$instance {
    readonly mode: RSASignaturePaddingMode;
    equals(obj: unknown): boolean;
    equals(other: RSASignaturePadding): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly pkcs1: RSASignaturePadding;
    static readonly pss: RSASignaturePadding;
}


export interface __RSASignaturePadding$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RSASignaturePadding>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RSASignaturePadding): boolean;
}

export type RSASignaturePadding = RSASignaturePadding$instance & __RSASignaturePadding$views;


export class SafeEvpPKeyHandle$instance extends System_Runtime_InteropServices_Internal.SafeHandle$instance {
    constructor();
    constructor(handle: nint, ownsHandle: boolean);
    readonly isInvalid: boolean;
    Dispose(): void;
    duplicateHandle(): SafeEvpPKeyHandle;
    static readonly openSslVersion: long;
    static openKeyFromProvider(providerName: string, keyUri: string): SafeEvpPKeyHandle;
    static openPrivateKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
    static openPublicKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
}


export interface __SafeEvpPKeyHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SafeEvpPKeyHandle$instance extends System_Internal.IDisposable$instance {}

export type SafeEvpPKeyHandle = SafeEvpPKeyHandle$instance & __SafeEvpPKeyHandle$views;


export abstract class SHA1$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA1$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1 = SHA1$instance & __SHA1$views;


export class SHA1CryptoServiceProvider$instance extends SHA1$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA1CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1CryptoServiceProvider = SHA1CryptoServiceProvider$instance & __SHA1CryptoServiceProvider$views;


export class SHA1Managed$instance extends SHA1$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA1Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1Managed = SHA1Managed$instance & __SHA1Managed$views;


export abstract class SHA256$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256 = SHA256$instance & __SHA256$views;


export class SHA256CryptoServiceProvider$instance extends SHA256$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA256CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256CryptoServiceProvider = SHA256CryptoServiceProvider$instance & __SHA256CryptoServiceProvider$views;


export class SHA256Managed$instance extends SHA256$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA256Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256Managed = SHA256Managed$instance & __SHA256Managed$views;


export abstract class SHA3_256$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static readonly isSupported: boolean;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA3_256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_256 = SHA3_256$instance & __SHA3_256$views;


export abstract class SHA3_384$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static readonly isSupported: boolean;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA3_384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_384 = SHA3_384$instance & __SHA3_384$views;


export abstract class SHA3_512$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static readonly isSupported: boolean;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA3_512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_512 = SHA3_512$instance & __SHA3_512$views;


export abstract class SHA384$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384 = SHA384$instance & __SHA384$views;


export class SHA384CryptoServiceProvider$instance extends SHA384$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA384CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384CryptoServiceProvider = SHA384CryptoServiceProvider$instance & __SHA384CryptoServiceProvider$views;


export class SHA384Managed$instance extends SHA384$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA384Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384Managed = SHA384Managed$instance & __SHA384Managed$views;


export abstract class SHA512$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    static readonly hashSizeInBits: int;
    static readonly hashSizeInBytes: int;
    static hashData(source: byte[]): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: Stream): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export interface __SHA512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512 = SHA512$instance & __SHA512$views;


export class SHA512CryptoServiceProvider$instance extends SHA512$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA512CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512CryptoServiceProvider = SHA512CryptoServiceProvider$instance & __SHA512CryptoServiceProvider$views;


export class SHA512Managed$instance extends SHA512$instance {
    constructor();
    Dispose(): void;
    initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __SHA512Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512Managed = SHA512Managed$instance & __SHA512Managed$views;


export class Shake128$instance {
    constructor();
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Shake128;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    read(outputLength: int): byte[];
    read(destination: Span_1<CLROf<byte>>): void;
    reset(): void;
    static readonly isSupported: boolean;
    static hashData(source: byte[], outputLength: int): byte[];
    static hashData(source: Stream, outputLength: int): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    static hashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Shake128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Shake128$instance extends System_Internal.IDisposable$instance {}

export type Shake128 = Shake128$instance & __Shake128$views;


export class Shake256$instance {
    constructor();
    appendData(data: byte[]): void;
    appendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    clone(): Shake256;
    dispose(): void;
    getCurrentHash(outputLength: int): byte[];
    getCurrentHash(destination: Span_1<CLROf<byte>>): void;
    getHashAndReset(outputLength: int): byte[];
    getHashAndReset(destination: Span_1<CLROf<byte>>): void;
    read(outputLength: int): byte[];
    read(destination: Span_1<CLROf<byte>>): void;
    reset(): void;
    static readonly isSupported: boolean;
    static hashData(source: byte[], outputLength: int): byte[];
    static hashData(source: Stream, outputLength: int): byte[];
    static hashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    static hashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    static hashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
}


export interface __Shake256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Shake256$instance extends System_Internal.IDisposable$instance {}

export type Shake256 = Shake256$instance & __Shake256$views;


export class SignatureDescription$instance {
    constructor();
    constructor(el: SecurityElement);
    deformatterAlgorithm: string;
    digestAlgorithm: string;
    formatterAlgorithm: string;
    keyAlgorithm: string;
    createDeformatter(key: AsymmetricAlgorithm): AsymmetricSignatureDeformatter;
    createDigest(): HashAlgorithm;
    createFormatter(key: AsymmetricAlgorithm): AsymmetricSignatureFormatter;
}


export type SignatureDescription = SignatureDescription$instance;

export abstract class SlhDsa$instance {
    readonly algorithm: SlhDsaAlgorithm;
    dispose(): void;
    exportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    exportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    exportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    exportPkcs8PrivateKey(): byte[];
    exportPkcs8PrivateKeyPem(): string;
    exportSlhDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    exportSlhDsaPrivateKey(): byte[];
    exportSlhDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    exportSlhDsaPublicKey(): byte[];
    exportSubjectPublicKeyInfo(): byte[];
    exportSubjectPublicKeyInfoPem(): string;
    signData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signData(data: byte[], context?: byte[]): byte[];
    signPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    signPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    tryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    verifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    verifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    verifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
    static readonly isSupported: boolean;
    static generateKey(algorithm: SlhDsaAlgorithm): SlhDsa;
    static importEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static importEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static importEncryptedPkcs8PrivateKey(password: string, source: byte[]): SlhDsa;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static importFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): SlhDsa;
    static importFromEncryptedPem(source: string, passwordBytes: byte[]): SlhDsa;
    static importFromEncryptedPem(source: string, password: string): SlhDsa;
    static importFromPem(source: ReadOnlySpan_1<CLROf<char>>): SlhDsa;
    static importFromPem(source: string): SlhDsa;
    static importPkcs8PrivateKey(source: byte[]): SlhDsa;
    static importPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static importSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    static importSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static importSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    static importSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    static importSubjectPublicKeyInfo(source: byte[]): SlhDsa;
    static importSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
}


export interface __SlhDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SlhDsa$instance extends System_Internal.IDisposable$instance {}

export type SlhDsa = SlhDsa$instance & __SlhDsa$views;


export class SlhDsaAlgorithm$instance {
    readonly name: string;
    readonly privateKeySizeInBytes: int;
    readonly publicKeySizeInBytes: int;
    readonly signatureSizeInBytes: int;
    equals(other: SlhDsaAlgorithm): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly slhDsaSha2_128s: SlhDsaAlgorithm;
    static readonly slhDsaShake128s: SlhDsaAlgorithm;
    static readonly slhDsaSha2_128f: SlhDsaAlgorithm;
    static readonly slhDsaShake128f: SlhDsaAlgorithm;
    static readonly slhDsaSha2_192s: SlhDsaAlgorithm;
    static readonly slhDsaShake192s: SlhDsaAlgorithm;
    static readonly slhDsaSha2_192f: SlhDsaAlgorithm;
    static readonly slhDsaShake192f: SlhDsaAlgorithm;
    static readonly slhDsaSha2_256s: SlhDsaAlgorithm;
    static readonly slhDsaShake256s: SlhDsaAlgorithm;
    static readonly slhDsaSha2_256f: SlhDsaAlgorithm;
    static readonly slhDsaShake256f: SlhDsaAlgorithm;
}


export interface __SlhDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SlhDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SlhDsaAlgorithm): boolean;
}

export type SlhDsaAlgorithm = SlhDsaAlgorithm$instance & __SlhDsaAlgorithm$views;


export class SlhDsaCng$instance extends SlhDsa$instance {
    constructor(key: CngKey);
    Dispose(): void;
    getKey(): CngKey;
}


export interface __SlhDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SlhDsaCng$instance extends System_Internal.IDisposable$instance {}

export type SlhDsaCng = SlhDsaCng$instance & __SlhDsaCng$views;


export class SlhDsaOpenSsl$instance extends SlhDsa$instance {
    constructor(pkeyHandle: SafeEvpPKeyHandle);
    Dispose(): void;
    duplicateKeyHandle(): SafeEvpPKeyHandle;
}


export interface __SlhDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SlhDsaOpenSsl$instance extends System_Internal.IDisposable$instance {}

export type SlhDsaOpenSsl = SlhDsaOpenSsl$instance & __SlhDsaOpenSsl$views;


export class SP800108HmacCounterKdf$instance {
    constructor(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName);
    constructor(key: byte[], hashAlgorithm: HashAlgorithmName);
    deriveKey(label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    deriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    deriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    deriveKey(label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, derivedKeyLengthInBytes: int): byte[];
    deriveKey(label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>): void;
    deriveKey(label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    dispose(): void;
    static deriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    static deriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    static deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    static deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    static deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, derivedKeyLengthInBytes: int): byte[];
    static deriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>): void;
}


export interface __SP800108HmacCounterKdf$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SP800108HmacCounterKdf$instance extends System_Internal.IDisposable$instance {}

export type SP800108HmacCounterKdf = SP800108HmacCounterKdf$instance & __SP800108HmacCounterKdf$views;


export abstract class SymmetricAlgorithm$instance {
    blockSize: int;
    feedbackSize: int;
    iv: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    clear(): void;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    decryptCbc(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    decryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    decryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    decryptCfb(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    decryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    decryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    decryptEcb(ciphertext: byte[], paddingMode: PaddingMode): byte[];
    decryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    decryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    dispose(): void;
    encryptCbc(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    encryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    encryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    encryptCfb(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    encryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    encryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    encryptEcb(plaintext: byte[], paddingMode: PaddingMode): byte[];
    encryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    encryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    abstract generateIV(): void;
    abstract generateKey(): void;
    getCiphertextLengthCbc(plaintextLength: int, paddingMode?: PaddingMode): int;
    getCiphertextLengthCfb(plaintextLength: int, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    getCiphertextLengthEcb(plaintextLength: int, paddingMode: PaddingMode): int;
    setKey(key: ReadOnlySpan_1<CLROf<byte>>): void;
    tryDecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    tryDecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    tryDecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    tryEncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    tryEncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    tryEncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    validKeySize(bitLength: int): boolean;
    static create(): SymmetricAlgorithm;
    static create(algName: string): SymmetricAlgorithm;
}


export interface __SymmetricAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SymmetricAlgorithm$instance extends System_Internal.IDisposable$instance {}

export type SymmetricAlgorithm = SymmetricAlgorithm$instance & __SymmetricAlgorithm$views;


export class ToBase64Transform$instance {
    constructor();
    readonly canReuseTransform: boolean;
    readonly canTransformMultipleBlocks: boolean;
    readonly inputBlockSize: int;
    readonly outputBlockSize: int;
    clear(): void;
    dispose(): void;
    transformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    transformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface __ToBase64Transform$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type ToBase64Transform = ToBase64Transform$instance & __ToBase64Transform$views;


export abstract class TripleDES$instance extends SymmetricAlgorithm$instance {
    key: byte[];
    Dispose(): void;
    static isWeakKey(rgbKey: byte[]): boolean;
}


export interface __TripleDES$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TripleDES$instance extends System_Internal.IDisposable$instance {}

export type TripleDES = TripleDES$instance & __TripleDES$views;


export class TripleDESCng$instance extends TripleDES$instance {
    constructor();
    constructor(keyName: string);
    constructor(keyName: string, provider: CngProvider);
    constructor(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions);
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateDecryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __TripleDESCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TripleDESCng$instance extends System_Internal.IDisposable$instance {}

export type TripleDESCng = TripleDESCng$instance & __TripleDESCng$views;


export class TripleDESCryptoServiceProvider$instance extends TripleDES$instance {
    constructor();
    blockSize: int;
    feedbackSize: int;
    iv: byte[];
    key: byte[];
    keySize: int;
    readonly legalBlockSizes: KeySizes[];
    readonly legalKeySizes: KeySizes[];
    mode: CipherMode;
    padding: PaddingMode;
    createDecryptor(): ICryptoTransform;
    createDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    createEncryptor(): ICryptoTransform;
    createEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    generateIV(): void;
    generateKey(): void;
}


export interface __TripleDESCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TripleDESCryptoServiceProvider$instance extends System_Internal.IDisposable$instance {}

export type TripleDESCryptoServiceProvider = TripleDESCryptoServiceProvider$instance & __TripleDESCryptoServiceProvider$views;


export abstract class CryptographicOperations$instance {
    static fixedTimeEquals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static hashData(hashAlgorithm: HashAlgorithmName, source: byte[]): byte[];
    static hashData(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hashData(hashAlgorithm: HashAlgorithmName, source: Stream): byte[];
    static hashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: byte[]): byte[];
    static hmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream): byte[];
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static hmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static hmacDataAsync(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static hmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static hmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static tryHashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryHmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static zeroMemory(buffer: Span_1<CLROf<byte>>): void;
}


export type CryptographicOperations = CryptographicOperations$instance;

export abstract class ECCurve_NamedCurves$instance {
    static readonly brainpoolP160r1: ECCurve;
    static readonly brainpoolP160t1: ECCurve;
    static readonly brainpoolP192r1: ECCurve;
    static readonly brainpoolP192t1: ECCurve;
    static readonly brainpoolP224r1: ECCurve;
    static readonly brainpoolP224t1: ECCurve;
    static readonly brainpoolP256r1: ECCurve;
    static readonly brainpoolP256t1: ECCurve;
    static readonly brainpoolP320r1: ECCurve;
    static readonly brainpoolP320t1: ECCurve;
    static readonly brainpoolP384r1: ECCurve;
    static readonly brainpoolP384t1: ECCurve;
    static readonly brainpoolP512r1: ECCurve;
    static readonly brainpoolP512t1: ECCurve;
    static readonly nistP256: ECCurve;
    static readonly nistP384: ECCurve;
    static readonly nistP521: ECCurve;
}


export type ECCurve_NamedCurves = ECCurve_NamedCurves$instance;

export abstract class HKDF$instance {
    static deriveKey(hashAlgorithmName: HashAlgorithmName, ikm: byte[], outputLength: int, salt?: byte[], info?: byte[]): byte[];
    static deriveKey(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static expand(hashAlgorithmName: HashAlgorithmName, prk: byte[], outputLength: int, info?: byte[]): byte[];
    static expand(hashAlgorithmName: HashAlgorithmName, prk: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static extract(hashAlgorithmName: HashAlgorithmName, ikm: byte[], salt?: byte[]): byte[];
    static extract(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, prk: Span_1<CLROf<byte>>): int;
}


export type HKDF = HKDF$instance;

export abstract class PemEncoding$instance {
    static find(pemData: ReadOnlySpan_1<CLROf<char>>): PemFields;
    static findUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>): PemFields;
    static getEncodedSize(labelLength: int, dataLength: int): int;
    static tryFind(pemData: ReadOnlySpan_1<CLROf<char>>, fields: { value: ref<PemFields> }): boolean;
    static tryFindUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>, fields: { value: ref<PemFields> }): boolean;
    static tryWrite(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static tryWriteUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static write(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>): char[];
    static writeString(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>): string;
    static writeUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>): byte[];
}


export type PemEncoding = PemEncoding$instance;

