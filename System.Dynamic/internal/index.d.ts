// Generated by tsbindgen - Architecture
// Namespace: System.Dynamic
// Assembly: System.Linq.Expressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { INotifyPropertyChanged } from "../../System.ComponentModel/internal/index.js";
import type { Expression, ExpressionType, LabelTarget, ParameterExpression } from "../../System.Linq.Expressions/internal/index.js";
import * as System_Runtime_CompilerServices_Internal from "../../System.Runtime.CompilerServices/internal/index.js";
import type { CallSite_1, CallSiteBinder } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Int32, Object as ClrObject, String as ClrString, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDynamicMetaObjectProvider$instance {
    GetMetaObject(parameter: Expression): DynamicMetaObject;
}


export type IDynamicMetaObjectProvider = IDynamicMetaObjectProvider$instance;

export interface IInvokeOnGetBinder$instance {
    readonly InvokeOnGet: boolean;
}


export type IInvokeOnGetBinder = IInvokeOnGetBinder$instance;

export abstract class BinaryOperationBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly Operation: ExpressionType;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackBinaryOperation(target: DynamicMetaObject, arg: DynamicMetaObject): DynamicMetaObject;
    FallbackBinaryOperation(target: DynamicMetaObject, arg: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type BinaryOperationBinder = BinaryOperationBinder$instance;

export abstract class BindingRestrictions$instance {
    Merge(restrictions: BindingRestrictions): BindingRestrictions;
    ToExpression(): Expression;
    static readonly Empty: BindingRestrictions;
    static Combine(contributingObjects: IList_1<DynamicMetaObject>): BindingRestrictions;
    static GetExpressionRestriction(expression: Expression): BindingRestrictions;
    static GetInstanceRestriction(expression: Expression, instance: any): BindingRestrictions;
    static GetTypeRestriction(expression: Expression, type_: Type): BindingRestrictions;
}


export type BindingRestrictions = BindingRestrictions$instance;

export class CallInfo$instance {
    constructor(argCount: int, argNames: string[]);
    constructor(argCount: int, argNames: IEnumerable_1<CLROf<string>>);
    readonly ArgumentCount: int;
    readonly ArgumentNames: ReadOnlyCollection_1<CLROf<string>>;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type CallInfo = CallInfo$instance;

export abstract class ConvertBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly Explicit: boolean;
    readonly ReturnType: Type;
    readonly Type: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackConvert(target: DynamicMetaObject): DynamicMetaObject;
    FallbackConvert(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type ConvertBinder = ConvertBinder$instance;

export abstract class CreateInstanceBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly CallInfo: CallInfo;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackCreateInstance(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    FallbackCreateInstance(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type CreateInstanceBinder = CreateInstanceBinder$instance;

export abstract class DeleteIndexBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly CallInfo: CallInfo;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackDeleteIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[]): DynamicMetaObject;
    FallbackDeleteIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type DeleteIndexBinder = DeleteIndexBinder$instance;

export abstract class DeleteMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly IgnoreCase: boolean;
    readonly Name: string;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackDeleteMember(target: DynamicMetaObject): DynamicMetaObject;
    FallbackDeleteMember(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type DeleteMemberBinder = DeleteMemberBinder$instance;

export class DynamicMetaObject$instance {
    constructor(expression: Expression, restrictions: BindingRestrictions);
    constructor(expression: Expression, restrictions: BindingRestrictions, value: any);
    readonly Expression: Expression;
    readonly HasValue: boolean;
    readonly LimitType: Type;
    readonly Restrictions: BindingRestrictions;
    readonly RuntimeType: Type;
    readonly Value: any;
    BindBinaryOperation(binder: BinaryOperationBinder, arg: DynamicMetaObject): DynamicMetaObject;
    BindConvert(binder: ConvertBinder): DynamicMetaObject;
    BindCreateInstance(binder: CreateInstanceBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    BindDeleteIndex(binder: DeleteIndexBinder, indexes: DynamicMetaObject[]): DynamicMetaObject;
    BindDeleteMember(binder: DeleteMemberBinder): DynamicMetaObject;
    BindGetIndex(binder: GetIndexBinder, indexes: DynamicMetaObject[]): DynamicMetaObject;
    BindGetMember(binder: GetMemberBinder): DynamicMetaObject;
    BindInvoke(binder: InvokeBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    BindInvokeMember(binder: InvokeMemberBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    BindSetIndex(binder: SetIndexBinder, indexes: DynamicMetaObject[], value: DynamicMetaObject): DynamicMetaObject;
    BindSetMember(binder: SetMemberBinder, value: DynamicMetaObject): DynamicMetaObject;
    BindUnaryOperation(binder: UnaryOperationBinder): DynamicMetaObject;
    GetDynamicMemberNames(): IEnumerable_1<CLROf<string>>;
    static readonly EmptyMetaObjects: DynamicMetaObject[];
    static Create(value: any, expression: Expression): DynamicMetaObject;
}


export type DynamicMetaObject = DynamicMetaObject$instance;

export abstract class DynamicMetaObjectBinder$instance extends System_Runtime_CompilerServices_Internal.CallSiteBinder$instance {
    readonly ReturnType: Type;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    Defer(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Defer(args: DynamicMetaObject[]): DynamicMetaObject;
    GetUpdateExpression(type_: Type): Expression;
}


export type DynamicMetaObjectBinder = DynamicMetaObjectBinder$instance;

export class DynamicObject$instance {
    GetDynamicMemberNames(): IEnumerable_1<CLROf<string>>;
    GetMetaObject(parameter: Expression): DynamicMetaObject;
    TryBinaryOperation(binder: BinaryOperationBinder, arg: any, result: { value: TSByRef<any> }): boolean;
    TryConvert(binder: ConvertBinder, result: { value: TSByRef<any> }): boolean;
    TryCreateInstance(binder: CreateInstanceBinder, args: any[], result: { value: TSByRef<any> }): boolean;
    TryDeleteIndex(binder: DeleteIndexBinder, indexes: any[]): boolean;
    TryDeleteMember(binder: DeleteMemberBinder): boolean;
    TryGetIndex(binder: GetIndexBinder, indexes: any[], result: { value: TSByRef<any> }): boolean;
    TryGetMember(binder: GetMemberBinder, result: { value: TSByRef<any> }): boolean;
    TryInvoke(binder: InvokeBinder, args: any[], result: { value: TSByRef<any> }): boolean;
    TryInvokeMember(binder: InvokeMemberBinder, args: any[], result: { value: TSByRef<any> }): boolean;
    TrySetIndex(binder: SetIndexBinder, indexes: any[], value: any): boolean;
    TrySetMember(binder: SetMemberBinder, value: any): boolean;
    TryUnaryOperation(binder: UnaryOperationBinder, result: { value: TSByRef<any> }): boolean;
}


export interface __DynamicObject$views {
    readonly As_IDynamicMetaObjectProvider: IDynamicMetaObjectProvider$instance;
}

export type DynamicObject = DynamicObject$instance & __DynamicObject$views;


export class ExpandoObject$instance {
    constructor();
}


export interface __ExpandoObject$views {
    readonly As_IDynamicMetaObjectProvider: IDynamicMetaObjectProvider$instance;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, any>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ExpandoObject = ExpandoObject$instance & __ExpandoObject$views;


export abstract class GetIndexBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly CallInfo: CallInfo;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackGetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[]): DynamicMetaObject;
    FallbackGetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type GetIndexBinder = GetIndexBinder$instance;

export abstract class GetMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly IgnoreCase: boolean;
    readonly Name: string;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackGetMember(target: DynamicMetaObject): DynamicMetaObject;
    FallbackGetMember(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type GetMemberBinder = GetMemberBinder$instance;

export abstract class InvokeBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly CallInfo: CallInfo;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    FallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type InvokeBinder = InvokeBinder$instance;

export abstract class InvokeMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly CallInfo: CallInfo;
    readonly IgnoreCase: boolean;
    readonly Name: string;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    abstract FallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
    FallbackInvokeMember(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    FallbackInvokeMember(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type InvokeMemberBinder = InvokeMemberBinder$instance;

export abstract class SetIndexBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly CallInfo: CallInfo;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackSetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], value: DynamicMetaObject): DynamicMetaObject;
    FallbackSetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], value: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type SetIndexBinder = SetIndexBinder$instance;

export abstract class SetMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly IgnoreCase: boolean;
    readonly Name: string;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackSetMember(target: DynamicMetaObject, value: DynamicMetaObject): DynamicMetaObject;
    FallbackSetMember(target: DynamicMetaObject, value: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type SetMemberBinder = SetMemberBinder$instance;

export abstract class UnaryOperationBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly Operation: ExpressionType;
    readonly ReturnType: Type;
    Bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    Bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    FallbackUnaryOperation(target: DynamicMetaObject): DynamicMetaObject;
    FallbackUnaryOperation(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type UnaryOperationBinder = UnaryOperationBinder$instance;

