// Generated by tsbindgen - Architecture
// Namespace: System.Dynamic
// Assembly: System.Linq.Expressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { INotifyPropertyChanged } from "../../System.ComponentModel/internal/index.js";
import type { Expression, ExpressionType, LabelTarget, ParameterExpression } from "../../System.Linq.Expressions/internal/index.js";
import * as System_Runtime_CompilerServices_Internal from "../../System.Runtime.CompilerServices/internal/index.js";
import type { CallSite_1, CallSiteBinder } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Int32, Object as ClrObject, String as ClrString, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDynamicMetaObjectProvider$instance {
    GetMetaObject(parameter: Expression): DynamicMetaObject;
}


export type IDynamicMetaObjectProvider = IDynamicMetaObjectProvider$instance;

export interface IInvokeOnGetBinder$instance {
    readonly InvokeOnGet: boolean;
}


export type IInvokeOnGetBinder = IInvokeOnGetBinder$instance;

export abstract class BinaryOperationBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly operation: ExpressionType;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackBinaryOperation(target: DynamicMetaObject, arg: DynamicMetaObject): DynamicMetaObject;
    fallbackBinaryOperation(target: DynamicMetaObject, arg: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type BinaryOperationBinder = BinaryOperationBinder$instance;

export abstract class BindingRestrictions$instance {
    merge(restrictions: BindingRestrictions): BindingRestrictions;
    toExpression(): Expression;
    static readonly empty: BindingRestrictions;
    static Combine(contributingObjects: IList_1<DynamicMetaObject>): BindingRestrictions;
    static GetExpressionRestriction(expression: Expression): BindingRestrictions;
    static GetInstanceRestriction(expression: Expression, instance: any): BindingRestrictions;
    static GetTypeRestriction(expression: Expression, type_: Type): BindingRestrictions;
}


export type BindingRestrictions = BindingRestrictions$instance;

export class CallInfo$instance {
    constructor(argCount: int, argNames: string[]);
    constructor(argCount: int, argNames: IEnumerable_1<CLROf<string>>);
    readonly argumentCount: int;
    readonly argumentNames: ReadOnlyCollection_1<CLROf<string>>;
    equals(obj: any): boolean;
    getHashCode(): int;
}


export type CallInfo = CallInfo$instance;

export abstract class ConvertBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly explicit: boolean;
    readonly returnType: Type;
    readonly type_: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackConvert(target: DynamicMetaObject): DynamicMetaObject;
    fallbackConvert(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type ConvertBinder = ConvertBinder$instance;

export abstract class CreateInstanceBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackCreateInstance(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    fallbackCreateInstance(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type CreateInstanceBinder = CreateInstanceBinder$instance;

export abstract class DeleteIndexBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackDeleteIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[]): DynamicMetaObject;
    fallbackDeleteIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type DeleteIndexBinder = DeleteIndexBinder$instance;

export abstract class DeleteMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackDeleteMember(target: DynamicMetaObject): DynamicMetaObject;
    fallbackDeleteMember(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type DeleteMemberBinder = DeleteMemberBinder$instance;

export class DynamicMetaObject$instance {
    constructor(expression: Expression, restrictions: BindingRestrictions);
    constructor(expression: Expression, restrictions: BindingRestrictions, value: any);
    readonly expression: Expression;
    readonly hasValue: boolean;
    readonly limitType: Type;
    readonly restrictions: BindingRestrictions;
    readonly runtimeType: Type;
    readonly value: any;
    bindBinaryOperation(binder: BinaryOperationBinder, arg: DynamicMetaObject): DynamicMetaObject;
    bindConvert(binder: ConvertBinder): DynamicMetaObject;
    bindCreateInstance(binder: CreateInstanceBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    bindDeleteIndex(binder: DeleteIndexBinder, indexes: DynamicMetaObject[]): DynamicMetaObject;
    bindDeleteMember(binder: DeleteMemberBinder): DynamicMetaObject;
    bindGetIndex(binder: GetIndexBinder, indexes: DynamicMetaObject[]): DynamicMetaObject;
    bindGetMember(binder: GetMemberBinder): DynamicMetaObject;
    bindInvoke(binder: InvokeBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    bindInvokeMember(binder: InvokeMemberBinder, args: DynamicMetaObject[]): DynamicMetaObject;
    bindSetIndex(binder: SetIndexBinder, indexes: DynamicMetaObject[], value: DynamicMetaObject): DynamicMetaObject;
    bindSetMember(binder: SetMemberBinder, value: DynamicMetaObject): DynamicMetaObject;
    bindUnaryOperation(binder: UnaryOperationBinder): DynamicMetaObject;
    getDynamicMemberNames(): IEnumerable_1<CLROf<string>>;
    static readonly emptyMetaObjects: DynamicMetaObject[];
    static Create(value: any, expression: Expression): DynamicMetaObject;
}


export type DynamicMetaObject = DynamicMetaObject$instance;

export abstract class DynamicMetaObjectBinder$instance extends System_Runtime_CompilerServices_Internal.CallSiteBinder$instance {
    readonly returnType: Type;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    defer(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    defer(args: DynamicMetaObject[]): DynamicMetaObject;
    getUpdateExpression(type_: Type): Expression;
}


export type DynamicMetaObjectBinder = DynamicMetaObjectBinder$instance;

export class DynamicObject$instance {
    getDynamicMemberNames(): IEnumerable_1<CLROf<string>>;
    getMetaObject(parameter: Expression): DynamicMetaObject;
    tryBinaryOperation(binder: BinaryOperationBinder, arg: any, result: { value: TSByRef<any> }): boolean;
    tryConvert(binder: ConvertBinder, result: { value: TSByRef<any> }): boolean;
    tryCreateInstance(binder: CreateInstanceBinder, args: any[], result: { value: TSByRef<any> }): boolean;
    tryDeleteIndex(binder: DeleteIndexBinder, indexes: any[]): boolean;
    tryDeleteMember(binder: DeleteMemberBinder): boolean;
    tryGetIndex(binder: GetIndexBinder, indexes: any[], result: { value: TSByRef<any> }): boolean;
    tryGetMember(binder: GetMemberBinder, result: { value: TSByRef<any> }): boolean;
    tryInvoke(binder: InvokeBinder, args: any[], result: { value: TSByRef<any> }): boolean;
    tryInvokeMember(binder: InvokeMemberBinder, args: any[], result: { value: TSByRef<any> }): boolean;
    trySetIndex(binder: SetIndexBinder, indexes: any[], value: any): boolean;
    trySetMember(binder: SetMemberBinder, value: any): boolean;
    tryUnaryOperation(binder: UnaryOperationBinder, result: { value: TSByRef<any> }): boolean;
}


export interface __DynamicObject$views {
    readonly As_IDynamicMetaObjectProvider: IDynamicMetaObjectProvider$instance;
}

export type DynamicObject = DynamicObject$instance & __DynamicObject$views;


export class ExpandoObject$instance {
    constructor();
}


export interface __ExpandoObject$views {
    readonly As_IDynamicMetaObjectProvider: IDynamicMetaObjectProvider$instance;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, any>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ExpandoObject = ExpandoObject$instance & __ExpandoObject$views;


export abstract class GetIndexBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackGetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[]): DynamicMetaObject;
    fallbackGetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type GetIndexBinder = GetIndexBinder$instance;

export abstract class GetMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackGetMember(target: DynamicMetaObject): DynamicMetaObject;
    fallbackGetMember(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type GetMemberBinder = GetMemberBinder$instance;

export abstract class InvokeBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    fallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type InvokeBinder = InvokeBinder$instance;

export abstract class InvokeMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly callInfo: CallInfo;
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    abstract fallbackInvoke(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
    fallbackInvokeMember(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    fallbackInvokeMember(target: DynamicMetaObject, args: DynamicMetaObject[], errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type InvokeMemberBinder = InvokeMemberBinder$instance;

export abstract class SetIndexBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly callInfo: CallInfo;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackSetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], value: DynamicMetaObject): DynamicMetaObject;
    fallbackSetIndex(target: DynamicMetaObject, indexes: DynamicMetaObject[], value: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type SetIndexBinder = SetIndexBinder$instance;

export abstract class SetMemberBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly ignoreCase: boolean;
    readonly name: string;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackSetMember(target: DynamicMetaObject, value: DynamicMetaObject): DynamicMetaObject;
    fallbackSetMember(target: DynamicMetaObject, value: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type SetMemberBinder = SetMemberBinder$instance;

export abstract class UnaryOperationBinder$instance extends DynamicMetaObjectBinder$instance {
    readonly operation: ExpressionType;
    readonly returnType: Type;
    bind(target: DynamicMetaObject, args: DynamicMetaObject[]): DynamicMetaObject;
    bind(args: any[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    fallbackUnaryOperation(target: DynamicMetaObject): DynamicMetaObject;
    fallbackUnaryOperation(target: DynamicMetaObject, errorSuggestion: DynamicMetaObject): DynamicMetaObject;
}


export type UnaryOperationBinder = UnaryOperationBinder$instance;

