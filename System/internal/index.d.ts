// Generated by tsbindgen - Architecture
// Namespace: System
// Assembly: System.ComponentModel, System.ComponentModel.TypeConverter, System.Console, System.Memory, System.Private.CoreLib, System.Private.Uri

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { MemoryHandle, OperationStatus, SearchValues_1, SpanAction_2 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IAlternateEqualityComparer_2, ICollection_1, IComparer_1, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IComparer, IDictionary, IEnumerable, IEnumerator, IEqualityComparer, IList, IStructuralComparable, IStructuralEquatable } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, PropertyDescriptorCollection, TypeConverter, TypeConverter_StandardValuesCollection } from "../../System.ComponentModel/internal/index.js";
import type { AssemblyHashAlgorithm } from "../../System.Configuration.Assemblies/internal/index.js";
import type { Calendar, CompareInfo, CompareOptions, CultureInfo, DateTimeStyles, DaylightTime, NumberStyles, TimeSpanStyles, UnicodeCategory } from "../../System.Globalization/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import * as System_Numerics_Internal from "../../System.Numerics/internal/index.js";
import type { IAdditionOperators_3, IAdditiveIdentity_2, IBinaryFloatingPointIeee754_1, IBinaryInteger_1, IBinaryNumber_1, IBitwiseOperators_3, IComparisonOperators_3, IDecrementOperators_1, IDivisionOperators_3, IEqualityOperators_3, IExponentialFunctions_1, IFloatingPoint_1, IFloatingPointConstants_1, IFloatingPointIeee754_1, IHyperbolicFunctions_1, IIncrementOperators_1, ILogarithmicFunctions_1, IMinMaxValue_1, IModulusOperators_3, IMultiplicativeIdentity_2, IMultiplyOperators_3, INumber_1, INumberBase_1, IPowerFunctions_1, IRootFunctions_1, IShiftOperators_3, ISignedNumber_1, ISubtractionOperators_3, ITrigonometricFunctions_1, IUnaryNegationOperators_2, IUnaryPlusOperators_2, IUnsignedNumber_1 } from "../../System.Numerics/internal/index.js";
import { MemberInfo } from "../../System.Reflection/internal/index.js";
import * as System_Reflection_Internal from "../../System.Reflection/internal/index.js";
import type { Assembly, AssemblyName, Binder, BindingFlags, CallingConventions, ConstructorInfo, CustomAttributeData, EventInfo, FieldInfo, GenericParameterAttributes, ICustomAttributeProvider, InterfaceMapping, IReflect, MemberFilter, MemberTypes, MethodBase, MethodInfo, Module, ParameterInfo, ParameterModifier, PropertyInfo, TypeAttributes, TypeFilter } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_CompilerServices_Internal from "../../System.Runtime.CompilerServices/internal/index.js";
import type { DefaultInterpolatedStringHandler, ITuple } from "../../System.Runtime.CompilerServices/internal/index.js";
import type { FirstChanceExceptionEventArgs } from "../../System.Runtime.ExceptionServices/internal/index.js";
import type { StructLayoutAttribute } from "../../System.Runtime.InteropServices/internal/index.js";
import type { ObjectHandle } from "../../System.Runtime.Remoting/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, IObjectReference, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IPrincipal, PrincipalPolicy } from "../../System.Security.Principal/internal/index.js";
import type { PermissionSet } from "../../System.Security/internal/index.js";
import type { CompositeFormat, Encoding, NormalizationForm, SpanLineEnumerator, SpanRuneEnumerator, StringRuneEnumerator } from "../../System.Text/internal/index.js";
import type { ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken, ITimer, LazyThreadSafetyMode, TimerCallback, WaitHandle } from "../../System.Threading/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? SByte :
    T extends short ? Int16 :
    T extends int ? Int32 :
    T extends long ? Int64 :
    T extends int128 ? Int128 :
    T extends nint ? IntPtr :
    T extends byte ? Byte :
    T extends ushort ? UInt16 :
    T extends uint ? UInt32 :
    T extends ulong ? UInt64 :
    T extends uint128 ? UInt128 :
    T extends nuint ? UIntPtr :
    T extends half ? Half :
    T extends float ? Single :
    T extends double ? Double :
    T extends decimal ? Decimal :
    T extends char ? Char :
    T extends boolean ? Boolean :
    T extends string ? String :
    T; // Identity fallback for non-primitive types

export enum AttributeTargets {
    assembly = 1,
    module_ = 2,
    class_ = 4,
    struct = 8,
    enum_ = 16,
    constructor_ = 32,
    method = 64,
    property = 128,
    field = 256,
    event = 512,
    interface_ = 1024,
    parameter = 2048,
    delegate = 4096,
    returnValue = 8192,
    genericParameter = 16384,
    all = 32767
}


export enum Base64FormattingOptions {
    none = 0,
    insertLineBreaks = 1
}


export enum ConsoleColor {
    black = 0,
    darkBlue = 1,
    darkGreen = 2,
    darkCyan = 3,
    darkRed = 4,
    darkMagenta = 5,
    darkYellow = 6,
    gray = 7,
    darkGray = 8,
    blue = 9,
    green = 10,
    cyan = 11,
    red = 12,
    magenta = 13,
    yellow = 14,
    white = 15
}


export enum ConsoleKey {
    none = 0,
    backspace = 8,
    tab = 9,
    clear = 12,
    enter = 13,
    pause = 19,
    escape = 27,
    spacebar = 32,
    pageUp = 33,
    pageDown = 34,
    end = 35,
    home = 36,
    leftArrow = 37,
    upArrow = 38,
    rightArrow = 39,
    downArrow = 40,
    select = 41,
    print = 42,
    execute = 43,
    printScreen = 44,
    insert = 45,
    delete_ = 46,
    help = 47,
    D0 = 48,
    D1 = 49,
    D2 = 50,
    D3 = 51,
    D4 = 52,
    D5 = 53,
    D6 = 54,
    D7 = 55,
    D8 = 56,
    D9 = 57,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    E = 69,
    F = 70,
    G = 71,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    L = 76,
    M = 77,
    N = 78,
    O = 79,
    P = 80,
    Q = 81,
    R = 82,
    S = 83,
    T = 84,
    U = 85,
    V = 86,
    W = 87,
    X = 88,
    Y = 89,
    Z = 90,
    leftWindows = 91,
    rightWindows = 92,
    applications = 93,
    sleep = 95,
    numPad0 = 96,
    numPad1 = 97,
    numPad2 = 98,
    numPad3 = 99,
    numPad4 = 100,
    numPad5 = 101,
    numPad6 = 102,
    numPad7 = 103,
    numPad8 = 104,
    numPad9 = 105,
    multiply = 106,
    add = 107,
    separator = 108,
    subtract = 109,
    decimal = 110,
    divide = 111,
    F1 = 112,
    F2 = 113,
    F3 = 114,
    F4 = 115,
    F5 = 116,
    F6 = 117,
    F7 = 118,
    F8 = 119,
    F9 = 120,
    F10 = 121,
    F11 = 122,
    F12 = 123,
    F13 = 124,
    F14 = 125,
    F15 = 126,
    F16 = 127,
    F17 = 128,
    F18 = 129,
    F19 = 130,
    F20 = 131,
    F21 = 132,
    F22 = 133,
    F23 = 134,
    F24 = 135,
    browserBack = 166,
    browserForward = 167,
    browserRefresh = 168,
    browserStop = 169,
    browserSearch = 170,
    browserFavorites = 171,
    browserHome = 172,
    volumeMute = 173,
    volumeDown = 174,
    volumeUp = 175,
    mediaNext = 176,
    mediaPrevious = 177,
    mediaStop = 178,
    mediaPlay = 179,
    launchMail = 180,
    launchMediaSelect = 181,
    launchApp1 = 182,
    launchApp2 = 183,
    oem1 = 186,
    oemPlus = 187,
    oemComma = 188,
    oemMinus = 189,
    oemPeriod = 190,
    oem2 = 191,
    oem3 = 192,
    oem4 = 219,
    oem5 = 220,
    oem6 = 221,
    oem7 = 222,
    oem8 = 223,
    oem102 = 226,
    process = 229,
    packet = 231,
    attention = 246,
    crSel = 247,
    exSel = 248,
    eraseEndOfFile = 249,
    play = 250,
    zoom = 251,
    noName = 252,
    pa1 = 253,
    oemClear = 254
}


export enum ConsoleModifiers {
    none = 0,
    alt = 1,
    shift = 2,
    control = 4
}


export enum ConsoleSpecialKey {
    controlC = 0,
    controlBreak = 1
}


export enum DateTimeKind {
    unspecified = 0,
    utc = 1,
    local = 2
}


export enum DayOfWeek {
    sunday = 0,
    monday = 1,
    tuesday = 2,
    wednesday = 3,
    thursday = 4,
    friday = 5,
    saturday = 6
}


export enum Environment_SpecialFolder {
    applicationData = 26,
    commonApplicationData = 35,
    localApplicationData = 28,
    cookies = 33,
    desktop = 0,
    favorites = 6,
    history = 34,
    internetCache = 32,
    programs = 2,
    myComputer = 17,
    myMusic = 13,
    myPictures = 39,
    myVideos = 14,
    recent = 8,
    sendTo = 9,
    startMenu = 11,
    startup = 7,
    system = 37,
    templates = 21,
    desktopDirectory = 16,
    personal = 5,
    myDocuments = 5,
    programFiles = 38,
    commonProgramFiles = 43,
    adminTools = 48,
    cdBurning = 59,
    commonAdminTools = 47,
    commonDocuments = 46,
    commonMusic = 53,
    commonOemLinks = 58,
    commonPictures = 54,
    commonStartMenu = 22,
    commonPrograms = 23,
    commonStartup = 24,
    commonDesktopDirectory = 25,
    commonTemplates = 45,
    commonVideos = 55,
    fonts = 20,
    networkShortcuts = 19,
    printerShortcuts = 27,
    userProfile = 40,
    commonProgramFilesX86 = 44,
    programFilesX86 = 42,
    resources = 56,
    localizedResources = 57,
    systemX86 = 41,
    windows = 36
}


export enum Environment_SpecialFolderOption {
    none = 0,
    create = 32768,
    doNotVerify = 16384
}


export enum EnvironmentVariableTarget {
    process = 0,
    user = 1,
    machine = 2
}


export enum GCCollectionMode {
    default_ = 0,
    forced = 1,
    optimized = 2,
    aggressive = 3
}


export enum GCKind {
    any_ = 0,
    ephemeral = 1,
    fullBlocking = 2,
    background = 3
}


export enum GCNotificationStatus {
    succeeded = 0,
    failed = 1,
    canceled = 2,
    timeout = 3,
    notApplicable = 4
}


export enum GenericUriParserOptions {
    default_ = 0,
    genericAuthority = 1,
    allowEmptyAuthority = 2,
    noUserInfo = 4,
    noPort = 8,
    noQuery = 16,
    noFragment = 32,
    dontConvertPathBackslashes = 64,
    dontCompressPath = 128,
    dontUnescapePathDotsAndSlashes = 256,
    idn = 512,
    iriParsing = 1024
}


export enum LoaderOptimization {
    disallowBindings = 4,
    domainMask = 3,
    multiDomain = 2,
    multiDomainHost = 3,
    notSpecified = 0,
    singleDomain = 1
}


export enum MidpointRounding {
    toEven = 0,
    awayFromZero = 1,
    toZero = 2,
    toNegativeInfinity = 3,
    toPositiveInfinity = 4
}


export enum PlatformID {
    win32S = 0,
    win32Windows = 1,
    win32NT = 2,
    winCE = 3,
    unix = 4,
    xbox = 5,
    macOSX = 6,
    other = 7
}


export enum StringComparison {
    currentCulture = 0,
    currentCultureIgnoreCase = 1,
    invariantCulture = 2,
    invariantCultureIgnoreCase = 3,
    ordinal = 4,
    ordinalIgnoreCase = 5
}


export enum StringSplitOptions {
    none = 0,
    removeEmptyEntries = 1,
    trimEntries = 2
}


export enum TypeCode {
    empty = 0,
    object_ = 1,
    dbNull = 2,
    boolean_ = 3,
    char = 4,
    sByte = 5,
    byte = 6,
    int16 = 7,
    uInt16 = 8,
    int32 = 9,
    uInt32 = 10,
    int64 = 11,
    uInt64 = 12,
    single = 13,
    double = 14,
    decimal = 15,
    dateTime = 16,
    string_ = 18
}


export enum UriComponents {
    scheme = 1,
    userInfo = 2,
    host = 4,
    port = 8,
    path = 16,
    query = 32,
    fragment = 64,
    strongPort = 128,
    normalizedHost = 256,
    keepDelimiter = 1073741824,
    serializationInfoString = -2147483648,
    absoluteUri = 127,
    hostAndPort = 132,
    strongAuthority = 134,
    schemeAndServer = 13,
    httpRequestUrl = 61,
    pathAndQuery = 48
}


export enum UriFormat {
    uriEscaped = 1,
    unescaped = 2,
    safeUnescaped = 3
}


export enum UriHostNameType {
    unknown_ = 0,
    basic = 1,
    dns = 2,
    iPv4 = 3,
    iPv6 = 4
}


export enum UriKind {
    relativeOrAbsolute = 0,
    absolute = 1,
    relative = 2
}


export enum UriPartial {
    scheme = 0,
    authority = 1,
    path = 2,
    query = 3
}


export interface IAsyncDisposable$instance {
    disposeAsync(): ValueTask;
}


export type IAsyncDisposable = IAsyncDisposable$instance;

export interface IAsyncResult$instance {
    readonly isCompleted: boolean;
    readonly asyncWaitHandle: WaitHandle;
    readonly asyncState: unknown;
    readonly completedSynchronously: boolean;
}


export type IAsyncResult = IAsyncResult$instance;

export interface ICloneable$instance {
    clone(): unknown;
}


export type ICloneable = ICloneable$instance;

export interface IComparable$instance {
    compareTo(obj: unknown): int;
}


export type IComparable = IComparable$instance;

export interface IComparable_1$instance<T> {
    compareTo(other: T): int;
}


export type IComparable_1<T> = IComparable_1$instance<T>;

export interface IConvertible$instance {
    getTypeCode(): TypeCode;
    toBoolean(provider: IFormatProvider): boolean;
    toByte(provider: IFormatProvider): byte;
    toChar(provider: IFormatProvider): char;
    toDateTime(provider: IFormatProvider): DateTime;
    toDecimal(provider: IFormatProvider): decimal;
    toDouble(provider: IFormatProvider): double;
    toInt16(provider: IFormatProvider): short;
    toInt32(provider: IFormatProvider): int;
    toInt64(provider: IFormatProvider): long;
    toSByte(provider: IFormatProvider): sbyte;
    toSingle(provider: IFormatProvider): float;
    toString(provider: IFormatProvider): string;
    toType(conversionType: Type, provider: IFormatProvider): unknown;
    toUInt16(provider: IFormatProvider): ushort;
    toUInt32(provider: IFormatProvider): uint;
    toUInt64(provider: IFormatProvider): ulong;
}


export type IConvertible = IConvertible$instance;

export interface ICustomFormatter$instance {
    format(format: string, arg: unknown, formatProvider: IFormatProvider): string;
}


export type ICustomFormatter = ICustomFormatter$instance;

export interface IDisposable$instance {
    dispose(): void;
}


export type IDisposable = IDisposable$instance;

export interface IEquatable_1$instance<T> {
    equals(other: T): boolean;
}


export type IEquatable_1<T> = IEquatable_1$instance<T>;

export interface IFormatProvider$instance {
    getFormat(formatType: Type): unknown;
}


export type IFormatProvider = IFormatProvider$instance;

export interface IFormattable$instance {
    toString(format: string, formatProvider: IFormatProvider): string;
}


export type IFormattable = IFormattable$instance;

export interface IObservable_1$instance<T> {
    subscribe(observer: IObserver_1<T>): IDisposable;
}


export type IObservable_1<T> = IObservable_1$instance<T>;

export interface IObserver_1$instance<T> {
    onCompleted(): void;
    onError(error: Exception): void;
    onNext(value: T): void;
}


export type IObserver_1<T> = IObserver_1$instance<T>;

export interface IParsable_1$instance<TSelf extends IParsable_1<TSelf>> {
}


export type IParsable_1<TSelf extends IParsable_1<TSelf>> = IParsable_1$instance<TSelf>;

export interface IProgress_1$instance<T> {
    report(value: T): void;
}


export type IProgress_1<T> = IProgress_1$instance<T>;

export interface IServiceProvider$instance {
    getService(serviceType: Type): unknown;
}


export type IServiceProvider = IServiceProvider$instance;

export interface ISpanFormattable$instance extends IFormattable {
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export interface ISpanFormattable$instance extends IFormattable$instance {}

export type ISpanFormattable = ISpanFormattable$instance;

export interface ISpanParsable_1$instance<TSelf extends ISpanParsable_1<TSelf>> extends IParsable_1<TSelf> {
}


export interface ISpanParsable_1$instance<TSelf extends ISpanParsable_1<TSelf>> extends IParsable_1$instance<TSelf> {}

export type ISpanParsable_1<TSelf extends ISpanParsable_1<TSelf>> = ISpanParsable_1$instance<TSelf>;

export interface IUtf8SpanFormattable$instance {
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
}


export type IUtf8SpanFormattable = IUtf8SpanFormattable$instance;

export interface IUtf8SpanParsable_1$instance<TSelf extends IUtf8SpanParsable_1<TSelf>> {
}


export type IUtf8SpanParsable_1<TSelf extends IUtf8SpanParsable_1<TSelf>> = IUtf8SpanParsable_1$instance<TSelf>;

export class ArgIterator$instance {
    constructor(arglist: RuntimeArgumentHandle);
    constructor(arglist: RuntimeArgumentHandle, ptr: ptr<void>);
    end(): void;
    equals(o: unknown): boolean;
    getHashCode(): int;
    getNextArg(): TypedReference;
    getNextArg(rth: RuntimeTypeHandle): TypedReference;
    getNextArgType(): RuntimeTypeHandle;
    getRemainingCount(): int;
}


export type ArgIterator = ArgIterator$instance;

export class ArraySegment_1$instance<T> {
    constructor(array: T[]);
    constructor(array: T[], offset: int, count: int);
    readonly array: T[];
    readonly count: int;
    item: T;
    readonly offset: int;
    copyTo(destination: T[]): void;
    copyTo(destination: T[], destinationIndex: int): void;
    copyTo(destination: ArraySegment_1<T>): void;
    equals(obj: unknown): boolean;
    equals(obj: ArraySegment_1<T>): boolean;
    getEnumerator(): ArraySegment_1_Enumerator<T>;
    getHashCode(): int;
    slice(index: int): ArraySegment_1<T>;
    slice(index: int, count: int): ArraySegment_1<T>;
    toArray(): T[];
    static readonly empty: unknown;
}


export interface __ArraySegment_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ArraySegment_1<T> = ArraySegment_1$instance<T> & __ArraySegment_1$views<T>;


export class ArraySegment_1_Enumerator$instance<T> implements IDisposable {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
}


export interface __ArraySegment_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ArraySegment_1_Enumerator<T> = ArraySegment_1_Enumerator$instance<T> & __ArraySegment_1_Enumerator$views<T>;


export class Boolean$instance {
    compareTo(obj: unknown): int;
    compareTo(value: boolean): int;
    equals(obj: unknown): boolean;
    equals(obj: boolean): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static readonly trueString: string;
    static readonly falseString: string;
    static parse2(value: ReadOnlySpan_1<CLROf<char>>): boolean;
    static parse2(value: string): boolean;
    static tryParse2(value: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<boolean> }): boolean;
    static tryParse2(value: string, result: { value: ref<boolean> }): boolean;
}


export interface __Boolean$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<boolean>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<boolean>>;
    As_IParsable_1(): IParsable_1$instance<CLROf<boolean>>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<boolean>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Boolean): boolean;
    CompareTo(obj: unknown): int;
}

export interface Boolean$instance extends IComparable$instance, ISpanParsable_1$instance<CLROf<boolean>> {}

export type Boolean = Boolean$instance & __Boolean$views;


export class Byte$instance implements IBitwiseOperators_3<CLROf<byte>, CLROf<byte>, CLROf<byte>>, IComparisonOperators_3<CLROf<byte>, CLROf<byte>, CLROf<boolean>>, IEqualityOperators_3<CLROf<byte>, CLROf<byte>, CLROf<boolean>>, IModulusOperators_3<CLROf<byte>, CLROf<byte>, CLROf<byte>>, IAdditionOperators_3<CLROf<byte>, CLROf<byte>, CLROf<byte>>, IDecrementOperators_1<CLROf<byte>>, IDivisionOperators_3<CLROf<byte>, CLROf<byte>, CLROf<byte>>, IIncrementOperators_1<CLROf<byte>>, IMultiplyOperators_3<CLROf<byte>, CLROf<byte>, CLROf<byte>>, ISubtractionOperators_3<CLROf<byte>, CLROf<byte>, CLROf<byte>>, IUnaryPlusOperators_2<CLROf<byte>, CLROf<byte>>, IUnaryNegationOperators_2<CLROf<byte>, CLROf<byte>>, IShiftOperators_3<CLROf<byte>, CLROf<int>, CLROf<byte>> {
    compareTo(value: unknown): int;
    compareTo(value: byte): int;
    equals(obj: unknown): boolean;
    equals(obj: byte): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: byte;
    static readonly minValue: byte;
    static clamp(value: byte, min: byte, max: byte): byte;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): byte;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): byte;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): byte;
    static divRem(left: byte, right: byte): ValueTuple_2<CLROf<byte>, CLROf<byte>>;
    static isEvenInteger(value: byte): boolean;
    static isOddInteger(value: byte): boolean;
    static isPow2(value: byte): boolean;
    static leadingZeroCount(value: byte): byte;
    static log2(value: byte): byte;
    static max(x: byte, y: byte): byte;
    static min(x: byte, y: byte): byte;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): byte;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): byte;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): byte;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): byte;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): byte;
    static parse7(s: string, style: NumberStyles): byte;
    static parse7(s: string, provider: IFormatProvider): byte;
    static parse7(s: string): byte;
    static popCount(value: byte): byte;
    static rotateLeft(value: byte, rotateAmount: int): byte;
    static rotateRight(value: byte, rotateAmount: int): byte;
    static sign(value: byte): int;
    static trailingZeroCount(value: byte): byte;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<byte> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<byte> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<byte> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<byte> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<byte> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<byte> }): boolean;
    static tryParse3(s: string, result: { value: ref<byte> }): boolean;
    static tryParse3(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<byte> }): boolean;
    static tryParse3(s: string, provider: IFormatProvider, result: { value: ref<byte> }): boolean;
}


export interface __Byte$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<byte>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<byte>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<byte>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<byte>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<byte>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<byte>, CLROf<byte>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<byte>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<byte>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<byte>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<byte>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Byte): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Byte$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<byte>> {}

export type Byte = Byte$instance & __Byte$views;


export class Char$instance implements IBitwiseOperators_3<CLROf<char>, CLROf<char>, CLROf<char>>, IComparisonOperators_3<CLROf<char>, CLROf<char>, CLROf<boolean>>, IEqualityOperators_3<CLROf<char>, CLROf<char>, CLROf<boolean>>, IModulusOperators_3<CLROf<char>, CLROf<char>, CLROf<char>>, IAdditionOperators_3<CLROf<char>, CLROf<char>, CLROf<char>>, IDecrementOperators_1<CLROf<char>>, IDivisionOperators_3<CLROf<char>, CLROf<char>, CLROf<char>>, IIncrementOperators_1<CLROf<char>>, IMultiplyOperators_3<CLROf<char>, CLROf<char>, CLROf<char>>, ISubtractionOperators_3<CLROf<char>, CLROf<char>, CLROf<char>>, IUnaryPlusOperators_2<CLROf<char>, CLROf<char>>, IUnaryNegationOperators_2<CLROf<char>, CLROf<char>>, IShiftOperators_3<CLROf<char>, CLROf<int>, CLROf<char>> {
    compareTo(value: unknown): int;
    compareTo(value: char): int;
    equals(obj: unknown): boolean;
    equals(obj: char): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    static readonly maxValue: char;
    static readonly minValue: char;
    static convertFromUtf32(utf32: int): string;
    static convertToUtf32(highSurrogate: char, lowSurrogate: char): int;
    static convertToUtf32(s: string, index: int): int;
    static getNumericValue(c: char): double;
    static getNumericValue(s: string, index: int): double;
    static getUnicodeCategory(c: char): UnicodeCategory;
    static getUnicodeCategory(s: string, index: int): UnicodeCategory;
    static isAscii(c: char): boolean;
    static isAsciiDigit(c: char): boolean;
    static isAsciiHexDigit(c: char): boolean;
    static isAsciiHexDigitLower(c: char): boolean;
    static isAsciiHexDigitUpper(c: char): boolean;
    static isAsciiLetter(c: char): boolean;
    static isAsciiLetterLower(c: char): boolean;
    static isAsciiLetterOrDigit(c: char): boolean;
    static isAsciiLetterUpper(c: char): boolean;
    static isBetween(c: char, minInclusive: char, maxInclusive: char): boolean;
    static isControl(c: char): boolean;
    static isControl(s: string, index: int): boolean;
    static isDigit(c: char): boolean;
    static isDigit(s: string, index: int): boolean;
    static isHighSurrogate(c: char): boolean;
    static isHighSurrogate(s: string, index: int): boolean;
    static isLetter(c: char): boolean;
    static isLetter(s: string, index: int): boolean;
    static isLetterOrDigit(c: char): boolean;
    static isLetterOrDigit(s: string, index: int): boolean;
    static isLower(c: char): boolean;
    static isLower(s: string, index: int): boolean;
    static isLowSurrogate(c: char): boolean;
    static isLowSurrogate(s: string, index: int): boolean;
    static isNumber(c: char): boolean;
    static isNumber(s: string, index: int): boolean;
    static isPunctuation(c: char): boolean;
    static isPunctuation(s: string, index: int): boolean;
    static isSeparator(c: char): boolean;
    static isSeparator(s: string, index: int): boolean;
    static isSurrogate(c: char): boolean;
    static isSurrogate(s: string, index: int): boolean;
    static isSurrogatePair2(highSurrogate: char, lowSurrogate: char): boolean;
    static isSurrogatePair2(s: string, index: int): boolean;
    static isSymbol(c: char): boolean;
    static isSymbol(s: string, index: int): boolean;
    static isUpper(c: char): boolean;
    static isUpper(s: string, index: int): boolean;
    static isWhiteSpace(c: char): boolean;
    static isWhiteSpace(s: string, index: int): boolean;
    static parse(s: string): char;
    static toLower(c: char, culture: CultureInfo): char;
    static toLower(c: char): char;
    static toLowerInvariant(c: char): char;
    static toString(c: char): string;
    static toUpper(c: char, culture: CultureInfo): char;
    static toUpper(c: char): char;
    static toUpperInvariant(c: char): char;
    static tryParse(s: string, result: { value: ref<char> }): boolean;
}


export interface __Char$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<char>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<char>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<char>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<char>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<char>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<char>, CLROf<char>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<char>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<char>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<char>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<char>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Char): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Char$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<char>> {}

export type Char = Char$instance & __Char$views;


export class ConsoleKeyInfo$instance {
    constructor(keyChar: char, key: ConsoleKey, shift: boolean, alt: boolean, control: boolean);
    readonly key: ConsoleKey;
    readonly keyChar: char;
    readonly modifiers: ConsoleModifiers;
    equals(value: unknown): boolean;
    equals(obj: ConsoleKeyInfo): boolean;
    getHashCode(): int;
}


export interface __ConsoleKeyInfo$views {
    As_IEquatable_1(): IEquatable_1$instance<ConsoleKeyInfo>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ConsoleKeyInfo): boolean;
}

export type ConsoleKeyInfo = ConsoleKeyInfo$instance & __ConsoleKeyInfo$views;


export class DateOnly$instance {
    constructor(year: int, month: int, day: int);
    constructor(year: int, month: int, day: int, calendar: Calendar);
    readonly day: int;
    readonly dayNumber: int;
    readonly dayOfWeek: DayOfWeek;
    readonly dayOfYear: int;
    readonly month: int;
    readonly year: int;
    addDays(value: int): DateOnly;
    addMonths(value: int): DateOnly;
    addYears(value: int): DateOnly;
    compareTo(value: DateOnly): int;
    compareTo(value: unknown): int;
    deconstruct(year: { value: ref<int> }, month: { value: ref<int> }, day: { value: ref<int> }): void;
    equals(value: DateOnly): boolean;
    equals(value: unknown): boolean;
    getHashCode(): int;
    toDateTime(time: TimeOnly): DateTime;
    toDateTime(time: TimeOnly, kind: DateTimeKind): DateTime;
    toLongDateString(): string;
    toShortDateString(): string;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly minValue: DateOnly;
    static readonly maxValue: DateOnly;
    static fromDateTime(dateTime: DateTime): DateOnly;
    static fromDayNumber(dayNumber: int): DateOnly;
    static parse(s: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider, style?: DateTimeStyles): DateOnly;
    static parse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): DateOnly;
    static parse(s: string, provider: IFormatProvider, style?: DateTimeStyles): DateOnly;
    static parse(s: string, provider: IFormatProvider): DateOnly;
    static parse(s: string): DateOnly;
    static parseExact(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider, style?: DateTimeStyles): DateOnly;
    static parseExact(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], provider: IFormatProvider, style?: DateTimeStyles): DateOnly;
    static parseExact(s: ReadOnlySpan_1<CLROf<char>>, formats: string[]): DateOnly;
    static parseExact(s: string, format: string, provider: IFormatProvider, style?: DateTimeStyles): DateOnly;
    static parseExact(s: string, format: string): DateOnly;
    static parseExact(s: string, formats: string[], provider: IFormatProvider, style?: DateTimeStyles): DateOnly;
    static parseExact(s: string, formats: string[]): DateOnly;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<DateOnly> }): boolean;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<DateOnly> }): boolean;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateOnly> }): boolean;
    static tryParse(s: string, result: { value: ref<DateOnly> }): boolean;
    static tryParse(s: string, provider: IFormatProvider, result: { value: ref<DateOnly> }): boolean;
    static tryParse(s: string, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: string, format: string, result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: string, formats: string[], result: { value: ref<DateOnly> }): boolean;
    static tryParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateOnly> }): boolean;
}


export interface __DateOnly$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<DateOnly>;
    As_IEquatable_1(): IEquatable_1$instance<DateOnly>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<DateOnly>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<DateOnly>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: DateOnly): boolean;
    CompareTo(obj: unknown): int;
}

export interface DateOnly$instance extends IComparable_1$instance<DateOnly>, ISpanParsable_1$instance<DateOnly> {}

export type DateOnly = DateOnly$instance & __DateOnly$views;


export class DateTime$instance {
    constructor(ticks: long);
    constructor(ticks: long, kind: DateTimeKind);
    constructor(date: DateOnly, time: TimeOnly);
    constructor(date: DateOnly, time: TimeOnly, kind: DateTimeKind);
    constructor(year: int, month: int, day: int);
    constructor(year: int, month: int, day: int, calendar: Calendar);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar, kind: DateTimeKind);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, kind: DateTimeKind);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: Calendar);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: DateTimeKind);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, kind: DateTimeKind);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: Calendar);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: Calendar, kind: DateTimeKind);
    readonly date: DateTime;
    readonly day: int;
    readonly dayOfWeek: DayOfWeek;
    readonly dayOfYear: int;
    readonly hour: int;
    readonly kind: DateTimeKind;
    readonly microsecond: int;
    readonly millisecond: int;
    readonly minute: int;
    readonly month: int;
    readonly nanosecond: int;
    readonly second: int;
    readonly ticks: long;
    readonly timeOfDay: TimeSpan;
    readonly year: int;
    add(value: TimeSpan): DateTime;
    addDays(value: double): DateTime;
    addHours(value: double): DateTime;
    addMicroseconds(value: double): DateTime;
    addMilliseconds(value: double): DateTime;
    addMinutes(value: double): DateTime;
    addMonths(months: int): DateTime;
    addSeconds(value: double): DateTime;
    addTicks(value: long): DateTime;
    addYears(value: int): DateTime;
    compareTo(value: unknown): int;
    compareTo(value: DateTime): int;
    deconstruct(date: { value: ref<DateOnly> }, time: { value: ref<TimeOnly> }): void;
    deconstruct(year: { value: ref<int> }, month: { value: ref<int> }, day: { value: ref<int> }): void;
    equals(value: unknown): boolean;
    equals(value: DateTime): boolean;
    getDateTimeFormats(): string[];
    getDateTimeFormats(provider: IFormatProvider): string[];
    getDateTimeFormats(format: char): string[];
    getDateTimeFormats(format: char, provider: IFormatProvider): string[];
    getHashCode(): int;
    getTypeCode(): TypeCode;
    isDaylightSavingTime(): boolean;
    subtract(value: DateTime): TimeSpan;
    subtract(value: TimeSpan): DateTime;
    toBinary(): long;
    toFileTime(): long;
    toFileTimeUtc(): long;
    toLocalTime(): DateTime;
    toLongDateString(): string;
    toLongTimeString(): string;
    toOADate(): double;
    toShortDateString(): string;
    toShortTimeString(): string;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    toUniversalTime(): DateTime;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly minValue: DateTime;
    static readonly maxValue: DateTime;
    static readonly unixEpoch: DateTime;
    static readonly now: DateTime;
    static readonly today: DateTime;
    static readonly utcNow: DateTime;
    static compare(t1: DateTime, t2: DateTime): int;
    static daysInMonth(year: int, month: int): int;
    static equals(t1: DateTime, t2: DateTime): boolean;
    static fromBinary(dateData: long): DateTime;
    static fromFileTime(fileTime: long): DateTime;
    static fromFileTimeUtc(fileTime: long): DateTime;
    static fromOADate(d: double): DateTime;
    static isLeapYear(year: int): boolean;
    static parse4(s: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider, styles?: DateTimeStyles): DateTime;
    static parse4(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): DateTime;
    static parse4(s: string, provider: IFormatProvider, styles: DateTimeStyles): DateTime;
    static parse4(s: string, provider: IFormatProvider): DateTime;
    static parse4(s: string): DateTime;
    static parseExact3(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, style?: DateTimeStyles): DateTime;
    static parseExact3(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], provider: IFormatProvider, style?: DateTimeStyles): DateTime;
    static parseExact3(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles): DateTime;
    static parseExact3(s: string, format: string, provider: IFormatProvider): DateTime;
    static parseExact3(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles): DateTime;
    static specifyKind(value: DateTime, kind: DateTimeKind): DateTime;
    static tryParse2(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<DateTime> }): boolean;
    static tryParse2(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<DateTime> }): boolean;
    static tryParse2(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTime> }): boolean;
    static tryParse2(s: string, result: { value: ref<DateTime> }): boolean;
    static tryParse2(s: string, provider: IFormatProvider, result: { value: ref<DateTime> }): boolean;
    static tryParse2(s: string, provider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTime> }): boolean;
    static tryParseExact2(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateTime> }): boolean;
    static tryParseExact2(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateTime> }): boolean;
    static tryParseExact2(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateTime> }): boolean;
    static tryParseExact2(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<DateTime> }): boolean;
}


export interface __DateTime$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<DateTime>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<DateTime>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<DateTime>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<DateTime>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: DateTime): boolean;
    CompareTo(obj: unknown): int;
}

export interface DateTime$instance extends IComparable$instance, ISpanParsable_1$instance<DateTime>, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DateTime = DateTime$instance & __DateTime$views;


export class DateTimeOffset$instance {
    constructor(ticks: long, offset: TimeSpan);
    constructor(dateTime: DateTime);
    constructor(dateTime: DateTime, offset: TimeSpan);
    constructor(date: DateOnly, time: TimeOnly, offset: TimeSpan);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, offset: TimeSpan);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, offset: TimeSpan);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar, offset: TimeSpan);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, offset: TimeSpan);
    constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: Calendar, offset: TimeSpan);
    readonly date: DateTime;
    readonly dateTime: DateTime;
    readonly day: int;
    readonly dayOfWeek: DayOfWeek;
    readonly dayOfYear: int;
    readonly hour: int;
    readonly localDateTime: DateTime;
    readonly microsecond: int;
    readonly millisecond: int;
    readonly minute: int;
    readonly month: int;
    readonly nanosecond: int;
    readonly offset: TimeSpan;
    readonly second: int;
    readonly ticks: long;
    readonly timeOfDay: TimeSpan;
    readonly totalOffsetMinutes: int;
    readonly utcDateTime: DateTime;
    readonly utcTicks: long;
    readonly year: int;
    add(timeSpan: TimeSpan): DateTimeOffset;
    addDays(days: double): DateTimeOffset;
    addHours(hours: double): DateTimeOffset;
    addMicroseconds(microseconds: double): DateTimeOffset;
    addMilliseconds(milliseconds: double): DateTimeOffset;
    addMinutes(minutes: double): DateTimeOffset;
    addMonths(months: int): DateTimeOffset;
    addSeconds(seconds: double): DateTimeOffset;
    addTicks(ticks: long): DateTimeOffset;
    addYears(years: int): DateTimeOffset;
    compareTo(other: DateTimeOffset): int;
    deconstruct(date: { value: ref<DateOnly> }, time: { value: ref<TimeOnly> }, offset: { value: ref<TimeSpan> }): void;
    equals(obj: unknown): boolean;
    equals(other: DateTimeOffset): boolean;
    equalsExact(other: DateTimeOffset): boolean;
    getHashCode(): int;
    subtract(value: DateTimeOffset): TimeSpan;
    subtract(value: TimeSpan): DateTimeOffset;
    toFileTime(): long;
    toLocalTime(): DateTimeOffset;
    toOffset(offset: TimeSpan): DateTimeOffset;
    toString(): string;
    toString(format: string): string;
    toString(formatProvider: IFormatProvider): string;
    toString(format: string, formatProvider: IFormatProvider): string;
    toUniversalTime(): DateTimeOffset;
    toUnixTimeMilliseconds(): long;
    toUnixTimeSeconds(): long;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, formatProvider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, formatProvider?: IFormatProvider): boolean;
    static readonly minValue: DateTimeOffset;
    static readonly maxValue: DateTimeOffset;
    static readonly unixEpoch: DateTimeOffset;
    static readonly utcNow: DateTimeOffset;
    static readonly now: DateTimeOffset;
    static compare(first: DateTimeOffset, second: DateTimeOffset): int;
    static equals(first: DateTimeOffset, second: DateTimeOffset): boolean;
    static fromFileTime(fileTime: long): DateTimeOffset;
    static fromUnixTimeMilliseconds(milliseconds: long): DateTimeOffset;
    static fromUnixTimeSeconds(seconds: long): DateTimeOffset;
    static parse4(input: ReadOnlySpan_1<CLROf<char>>, formatProvider?: IFormatProvider, styles?: DateTimeStyles): DateTimeOffset;
    static parse4(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): DateTimeOffset;
    static parse4(input: string, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset;
    static parse4(input: string, formatProvider: IFormatProvider): DateTimeOffset;
    static parse4(input: string): DateTimeOffset;
    static parseExact3(input: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, formatProvider: IFormatProvider, styles?: DateTimeStyles): DateTimeOffset;
    static parseExact3(input: ReadOnlySpan_1<CLROf<char>>, formats: string[], formatProvider: IFormatProvider, styles?: DateTimeStyles): DateTimeOffset;
    static parseExact3(input: string, format: string, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset;
    static parseExact3(input: string, format: string, formatProvider: IFormatProvider): DateTimeOffset;
    static parseExact3(input: string, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset;
    static tryParse2(input: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParse2(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParse2(input: ReadOnlySpan_1<CLROf<char>>, formatProvider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParse2(input: string, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParse2(s: string, provider: IFormatProvider, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParse2(input: string, formatProvider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParseExact2(input: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, formatProvider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParseExact2(input: ReadOnlySpan_1<CLROf<char>>, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParseExact2(input: string, format: string, formatProvider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTimeOffset> }): boolean;
    static tryParseExact2(input: string, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles, result: { value: ref<DateTimeOffset> }): boolean;
}


export interface __DateTimeOffset$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<DateTimeOffset>;
    As_IEquatable_1(): IEquatable_1$instance<DateTimeOffset>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<DateTimeOffset>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<DateTimeOffset>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: DateTimeOffset): boolean;
    CompareTo(obj: unknown): int;
}

export interface DateTimeOffset$instance extends IComparable_1$instance<DateTimeOffset>, ISpanParsable_1$instance<DateTimeOffset>, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DateTimeOffset = DateTimeOffset$instance & __DateTimeOffset$views;


export class Decimal$instance implements IAdditionOperators_3<CLROf<decimal>, CLROf<decimal>, CLROf<decimal>>, IDecrementOperators_1<CLROf<decimal>>, IDivisionOperators_3<CLROf<decimal>, CLROf<decimal>, CLROf<decimal>>, IEqualityOperators_3<CLROf<decimal>, CLROf<decimal>, CLROf<boolean>>, IIncrementOperators_1<CLROf<decimal>>, IMultiplyOperators_3<CLROf<decimal>, CLROf<decimal>, CLROf<decimal>>, ISubtractionOperators_3<CLROf<decimal>, CLROf<decimal>, CLROf<decimal>>, IUnaryPlusOperators_2<CLROf<decimal>, CLROf<decimal>>, IUnaryNegationOperators_2<CLROf<decimal>, CLROf<decimal>>, IComparisonOperators_3<CLROf<decimal>, CLROf<decimal>, CLROf<boolean>>, IModulusOperators_3<CLROf<decimal>, CLROf<decimal>, CLROf<decimal>> {
    constructor(value: int);
    constructor(value: uint);
    constructor(value: long);
    constructor(value: ulong);
    constructor(value: float);
    constructor(value: double);
    constructor(bits: int[]);
    constructor(bits: ReadOnlySpan_1<CLROf<int>>);
    constructor(lo: int, mid: int, hi: int, isNegative: boolean, scale: byte);
    readonly scale: byte;
    compareTo(value: unknown): int;
    compareTo(value: decimal): int;
    equals(value: unknown): boolean;
    equals(value: decimal): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly zero: decimal;
    static readonly one: decimal;
    static readonly minusOne: decimal;
    static readonly maxValue: decimal;
    static readonly minValue: decimal;
    static abs(value: decimal): decimal;
    static add(d1: decimal, d2: decimal): decimal;
    static ceiling(d: decimal): decimal;
    static clamp(value: decimal, min: decimal, max: decimal): decimal;
    static compare(d1: decimal, d2: decimal): int;
    static convertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: decimal): TInteger;
    static convertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: decimal): TInteger;
    static copySign(value: decimal, sign: decimal): decimal;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): decimal;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): decimal;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): decimal;
    static divide(d1: decimal, d2: decimal): decimal;
    static equals(d1: decimal, d2: decimal): boolean;
    static floor(d: decimal): decimal;
    static fromOACurrency(cy: long): decimal;
    static getBits2(d: decimal, destination: Span_1<CLROf<int>>): int;
    static getBits2(d: decimal): int[];
    static isCanonical(value: decimal): boolean;
    static isEvenInteger(value: decimal): boolean;
    static isInteger(value: decimal): boolean;
    static isNegative(value: decimal): boolean;
    static isOddInteger(value: decimal): boolean;
    static isPositive(value: decimal): boolean;
    static max(x: decimal, y: decimal): decimal;
    static maxMagnitude(x: decimal, y: decimal): decimal;
    static min(x: decimal, y: decimal): decimal;
    static minMagnitude(x: decimal, y: decimal): decimal;
    static multiply(d1: decimal, d2: decimal): decimal;
    static negate(d: decimal): decimal;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): decimal;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): decimal;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): decimal;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): decimal;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): decimal;
    static parse7(s: string, style: NumberStyles): decimal;
    static parse7(s: string, provider: IFormatProvider): decimal;
    static parse7(s: string): decimal;
    static remainder(d1: decimal, d2: decimal): decimal;
    static round4(d: decimal, decimals: int, mode: MidpointRounding): decimal;
    static round4(d: decimal, decimals: int): decimal;
    static round4(d: decimal, mode: MidpointRounding): decimal;
    static round4(d: decimal): decimal;
    static sign(d: decimal): int;
    static subtract(d1: decimal, d2: decimal): decimal;
    static toByte(value: decimal): byte;
    static toDouble(d: decimal): double;
    static toInt16(value: decimal): short;
    static toInt32(d: decimal): int;
    static toInt64(d: decimal): long;
    static toOACurrency(value: decimal): long;
    static toSByte(value: decimal): sbyte;
    static toSingle(d: decimal): float;
    static toUInt16(value: decimal): ushort;
    static toUInt32(d: decimal): uint;
    static toUInt64(d: decimal): ulong;
    static truncate(d: decimal): decimal;
    static tryGetBits(d: decimal, destination: Span_1<CLROf<int>>, valuesWritten: { value: ref<int> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<decimal> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<decimal> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<decimal> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<decimal> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<decimal> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<decimal> }): boolean;
    static tryParse3(s: string, result: { value: ref<decimal> }): boolean;
    static tryParse3(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<decimal> }): boolean;
    static tryParse3(s: string, provider: IFormatProvider, result: { value: ref<decimal> }): boolean;
}


export interface __Decimal$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<decimal>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<decimal>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<decimal>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<decimal>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<decimal>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<decimal>, CLROf<decimal>>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<CLROf<decimal>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<decimal>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<decimal>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<decimal>>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Decimal): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Decimal$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<decimal>>, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Decimal = Decimal$instance & __Decimal$views;


export class Delegate_InvocationListEnumerator_1$instance<TDelegate extends Function> {
    readonly current: TDelegate;
    getEnumerator(): Delegate_InvocationListEnumerator_1<TDelegate>;
    moveNext(): boolean;
}


export type Delegate_InvocationListEnumerator_1<TDelegate extends Function> = Delegate_InvocationListEnumerator_1$instance<TDelegate>;

export class Double$instance implements IBitwiseOperators_3<CLROf<double>, CLROf<double>, CLROf<double>>, IComparisonOperators_3<CLROf<double>, CLROf<double>, CLROf<boolean>>, IEqualityOperators_3<CLROf<double>, CLROf<double>, CLROf<boolean>>, IModulusOperators_3<CLROf<double>, CLROf<double>, CLROf<double>>, IAdditionOperators_3<CLROf<double>, CLROf<double>, CLROf<double>>, IDecrementOperators_1<CLROf<double>>, IDivisionOperators_3<CLROf<double>, CLROf<double>, CLROf<double>>, IIncrementOperators_1<CLROf<double>>, IMultiplyOperators_3<CLROf<double>, CLROf<double>, CLROf<double>>, ISubtractionOperators_3<CLROf<double>, CLROf<double>, CLROf<double>>, IUnaryPlusOperators_2<CLROf<double>, CLROf<double>>, IUnaryNegationOperators_2<CLROf<double>, CLROf<double>> {
    compareTo(value: unknown): int;
    compareTo(value: double): int;
    equals(obj: unknown): boolean;
    equals(obj: double): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly minValue: double;
    static readonly maxValue: double;
    static readonly epsilon: double;
    static readonly negativeInfinity: double;
    static readonly positiveInfinity: double;
    static readonly naN: double;
    static readonly negativeZero: double;
    static readonly E: double;
    static readonly pi: double;
    static readonly tau: double;
    static abs(value: double): double;
    static acos(x: double): double;
    static acosh(x: double): double;
    static acosPi(x: double): double;
    static asin(x: double): double;
    static asinh(x: double): double;
    static asinPi(x: double): double;
    static atan(x: double): double;
    static atan2(y: double, x: double): double;
    static atan2Pi(y: double, x: double): double;
    static atanh(x: double): double;
    static atanPi(x: double): double;
    static bitDecrement(x: double): double;
    static bitIncrement(x: double): double;
    static cbrt(x: double): double;
    static ceiling(x: double): double;
    static clamp(value: double, min: double, max: double): double;
    static clampNative(value: double, min: double, max: double): double;
    static convertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: double): TInteger;
    static convertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: double): TInteger;
    static copySign(value: double, sign: double): double;
    static cos(x: double): double;
    static cosh(x: double): double;
    static cosPi(x: double): double;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): double;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): double;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): double;
    static degreesToRadians(degrees: double): double;
    static exp(x: double): double;
    static exp10(x: double): double;
    static exp10M1(x: double): double;
    static exp2(x: double): double;
    static exp2M1(x: double): double;
    static expM1(x: double): double;
    static floor(x: double): double;
    static fusedMultiplyAdd(left: double, right: double, addend: double): double;
    static hypot(x: double, y: double): double;
    static ieee754Remainder(left: double, right: double): double;
    static iLogB(x: double): int;
    static isEvenInteger(value: double): boolean;
    static isFinite(d: double): boolean;
    static isInfinity(d: double): boolean;
    static isInteger(value: double): boolean;
    static isNaN(d: double): boolean;
    static isNegative(d: double): boolean;
    static isNegativeInfinity(d: double): boolean;
    static isNormal(d: double): boolean;
    static isOddInteger(value: double): boolean;
    static isPositive(value: double): boolean;
    static isPositiveInfinity(d: double): boolean;
    static isPow2(value: double): boolean;
    static isRealNumber(value: double): boolean;
    static isSubnormal(d: double): boolean;
    static lerp(value1: double, value2: double, amount: double): double;
    static log2(x: double, newBase: double): double;
    static log2(x: double): double;
    static log10(x: double): double;
    static log10P1(x: double): double;
    static log22(value: double): double;
    static log2P1(x: double): double;
    static logP1(x: double): double;
    static max(x: double, y: double): double;
    static maxMagnitude(x: double, y: double): double;
    static maxMagnitudeNumber(x: double, y: double): double;
    static maxNative(x: double, y: double): double;
    static maxNumber(x: double, y: double): double;
    static min(x: double, y: double): double;
    static minMagnitude(x: double, y: double): double;
    static minMagnitudeNumber(x: double, y: double): double;
    static minNative(x: double, y: double): double;
    static minNumber(x: double, y: double): double;
    static multiplyAddEstimate(left: double, right: double, addend: double): double;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): double;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): double;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): double;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): double;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): double;
    static parse7(s: string, style: NumberStyles): double;
    static parse7(s: string, provider: IFormatProvider): double;
    static parse7(s: string): double;
    static pow(x: double, y: double): double;
    static radiansToDegrees(radians: double): double;
    static reciprocalEstimate(x: double): double;
    static reciprocalSqrtEstimate(x: double): double;
    static rootN(x: double, n: int): double;
    static round4(x: double, digits: int, mode: MidpointRounding): double;
    static round4(x: double, digits: int): double;
    static round4(x: double, mode: MidpointRounding): double;
    static round4(x: double): double;
    static scaleB(x: double, n: int): double;
    static sign(value: double): int;
    static sin(x: double): double;
    static sinCos(x: double): ValueTuple_2<CLROf<double>, CLROf<double>>;
    static sinCosPi(x: double): ValueTuple_2<CLROf<double>, CLROf<double>>;
    static sinh(x: double): double;
    static sinPi(x: double): double;
    static sqrt(x: double): double;
    static tan(x: double): double;
    static tanh(x: double): double;
    static tanPi(x: double): double;
    static truncate(x: double): double;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<double> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<double> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<double> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<double> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<double> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<double> }): boolean;
    static tryParse3(s: string, result: { value: ref<double> }): boolean;
    static tryParse3(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<double> }): boolean;
    static tryParse3(s: string, provider: IFormatProvider, result: { value: ref<double> }): boolean;
}


export interface __Double$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<double>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<double>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<double>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<double>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<double>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<double>, CLROf<double>>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<CLROf<double>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<double>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<double>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<double>>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<CLROf<double>>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<CLROf<double>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Double): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Double$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<double>> {}

export type Double = Double$instance & __Double$views;


export class Environment_ProcessCpuUsage$instance {
    readonly privilegedTime: TimeSpan;
    readonly totalTime: TimeSpan;
    readonly userTime: TimeSpan;
}


export type Environment_ProcessCpuUsage = Environment_ProcessCpuUsage$instance;

export class GCGenerationInfo$instance {
    readonly fragmentationAfterBytes: long;
    readonly fragmentationBeforeBytes: long;
    readonly sizeAfterBytes: long;
    readonly sizeBeforeBytes: long;
}


export type GCGenerationInfo = GCGenerationInfo$instance;

export class GCMemoryInfo$instance {
    readonly compacted: boolean;
    readonly concurrent: boolean;
    readonly finalizationPendingCount: long;
    readonly fragmentedBytes: long;
    readonly generation: int;
    readonly generationInfo: ReadOnlySpan_1<GCGenerationInfo>;
    readonly heapSizeBytes: long;
    readonly highMemoryLoadThresholdBytes: long;
    readonly index: long;
    readonly memoryLoadBytes: long;
    readonly pauseDurations: ReadOnlySpan_1<TimeSpan>;
    readonly pauseTimePercentage: double;
    readonly pinnedObjectsCount: long;
    readonly promotedBytes: long;
    readonly totalAvailableMemoryBytes: long;
    readonly totalCommittedBytes: long;
}


export type GCMemoryInfo = GCMemoryInfo$instance;

export class Guid$instance {
    constructor(b: byte[]);
    constructor(b: ReadOnlySpan_1<CLROf<byte>>);
    constructor(b: ReadOnlySpan_1<CLROf<byte>>, bigEndian: boolean);
    constructor(a: uint, b: ushort, c: ushort, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte);
    constructor(a: int, b: short, c: short, d: byte[]);
    constructor(a: int, b: short, c: short, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte);
    constructor(g: string);
    readonly variant: int;
    readonly version: int;
    compareTo(value: unknown): int;
    compareTo(value: Guid): int;
    equals(o: unknown): boolean;
    equals(g: Guid): boolean;
    getHashCode(): int;
    toByteArray(): byte[];
    toByteArray(bigEndian: boolean): byte[];
    toString(): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>): boolean;
    tryWriteBytes(destination: Span_1<CLROf<byte>>): boolean;
    tryWriteBytes(destination: Span_1<CLROf<byte>>, bigEndian: boolean, bytesWritten: { value: ref<int> }): boolean;
    static readonly empty: Guid;
    static readonly allBitsSet: Guid;
    static createVersion7(): Guid;
    static createVersion7(timestamp: DateTimeOffset): Guid;
    static newGuid(): Guid;
    static parse6(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): Guid;
    static parse6(utf8Text: ReadOnlySpan_1<CLROf<byte>>): Guid;
    static parse6(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): Guid;
    static parse6(input: ReadOnlySpan_1<CLROf<char>>): Guid;
    static parse6(s: string, provider: IFormatProvider): Guid;
    static parse6(input: string): Guid;
    static parseExact2(input: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>): Guid;
    static parseExact2(input: string, format: string): Guid;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<Guid> }): boolean;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<Guid> }): boolean;
    static tryParse3(input: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Guid> }): boolean;
    static tryParse3(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<Guid> }): boolean;
    static tryParse3(input: string, result: { value: ref<Guid> }): boolean;
    static tryParse3(s: string, provider: IFormatProvider, result: { value: ref<Guid> }): boolean;
    static tryParseExact2(input: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Guid> }): boolean;
    static tryParseExact2(input: string, format: string, result: { value: ref<Guid> }): boolean;
}


export interface __Guid$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Guid>;
    As_IEquatable_1(): IEquatable_1$instance<Guid>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Guid>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Guid>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Guid>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Guid): boolean;
    CompareTo(obj: unknown): int;
}

export interface Guid$instance extends IComparable$instance, ISpanParsable_1$instance<Guid> {}

export type Guid = Guid$instance & __Guid$views;


export class Half$instance implements IBitwiseOperators_3<CLROf<half>, CLROf<half>, CLROf<half>>, IComparisonOperators_3<CLROf<half>, CLROf<half>, CLROf<boolean>>, IEqualityOperators_3<CLROf<half>, CLROf<half>, CLROf<boolean>>, IModulusOperators_3<CLROf<half>, CLROf<half>, CLROf<half>>, IAdditionOperators_3<CLROf<half>, CLROf<half>, CLROf<half>>, IDecrementOperators_1<CLROf<half>>, IDivisionOperators_3<CLROf<half>, CLROf<half>, CLROf<half>>, IIncrementOperators_1<CLROf<half>>, IMultiplicativeIdentity_2<CLROf<half>, CLROf<half>>, IMultiplyOperators_3<CLROf<half>, CLROf<half>, CLROf<half>>, ISubtractionOperators_3<CLROf<half>, CLROf<half>, CLROf<half>>, IUnaryPlusOperators_2<CLROf<half>, CLROf<half>>, IUnaryNegationOperators_2<CLROf<half>, CLROf<half>> {
    compareTo(obj: unknown): int;
    compareTo(other: half): int;
    equals(obj: unknown): boolean;
    equals(other: half): boolean;
    getHashCode(): int;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly epsilon: half;
    static readonly positiveInfinity: half;
    static readonly negativeInfinity: half;
    static readonly naN: half;
    static readonly minValue: half;
    static readonly maxValue: half;
    static readonly E: half;
    static readonly pi: half;
    static readonly tau: half;
    static readonly negativeZero: half;
    static readonly multiplicativeIdentity: half;
    static readonly one: half;
    static readonly zero: half;
    static readonly negativeOne: half;
    static abs(value: half): half;
    static acos(x: half): half;
    static acosh(x: half): half;
    static acosPi(x: half): half;
    static asin(x: half): half;
    static asinh(x: half): half;
    static asinPi(x: half): half;
    static atan(x: half): half;
    static atan2(y: half, x: half): half;
    static atan2Pi(y: half, x: half): half;
    static atanh(x: half): half;
    static atanPi(x: half): half;
    static bitDecrement(x: half): half;
    static bitIncrement(x: half): half;
    static cbrt(x: half): half;
    static ceiling(x: half): half;
    static clamp(value: half, min: half, max: half): half;
    static clampNative(value: half, min: half, max: half): half;
    static convertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: half): TInteger;
    static convertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: half): TInteger;
    static copySign(value: half, sign: half): half;
    static cos(x: half): half;
    static cosh(x: half): half;
    static cosPi(x: half): half;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): half;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): half;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): half;
    static degreesToRadians(degrees: half): half;
    static exp(x: half): half;
    static exp10(x: half): half;
    static exp10M1(x: half): half;
    static exp2(x: half): half;
    static exp2M1(x: half): half;
    static expM1(x: half): half;
    static floor(x: half): half;
    static fusedMultiplyAdd(left: half, right: half, addend: half): half;
    static hypot(x: half, y: half): half;
    static ieee754Remainder(left: half, right: half): half;
    static iLogB(x: half): int;
    static isEvenInteger(value: half): boolean;
    static isFinite(value: half): boolean;
    static isInfinity(value: half): boolean;
    static isInteger(value: half): boolean;
    static isNaN(value: half): boolean;
    static isNegative(value: half): boolean;
    static isNegativeInfinity(value: half): boolean;
    static isNormal(value: half): boolean;
    static isOddInteger(value: half): boolean;
    static isPositive(value: half): boolean;
    static isPositiveInfinity(value: half): boolean;
    static isPow2(value: half): boolean;
    static isRealNumber(value: half): boolean;
    static isSubnormal(value: half): boolean;
    static lerp(value1: half, value2: half, amount: half): half;
    static log2(x: half, newBase: half): half;
    static log2(x: half): half;
    static log10(x: half): half;
    static log10P1(x: half): half;
    static log22(value: half): half;
    static log2P1(x: half): half;
    static logP1(x: half): half;
    static max(x: half, y: half): half;
    static maxMagnitude(x: half, y: half): half;
    static maxMagnitudeNumber(x: half, y: half): half;
    static maxNative(x: half, y: half): half;
    static maxNumber(x: half, y: half): half;
    static min(x: half, y: half): half;
    static minMagnitude(x: half, y: half): half;
    static minMagnitudeNumber(x: half, y: half): half;
    static minNative(x: half, y: half): half;
    static minNumber(x: half, y: half): half;
    static multiplyAddEstimate(left: half, right: half, addend: half): half;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): half;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): half;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): half;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): half;
    static parse7(s: string, style?: NumberStyles, provider?: IFormatProvider): half;
    static parse7(s: string, style: NumberStyles): half;
    static parse7(s: string, provider: IFormatProvider): half;
    static parse7(s: string): half;
    static pow(x: half, y: half): half;
    static radiansToDegrees(radians: half): half;
    static reciprocalEstimate(x: half): half;
    static reciprocalSqrtEstimate(x: half): half;
    static rootN(x: half, n: int): half;
    static round4(x: half, digits: int, mode: MidpointRounding): half;
    static round4(x: half, digits: int): half;
    static round4(x: half, mode: MidpointRounding): half;
    static round4(x: half): half;
    static scaleB(x: half, n: int): half;
    static sign(value: half): int;
    static sin(x: half): half;
    static sinCos(x: half): ValueTuple_2<CLROf<half>, CLROf<half>>;
    static sinCosPi(x: half): ValueTuple_2<CLROf<half>, CLROf<half>>;
    static sinh(x: half): half;
    static sinPi(x: half): half;
    static sqrt(x: half): half;
    static tan(x: half): half;
    static tanh(x: half): half;
    static tanPi(x: half): half;
    static truncate(x: half): half;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<half> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<half> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<half> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<half> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<half> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<half> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<half> }): boolean;
    static tryParse8(s: string, result: { value: ref<half> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<half> }): boolean;
}


export interface __Half$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<half>>;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<half>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<half>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<half>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<half>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<half>, CLROf<half>>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<CLROf<half>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<half>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<half>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<half>>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<CLROf<half>>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<CLROf<half>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Half): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Half$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<half>> {}

export type Half = Half$instance & __Half$views;


export class HashCode$instance {
    add<T>(value: T): void;
    add<T>(value: T, comparer: IEqualityComparer_1<T>): void;
    addBytes(value: ReadOnlySpan_1<CLROf<byte>>): void;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toHashCode(): int;
    static combine8<T1, T2, T3, T4, T5, T6, T7, T8>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8): int;
    static combine8<T1, T2, T3, T4, T5, T6, T7>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7): int;
    static combine8<T1, T2, T3, T4, T5, T6>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6): int;
    static combine8<T1, T2, T3, T4, T5>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5): int;
    static combine8<T1, T2, T3, T4>(value1: T1, value2: T2, value3: T3, value4: T4): int;
    static combine8<T1, T2, T3>(value1: T1, value2: T2, value3: T3): int;
    static combine8<T1, T2>(value1: T1, value2: T2): int;
    static combine8<T1>(value1: T1): int;
}


export type HashCode = HashCode$instance;

export class Index$instance {
    constructor(value: int, fromEnd: boolean);
    readonly isFromEnd: boolean;
    readonly value: int;
    equals(value: unknown): boolean;
    equals(other: Index): boolean;
    getHashCode(): int;
    getOffset(length: int): int;
    toString(): string;
    static readonly start: Index;
    static readonly end: Index;
    static fromEnd(value: int): Index;
    static fromStart(value: int): Index;
}


export interface __Index$views {
    As_IEquatable_1(): IEquatable_1$instance<Index>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Index): boolean;
}

export type Index = Index$instance & __Index$views;


export class Int128$instance implements IBitwiseOperators_3<CLROf<int128>, CLROf<int128>, CLROf<int128>>, IComparisonOperators_3<CLROf<int128>, CLROf<int128>, CLROf<boolean>>, IEqualityOperators_3<CLROf<int128>, CLROf<int128>, CLROf<boolean>>, IModulusOperators_3<CLROf<int128>, CLROf<int128>, CLROf<int128>>, IAdditionOperators_3<CLROf<int128>, CLROf<int128>, CLROf<int128>>, IDecrementOperators_1<CLROf<int128>>, IDivisionOperators_3<CLROf<int128>, CLROf<int128>, CLROf<int128>>, IIncrementOperators_1<CLROf<int128>>, IMultiplyOperators_3<CLROf<int128>, CLROf<int128>, CLROf<int128>>, ISubtractionOperators_3<CLROf<int128>, CLROf<int128>, CLROf<int128>>, IUnaryPlusOperators_2<CLROf<int128>, CLROf<int128>>, IUnaryNegationOperators_2<CLROf<int128>, CLROf<int128>>, IShiftOperators_3<CLROf<int128>, CLROf<int>, CLROf<int128>> {
    constructor(upper: ulong, lower: ulong);
    compareTo(value: unknown): int;
    compareTo(value: int128): int;
    equals(obj: unknown): boolean;
    equals(other: int128): boolean;
    getHashCode(): int;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly minValue: int128;
    static readonly maxValue: int128;
    static readonly one: int128;
    static readonly zero: int128;
    static readonly negativeOne: int128;
    static abs(value: int128): int128;
    static bigMul(left: int128, right: int128, lower: { value: ref<int128> }): int128;
    static clamp(value: int128, min: int128, max: int128): int128;
    static copySign(value: int128, sign: int128): int128;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): int128;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): int128;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): int128;
    static divRem(left: int128, right: int128): ValueTuple_2<CLROf<int128>, CLROf<int128>>;
    static isEvenInteger(value: int128): boolean;
    static isNegative(value: int128): boolean;
    static isOddInteger(value: int128): boolean;
    static isPositive(value: int128): boolean;
    static isPow2(value: int128): boolean;
    static leadingZeroCount(value: int128): int128;
    static log2(value: int128): int128;
    static max(x: int128, y: int128): int128;
    static maxMagnitude(x: int128, y: int128): int128;
    static min(x: int128, y: int128): int128;
    static minMagnitude(x: int128, y: int128): int128;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): int128;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): int128;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): int128;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): int128;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): int128;
    static parse7(s: string, style: NumberStyles): int128;
    static parse7(s: string, provider: IFormatProvider): int128;
    static parse7(s: string): int128;
    static popCount(value: int128): int128;
    static rotateLeft(value: int128, rotateAmount: int): int128;
    static rotateRight(value: int128, rotateAmount: int): int128;
    static sign(value: int128): int;
    static trailingZeroCount(value: int128): int128;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<int128> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<int128> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<int128> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<int128> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<int128> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<int128> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<int128> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<int128> }): boolean;
    static tryParse8(s: string, result: { value: ref<int128> }): boolean;
}


export interface __Int128$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<int128>>;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<int128>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<int128>>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<int128>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<int128>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<int128>, CLROf<int128>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<int128>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<int128>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<int128>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<int128>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int128): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Int128$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<int128>> {}

export type Int128 = Int128$instance & __Int128$views;


export class Int16$instance implements IBitwiseOperators_3<CLROf<short>, CLROf<short>, CLROf<short>>, IComparisonOperators_3<CLROf<short>, CLROf<short>, CLROf<boolean>>, IEqualityOperators_3<CLROf<short>, CLROf<short>, CLROf<boolean>>, IModulusOperators_3<CLROf<short>, CLROf<short>, CLROf<short>>, IAdditionOperators_3<CLROf<short>, CLROf<short>, CLROf<short>>, IDecrementOperators_1<CLROf<short>>, IDivisionOperators_3<CLROf<short>, CLROf<short>, CLROf<short>>, IIncrementOperators_1<CLROf<short>>, IMultiplyOperators_3<CLROf<short>, CLROf<short>, CLROf<short>>, ISubtractionOperators_3<CLROf<short>, CLROf<short>, CLROf<short>>, IUnaryPlusOperators_2<CLROf<short>, CLROf<short>>, IUnaryNegationOperators_2<CLROf<short>, CLROf<short>>, IShiftOperators_3<CLROf<short>, CLROf<int>, CLROf<short>> {
    compareTo(value: unknown): int;
    compareTo(value: short): int;
    equals(obj: unknown): boolean;
    equals(obj: short): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: short;
    static readonly minValue: short;
    static abs(value: short): short;
    static clamp(value: short, min: short, max: short): short;
    static copySign(value: short, sign: short): short;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): short;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): short;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): short;
    static divRem(left: short, right: short): ValueTuple_2<CLROf<short>, CLROf<short>>;
    static isEvenInteger(value: short): boolean;
    static isNegative(value: short): boolean;
    static isOddInteger(value: short): boolean;
    static isPositive(value: short): boolean;
    static isPow2(value: short): boolean;
    static leadingZeroCount(value: short): short;
    static log2(value: short): short;
    static max(x: short, y: short): short;
    static maxMagnitude(x: short, y: short): short;
    static min(x: short, y: short): short;
    static minMagnitude(x: short, y: short): short;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): short;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): short;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): short;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): short;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): short;
    static parse7(s: string, style: NumberStyles): short;
    static parse7(s: string, provider: IFormatProvider): short;
    static parse7(s: string): short;
    static popCount(value: short): short;
    static rotateLeft(value: short, rotateAmount: int): short;
    static rotateRight(value: short, rotateAmount: int): short;
    static sign(value: short): int;
    static trailingZeroCount(value: short): short;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<short> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<short> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<short> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<short> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<short> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<short> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<short> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<short> }): boolean;
    static tryParse8(s: string, result: { value: ref<short> }): boolean;
}


export interface __Int16$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<short>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<short>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<short>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<short>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<short>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<short>, CLROf<short>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<short>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<short>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<short>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<short>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int16): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Int16$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<short>> {}

export type Int16 = Int16$instance & __Int16$views;


export class Int32$instance implements IBitwiseOperators_3<CLROf<int>, CLROf<int>, CLROf<int>>, IComparisonOperators_3<CLROf<int>, CLROf<int>, CLROf<boolean>>, IEqualityOperators_3<CLROf<int>, CLROf<int>, CLROf<boolean>>, IModulusOperators_3<CLROf<int>, CLROf<int>, CLROf<int>>, IAdditionOperators_3<CLROf<int>, CLROf<int>, CLROf<int>>, IDecrementOperators_1<CLROf<int>>, IDivisionOperators_3<CLROf<int>, CLROf<int>, CLROf<int>>, IIncrementOperators_1<CLROf<int>>, IMultiplyOperators_3<CLROf<int>, CLROf<int>, CLROf<int>>, ISubtractionOperators_3<CLROf<int>, CLROf<int>, CLROf<int>>, IUnaryPlusOperators_2<CLROf<int>, CLROf<int>>, IUnaryNegationOperators_2<CLROf<int>, CLROf<int>>, IShiftOperators_3<CLROf<int>, CLROf<int>, CLROf<int>> {
    compareTo(value: unknown): int;
    compareTo(value: int): int;
    equals(obj: unknown): boolean;
    equals(obj: int): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: int;
    static readonly minValue: int;
    static abs(value: int): int;
    static bigMul(left: int, right: int): long;
    static clamp(value: int, min: int, max: int): int;
    static copySign(value: int, sign: int): int;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): int;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): int;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): int;
    static divRem(left: int, right: int): ValueTuple_2<CLROf<int>, CLROf<int>>;
    static isEvenInteger(value: int): boolean;
    static isNegative(value: int): boolean;
    static isOddInteger(value: int): boolean;
    static isPositive(value: int): boolean;
    static isPow2(value: int): boolean;
    static leadingZeroCount(value: int): int;
    static log2(value: int): int;
    static max(x: int, y: int): int;
    static maxMagnitude(x: int, y: int): int;
    static min(x: int, y: int): int;
    static minMagnitude(x: int, y: int): int;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): int;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): int;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): int;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): int;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): int;
    static parse7(s: string, style: NumberStyles): int;
    static parse7(s: string, provider: IFormatProvider): int;
    static parse7(s: string): int;
    static popCount(value: int): int;
    static rotateLeft(value: int, rotateAmount: int): int;
    static rotateRight(value: int, rotateAmount: int): int;
    static sign(value: int): int;
    static trailingZeroCount(value: int): int;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<int> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<int> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<int> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<int> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<int> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<int> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<int> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<int> }): boolean;
    static tryParse8(s: string, result: { value: ref<int> }): boolean;
}


export interface __Int32$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<int>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<int>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<int>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<int>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<int>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<int>, CLROf<int>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<int>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<int>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<int>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<int>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int32): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Int32$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<int>> {}

export type Int32 = Int32$instance & __Int32$views;


export class Int64$instance implements IBitwiseOperators_3<CLROf<long>, CLROf<long>, CLROf<long>>, IComparisonOperators_3<CLROf<long>, CLROf<long>, CLROf<boolean>>, IEqualityOperators_3<CLROf<long>, CLROf<long>, CLROf<boolean>>, IModulusOperators_3<CLROf<long>, CLROf<long>, CLROf<long>>, IAdditionOperators_3<CLROf<long>, CLROf<long>, CLROf<long>>, IDecrementOperators_1<CLROf<long>>, IDivisionOperators_3<CLROf<long>, CLROf<long>, CLROf<long>>, IIncrementOperators_1<CLROf<long>>, IMultiplyOperators_3<CLROf<long>, CLROf<long>, CLROf<long>>, ISubtractionOperators_3<CLROf<long>, CLROf<long>, CLROf<long>>, IUnaryPlusOperators_2<CLROf<long>, CLROf<long>>, IUnaryNegationOperators_2<CLROf<long>, CLROf<long>>, IShiftOperators_3<CLROf<long>, CLROf<int>, CLROf<long>> {
    compareTo(value: unknown): int;
    compareTo(value: long): int;
    equals(obj: unknown): boolean;
    equals(obj: long): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: long;
    static readonly minValue: long;
    static abs(value: long): long;
    static bigMul(left: long, right: long): int128;
    static clamp(value: long, min: long, max: long): long;
    static copySign(value: long, sign: long): long;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): long;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): long;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): long;
    static divRem(left: long, right: long): ValueTuple_2<CLROf<long>, CLROf<long>>;
    static isEvenInteger(value: long): boolean;
    static isNegative(value: long): boolean;
    static isOddInteger(value: long): boolean;
    static isPositive(value: long): boolean;
    static isPow2(value: long): boolean;
    static leadingZeroCount(value: long): long;
    static log2(value: long): long;
    static max(x: long, y: long): long;
    static maxMagnitude(x: long, y: long): long;
    static min(x: long, y: long): long;
    static minMagnitude(x: long, y: long): long;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): long;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): long;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): long;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): long;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): long;
    static parse7(s: string, style: NumberStyles): long;
    static parse7(s: string, provider: IFormatProvider): long;
    static parse7(s: string): long;
    static popCount(value: long): long;
    static rotateLeft(value: long, rotateAmount: int): long;
    static rotateRight(value: long, rotateAmount: int): long;
    static sign(value: long): int;
    static trailingZeroCount(value: long): long;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<long> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<long> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<long> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<long> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<long> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<long> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<long> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<long> }): boolean;
    static tryParse8(s: string, result: { value: ref<long> }): boolean;
}


export interface __Int64$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<long>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<long>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<long>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<long>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<long>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<long>, CLROf<long>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<long>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<long>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<long>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<long>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int64): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Int64$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<long>> {}

export type Int64 = Int64$instance & __Int64$views;


export class IntPtr$instance implements IBitwiseOperators_3<CLROf<nint>, CLROf<nint>, CLROf<nint>>, IComparisonOperators_3<CLROf<nint>, CLROf<nint>, CLROf<boolean>>, IEqualityOperators_3<CLROf<nint>, CLROf<nint>, CLROf<boolean>>, IModulusOperators_3<CLROf<nint>, CLROf<nint>, CLROf<nint>>, IAdditionOperators_3<CLROf<nint>, CLROf<nint>, CLROf<nint>>, IDecrementOperators_1<CLROf<nint>>, IDivisionOperators_3<CLROf<nint>, CLROf<nint>, CLROf<nint>>, IIncrementOperators_1<CLROf<nint>>, IMultiplyOperators_3<CLROf<nint>, CLROf<nint>, CLROf<nint>>, ISubtractionOperators_3<CLROf<nint>, CLROf<nint>, CLROf<nint>>, IUnaryPlusOperators_2<CLROf<nint>, CLROf<nint>>, IUnaryNegationOperators_2<CLROf<nint>, CLROf<nint>>, IShiftOperators_3<CLROf<nint>, CLROf<int>, CLROf<nint>> {
    constructor(value: int);
    constructor(value: long);
    constructor(value: ptr<void>);
    compareTo(value: unknown): int;
    compareTo(value: nint): int;
    equals(obj: unknown): boolean;
    equals(other: nint): boolean;
    getHashCode(): int;
    toInt32(): int;
    toInt64(): long;
    toPointer(): ptr<void>;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly zero: nint;
    static readonly size: int;
    static readonly maxValue: nint;
    static readonly minValue: nint;
    static abs(value: nint): nint;
    static add(pointer: nint, offset: int): nint;
    static bigMul(left: nint, right: nint, lower: { value: ref<nint> }): nint;
    static clamp(value: nint, min: nint, max: nint): nint;
    static copySign(value: nint, sign: nint): nint;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): nint;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): nint;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): nint;
    static divRem(left: nint, right: nint): ValueTuple_2<CLROf<nint>, CLROf<nint>>;
    static isEvenInteger(value: nint): boolean;
    static isNegative(value: nint): boolean;
    static isOddInteger(value: nint): boolean;
    static isPositive(value: nint): boolean;
    static isPow2(value: nint): boolean;
    static leadingZeroCount(value: nint): nint;
    static log2(value: nint): nint;
    static max(x: nint, y: nint): nint;
    static maxMagnitude(x: nint, y: nint): nint;
    static min(x: nint, y: nint): nint;
    static minMagnitude(x: nint, y: nint): nint;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): nint;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): nint;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): nint;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): nint;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): nint;
    static parse7(s: string, style: NumberStyles): nint;
    static parse7(s: string, provider: IFormatProvider): nint;
    static parse7(s: string): nint;
    static popCount(value: nint): nint;
    static rotateLeft(value: nint, rotateAmount: int): nint;
    static rotateRight(value: nint, rotateAmount: int): nint;
    static sign(value: nint): int;
    static subtract(pointer: nint, offset: int): nint;
    static trailingZeroCount(value: nint): nint;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<nint> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<nint> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<nint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<nint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<nint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<nint> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<nint> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<nint> }): boolean;
    static tryParse8(s: string, result: { value: ref<nint> }): boolean;
}


export interface __IntPtr$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<nint>>;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<nint>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<nint>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<nint>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<nint>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<nint>, CLROf<nint>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<nint>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<nint>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<nint>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<nint>>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: IntPtr): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface IntPtr$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<nint>>, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type IntPtr = IntPtr$instance & __IntPtr$views;


export class Memory_1$instance<T> {
    constructor(array: T[]);
    constructor(array: T[], start: int, length: int);
    readonly isEmpty: boolean;
    readonly length: int;
    readonly span: Span_1<T>;
    copyTo(destination: Memory_1<T>): void;
    equals(obj: unknown): boolean;
    equals(other: Memory_1<T>): boolean;
    getHashCode(): int;
    pin(): MemoryHandle;
    slice(start: int): Memory_1<T>;
    slice(start: int, length: int): Memory_1<T>;
    toArray(): T[];
    toString(): string;
    tryCopyTo(destination: Memory_1<T>): boolean;
    static readonly empty: unknown;
}


export interface __Memory_1$views<T> {
    As_IEquatable_1(): IEquatable_1$instance<Memory_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Memory_1<T>): boolean;
}

export type Memory_1<T> = Memory_1$instance<T> & __Memory_1$views<T>;


export class MemoryExtensions_SpanSplitEnumerator_1$instance<T extends IEquatable_1<T>> {
    readonly current: Range;
    readonly source: ReadOnlySpan_1<T>;
    getEnumerator(): MemoryExtensions_SpanSplitEnumerator_1<T>;
    moveNext(): boolean;
}


export interface __MemoryExtensions_SpanSplitEnumerator_1$views<T extends IEquatable_1<T>> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Range>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): IDisposable$instance;
}

export type MemoryExtensions_SpanSplitEnumerator_1<T extends IEquatable_1<T>> = MemoryExtensions_SpanSplitEnumerator_1$instance<T> & __MemoryExtensions_SpanSplitEnumerator_1$views<T>;


export class MemoryExtensions_TryWriteInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, destination: Span_1<CLROf<char>>, shouldAppend: ref<boolean>);
    constructor(literalLength: int, formattedCount: int, destination: Span_1<CLROf<char>>, provider: IFormatProvider, shouldAppend: ref<boolean>);
    appendFormatted<T>(value: T): boolean;
    appendFormatted<T>(value: T, format: string): boolean;
    appendFormatted<T>(value: T, alignment: int): boolean;
    appendFormatted<T>(value: T, alignment: int, format: string): boolean;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>): boolean;
    appendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): boolean;
    appendFormatted(value: string): boolean;
    appendFormatted(value: string, alignment?: int, format?: string): boolean;
    appendFormatted(value: unknown, alignment?: int, format?: string): boolean;
    appendLiteral(value: string): boolean;
}


export type MemoryExtensions_TryWriteInterpolatedStringHandler = MemoryExtensions_TryWriteInterpolatedStringHandler$instance;

export class ModuleHandle$instance {
    readonly mdStreamVersion: int;
    equals(obj: unknown): boolean;
    equals(handle: ModuleHandle): boolean;
    getHashCode(): int;
    getRuntimeFieldHandleFromMetadataToken(fieldToken: int): RuntimeFieldHandle;
    getRuntimeMethodHandleFromMetadataToken(methodToken: int): RuntimeMethodHandle;
    getRuntimeTypeHandleFromMetadataToken(typeToken: int): RuntimeTypeHandle;
    resolveFieldHandle(fieldToken: int): RuntimeFieldHandle;
    resolveFieldHandle(fieldToken: int, typeInstantiationContext: RuntimeTypeHandle[], methodInstantiationContext: RuntimeTypeHandle[]): RuntimeFieldHandle;
    resolveMethodHandle(methodToken: int): RuntimeMethodHandle;
    resolveMethodHandle(methodToken: int, typeInstantiationContext: RuntimeTypeHandle[], methodInstantiationContext: RuntimeTypeHandle[]): RuntimeMethodHandle;
    resolveTypeHandle(typeToken: int): RuntimeTypeHandle;
    resolveTypeHandle(typeToken: int, typeInstantiationContext: RuntimeTypeHandle[], methodInstantiationContext: RuntimeTypeHandle[]): RuntimeTypeHandle;
    static readonly emptyHandle: ModuleHandle;
}


export interface __ModuleHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<ModuleHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ModuleHandle): boolean;
}

export type ModuleHandle = ModuleHandle$instance & __ModuleHandle$views;


export class Nullable_1$instance<T extends unknown> {
    constructor(value: T);
    readonly hasValue: boolean;
    readonly value: T;
    equals(other: unknown): boolean;
    getHashCode(): int;
    getValueOrDefault(): T;
    getValueOrDefault(defaultValue: T): T;
    toString(): string;
}


export type Nullable_1<T> = Nullable_1$instance<T>;

export class Range$instance {
    constructor(start: Index, end: Index);
    readonly end: Index;
    readonly start: Index;
    equals(value: unknown): boolean;
    equals(other: Range): boolean;
    getHashCode(): int;
    getOffsetAndLength(length: int): ValueTuple_2<CLROf<int>, CLROf<int>>;
    toString(): string;
    static readonly all: Range;
    static endAt(end: Index): Range;
    static startAt(start: Index): Range;
}


export interface __Range$views {
    As_IEquatable_1(): IEquatable_1$instance<Range>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Range): boolean;
}

export type Range = Range$instance & __Range$views;


export class ReadOnlyMemory_1$instance<T> {
    constructor(array: T[]);
    constructor(array: T[], start: int, length: int);
    readonly isEmpty: boolean;
    readonly length: int;
    readonly span: ReadOnlySpan_1<T>;
    copyTo(destination: Memory_1<T>): void;
    equals(obj: unknown): boolean;
    equals(other: ReadOnlyMemory_1<T>): boolean;
    getHashCode(): int;
    pin(): MemoryHandle;
    slice(start: int): ReadOnlyMemory_1<T>;
    slice(start: int, length: int): ReadOnlyMemory_1<T>;
    toArray(): T[];
    toString(): string;
    tryCopyTo(destination: Memory_1<T>): boolean;
    static readonly empty: unknown;
}


export interface __ReadOnlyMemory_1$views<T> {
    As_IEquatable_1(): IEquatable_1$instance<ReadOnlyMemory_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ReadOnlyMemory_1<T>): boolean;
}

export type ReadOnlyMemory_1<T> = ReadOnlyMemory_1$instance<T> & __ReadOnlyMemory_1$views<T>;


export class ReadOnlySpan_1$instance<T> {
    constructor(array: T[]);
    constructor(array: T[], start: int, length: int);
    constructor(pointer: ptr<void>, length: int);
    constructor(reference: ref<T>);
    readonly isEmpty: boolean;
    readonly item: ref<T>;
    readonly length: int;
    copyTo(destination: Span_1<T>): void;
    equals(obj: unknown): boolean;
    getEnumerator(): ReadOnlySpan_1_Enumerator<T>;
    getHashCode(): int;
    getPinnableReference(): ref<T>;
    slice(start: int): ReadOnlySpan_1<T>;
    slice(start: int, length: int): ReadOnlySpan_1<T>;
    toArray(): T[];
    toString(): string;
    tryCopyTo(destination: Span_1<T>): boolean;
    static readonly empty: unknown;
    static castUp<T, TDerived extends T>(items: ReadOnlySpan_1<TDerived>): ReadOnlySpan_1<T>;
}


export type ReadOnlySpan_1<T> = ReadOnlySpan_1$instance<T>;

export class ReadOnlySpan_1_Enumerator$instance<T> {
    readonly current: ref<T>;
    moveNext(): boolean;
}


export interface __ReadOnlySpan_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): IDisposable$instance;
}

export type ReadOnlySpan_1_Enumerator<T> = ReadOnlySpan_1_Enumerator$instance<T> & __ReadOnlySpan_1_Enumerator$views<T>;


export class RuntimeArgumentHandle$instance {
}


export type RuntimeArgumentHandle = RuntimeArgumentHandle$instance;

export class RuntimeFieldHandle$instance {
    readonly value: nint;
    equals(obj: unknown): boolean;
    equals(handle: RuntimeFieldHandle): boolean;
    getHashCode(): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static fromIntPtr(value: nint): RuntimeFieldHandle;
    static toIntPtr(value: RuntimeFieldHandle): nint;
}


export interface __RuntimeFieldHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<RuntimeFieldHandle>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: RuntimeFieldHandle): boolean;
}

export interface RuntimeFieldHandle$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type RuntimeFieldHandle = RuntimeFieldHandle$instance & __RuntimeFieldHandle$views;


export class RuntimeMethodHandle$instance {
    readonly value: nint;
    equals(obj: unknown): boolean;
    equals(handle: RuntimeMethodHandle): boolean;
    getFunctionPointer(): nint;
    getHashCode(): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static fromIntPtr(value: nint): RuntimeMethodHandle;
    static toIntPtr(value: RuntimeMethodHandle): nint;
}


export interface __RuntimeMethodHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<RuntimeMethodHandle>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: RuntimeMethodHandle): boolean;
}

export interface RuntimeMethodHandle$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type RuntimeMethodHandle = RuntimeMethodHandle$instance & __RuntimeMethodHandle$views;


export class RuntimeTypeHandle$instance {
    readonly value: nint;
    equals(obj: unknown): boolean;
    equals(handle: RuntimeTypeHandle): boolean;
    getHashCode(): int;
    getModuleHandle(): ModuleHandle;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static fromIntPtr(value: nint): RuntimeTypeHandle;
    static toIntPtr(value: RuntimeTypeHandle): nint;
}


export interface __RuntimeTypeHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<RuntimeTypeHandle>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: RuntimeTypeHandle): boolean;
}

export interface RuntimeTypeHandle$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type RuntimeTypeHandle = RuntimeTypeHandle$instance & __RuntimeTypeHandle$views;


export class SByte$instance implements IBitwiseOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<sbyte>>, IComparisonOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<boolean>>, IEqualityOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<boolean>>, IModulusOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<sbyte>>, IAdditionOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<sbyte>>, IDecrementOperators_1<CLROf<sbyte>>, IDivisionOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<sbyte>>, IIncrementOperators_1<CLROf<sbyte>>, IMultiplyOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<sbyte>>, ISubtractionOperators_3<CLROf<sbyte>, CLROf<sbyte>, CLROf<sbyte>>, IUnaryPlusOperators_2<CLROf<sbyte>, CLROf<sbyte>>, IUnaryNegationOperators_2<CLROf<sbyte>, CLROf<sbyte>>, IShiftOperators_3<CLROf<sbyte>, CLROf<int>, CLROf<sbyte>> {
    compareTo(obj: unknown): int;
    compareTo(value: sbyte): int;
    equals(obj: unknown): boolean;
    equals(obj: sbyte): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: sbyte;
    static readonly minValue: sbyte;
    static abs(value: sbyte): sbyte;
    static clamp(value: sbyte, min: sbyte, max: sbyte): sbyte;
    static copySign(value: sbyte, sign: sbyte): sbyte;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): sbyte;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): sbyte;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): sbyte;
    static divRem(left: sbyte, right: sbyte): ValueTuple_2<CLROf<sbyte>, CLROf<sbyte>>;
    static isEvenInteger(value: sbyte): boolean;
    static isNegative(value: sbyte): boolean;
    static isOddInteger(value: sbyte): boolean;
    static isPositive(value: sbyte): boolean;
    static isPow2(value: sbyte): boolean;
    static leadingZeroCount(value: sbyte): sbyte;
    static log2(value: sbyte): sbyte;
    static max(x: sbyte, y: sbyte): sbyte;
    static maxMagnitude(x: sbyte, y: sbyte): sbyte;
    static min(x: sbyte, y: sbyte): sbyte;
    static minMagnitude(x: sbyte, y: sbyte): sbyte;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): sbyte;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): sbyte;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): sbyte;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): sbyte;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): sbyte;
    static parse7(s: string, style: NumberStyles): sbyte;
    static parse7(s: string, provider: IFormatProvider): sbyte;
    static parse7(s: string): sbyte;
    static popCount(value: sbyte): sbyte;
    static rotateLeft(value: sbyte, rotateAmount: int): sbyte;
    static rotateRight(value: sbyte, rotateAmount: int): sbyte;
    static sign(value: sbyte): int;
    static trailingZeroCount(value: sbyte): sbyte;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<sbyte> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<sbyte> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<sbyte> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<sbyte> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<sbyte> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<sbyte> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<sbyte> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<sbyte> }): boolean;
    static tryParse8(s: string, result: { value: ref<sbyte> }): boolean;
}


export interface __SByte$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<sbyte>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<sbyte>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<sbyte>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<sbyte>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<sbyte>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<sbyte>, CLROf<sbyte>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<sbyte>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<sbyte>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<sbyte>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<sbyte>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SByte): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface SByte$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<sbyte>> {}

export type SByte = SByte$instance & __SByte$views;


export class SequencePosition$instance {
    constructor(object_: unknown, integer: int);
    equals(other: SequencePosition): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getInteger(): int;
    getObject(): unknown;
}


export interface __SequencePosition$views {
    As_IEquatable_1(): IEquatable_1$instance<SequencePosition>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SequencePosition): boolean;
}

export type SequencePosition = SequencePosition$instance & __SequencePosition$views;


export class Single$instance implements IBitwiseOperators_3<CLROf<float>, CLROf<float>, CLROf<float>>, IComparisonOperators_3<CLROf<float>, CLROf<float>, CLROf<boolean>>, IEqualityOperators_3<CLROf<float>, CLROf<float>, CLROf<boolean>>, IModulusOperators_3<CLROf<float>, CLROf<float>, CLROf<float>>, IAdditionOperators_3<CLROf<float>, CLROf<float>, CLROf<float>>, IDecrementOperators_1<CLROf<float>>, IDivisionOperators_3<CLROf<float>, CLROf<float>, CLROf<float>>, IIncrementOperators_1<CLROf<float>>, IMultiplyOperators_3<CLROf<float>, CLROf<float>, CLROf<float>>, ISubtractionOperators_3<CLROf<float>, CLROf<float>, CLROf<float>>, IUnaryPlusOperators_2<CLROf<float>, CLROf<float>>, IUnaryNegationOperators_2<CLROf<float>, CLROf<float>> {
    compareTo(value: unknown): int;
    compareTo(value: float): int;
    equals(obj: unknown): boolean;
    equals(obj: float): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly minValue: float;
    static readonly maxValue: float;
    static readonly epsilon: float;
    static readonly negativeInfinity: float;
    static readonly positiveInfinity: float;
    static readonly naN: float;
    static readonly negativeZero: float;
    static readonly E: float;
    static readonly pi: float;
    static readonly tau: float;
    static abs(value: float): float;
    static acos(x: float): float;
    static acosh(x: float): float;
    static acosPi(x: float): float;
    static asin(x: float): float;
    static asinh(x: float): float;
    static asinPi(x: float): float;
    static atan(x: float): float;
    static atan2(y: float, x: float): float;
    static atan2Pi(y: float, x: float): float;
    static atanh(x: float): float;
    static atanPi(x: float): float;
    static bitDecrement(x: float): float;
    static bitIncrement(x: float): float;
    static cbrt(x: float): float;
    static ceiling(x: float): float;
    static clamp(value: float, min: float, max: float): float;
    static clampNative(value: float, min: float, max: float): float;
    static convertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: float): TInteger;
    static convertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: float): TInteger;
    static copySign(value: float, sign: float): float;
    static cos(x: float): float;
    static cosh(x: float): float;
    static cosPi(x: float): float;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): float;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): float;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): float;
    static degreesToRadians(degrees: float): float;
    static exp(x: float): float;
    static exp10(x: float): float;
    static exp10M1(x: float): float;
    static exp2(x: float): float;
    static exp2M1(x: float): float;
    static expM1(x: float): float;
    static floor(x: float): float;
    static fusedMultiplyAdd(left: float, right: float, addend: float): float;
    static hypot(x: float, y: float): float;
    static ieee754Remainder(left: float, right: float): float;
    static iLogB(x: float): int;
    static isEvenInteger(value: float): boolean;
    static isFinite(f: float): boolean;
    static isInfinity(f: float): boolean;
    static isInteger(value: float): boolean;
    static isNaN(f: float): boolean;
    static isNegative(f: float): boolean;
    static isNegativeInfinity(f: float): boolean;
    static isNormal(f: float): boolean;
    static isOddInteger(value: float): boolean;
    static isPositive(value: float): boolean;
    static isPositiveInfinity(f: float): boolean;
    static isPow2(value: float): boolean;
    static isRealNumber(value: float): boolean;
    static isSubnormal(f: float): boolean;
    static lerp(value1: float, value2: float, amount: float): float;
    static log2(x: float, newBase: float): float;
    static log2(x: float): float;
    static log10(x: float): float;
    static log10P1(x: float): float;
    static log22(value: float): float;
    static log2P1(x: float): float;
    static logP1(x: float): float;
    static max(x: float, y: float): float;
    static maxMagnitude(x: float, y: float): float;
    static maxMagnitudeNumber(x: float, y: float): float;
    static maxNative(x: float, y: float): float;
    static maxNumber(x: float, y: float): float;
    static min(x: float, y: float): float;
    static minMagnitude(x: float, y: float): float;
    static minMagnitudeNumber(x: float, y: float): float;
    static minNative(x: float, y: float): float;
    static minNumber(x: float, y: float): float;
    static multiplyAddEstimate(left: float, right: float, addend: float): float;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): float;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): float;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): float;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): float;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): float;
    static parse7(s: string, style: NumberStyles): float;
    static parse7(s: string, provider: IFormatProvider): float;
    static parse7(s: string): float;
    static pow(x: float, y: float): float;
    static radiansToDegrees(radians: float): float;
    static reciprocalEstimate(x: float): float;
    static reciprocalSqrtEstimate(x: float): float;
    static rootN(x: float, n: int): float;
    static round4(x: float, digits: int, mode: MidpointRounding): float;
    static round4(x: float, digits: int): float;
    static round4(x: float, mode: MidpointRounding): float;
    static round4(x: float): float;
    static scaleB(x: float, n: int): float;
    static sign(value: float): int;
    static sin(x: float): float;
    static sinCos(x: float): ValueTuple_2<CLROf<float>, CLROf<float>>;
    static sinCosPi(x: float): ValueTuple_2<CLROf<float>, CLROf<float>>;
    static sinh(x: float): float;
    static sinPi(x: float): float;
    static sqrt(x: float): float;
    static tan(x: float): float;
    static tanh(x: float): float;
    static tanPi(x: float): float;
    static truncate(x: float): float;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<float> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<float> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<float> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<float> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<float> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<float> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<float> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<float> }): boolean;
    static tryParse8(s: string, result: { value: ref<float> }): boolean;
}


export interface __Single$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<float>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<float>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<float>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<float>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<float>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<float>, CLROf<float>>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<CLROf<float>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<float>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<float>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<float>>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<CLROf<float>>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<CLROf<float>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Single): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface Single$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<float>> {}

export type Single = Single$instance & __Single$views;


export class Span_1$instance<T> {
    constructor(array: T[]);
    constructor(array: T[], start: int, length: int);
    constructor(pointer: ptr<void>, length: int);
    constructor(reference: ref<T>);
    readonly isEmpty: boolean;
    readonly item: ref<T>;
    readonly length: int;
    clear(): void;
    copyTo(destination: Span_1<T>): void;
    equals(obj: unknown): boolean;
    fill(value: T): void;
    getEnumerator(): Span_1_Enumerator<T>;
    getHashCode(): int;
    getPinnableReference(): ref<T>;
    slice(start: int): Span_1<T>;
    slice(start: int, length: int): Span_1<T>;
    toArray(): T[];
    toString(): string;
    tryCopyTo(destination: Span_1<T>): boolean;
    static readonly empty: unknown;
}


export type Span_1<T> = Span_1$instance<T>;

export class Span_1_Enumerator$instance<T> {
    readonly current: ref<T>;
    moveNext(): boolean;
}


export interface __Span_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): IDisposable$instance;
}

export type Span_1_Enumerator<T> = Span_1_Enumerator$instance<T> & __Span_1_Enumerator$views<T>;


export class TimeOnly$instance {
    constructor(hour: int, minute: int);
    constructor(hour: int, minute: int, second: int);
    constructor(hour: int, minute: int, second: int, millisecond: int);
    constructor(hour: int, minute: int, second: int, millisecond: int, microsecond: int);
    constructor(ticks: long);
    readonly hour: int;
    readonly microsecond: int;
    readonly millisecond: int;
    readonly minute: int;
    readonly nanosecond: int;
    readonly second: int;
    readonly ticks: long;
    add(value: TimeSpan): TimeOnly;
    add(value: TimeSpan, wrappedDays: { value: ref<int> }): TimeOnly;
    addHours(value: double): TimeOnly;
    addHours(value: double, wrappedDays: { value: ref<int> }): TimeOnly;
    addMinutes(value: double): TimeOnly;
    addMinutes(value: double, wrappedDays: { value: ref<int> }): TimeOnly;
    compareTo(value: TimeOnly): int;
    compareTo(value: unknown): int;
    deconstruct(hour: { value: ref<int> }, minute: { value: ref<int> }): void;
    deconstruct(hour: { value: ref<int> }, minute: { value: ref<int> }, second: { value: ref<int> }): void;
    deconstruct(hour: { value: ref<int> }, minute: { value: ref<int> }, second: { value: ref<int> }, millisecond: { value: ref<int> }): void;
    deconstruct(hour: { value: ref<int> }, minute: { value: ref<int> }, second: { value: ref<int> }, millisecond: { value: ref<int> }, microsecond: { value: ref<int> }): void;
    equals(value: TimeOnly): boolean;
    equals(value: unknown): boolean;
    getHashCode(): int;
    isBetween(start: TimeOnly, end: TimeOnly): boolean;
    toLongTimeString(): string;
    toShortTimeString(): string;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    toTimeSpan(): TimeSpan;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly minValue: TimeOnly;
    static readonly maxValue: TimeOnly;
    static fromDateTime(dateTime: DateTime): TimeOnly;
    static fromTimeSpan(timeSpan: TimeSpan): TimeOnly;
    static parse(s: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider, style?: DateTimeStyles): TimeOnly;
    static parse(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): TimeOnly;
    static parse(s: string, provider: IFormatProvider, style?: DateTimeStyles): TimeOnly;
    static parse(s: string, provider: IFormatProvider): TimeOnly;
    static parse(s: string): TimeOnly;
    static parseExact(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider, style?: DateTimeStyles): TimeOnly;
    static parseExact(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], provider: IFormatProvider, style?: DateTimeStyles): TimeOnly;
    static parseExact(s: ReadOnlySpan_1<CLROf<char>>, formats: string[]): TimeOnly;
    static parseExact(s: string, format: string, provider: IFormatProvider, style?: DateTimeStyles): TimeOnly;
    static parseExact(s: string, format: string): TimeOnly;
    static parseExact(s: string, formats: string[], provider: IFormatProvider, style?: DateTimeStyles): TimeOnly;
    static parseExact(s: string, formats: string[]): TimeOnly;
    static tryParse2(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<TimeOnly> }): boolean;
    static tryParse2(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<TimeOnly> }): boolean;
    static tryParse2(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<TimeOnly> }): boolean;
    static tryParse2(s: string, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<TimeOnly> }): boolean;
    static tryParse2(s: string, provider: IFormatProvider, result: { value: ref<TimeOnly> }): boolean;
    static tryParse2(s: string, result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: ReadOnlySpan_1<CLROf<char>>, formats: string[], result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: string, format: string, result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles, result: { value: ref<TimeOnly> }): boolean;
    static tryParseExact2(s: string, formats: string[], result: { value: ref<TimeOnly> }): boolean;
}


export interface __TimeOnly$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<TimeOnly>;
    As_IEquatable_1(): IEquatable_1$instance<TimeOnly>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<TimeOnly>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<TimeOnly>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeOnly): boolean;
    CompareTo(obj: unknown): int;
}

export interface TimeOnly$instance extends IComparable_1$instance<TimeOnly>, ISpanParsable_1$instance<TimeOnly> {}

export type TimeOnly = TimeOnly$instance & __TimeOnly$views;


export class TimeSpan$instance {
    constructor(ticks: long);
    constructor(hours: int, minutes: int, seconds: int);
    constructor(days: int, hours: int, minutes: int, seconds: int);
    constructor(days: int, hours: int, minutes: int, seconds: int, milliseconds: int);
    constructor(days: int, hours: int, minutes: int, seconds: int, milliseconds: int, microseconds: int);
    readonly days: int;
    readonly hours: int;
    readonly microseconds: int;
    readonly milliseconds: int;
    readonly minutes: int;
    readonly nanoseconds: int;
    readonly seconds: int;
    readonly ticks: long;
    readonly totalDays: double;
    readonly totalHours: double;
    readonly totalMicroseconds: double;
    readonly totalMilliseconds: double;
    readonly totalMinutes: double;
    readonly totalNanoseconds: double;
    readonly totalSeconds: double;
    add(ts: TimeSpan): TimeSpan;
    compareTo(value: unknown): int;
    compareTo(value: TimeSpan): int;
    divide(divisor: double): TimeSpan;
    divide(ts: TimeSpan): double;
    duration(): TimeSpan;
    equals(value: unknown): boolean;
    equals(obj: TimeSpan): boolean;
    getHashCode(): int;
    multiply(factor: double): TimeSpan;
    negate(): TimeSpan;
    subtract(ts: TimeSpan): TimeSpan;
    toString(): string;
    toString(format: string): string;
    toString(format: string, formatProvider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, formatProvider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, formatProvider?: IFormatProvider): boolean;
    static readonly zero: TimeSpan;
    static readonly maxValue: TimeSpan;
    static readonly minValue: TimeSpan;
    static readonly nanosecondsPerTick: long;
    static readonly ticksPerMicrosecond: long;
    static readonly ticksPerMillisecond: long;
    static readonly ticksPerSecond: long;
    static readonly ticksPerMinute: long;
    static readonly ticksPerHour: long;
    static readonly ticksPerDay: long;
    static readonly microsecondsPerMillisecond: long;
    static readonly microsecondsPerSecond: long;
    static readonly microsecondsPerMinute: long;
    static readonly microsecondsPerHour: long;
    static readonly microsecondsPerDay: long;
    static readonly millisecondsPerSecond: long;
    static readonly millisecondsPerMinute: long;
    static readonly millisecondsPerHour: long;
    static readonly millisecondsPerDay: long;
    static readonly secondsPerMinute: long;
    static readonly secondsPerHour: long;
    static readonly secondsPerDay: long;
    static readonly minutesPerHour: long;
    static readonly minutesPerDay: long;
    static readonly hoursPerDay: int;
    static compare(t1: TimeSpan, t2: TimeSpan): int;
    static equals(t1: TimeSpan, t2: TimeSpan): boolean;
    static fromDays(value: double): TimeSpan;
    static fromDays(days: int, hours?: int, minutes?: long, seconds?: long, milliseconds?: long, microseconds?: long): TimeSpan;
    static fromDays(days: int): TimeSpan;
    static fromHours3(value: double): TimeSpan;
    static fromHours3(hours: int, minutes?: long, seconds?: long, milliseconds?: long, microseconds?: long): TimeSpan;
    static fromHours3(hours: int): TimeSpan;
    static fromMicroseconds2(value: double): TimeSpan;
    static fromMicroseconds2(microseconds: long): TimeSpan;
    static fromMilliseconds3(value: double): TimeSpan;
    static fromMilliseconds3(milliseconds: long, microseconds: long): TimeSpan;
    static fromMilliseconds3(milliseconds: long): TimeSpan;
    static fromMinutes3(value: double): TimeSpan;
    static fromMinutes3(minutes: long, seconds?: long, milliseconds?: long, microseconds?: long): TimeSpan;
    static fromMinutes3(minutes: long): TimeSpan;
    static fromSeconds3(value: double): TimeSpan;
    static fromSeconds3(seconds: long, milliseconds?: long, microseconds?: long): TimeSpan;
    static fromSeconds3(seconds: long): TimeSpan;
    static fromTicks(value: long): TimeSpan;
    static parse3(input: ReadOnlySpan_1<CLROf<char>>, formatProvider?: IFormatProvider): TimeSpan;
    static parse3(input: string, formatProvider: IFormatProvider): TimeSpan;
    static parse3(s: string): TimeSpan;
    static parseExact4(input: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, formatProvider: IFormatProvider, styles?: TimeSpanStyles): TimeSpan;
    static parseExact4(input: ReadOnlySpan_1<CLROf<char>>, formats: string[], formatProvider: IFormatProvider, styles?: TimeSpanStyles): TimeSpan;
    static parseExact4(input: string, format: string, formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan;
    static parseExact4(input: string, format: string, formatProvider: IFormatProvider): TimeSpan;
    static parseExact4(input: string, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan;
    static parseExact4(input: string, formats: string[], formatProvider: IFormatProvider): TimeSpan;
    static tryParse4(input: ReadOnlySpan_1<CLROf<char>>, formatProvider: IFormatProvider, result: { value: ref<TimeSpan> }): boolean;
    static tryParse4(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<TimeSpan> }): boolean;
    static tryParse4(input: string, formatProvider: IFormatProvider, result: { value: ref<TimeSpan> }): boolean;
    static tryParse4(s: string, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, formatProvider: IFormatProvider, styles: TimeSpanStyles, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: ReadOnlySpan_1<CLROf<char>>, format: ReadOnlySpan_1<CLROf<char>>, formatProvider: IFormatProvider, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: ReadOnlySpan_1<CLROf<char>>, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: ReadOnlySpan_1<CLROf<char>>, formats: string[], formatProvider: IFormatProvider, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: string, format: string, formatProvider: IFormatProvider, styles: TimeSpanStyles, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: string, format: string, formatProvider: IFormatProvider, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: string, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles, result: { value: ref<TimeSpan> }): boolean;
    static tryParseExact6(input: string, formats: string[], formatProvider: IFormatProvider, result: { value: ref<TimeSpan> }): boolean;
}


export interface __TimeSpan$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<TimeSpan>;
    As_IEquatable_1(): IEquatable_1$instance<TimeSpan>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<TimeSpan>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<TimeSpan>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeSpan): boolean;
    CompareTo(obj: unknown): int;
}

export interface TimeSpan$instance extends IComparable$instance, ISpanParsable_1$instance<TimeSpan> {}

export type TimeSpan = TimeSpan$instance & __TimeSpan$views;


export class TimeZoneInfo_TransitionTime$instance {
    readonly day: int;
    readonly dayOfWeek: DayOfWeek;
    readonly isFixedDateRule: boolean;
    readonly month: int;
    readonly timeOfDay: DateTime;
    readonly week: int;
    equals(obj: unknown): boolean;
    equals(other: TimeZoneInfo_TransitionTime): boolean;
    getHashCode(): int;
    static createFixedDateRule(timeOfDay: DateTime, month: int, day: int): TimeZoneInfo_TransitionTime;
    static createFloatingDateRule(timeOfDay: DateTime, month: int, week: int, dayOfWeek: DayOfWeek): TimeZoneInfo_TransitionTime;
}


export interface __TimeZoneInfo_TransitionTime$views {
    As_IEquatable_1(): IEquatable_1$instance<TimeZoneInfo_TransitionTime>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeZoneInfo_TransitionTime): boolean;
}

export interface TimeZoneInfo_TransitionTime$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TimeZoneInfo_TransitionTime = TimeZoneInfo_TransitionTime$instance & __TimeZoneInfo_TransitionTime$views;


export class TypedReference$instance {
    equals(o: unknown): boolean;
    getHashCode(): int;
    static getTargetType(value: TypedReference): Type;
    static makeTypedReference(target: unknown, flds: FieldInfo[]): TypedReference;
    static setTypedReference(target: TypedReference, value: unknown): void;
    static targetTypeToken(value: TypedReference): RuntimeTypeHandle;
    static toObject(value: TypedReference): unknown;
}


export type TypedReference = TypedReference$instance;

export class UInt128$instance implements IBitwiseOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<uint128>>, IComparisonOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<boolean>>, IEqualityOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<boolean>>, IModulusOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<uint128>>, IAdditionOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<uint128>>, IDecrementOperators_1<CLROf<uint128>>, IDivisionOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<uint128>>, IIncrementOperators_1<CLROf<uint128>>, IMultiplyOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<uint128>>, ISubtractionOperators_3<CLROf<uint128>, CLROf<uint128>, CLROf<uint128>>, IUnaryPlusOperators_2<CLROf<uint128>, CLROf<uint128>>, IUnaryNegationOperators_2<CLROf<uint128>, CLROf<uint128>>, IShiftOperators_3<CLROf<uint128>, CLROf<int>, CLROf<uint128>> {
    constructor(upper: ulong, lower: ulong);
    compareTo(value: unknown): int;
    compareTo(value: uint128): int;
    equals(obj: unknown): boolean;
    equals(other: uint128): boolean;
    getHashCode(): int;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly minValue: uint128;
    static readonly maxValue: uint128;
    static readonly one: uint128;
    static readonly zero: uint128;
    static bigMul(left: uint128, right: uint128, lower: { value: ref<uint128> }): uint128;
    static clamp(value: uint128, min: uint128, max: uint128): uint128;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): uint128;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): uint128;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): uint128;
    static divRem(left: uint128, right: uint128): ValueTuple_2<CLROf<uint128>, CLROf<uint128>>;
    static isEvenInteger(value: uint128): boolean;
    static isOddInteger(value: uint128): boolean;
    static isPow2(value: uint128): boolean;
    static leadingZeroCount(value: uint128): uint128;
    static log2(value: uint128): uint128;
    static max(x: uint128, y: uint128): uint128;
    static min(x: uint128, y: uint128): uint128;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): uint128;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): uint128;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): uint128;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): uint128;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): uint128;
    static parse7(s: string, style: NumberStyles): uint128;
    static parse7(s: string, provider: IFormatProvider): uint128;
    static parse7(s: string): uint128;
    static popCount(value: uint128): uint128;
    static rotateLeft(value: uint128, rotateAmount: int): uint128;
    static rotateRight(value: uint128, rotateAmount: int): uint128;
    static sign(value: uint128): int;
    static trailingZeroCount(value: uint128): uint128;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<uint128> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<uint128> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<uint128> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<uint128> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<uint128> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<uint128> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<uint128> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<uint128> }): boolean;
    static tryParse8(s: string, result: { value: ref<uint128> }): boolean;
}


export interface __UInt128$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<uint128>>;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<uint128>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<uint128>>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<uint128>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<uint128>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<uint128>, CLROf<uint128>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<uint128>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<uint128>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<uint128>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<uint128>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt128): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface UInt128$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<uint128>> {}

export type UInt128 = UInt128$instance & __UInt128$views;


export class UInt16$instance implements IBitwiseOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<ushort>>, IComparisonOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<boolean>>, IEqualityOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<boolean>>, IModulusOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<ushort>>, IAdditionOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<ushort>>, IDecrementOperators_1<CLROf<ushort>>, IDivisionOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<ushort>>, IIncrementOperators_1<CLROf<ushort>>, IMultiplyOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<ushort>>, ISubtractionOperators_3<CLROf<ushort>, CLROf<ushort>, CLROf<ushort>>, IUnaryPlusOperators_2<CLROf<ushort>, CLROf<ushort>>, IUnaryNegationOperators_2<CLROf<ushort>, CLROf<ushort>>, IShiftOperators_3<CLROf<ushort>, CLROf<int>, CLROf<ushort>> {
    compareTo(value: unknown): int;
    compareTo(value: ushort): int;
    equals(obj: unknown): boolean;
    equals(obj: ushort): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: ushort;
    static readonly minValue: ushort;
    static clamp(value: ushort, min: ushort, max: ushort): ushort;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): ushort;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): ushort;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): ushort;
    static divRem(left: ushort, right: ushort): ValueTuple_2<CLROf<ushort>, CLROf<ushort>>;
    static isEvenInteger(value: ushort): boolean;
    static isOddInteger(value: ushort): boolean;
    static isPow2(value: ushort): boolean;
    static leadingZeroCount(value: ushort): ushort;
    static log2(value: ushort): ushort;
    static max(x: ushort, y: ushort): ushort;
    static min(x: ushort, y: ushort): ushort;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): ushort;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): ushort;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): ushort;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): ushort;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): ushort;
    static parse7(s: string, style: NumberStyles): ushort;
    static parse7(s: string, provider: IFormatProvider): ushort;
    static parse7(s: string): ushort;
    static popCount(value: ushort): ushort;
    static rotateLeft(value: ushort, rotateAmount: int): ushort;
    static rotateRight(value: ushort, rotateAmount: int): ushort;
    static sign(value: ushort): int;
    static trailingZeroCount(value: ushort): ushort;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<ushort> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<ushort> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<ushort> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<ushort> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<ushort> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<ushort> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<ushort> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<ushort> }): boolean;
    static tryParse8(s: string, result: { value: ref<ushort> }): boolean;
}


export interface __UInt16$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<ushort>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<ushort>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<ushort>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<ushort>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<ushort>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<ushort>, CLROf<ushort>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<ushort>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<ushort>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<ushort>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<ushort>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt16): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface UInt16$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<ushort>> {}

export type UInt16 = UInt16$instance & __UInt16$views;


export class UInt32$instance implements IBitwiseOperators_3<CLROf<uint>, CLROf<uint>, CLROf<uint>>, IComparisonOperators_3<CLROf<uint>, CLROf<uint>, CLROf<boolean>>, IEqualityOperators_3<CLROf<uint>, CLROf<uint>, CLROf<boolean>>, IModulusOperators_3<CLROf<uint>, CLROf<uint>, CLROf<uint>>, IAdditionOperators_3<CLROf<uint>, CLROf<uint>, CLROf<uint>>, IDecrementOperators_1<CLROf<uint>>, IDivisionOperators_3<CLROf<uint>, CLROf<uint>, CLROf<uint>>, IIncrementOperators_1<CLROf<uint>>, IMultiplyOperators_3<CLROf<uint>, CLROf<uint>, CLROf<uint>>, ISubtractionOperators_3<CLROf<uint>, CLROf<uint>, CLROf<uint>>, IUnaryPlusOperators_2<CLROf<uint>, CLROf<uint>>, IUnaryNegationOperators_2<CLROf<uint>, CLROf<uint>>, IShiftOperators_3<CLROf<uint>, CLROf<int>, CLROf<uint>> {
    compareTo(value: unknown): int;
    compareTo(value: uint): int;
    equals(obj: unknown): boolean;
    equals(obj: uint): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: uint;
    static readonly minValue: uint;
    static bigMul(left: uint, right: uint): ulong;
    static clamp(value: uint, min: uint, max: uint): uint;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): uint;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): uint;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): uint;
    static divRem(left: uint, right: uint): ValueTuple_2<CLROf<uint>, CLROf<uint>>;
    static isEvenInteger(value: uint): boolean;
    static isOddInteger(value: uint): boolean;
    static isPow2(value: uint): boolean;
    static leadingZeroCount(value: uint): uint;
    static log2(value: uint): uint;
    static max(x: uint, y: uint): uint;
    static min(x: uint, y: uint): uint;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): uint;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): uint;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): uint;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): uint;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): uint;
    static parse7(s: string, style: NumberStyles): uint;
    static parse7(s: string, provider: IFormatProvider): uint;
    static parse7(s: string): uint;
    static popCount(value: uint): uint;
    static rotateLeft(value: uint, rotateAmount: int): uint;
    static rotateRight(value: uint, rotateAmount: int): uint;
    static sign(value: uint): int;
    static trailingZeroCount(value: uint): uint;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<uint> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<uint> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<uint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<uint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<uint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<uint> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<uint> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<uint> }): boolean;
    static tryParse8(s: string, result: { value: ref<uint> }): boolean;
}


export interface __UInt32$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<uint>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<uint>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<uint>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<uint>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<uint>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<uint>, CLROf<uint>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<uint>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<uint>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<uint>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<uint>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt32): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface UInt32$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<uint>> {}

export type UInt32 = UInt32$instance & __UInt32$views;


export class UInt64$instance implements IBitwiseOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<ulong>>, IComparisonOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<boolean>>, IEqualityOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<boolean>>, IModulusOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<ulong>>, IAdditionOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<ulong>>, IDecrementOperators_1<CLROf<ulong>>, IDivisionOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<ulong>>, IIncrementOperators_1<CLROf<ulong>>, IMultiplyOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<ulong>>, ISubtractionOperators_3<CLROf<ulong>, CLROf<ulong>, CLROf<ulong>>, IUnaryPlusOperators_2<CLROf<ulong>, CLROf<ulong>>, IUnaryNegationOperators_2<CLROf<ulong>, CLROf<ulong>>, IShiftOperators_3<CLROf<ulong>, CLROf<int>, CLROf<ulong>> {
    compareTo(value: unknown): int;
    compareTo(value: ulong): int;
    equals(obj: unknown): boolean;
    equals(obj: ulong): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toString(format: string): string;
    toString(format: string, provider: IFormatProvider): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly maxValue: ulong;
    static readonly minValue: ulong;
    static bigMul(left: ulong, right: ulong): uint128;
    static clamp(value: ulong, min: ulong, max: ulong): ulong;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): ulong;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): ulong;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): ulong;
    static divRem(left: ulong, right: ulong): ValueTuple_2<CLROf<ulong>, CLROf<ulong>>;
    static isEvenInteger(value: ulong): boolean;
    static isOddInteger(value: ulong): boolean;
    static isPow2(value: ulong): boolean;
    static leadingZeroCount(value: ulong): ulong;
    static log2(value: ulong): ulong;
    static max(x: ulong, y: ulong): ulong;
    static min(x: ulong, y: ulong): ulong;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): ulong;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): ulong;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): ulong;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): ulong;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): ulong;
    static parse7(s: string, style: NumberStyles): ulong;
    static parse7(s: string, provider: IFormatProvider): ulong;
    static parse7(s: string): ulong;
    static popCount(value: ulong): ulong;
    static rotateLeft(value: ulong, rotateAmount: int): ulong;
    static rotateRight(value: ulong, rotateAmount: int): ulong;
    static sign(value: ulong): int;
    static trailingZeroCount(value: ulong): ulong;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<ulong> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<ulong> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<ulong> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<ulong> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<ulong> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<ulong> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<ulong> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<ulong> }): boolean;
    static tryParse8(s: string, result: { value: ref<ulong> }): boolean;
}


export interface __UInt64$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<ulong>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<ulong>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<ulong>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<ulong>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<ulong>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<ulong>, CLROf<ulong>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<ulong>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<ulong>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<ulong>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<ulong>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt64): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface UInt64$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<ulong>> {}

export type UInt64 = UInt64$instance & __UInt64$views;


export class UIntPtr$instance implements IBitwiseOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<nuint>>, IComparisonOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<boolean>>, IEqualityOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<boolean>>, IModulusOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<nuint>>, IAdditionOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<nuint>>, IDecrementOperators_1<CLROf<nuint>>, IDivisionOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<nuint>>, IIncrementOperators_1<CLROf<nuint>>, IMultiplyOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<nuint>>, ISubtractionOperators_3<CLROf<nuint>, CLROf<nuint>, CLROf<nuint>>, IUnaryPlusOperators_2<CLROf<nuint>, CLROf<nuint>>, IUnaryNegationOperators_2<CLROf<nuint>, CLROf<nuint>>, IShiftOperators_3<CLROf<nuint>, CLROf<int>, CLROf<nuint>> {
    constructor(value: uint);
    constructor(value: ulong);
    constructor(value: ptr<void>);
    compareTo(value: unknown): int;
    compareTo(value: nuint): int;
    equals(obj: unknown): boolean;
    equals(other: nuint): boolean;
    getHashCode(): int;
    toPointer(): ptr<void>;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    toUInt32(): uint;
    toUInt64(): ulong;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>, provider?: IFormatProvider): boolean;
    static readonly zero: nuint;
    static readonly size: int;
    static readonly maxValue: nuint;
    static readonly minValue: nuint;
    static add(pointer: nuint, offset: int): nuint;
    static bigMul(left: nuint, right: nuint, lower: { value: ref<nuint> }): nuint;
    static clamp(value: nuint, min: nuint, max: nuint): nuint;
    static createChecked<TOther extends INumberBase_1<TOther>>(value: TOther): nuint;
    static createSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): nuint;
    static createTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): nuint;
    static divRem(left: nuint, right: nuint): ValueTuple_2<CLROf<nuint>, CLROf<nuint>>;
    static isEvenInteger(value: nuint): boolean;
    static isOddInteger(value: nuint): boolean;
    static isPow2(value: nuint): boolean;
    static leadingZeroCount(value: nuint): nuint;
    static log2(value: nuint): nuint;
    static max(x: nuint, y: nuint): nuint;
    static min(x: nuint, y: nuint): nuint;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style?: NumberStyles, provider?: IFormatProvider): nuint;
    static parse7(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider): nuint;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, style?: NumberStyles, provider?: IFormatProvider): nuint;
    static parse7(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): nuint;
    static parse7(s: string, style: NumberStyles, provider: IFormatProvider): nuint;
    static parse7(s: string, style: NumberStyles): nuint;
    static parse7(s: string, provider: IFormatProvider): nuint;
    static parse7(s: string): nuint;
    static popCount(value: nuint): nuint;
    static rotateLeft(value: nuint, rotateAmount: int): nuint;
    static rotateRight(value: nuint, rotateAmount: int): nuint;
    static sign(value: nuint): int;
    static subtract(pointer: nuint, offset: int): nuint;
    static trailingZeroCount(value: nuint): nuint;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<nuint> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, provider: IFormatProvider, result: { value: ref<nuint> }): boolean;
    static tryParse8(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<nuint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, style: NumberStyles, provider: IFormatProvider, result: { value: ref<nuint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider, result: { value: ref<nuint> }): boolean;
    static tryParse8(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<nuint> }): boolean;
    static tryParse8(s: string, style: NumberStyles, provider: IFormatProvider, result: { value: ref<nuint> }): boolean;
    static tryParse8(s: string, provider: IFormatProvider, result: { value: ref<nuint> }): boolean;
    static tryParse8(s: string, result: { value: ref<nuint> }): boolean;
}


export interface __UIntPtr$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<nuint>>;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<nuint>>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<CLROf<nuint>>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<nuint>>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<CLROf<nuint>>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<CLROf<nuint>, CLROf<nuint>>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<CLROf<nuint>>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<nuint>>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<CLROf<nuint>>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<CLROf<nuint>>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: UIntPtr): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format: ReadOnlySpan_1<CLROf<char>>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<CLROf<byte>>): int;
}

export interface UIntPtr$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<CLROf<nuint>>, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type UIntPtr = UIntPtr$instance & __UIntPtr$views;


export class UriCreationOptions$instance {
    dangerousDisablePathAndQueryCanonicalization: boolean;
}


export type UriCreationOptions = UriCreationOptions$instance;

export class ValueTuple$instance {
    compareTo(other: ValueTuple): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple): boolean;
    getHashCode(): int;
    toString(): string;
    static create(): ValueTuple;
    static create<T1, T2, T3, T4, T5, T6, T7, T8>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8): ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, ValueTuple_1<T8>>;
    static create<T1, T2, T3, T4, T5, T6, T7>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>;
    static create<T1, T2, T3, T4, T5, T6>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): ValueTuple_6<T1, T2, T3, T4, T5, T6>;
    static create<T1, T2, T3, T4, T5>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): ValueTuple_5<T1, T2, T3, T4, T5>;
    static create<T1, T2, T3, T4>(item1: T1, item2: T2, item3: T3, item4: T4): ValueTuple_4<T1, T2, T3, T4>;
    static create<T1, T2, T3>(item1: T1, item2: T2, item3: T3): ValueTuple_3<T1, T2, T3>;
    static create<T1, T2>(item1: T1, item2: T2): ValueTuple_2<T1, T2>;
    static create<T1>(item1: T1): ValueTuple_1<T1>;
}


export interface __ValueTuple$views {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple$instance extends IComparable_1$instance<ValueTuple>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple = ValueTuple$instance & __ValueTuple$views;


export class ValueTuple_1$instance<T1> {
    constructor(item1: T1);
    item1: T1;
    compareTo(other: ValueTuple_1<T1>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_1<T1>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_1$views<T1> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_1<T1>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_1<T1>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_1<T1>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_1$instance<T1> extends IComparable_1$instance<ValueTuple_1<T1>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_1<T1> = ValueTuple_1$instance<T1> & __ValueTuple_1$views<T1>;


export class ValueTuple_2$instance<T1, T2> {
    constructor(item1: T1, item2: T2);
    item1: T1;
    item2: T2;
    compareTo(other: ValueTuple_2<T1, T2>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_2<T1, T2>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_2$views<T1, T2> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_2<T1, T2>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_2<T1, T2>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_2<T1, T2>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_2$instance<T1, T2> extends IComparable_1$instance<ValueTuple_2<T1, T2>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_2<T1, T2> = ValueTuple_2$instance<T1, T2> & __ValueTuple_2$views<T1, T2>;


export class ValueTuple_3$instance<T1, T2, T3> {
    constructor(item1: T1, item2: T2, item3: T3);
    item1: T1;
    item2: T2;
    item3: T3;
    compareTo(other: ValueTuple_3<T1, T2, T3>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_3<T1, T2, T3>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_3$views<T1, T2, T3> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_3<T1, T2, T3>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_3<T1, T2, T3>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_3<T1, T2, T3>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_3$instance<T1, T2, T3> extends IComparable_1$instance<ValueTuple_3<T1, T2, T3>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_3<T1, T2, T3> = ValueTuple_3$instance<T1, T2, T3> & __ValueTuple_3$views<T1, T2, T3>;


export class ValueTuple_4$instance<T1, T2, T3, T4> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4);
    item1: T1;
    item2: T2;
    item3: T3;
    item4: T4;
    compareTo(other: ValueTuple_4<T1, T2, T3, T4>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_4<T1, T2, T3, T4>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_4$views<T1, T2, T3, T4> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_4<T1, T2, T3, T4>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_4<T1, T2, T3, T4>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_4<T1, T2, T3, T4>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_4$instance<T1, T2, T3, T4> extends IComparable_1$instance<ValueTuple_4<T1, T2, T3, T4>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_4<T1, T2, T3, T4> = ValueTuple_4$instance<T1, T2, T3, T4> & __ValueTuple_4$views<T1, T2, T3, T4>;


export class ValueTuple_5$instance<T1, T2, T3, T4, T5> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5);
    item1: T1;
    item2: T2;
    item3: T3;
    item4: T4;
    item5: T5;
    compareTo(other: ValueTuple_5<T1, T2, T3, T4, T5>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_5<T1, T2, T3, T4, T5>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_5$views<T1, T2, T3, T4, T5> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_5<T1, T2, T3, T4, T5>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_5<T1, T2, T3, T4, T5>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_5<T1, T2, T3, T4, T5>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_5$instance<T1, T2, T3, T4, T5> extends IComparable_1$instance<ValueTuple_5<T1, T2, T3, T4, T5>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_5<T1, T2, T3, T4, T5> = ValueTuple_5$instance<T1, T2, T3, T4, T5> & __ValueTuple_5$views<T1, T2, T3, T4, T5>;


export class ValueTuple_6$instance<T1, T2, T3, T4, T5, T6> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6);
    item1: T1;
    item2: T2;
    item3: T3;
    item4: T4;
    item5: T5;
    item6: T6;
    compareTo(other: ValueTuple_6<T1, T2, T3, T4, T5, T6>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_6<T1, T2, T3, T4, T5, T6>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_6$views<T1, T2, T3, T4, T5, T6> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_6<T1, T2, T3, T4, T5, T6>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_6<T1, T2, T3, T4, T5, T6>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_6<T1, T2, T3, T4, T5, T6>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_6$instance<T1, T2, T3, T4, T5, T6> extends IComparable_1$instance<ValueTuple_6<T1, T2, T3, T4, T5, T6>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_6<T1, T2, T3, T4, T5, T6> = ValueTuple_6$instance<T1, T2, T3, T4, T5, T6> & __ValueTuple_6$views<T1, T2, T3, T4, T5, T6>;


export class ValueTuple_7$instance<T1, T2, T3, T4, T5, T6, T7> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7);
    item1: T1;
    item2: T2;
    item3: T3;
    item4: T4;
    item5: T5;
    item6: T6;
    item7: T7;
    compareTo(other: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_7$views<T1, T2, T3, T4, T5, T6, T7> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_7$instance<T1, T2, T3, T4, T5, T6, T7> extends IComparable_1$instance<ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_7<T1, T2, T3, T4, T5, T6, T7> = ValueTuple_7$instance<T1, T2, T3, T4, T5, T6, T7> & __ValueTuple_7$views<T1, T2, T3, T4, T5, T6, T7>;


export class ValueTuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest extends unknown> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, rest: TRest);
    item1: T1;
    item2: T2;
    item3: T3;
    item4: T4;
    item5: T5;
    item6: T6;
    item7: T7;
    rest: TRest;
    compareTo(other: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>): int;
    equals(obj: unknown): boolean;
    equals(other: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __ValueTuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest extends unknown> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest extends unknown> extends IComparable_1$instance<ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest> = ValueTuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> & __ValueTuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest>;


export class Void$instance {
}


export type Void = Void$instance;

export class AccessViolationException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AccessViolationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AccessViolationException = AccessViolationException$instance & __AccessViolationException$views;


export class Action$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(): void;
}


export interface __Action$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action = Action$instance & __Action$views;


export class Action_1$instance<T> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(obj: T, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(obj: T): void;
}


export interface __Action_1$views<T> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_1<T> = Action_1$instance<T> & __Action_1$views<T>;


export class Action_10$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10): void;
}


export interface __Action_10$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> = Action_10$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> & __Action_10$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;


export class Action_11$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11): void;
}


export interface __Action_11$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> = Action_11$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> & __Action_11$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;


export class Action_12$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12): void;
}


export interface __Action_12$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> = Action_12$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> & __Action_12$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;


export class Action_13$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13): void;
}


export interface __Action_13$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> = Action_13$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> & __Action_13$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;


export class Action_14$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14): void;
}


export interface __Action_14$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> = Action_14$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> & __Action_14$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;


export class Action_15$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15): void;
}


export interface __Action_15$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> = Action_15$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> & __Action_15$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;


export class Action_16$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16): void;
}


export interface __Action_16$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> = Action_16$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> & __Action_16$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;


export class Action_2$instance<T1, T2> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2): void;
}


export interface __Action_2$views<T1, T2> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_2<T1, T2> = Action_2$instance<T1, T2> & __Action_2$views<T1, T2>;


export class Action_3$instance<T1, T2, T3> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3): void;
}


export interface __Action_3$views<T1, T2, T3> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_3<T1, T2, T3> = Action_3$instance<T1, T2, T3> & __Action_3$views<T1, T2, T3>;


export class Action_4$instance<T1, T2, T3, T4> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4): void;
}


export interface __Action_4$views<T1, T2, T3, T4> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_4<T1, T2, T3, T4> = Action_4$instance<T1, T2, T3, T4> & __Action_4$views<T1, T2, T3, T4>;


export class Action_5$instance<T1, T2, T3, T4, T5> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): void;
}


export interface __Action_5$views<T1, T2, T3, T4, T5> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_5<T1, T2, T3, T4, T5> = Action_5$instance<T1, T2, T3, T4, T5> & __Action_5$views<T1, T2, T3, T4, T5>;


export class Action_6$instance<T1, T2, T3, T4, T5, T6> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6): void;
}


export interface __Action_6$views<T1, T2, T3, T4, T5, T6> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_6<T1, T2, T3, T4, T5, T6> = Action_6$instance<T1, T2, T3, T4, T5, T6> & __Action_6$views<T1, T2, T3, T4, T5, T6>;


export class Action_7$instance<T1, T2, T3, T4, T5, T6, T7> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7): void;
}


export interface __Action_7$views<T1, T2, T3, T4, T5, T6, T7> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_7<T1, T2, T3, T4, T5, T6, T7> = Action_7$instance<T1, T2, T3, T4, T5, T6, T7> & __Action_7$views<T1, T2, T3, T4, T5, T6, T7>;


export class Action_8$instance<T1, T2, T3, T4, T5, T6, T7, T8> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8): void;
}


export interface __Action_8$views<T1, T2, T3, T4, T5, T6, T7, T8> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_8<T1, T2, T3, T4, T5, T6, T7, T8> = Action_8$instance<T1, T2, T3, T4, T5, T6, T7, T8> & __Action_8$views<T1, T2, T3, T4, T5, T6, T7, T8>;


export class Action_9$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9): void;
}


export interface __Action_9$views<T1, T2, T3, T4, T5, T6, T7, T8, T9> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Action_9<T1, T2, T3, T4, T5, T6, T7, T8, T9> = Action_9$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9> & __Action_9$views<T1, T2, T3, T4, T5, T6, T7, T8, T9>;


export class AggregateException$instance extends Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(innerExceptions: IEnumerable_1<Exception>);
    constructor(innerExceptions: Exception[]);
    constructor(message: string, innerExceptions: IEnumerable_1<Exception>);
    constructor(message: string, innerExceptions: Exception[]);
    readonly innerExceptions: ReadOnlyCollection_1<Exception>;
    readonly message: string;
    flatten(): AggregateException;
    getBaseException(): Exception;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    handle(predicate: Func_2<Exception, CLROf<boolean>>): void;
    toString(): string;
}


export interface __AggregateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AggregateException = AggregateException$instance & __AggregateException$views;


export class AppDomain$instance extends MarshalByRefObject$instance {
    readonly baseDirectory: string;
    readonly dynamicDirectory: string;
    readonly friendlyName: string;
    readonly id: int;
    readonly isFullyTrusted: boolean;
    readonly isHomogenous: boolean;
    readonly monitoringSurvivedMemorySize: long;
    readonly monitoringTotalAllocatedMemorySize: long;
    readonly monitoringTotalProcessorTime: TimeSpan;
    readonly permissionSet: PermissionSet;
    readonly relativeSearchPath: string;
    readonly setupInformation: AppDomainSetup;
    readonly shadowCopyFiles: boolean;
    appendPrivatePath(path: string): void;
    applyPolicy(assemblyName: string): string;
    clearPrivatePath(): void;
    clearShadowCopyPath(): void;
    createInstance(assemblyName: string, typeName: string): ObjectHandle;
    createInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): ObjectHandle;
    createInstance(assemblyName: string, typeName: string, activationAttributes: unknown[]): ObjectHandle;
    createInstanceAndUnwrap(assemblyName: string, typeName: string): unknown;
    createInstanceAndUnwrap(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): unknown;
    createInstanceAndUnwrap(assemblyName: string, typeName: string, activationAttributes: unknown[]): unknown;
    createInstanceFrom(assemblyFile: string, typeName: string): ObjectHandle;
    createInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): ObjectHandle;
    createInstanceFrom(assemblyFile: string, typeName: string, activationAttributes: unknown[]): ObjectHandle;
    createInstanceFromAndUnwrap(assemblyFile: string, typeName: string): unknown;
    createInstanceFromAndUnwrap(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): unknown;
    createInstanceFromAndUnwrap(assemblyFile: string, typeName: string, activationAttributes: unknown[]): unknown;
    executeAssembly(assemblyFile: string): int;
    executeAssembly(assemblyFile: string, args: string[]): int;
    executeAssembly(assemblyFile: string, args: string[], hashValue: byte[], hashAlgorithm: AssemblyHashAlgorithm): int;
    executeAssemblyByName(assemblyName: AssemblyName, args: string[]): int;
    executeAssemblyByName(assemblyName: string): int;
    executeAssemblyByName(assemblyName: string, args: string[]): int;
    getAssemblies(): Assembly[];
    getData(name: string): unknown;
    isCompatibilitySwitchSet(value: string): Nullable_1<CLROf<boolean>>;
    isDefaultAppDomain(): boolean;
    isFinalizingForUnload(): boolean;
    load(rawAssembly: byte[]): Assembly;
    load(rawAssembly: byte[], rawSymbolStore: byte[]): Assembly;
    load(assemblyRef: AssemblyName): Assembly;
    load(assemblyString: string): Assembly;
    reflectionOnlyGetAssemblies(): Assembly[];
    setCachePath(path: string): void;
    setData(name: string, data: unknown): void;
    setDynamicBase(path: string): void;
    setPrincipalPolicy(policy: PrincipalPolicy): void;
    setShadowCopyFiles(): void;
    setShadowCopyPath(path: string): void;
    setThreadPrincipal(principal: IPrincipal): void;
    toString(): string;
    static readonly currentDomain: AppDomain;
    static monitoringIsEnabled: boolean;
    static readonly monitoringSurvivedProcessMemorySize: long;
    static createDomain(friendlyName: string): AppDomain;
    static getCurrentThreadId(): int;
    static unload(domain: AppDomain): void;
}


export type AppDomain = AppDomain$instance;

export class AppDomainSetup$instance {
    readonly applicationBase: string;
    readonly targetFrameworkName: string;
}


export type AppDomainSetup = AppDomainSetup$instance;

export class AppDomainUnloadedException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AppDomainUnloadedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AppDomainUnloadedException = AppDomainUnloadedException$instance & __AppDomainUnloadedException$views;


export class ApplicationException$instance extends Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ApplicationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ApplicationException = ApplicationException$instance & __ApplicationException$views;


export class ApplicationId$instance {
    constructor(publicKeyToken: byte[], name: string, version: Version, processorArchitecture: string, culture: string);
    readonly culture: string;
    readonly name: string;
    readonly processorArchitecture: string;
    readonly publicKeyToken: byte[];
    readonly version: Version;
    copy(): ApplicationId;
    equals(o: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export type ApplicationId = ApplicationId$instance;

export class ArgumentException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, paramName: string, innerException: Exception);
    constructor(message: string, paramName: string);
    readonly message: string;
    readonly paramName: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static throwIfNullOrEmpty(argument: string, paramName?: string): void;
    static throwIfNullOrWhiteSpace(argument: string, paramName?: string): void;
}


export interface __ArgumentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArgumentException = ArgumentException$instance & __ArgumentException$views;


export class ArgumentNullException$instance extends ArgumentException$instance {
    constructor();
    constructor(paramName: string);
    constructor(message: string, innerException: Exception);
    constructor(paramName: string, message: string);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static throwIfNull(argument: unknown, paramName?: string): void;
    static throwIfNull(argument: ptr<void>, paramName?: string): void;
}


export interface __ArgumentNullException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArgumentNullException = ArgumentNullException$instance & __ArgumentNullException$views;


export class ArgumentOutOfRangeException$instance extends ArgumentException$instance {
    constructor();
    constructor(paramName: string);
    constructor(paramName: string, message: string);
    constructor(message: string, innerException: Exception);
    constructor(paramName: string, actualValue: unknown, message: string);
    readonly actualValue: unknown;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static throwIfEqual<T extends IEquatable_1<T>>(value: T, other: T, paramName?: string): void;
    static throwIfGreaterThan<T extends IComparable_1<T>>(value: T, other: T, paramName?: string): void;
    static throwIfGreaterThanOrEqual<T extends IComparable_1<T>>(value: T, other: T, paramName?: string): void;
    static throwIfLessThan<T extends IComparable_1<T>>(value: T, other: T, paramName?: string): void;
    static throwIfLessThanOrEqual<T extends IComparable_1<T>>(value: T, other: T, paramName?: string): void;
    static throwIfNegative<T extends INumberBase_1<T>>(value: T, paramName?: string): void;
    static throwIfNegativeOrZero<T extends INumberBase_1<T>>(value: T, paramName?: string): void;
    static throwIfNotEqual<T extends IEquatable_1<T>>(value: T, other: T, paramName?: string): void;
    static throwIfZero<T extends INumberBase_1<T>>(value: T, paramName?: string): void;
}


export interface __ArgumentOutOfRangeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArgumentOutOfRangeException = ArgumentOutOfRangeException$instance & __ArgumentOutOfRangeException$views;


export class ArithmeticException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ArithmeticException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArithmeticException = ArithmeticException$instance & __ArithmeticException$views;


export abstract class Array$instance {
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly length: int;
    readonly longLength: long;
    readonly rank: int;
    readonly syncRoot: unknown;
    clone(): unknown;
    copyTo(array: Array, index: int): void;
    copyTo(array: Array, index: long): void;
    getEnumerator(): IEnumerator;
    getLength(dimension: int): int;
    getLongLength(dimension: int): long;
    getLowerBound(dimension: int): int;
    getUpperBound(dimension: int): int;
    getValue(indices: int[]): unknown;
    getValue(index: int): unknown;
    getValue(index1: int, index2: int): unknown;
    getValue(index1: int, index2: int, index3: int): unknown;
    getValue(index: long): unknown;
    getValue(index1: long, index2: long): unknown;
    getValue(index1: long, index2: long, index3: long): unknown;
    getValue(indices: long[]): unknown;
    initialize(): void;
    setValue(value: unknown, index: int): void;
    setValue(value: unknown, index1: int, index2: int): void;
    setValue(value: unknown, index1: int, index2: int, index3: int): void;
    setValue(value: unknown, indices: int[]): void;
    setValue(value: unknown, index: long): void;
    setValue(value: unknown, index1: long, index2: long): void;
    setValue(value: unknown, index1: long, index2: long, index3: long): void;
    setValue(value: unknown, indices: long[]): void;
    static readonly maxLength: int;
    static asReadOnly<T>(array: T[]): ReadOnlyCollection_1<T>;
    static binarySearch4(array: Array, index: int, length: int, value: unknown, comparer: IComparer): int;
    static binarySearch4(array: Array, index: int, length: int, value: unknown): int;
    static binarySearch4(array: Array, value: unknown, comparer: IComparer): int;
    static binarySearch4(array: Array, value: unknown): int;
    static binarySearch4<T>(array: T[], index: int, length: int, value: T, comparer: IComparer_1<T>): int;
    static binarySearch4<T>(array: T[], index: int, length: int, value: T): int;
    static binarySearch4<T>(array: T[], value: T, comparer: IComparer_1<T>): int;
    static binarySearch4<T>(array: T[], value: T): int;
    static clear2(array: Array, index: int, length: int): void;
    static clear2(array: Array): void;
    static constrainedCopy(sourceArray: Array, sourceIndex: int, destinationArray: Array, destinationIndex: int, length: int): void;
    static convertAll<TInput, TOutput>(array: TInput[], converter: Converter_2<TInput, TOutput>): TOutput[];
    static copy3(sourceArray: Array, destinationArray: Array, length: int): void;
    static copy3(sourceArray: Array, destinationArray: Array, length: long): void;
    static copy3(sourceArray: Array, sourceIndex: int, destinationArray: Array, destinationIndex: int, length: int): void;
    static copy3(sourceArray: Array, sourceIndex: long, destinationArray: Array, destinationIndex: long, length: long): void;
    static createInstance3(elementType: Type, length1: int, length2: int, length3: int): Array;
    static createInstance3(elementType: Type, length1: int, length2: int): Array;
    static createInstance3(elementType: Type, length: int): Array;
    static createInstance3(elementType: Type, lengths: int[], lowerBounds: int[]): Array;
    static createInstance3(elementType: Type, lengths: int[]): Array;
    static createInstance3(elementType: Type, lengths: long[]): Array;
    static createInstanceFromArrayType(arrayType: Type, length: int): Array;
    static createInstanceFromArrayType(arrayType: Type, lengths: int[], lowerBounds: int[]): Array;
    static createInstanceFromArrayType(arrayType: Type, lengths: int[]): Array;
    static empty<T>(): T[];
    static exists<T>(array: T[], match: Predicate_1<T>): boolean;
    static fill2<T>(array: T[], value: T, startIndex: int, count: int): void;
    static fill2<T>(array: T[], value: T): void;
    static find<T>(array: T[], match: Predicate_1<T>): T;
    static findAll<T>(array: T[], match: Predicate_1<T>): T[];
    static findIndex<T>(array: T[], match: Predicate_1<T>): int;
    static findIndex<T>(array: T[], startIndex: int, match: Predicate_1<T>): int;
    static findIndex<T>(array: T[], startIndex: int, count: int, match: Predicate_1<T>): int;
    static findLast<T>(array: T[], match: Predicate_1<T>): T;
    static findLastIndex<T>(array: T[], match: Predicate_1<T>): int;
    static findLastIndex<T>(array: T[], startIndex: int, match: Predicate_1<T>): int;
    static findLastIndex<T>(array: T[], startIndex: int, count: int, match: Predicate_1<T>): int;
    static forEach<T>(array: T[], action: Action_1<T>): void;
    static indexOf3(array: Array, value: unknown, startIndex: int, count: int): int;
    static indexOf3(array: Array, value: unknown, startIndex: int): int;
    static indexOf3(array: Array, value: unknown): int;
    static indexOf3<T>(array: T[], value: T, startIndex: int, count: int): int;
    static indexOf3<T>(array: T[], value: T, startIndex: int): int;
    static indexOf3<T>(array: T[], value: T): int;
    static lastIndexOf3(array: Array, value: unknown, startIndex: int, count: int): int;
    static lastIndexOf3(array: Array, value: unknown, startIndex: int): int;
    static lastIndexOf3(array: Array, value: unknown): int;
    static lastIndexOf3<T>(array: T[], value: T, startIndex: int, count: int): int;
    static lastIndexOf3<T>(array: T[], value: T, startIndex: int): int;
    static lastIndexOf3<T>(array: T[], value: T): int;
    static resize<T>(array: { value: ref<T[]> }, newSize: int): void;
    static reverse2(array: Array, index: int, length: int): void;
    static reverse2(array: Array): void;
    static reverse2<T>(array: T[], index: int, length: int): void;
    static reverse2<T>(array: T[]): void;
    static sort6(keys: Array, items: Array, comparer: IComparer): void;
    static sort6(keys: Array, items: Array, index: int, length: int, comparer: IComparer): void;
    static sort6(keys: Array, items: Array, index: int, length: int): void;
    static sort6(keys: Array, items: Array): void;
    static sort6(array: Array, comparer: IComparer): void;
    static sort6(array: Array, index: int, length: int, comparer: IComparer): void;
    static sort6(array: Array, index: int, length: int): void;
    static sort6(array: Array): void;
    static sort6<T>(array: T[], comparison: Comparison_1<T>): void;
    static sort6<T>(array: T[], comparer: IComparer_1<T>): void;
    static sort6<T>(array: T[], index: int, length: int, comparer: IComparer_1<T>): void;
    static sort6<T>(array: T[], index: int, length: int): void;
    static sort6<T>(array: T[]): void;
    static sort6<TKey, TValue>(keys: TKey[], items: TValue[], comparer: IComparer_1<TKey>): void;
    static sort6<TKey, TValue>(keys: TKey[], items: TValue[], index: int, length: int, comparer: IComparer_1<TKey>): void;
    static sort6<TKey, TValue>(keys: TKey[], items: TValue[], index: int, length: int): void;
    static sort6<TKey, TValue>(keys: TKey[], items: TValue[]): void;
    static trueForAll<T>(array: T[], match: Predicate_1<T>): boolean;
}


export interface __Array$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_ICloneable(): ICloneable$instance;
}

export interface Array$instance extends System_Collections_Internal.IStructuralComparable$instance, ICloneable$instance {}

export type Array = Array$instance & __Array$views;


export class ArrayTypeMismatchException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ArrayTypeMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArrayTypeMismatchException = ArrayTypeMismatchException$instance & __ArrayTypeMismatchException$views;


export class AssemblyLoadEventArgs$instance extends EventArgs$instance {
    constructor(loadedAssembly: Assembly);
    readonly loadedAssembly: Assembly;
}


export type AssemblyLoadEventArgs = AssemblyLoadEventArgs$instance;

export class AssemblyLoadEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, args: AssemblyLoadEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, args: AssemblyLoadEventArgs): void;
}


export interface __AssemblyLoadEventHandler$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AssemblyLoadEventHandler = AssemblyLoadEventHandler$instance & __AssemblyLoadEventHandler$views;


export class AsyncCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(ar: IAsyncResult, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(ar: IAsyncResult): void;
}


export interface __AsyncCallback$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AsyncCallback = AsyncCallback$instance & __AsyncCallback$views;


export abstract class Attribute$instance {
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    match(obj: unknown): boolean;
    static getCustomAttribute8(element: Assembly, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute8(element: Assembly, attributeType: Type): Attribute;
    static getCustomAttribute8(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute8(element: MemberInfo, attributeType: Type): Attribute;
    static getCustomAttribute8(element: Module, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute8(element: Module, attributeType: Type): Attribute;
    static getCustomAttribute8(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute8(element: ParameterInfo, attributeType: Type): Attribute;
    static getCustomAttributes16(element: Assembly, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: Assembly, attributeType: Type, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: Assembly, attributeType: Type): Attribute[];
    static getCustomAttributes16(element: Assembly): Attribute[];
    static getCustomAttributes16(element: MemberInfo, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: MemberInfo, attributeType: Type): Attribute[];
    static getCustomAttributes16(element: MemberInfo): Attribute[];
    static getCustomAttributes16(element: Module, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: Module, attributeType: Type, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: Module, attributeType: Type): Attribute[];
    static getCustomAttributes16(element: Module): Attribute[];
    static getCustomAttributes16(element: ParameterInfo, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute[];
    static getCustomAttributes16(element: ParameterInfo, attributeType: Type): Attribute[];
    static getCustomAttributes16(element: ParameterInfo): Attribute[];
    static isDefined8(element: Assembly, attributeType: Type, inherit: boolean): boolean;
    static isDefined8(element: Assembly, attributeType: Type): boolean;
    static isDefined8(element: MemberInfo, attributeType: Type, inherit: boolean): boolean;
    static isDefined8(element: MemberInfo, attributeType: Type): boolean;
    static isDefined8(element: Module, attributeType: Type, inherit: boolean): boolean;
    static isDefined8(element: Module, attributeType: Type): boolean;
    static isDefined8(element: ParameterInfo, attributeType: Type, inherit: boolean): boolean;
    static isDefined8(element: ParameterInfo, attributeType: Type): boolean;
}


export type Attribute = Attribute$instance;

export class AttributeUsageAttribute$instance extends Attribute$instance {
    constructor(validOn: AttributeTargets);
    allowMultiple: boolean;
    inherited: boolean;
    readonly validOn: AttributeTargets;
}


export type AttributeUsageAttribute = AttributeUsageAttribute$instance;

export class BadImageFormatException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, fileName: string);
    constructor(message: string, fileName: string, inner: Exception);
    readonly fileName: string;
    readonly fusionLog: string;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __BadImageFormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BadImageFormatException = BadImageFormatException$instance & __BadImageFormatException$views;


export class CannotUnloadAppDomainException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CannotUnloadAppDomainException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CannotUnloadAppDomainException = CannotUnloadAppDomainException$instance & __CannotUnloadAppDomainException$views;


export class CharEnumerator$instance implements IDisposable$instance {
    readonly current: char;
    clone(): unknown;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export interface __CharEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<CLROf<char>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_ICloneable(): ICloneable$instance;
}

export interface CharEnumerator$instance extends ICloneable$instance {}

export type CharEnumerator = CharEnumerator$instance & __CharEnumerator$views;


export class CLSCompliantAttribute$instance extends Attribute$instance {
    constructor(isCompliant: boolean);
    readonly isCompliant: boolean;
}


export type CLSCompliantAttribute = CLSCompliantAttribute$instance;

export class Comparison_1$instance<T> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(x: T, y: T, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(x: T, y: T): int;
}


export interface __Comparison_1$views<T> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Comparison_1<T> = Comparison_1$instance<T> & __Comparison_1$views<T>;


export class ConsoleCancelEventArgs$instance extends EventArgs$instance {
    cancel: boolean;
    readonly specialKey: ConsoleSpecialKey;
}


export type ConsoleCancelEventArgs = ConsoleCancelEventArgs$instance;

export class ConsoleCancelEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: ConsoleCancelEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: ConsoleCancelEventArgs): void;
}


export interface __ConsoleCancelEventHandler$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ConsoleCancelEventHandler = ConsoleCancelEventHandler$instance & __ConsoleCancelEventHandler$views;


export abstract class ContextBoundObject$instance extends MarshalByRefObject$instance {
}


export type ContextBoundObject = ContextBoundObject$instance;

export class ContextMarshalException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ContextMarshalException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ContextMarshalException = ContextMarshalException$instance & __ContextMarshalException$views;


export class ContextStaticAttribute$instance extends Attribute$instance {
    constructor();
}


export type ContextStaticAttribute = ContextStaticAttribute$instance;

export class Converter_2$instance<TInput, TOutput> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(input: TInput, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TOutput;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(input: TInput): TOutput;
}


export interface __Converter_2$views<TInput, TOutput> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Converter_2<TInput, TOutput> = Converter_2$instance<TInput, TOutput> & __Converter_2$views<TInput, TOutput>;


export class CultureAwareComparer$instance extends StringComparer$instance {
    compare(x: string, y: string): int;
    compare(x: unknown, y: unknown): int;
    compare(x: unknown, y: unknown): int;
    equals(x: string, y: string): boolean;
    equals(x: unknown, y: unknown): boolean;
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: string): int;
    getHashCode(obj: unknown): int;
    getHashCode(obj: unknown): int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CultureAwareComparer$views {
    As_IAlternateEqualityComparer_2(): System_Collections_Generic_Internal.IAlternateEqualityComparer_2$instance<ReadOnlySpan_1<CLROf<char>>, CLROf<string>>;
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<CLROf<string>>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<CLROf<string>>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CultureAwareComparer$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CultureAwareComparer = CultureAwareComparer$instance & __CultureAwareComparer$views;


export class DataMisalignedException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DataMisalignedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataMisalignedException = DataMisalignedException$instance & __DataMisalignedException$views;


export class DBNull$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getTypeCode(): TypeCode;
    toString(): string;
    toString(provider: IFormatProvider): string;
    static readonly value: DBNull;
}


export interface __DBNull$views {
    As_IConvertible(): IConvertible$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DBNull$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DBNull = DBNull$instance & __DBNull$views;


export abstract class Delegate$instance {
    readonly hasSingleTarget: boolean;
    readonly method: MethodInfo;
    readonly target: unknown;
    clone(): unknown;
    dynamicInvoke(args: unknown[]): unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getInvocationList(): Function[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static combine(a: Function, b: Function): Function;
    static combine(delegates: Function[]): Function;
    static combine(delegates: ReadOnlySpan_1<Function>): Function;
    static createDelegate4(type_: Type, firstArgument: unknown, method: MethodInfo, throwOnBindFailure: boolean): Function;
    static createDelegate4(type_: Type, firstArgument: unknown, method: MethodInfo): Function;
    static createDelegate4(type_: Type, target: unknown, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): Function;
    static createDelegate4(type_: Type, target: unknown, method: string, ignoreCase: boolean): Function;
    static createDelegate4(type_: Type, target: unknown, method: string): Function;
    static createDelegate4(type_: Type, method: MethodInfo, throwOnBindFailure: boolean): Function;
    static createDelegate4(type_: Type, method: MethodInfo): Function;
    static createDelegate4(type_: Type, target: Type, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): Function;
    static createDelegate4(type_: Type, target: Type, method: string, ignoreCase: boolean): Function;
    static createDelegate4(type_: Type, target: Type, method: string): Function;
    static enumerateInvocationList<TDelegate extends Function>(d: TDelegate): Delegate_InvocationListEnumerator_1<TDelegate>;
    static remove(source: Function, value: Function): Function;
    static removeAll(source: Function, value: Function): Function;
}


export interface __Delegate$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Delegate$instance extends ICloneable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Delegate = Delegate$instance & __Delegate$views;


export class DivideByZeroException$instance extends ArithmeticException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DivideByZeroException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DivideByZeroException = DivideByZeroException$instance & __DivideByZeroException$views;


export class DllNotFoundException$instance extends TypeLoadException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DllNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DllNotFoundException = DllNotFoundException$instance & __DllNotFoundException$views;


export class DuplicateWaitObjectException$instance extends ArgumentException$instance {
    constructor();
    constructor(parameterName: string);
    constructor(parameterName: string, message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DuplicateWaitObjectException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DuplicateWaitObjectException = DuplicateWaitObjectException$instance & __DuplicateWaitObjectException$views;


export class EntryPointNotFoundException$instance extends TypeLoadException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __EntryPointNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EntryPointNotFoundException = EntryPointNotFoundException$instance & __EntryPointNotFoundException$views;


export abstract class Enum$instance {
    compareTo(target: unknown): int;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getTypeCode(): TypeCode;
    hasFlag(flag: number): boolean;
    toString(): string;
    toString(format: string): string;
    toString(provider: IFormatProvider): string;
    toString(format: string, provider: IFormatProvider): string;
    static format(enumType: Type, value: unknown, format: string): string;
    static getName2(enumType: Type, value: unknown): string;
    static getName2<TEnum extends number>(value: TEnum): string;
    static getNames<TEnum extends number>(): string[];
    static getNames(enumType: Type): string[];
    static getUnderlyingType(enumType: Type): Type;
    static getValues<TEnum extends number>(): TEnum[];
    static getValues(enumType: Type): Array;
    static getValuesAsUnderlyingType<TEnum extends number>(): Array;
    static getValuesAsUnderlyingType(enumType: Type): Array;
    static isDefined2(enumType: Type, value: unknown): boolean;
    static isDefined2<TEnum extends number>(value: TEnum): boolean;
    static parse8<TEnum extends unknown>(value: ReadOnlySpan_1<CLROf<char>>, ignoreCase: boolean): TEnum;
    static parse8<TEnum extends unknown>(value: ReadOnlySpan_1<CLROf<char>>): TEnum;
    static parse8<TEnum extends unknown>(value: string, ignoreCase: boolean): TEnum;
    static parse8<TEnum extends unknown>(value: string): TEnum;
    static parse8(enumType: Type, value: ReadOnlySpan_1<CLROf<char>>, ignoreCase: boolean): unknown;
    static parse8(enumType: Type, value: ReadOnlySpan_1<CLROf<char>>): unknown;
    static parse8(enumType: Type, value: string, ignoreCase: boolean): unknown;
    static parse8(enumType: Type, value: string): unknown;
    static toObject5(enumType: Type, value: byte): unknown;
    static toObject5(enumType: Type, value: short): unknown;
    static toObject5(enumType: Type, value: int): unknown;
    static toObject5(enumType: Type, value: long): unknown;
    static toObject5(enumType: Type, value: unknown): unknown;
    static toObject5(enumType: Type, value: sbyte): unknown;
    static toObject5(enumType: Type, value: ushort): unknown;
    static toObject5(enumType: Type, value: uint): unknown;
    static toObject5(enumType: Type, value: ulong): unknown;
    static tryFormat<TEnum extends unknown>(value: TEnum, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, format?: ReadOnlySpan_1<CLROf<char>>): boolean;
    static tryParse8<TEnum extends unknown>(value: ReadOnlySpan_1<CLROf<char>>, ignoreCase: boolean, result: { value: ref<TEnum> }): boolean;
    static tryParse8<TEnum extends unknown>(value: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<TEnum> }): boolean;
    static tryParse8<TEnum extends unknown>(value: string, ignoreCase: boolean, result: { value: ref<TEnum> }): boolean;
    static tryParse8<TEnum extends unknown>(value: string, result: { value: ref<TEnum> }): boolean;
    static tryParse8(enumType: Type, value: ReadOnlySpan_1<CLROf<char>>, ignoreCase: boolean, result: { value: ref<unknown> }): boolean;
    static tryParse8(enumType: Type, value: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<unknown> }): boolean;
    static tryParse8(enumType: Type, value: string, ignoreCase: boolean, result: { value: ref<unknown> }): boolean;
    static tryParse8(enumType: Type, value: string, result: { value: ref<unknown> }): boolean;
}


export interface __Enum$views {
    As_IComparable(): IComparable$instance;
    As_IConvertible(): IConvertible$instance;
    As_IFormattable(): IFormattable$instance;
    As_ISpanFormattable(): ISpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Enum$instance extends IComparable$instance {}

export type Enum = Enum$instance & __Enum$views;


export class EventArgs$instance {
    constructor();
    static readonly empty: EventArgs;
}


export type EventArgs = EventArgs$instance;

export class EventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: EventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: EventArgs): void;
}


export interface __EventHandler$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventHandler = EventHandler$instance & __EventHandler$views;


export class EventHandler_1$instance<TEventArgs> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: TEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: TEventArgs): void;
}


export interface __EventHandler_1$views<TEventArgs> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventHandler_1<TEventArgs> = EventHandler_1$instance<TEventArgs> & __EventHandler_1$views<TEventArgs>;


export class EventHandler_2$instance<TSender, TEventArgs> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: TSender, e: TEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: TSender, e: TEventArgs): void;
}


export interface __EventHandler_2$views<TSender, TEventArgs> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventHandler_2<TSender, TEventArgs> = EventHandler_2$instance<TSender, TEventArgs> & __EventHandler_2$views<TSender, TEventArgs>;


export class Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly data: IDictionary;
    helpLink: string;
    hResult: int;
    readonly innerException: Exception;
    readonly message: string;
    source: string;
    readonly stackTrace: string;
    readonly targetSite: MethodBase;
    getBaseException(): Exception;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getType(): Type;
    toString(): string;
}


export interface __Exception$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Exception$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Exception = Exception$instance & __Exception$views;


export class ExecutionEngineException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ExecutionEngineException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExecutionEngineException = ExecutionEngineException$instance & __ExecutionEngineException$views;


export class FieldAccessException$instance extends MemberAccessException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __FieldAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FieldAccessException = FieldAccessException$instance & __FieldAccessException$views;


export class FileStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type FileStyleUriParser = FileStyleUriParser$instance;

export class FlagsAttribute$instance extends Attribute$instance {
    constructor();
}


export type FlagsAttribute = FlagsAttribute$instance;

export class FormatException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __FormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FormatException = FormatException$instance & __FormatException$views;


export abstract class FormattableString$instance {
    readonly argumentCount: int;
    readonly format: string;
    abstract getArgument(index: int): unknown;
    abstract getArguments(): unknown[];
    toString(formatProvider: IFormatProvider): string;
    toString(): string;
    static currentCulture(formattable: FormattableString): string;
    static invariant(formattable: FormattableString): string;
}


export interface __FormattableString$views {
    As_IFormattable(): IFormattable$instance;
}

export type FormattableString = FormattableString$instance & __FormattableString$views;


export class FtpStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type FtpStyleUriParser = FtpStyleUriParser$instance;

export class Func_1$instance<TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(): TResult;
}


export interface __Func_1$views<TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_1<TResult> = Func_1$instance<TResult> & __Func_1$views<TResult>;


export class Func_10$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9): TResult;
}


export interface __Func_10$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> = Func_10$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> & __Func_10$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>;


export class Func_11$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10): TResult;
}


export interface __Func_11$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> = Func_11$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> & __Func_11$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>;


export class Func_12$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11): TResult;
}


export interface __Func_12$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> = Func_12$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> & __Func_12$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>;


export class Func_13$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12): TResult;
}


export interface __Func_13$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> = Func_13$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> & __Func_13$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>;


export class Func_14$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13): TResult;
}


export interface __Func_14$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> = Func_14$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> & __Func_14$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>;


export class Func_15$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14): TResult;
}


export interface __Func_15$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> = Func_15$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> & __Func_15$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>;


export class Func_16$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15): TResult;
}


export interface __Func_16$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> = Func_16$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> & __Func_16$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>;


export class Func_17$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16): TResult;
}


export interface __Func_17$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> = Func_17$instance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> & __Func_17$views<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>;


export class Func_2$instance<T, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg: T, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg: T): TResult;
}


export interface __Func_2$views<T, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_2<T, TResult> = Func_2$instance<T, TResult> & __Func_2$views<T, TResult>;


export class Func_3$instance<T1, T2, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2): TResult;
}


export interface __Func_3$views<T1, T2, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_3<T1, T2, TResult> = Func_3$instance<T1, T2, TResult> & __Func_3$views<T1, T2, TResult>;


export class Func_4$instance<T1, T2, T3, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3): TResult;
}


export interface __Func_4$views<T1, T2, T3, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_4<T1, T2, T3, TResult> = Func_4$instance<T1, T2, T3, TResult> & __Func_4$views<T1, T2, T3, TResult>;


export class Func_5$instance<T1, T2, T3, T4, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4): TResult;
}


export interface __Func_5$views<T1, T2, T3, T4, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_5<T1, T2, T3, T4, TResult> = Func_5$instance<T1, T2, T3, T4, TResult> & __Func_5$views<T1, T2, T3, T4, TResult>;


export class Func_6$instance<T1, T2, T3, T4, T5, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): TResult;
}


export interface __Func_6$views<T1, T2, T3, T4, T5, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_6<T1, T2, T3, T4, T5, TResult> = Func_6$instance<T1, T2, T3, T4, T5, TResult> & __Func_6$views<T1, T2, T3, T4, T5, TResult>;


export class Func_7$instance<T1, T2, T3, T4, T5, T6, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6): TResult;
}


export interface __Func_7$views<T1, T2, T3, T4, T5, T6, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_7<T1, T2, T3, T4, T5, T6, TResult> = Func_7$instance<T1, T2, T3, T4, T5, T6, TResult> & __Func_7$views<T1, T2, T3, T4, T5, T6, TResult>;


export class Func_8$instance<T1, T2, T3, T4, T5, T6, T7, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7): TResult;
}


export interface __Func_8$views<T1, T2, T3, T4, T5, T6, T7, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_8<T1, T2, T3, T4, T5, T6, T7, TResult> = Func_8$instance<T1, T2, T3, T4, T5, T6, T7, TResult> & __Func_8$views<T1, T2, T3, T4, T5, T6, T7, TResult>;


export class Func_9$instance<T1, T2, T3, T4, T5, T6, T7, T8, TResult> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): TResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8): TResult;
}


export interface __Func_9$views<T1, T2, T3, T4, T5, T6, T7, T8, TResult> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Func_9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> = Func_9$instance<T1, T2, T3, T4, T5, T6, T7, T8, TResult> & __Func_9$views<T1, T2, T3, T4, T5, T6, T7, T8, TResult>;


export class GenericUriParser$instance extends UriParser$instance {
    constructor(options: GenericUriParserOptions);
}


export type GenericUriParser = GenericUriParser$instance;

export class GopherStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type GopherStyleUriParser = GopherStyleUriParser$instance;

export class HttpStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type HttpStyleUriParser = HttpStyleUriParser$instance;

export class IndexOutOfRangeException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __IndexOutOfRangeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IndexOutOfRangeException = IndexOutOfRangeException$instance & __IndexOutOfRangeException$views;


export class InsufficientExecutionStackException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InsufficientExecutionStackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InsufficientExecutionStackException = InsufficientExecutionStackException$instance & __InsufficientExecutionStackException$views;


export class InsufficientMemoryException$instance extends OutOfMemoryException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InsufficientMemoryException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InsufficientMemoryException = InsufficientMemoryException$instance & __InsufficientMemoryException$views;


export class InvalidCastException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, errorCode: int);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidCastException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidCastException = InvalidCastException$instance & __InvalidCastException$views;


export class InvalidOperationException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidOperationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidOperationException = InvalidOperationException$instance & __InvalidOperationException$views;


export class InvalidProgramException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidProgramException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidProgramException = InvalidProgramException$instance & __InvalidProgramException$views;


export class InvalidTimeZoneException$instance extends Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidTimeZoneException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidTimeZoneException = InvalidTimeZoneException$instance & __InvalidTimeZoneException$views;


export class Lazy_1$instance<T> {
    constructor();
    constructor(value: T);
    constructor(valueFactory: Func_1<T>);
    constructor(isThreadSafe: boolean);
    constructor(mode: LazyThreadSafetyMode);
    constructor(valueFactory: Func_1<T>, isThreadSafe: boolean);
    constructor(valueFactory: Func_1<T>, mode: LazyThreadSafetyMode);
    readonly isValueCreated: boolean;
    readonly value: T;
    toString(): string;
}


export type Lazy_1<T> = Lazy_1$instance<T>;

export class Lazy_2$instance<T, TMetadata> extends Lazy_1$instance<T> {
    constructor(valueFactory: Func_1<T>, metadata: TMetadata);
    constructor(metadata: TMetadata);
    constructor(metadata: TMetadata, isThreadSafe: boolean);
    constructor(valueFactory: Func_1<T>, metadata: TMetadata, isThreadSafe: boolean);
    constructor(metadata: TMetadata, mode: LazyThreadSafetyMode);
    constructor(valueFactory: Func_1<T>, metadata: TMetadata, mode: LazyThreadSafetyMode);
    readonly metadata: TMetadata;
}


export type Lazy_2<T, TMetadata> = Lazy_2$instance<T, TMetadata>;

export class LdapStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type LdapStyleUriParser = LdapStyleUriParser$instance;

export class LoaderOptimizationAttribute$instance extends Attribute$instance {
    constructor(value: byte);
    constructor(value: LoaderOptimization);
    readonly value: LoaderOptimization;
}


export type LoaderOptimizationAttribute = LoaderOptimizationAttribute$instance;

export class LocalDataStoreSlot$instance {
}


export type LocalDataStoreSlot = LocalDataStoreSlot$instance;

export abstract class MarshalByRefObject$instance {
    getLifetimeService(): unknown;
    initializeLifetimeService(): unknown;
}


export type MarshalByRefObject = MarshalByRefObject$instance;

export class MemberAccessException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MemberAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MemberAccessException = MemberAccessException$instance & __MemberAccessException$views;


export class MethodAccessException$instance extends MemberAccessException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MethodAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MethodAccessException = MethodAccessException$instance & __MethodAccessException$views;


export class MissingFieldException$instance extends MissingMemberException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(className: string, fieldName: string);
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MissingFieldException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingFieldException = MissingFieldException$instance & __MissingFieldException$views;


export class MissingMemberException$instance extends MemberAccessException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(className: string, memberName: string);
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MissingMemberException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingMemberException = MissingMemberException$instance & __MissingMemberException$views;


export class MissingMethodException$instance extends MissingMemberException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(className: string, methodName: string);
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MissingMethodException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingMethodException = MissingMethodException$instance & __MissingMethodException$views;


export class MTAThreadAttribute$instance extends Attribute$instance {
    constructor();
}


export type MTAThreadAttribute = MTAThreadAttribute$instance;

export abstract class MulticastDelegate$instance extends Function {
    clone(): unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getInvocationList(): Function[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MulticastDelegate$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MulticastDelegate = MulticastDelegate$instance & __MulticastDelegate$views;


export class MulticastNotSupportedException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __MulticastNotSupportedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MulticastNotSupportedException = MulticastNotSupportedException$instance & __MulticastNotSupportedException$views;


export class NetPipeStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type NetPipeStyleUriParser = NetPipeStyleUriParser$instance;

export class NetTcpStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type NetTcpStyleUriParser = NetTcpStyleUriParser$instance;

export class NewsStyleUriParser$instance extends UriParser$instance {
    constructor();
}


export type NewsStyleUriParser = NewsStyleUriParser$instance;

export class NonSerializedAttribute$instance extends Attribute$instance {
    constructor();
}


export type NonSerializedAttribute = NonSerializedAttribute$instance;

export class NotFiniteNumberException$instance extends ArithmeticException$instance {
    constructor();
    constructor(offendingNumber: double);
    constructor(message: string);
    constructor(message: string, offendingNumber: double);
    constructor(message: string, innerException: Exception);
    constructor(message: string, offendingNumber: double, innerException: Exception);
    readonly offendingNumber: double;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NotFiniteNumberException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NotFiniteNumberException = NotFiniteNumberException$instance & __NotFiniteNumberException$views;


export class NotImplementedException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NotImplementedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NotImplementedException = NotImplementedException$instance & __NotImplementedException$views;


export class NotSupportedException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NotSupportedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NotSupportedException = NotSupportedException$instance & __NotSupportedException$views;


export class NullReferenceException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NullReferenceException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NullReferenceException = NullReferenceException$instance & __NullReferenceException$views;


export class Object$instance {
    constructor();
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getType(): Type;
    toString(): string;
    static equals(objA: unknown, objB: unknown): boolean;
    static referenceEquals(objA: unknown, objB: unknown): boolean;
}


export type Object = Object$instance;

export class ObjectDisposedException$instance extends InvalidOperationException$instance {
    constructor(objectName: string);
    constructor(objectName: string, message: string);
    constructor(message: string, innerException: Exception);
    readonly message: string;
    readonly objectName: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static throwIf(condition: boolean, instance: unknown): void;
    static throwIf(condition: boolean, type_: Type): void;
}


export interface __ObjectDisposedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ObjectDisposedException = ObjectDisposedException$instance & __ObjectDisposedException$views;


export class ObsoleteAttribute$instance extends Attribute$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, error: boolean);
    diagnosticId: string;
    readonly isError: boolean;
    readonly message: string;
    urlFormat: string;
}


export type ObsoleteAttribute = ObsoleteAttribute$instance;

export class OperatingSystem$instance {
    constructor(platform: PlatformID, version: Version);
    readonly platform: PlatformID;
    readonly servicePack: string;
    readonly version: Version;
    readonly versionString: string;
    clone(): unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
    static isAndroid(): boolean;
    static isAndroidVersionAtLeast(major: int, minor?: int, build?: int, revision?: int): boolean;
    static isBrowser(): boolean;
    static isFreeBSD(): boolean;
    static isFreeBSDVersionAtLeast(major: int, minor?: int, build?: int, revision?: int): boolean;
    static isIOS(): boolean;
    static isIOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    static isLinux(): boolean;
    static isMacCatalyst(): boolean;
    static isMacCatalystVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    static isMacOS(): boolean;
    static isMacOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    static isOSPlatform(platform: string): boolean;
    static isOSPlatformVersionAtLeast(platform: string, major: int, minor?: int, build?: int, revision?: int): boolean;
    static isTvOS(): boolean;
    static isTvOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    static isWasi(): boolean;
    static isWatchOS(): boolean;
    static isWatchOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    static isWindows(): boolean;
    static isWindowsVersionAtLeast(major: int, minor?: int, build?: int, revision?: int): boolean;
}


export interface __OperatingSystem$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface OperatingSystem$instance extends ICloneable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type OperatingSystem = OperatingSystem$instance & __OperatingSystem$views;


export class OperationCanceledException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(token: CancellationToken);
    constructor(message: string, token: CancellationToken);
    constructor(message: string, innerException: Exception, token: CancellationToken);
    readonly cancellationToken: CancellationToken;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __OperationCanceledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OperationCanceledException = OperationCanceledException$instance & __OperationCanceledException$views;


export class OrdinalComparer$instance extends StringComparer$instance {
    compare(x: string, y: string): int;
    compare(x: unknown, y: unknown): int;
    compare(x: unknown, y: unknown): int;
    equals(x: string, y: string): boolean;
    equals(x: unknown, y: unknown): boolean;
    equals(x: unknown, y: unknown): boolean;
    getHashCode(obj: string): int;
    getHashCode(obj: unknown): int;
    getHashCode(obj: unknown): int;
}


export interface __OrdinalComparer$views {
    As_IAlternateEqualityComparer_2(): System_Collections_Generic_Internal.IAlternateEqualityComparer_2$instance<ReadOnlySpan_1<CLROf<char>>, CLROf<string>>;
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<CLROf<string>>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<CLROf<string>>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type OrdinalComparer = OrdinalComparer$instance & __OrdinalComparer$views;


export class OutOfMemoryException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __OutOfMemoryException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OutOfMemoryException = OutOfMemoryException$instance & __OutOfMemoryException$views;


export class OverflowException$instance extends ArithmeticException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __OverflowException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OverflowException = OverflowException$instance & __OverflowException$views;


export class ParamArrayAttribute$instance extends Attribute$instance {
    constructor();
}


export type ParamArrayAttribute = ParamArrayAttribute$instance;

export class PlatformNotSupportedException$instance extends NotSupportedException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __PlatformNotSupportedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PlatformNotSupportedException = PlatformNotSupportedException$instance & __PlatformNotSupportedException$views;


export class Predicate_1$instance<T> extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(obj: T, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): boolean;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(obj: T): boolean;
}


export interface __Predicate_1$views<T> {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Predicate_1<T> = Predicate_1$instance<T> & __Predicate_1$views<T>;


export class Progress_1$instance<T> {
    constructor();
    constructor(handler: Action_1<T>);
}


export interface __Progress_1$views<T> {
    As_IProgress_1(): IProgress_1$instance<T>;
}

export interface Progress_1$instance<T> extends IProgress_1$instance<T> {}

export type Progress_1<T> = Progress_1$instance<T> & __Progress_1$views<T>;


export class Random$instance {
    constructor();
    constructor(Seed: int);
    getHexString(stringLength: int, lowercase?: boolean): string;
    getHexString(destination: Span_1<CLROf<char>>, lowercase?: boolean): void;
    getItems<T>(choices: ReadOnlySpan_1<T>, destination: Span_1<T>): void;
    getItems<T>(choices: T[], length: int): T[];
    getItems<T>(choices: ReadOnlySpan_1<T>, length: int): T[];
    getString(choices: ReadOnlySpan_1<CLROf<char>>, length: int): string;
    next(): int;
    next(maxValue: int): int;
    next(minValue: int, maxValue: int): int;
    nextBytes(buffer: byte[]): void;
    nextBytes(buffer: Span_1<CLROf<byte>>): void;
    nextDouble(): double;
    nextInt64(): long;
    nextInt64(maxValue: long): long;
    nextInt64(minValue: long, maxValue: long): long;
    nextSingle(): float;
    shuffle<T>(values: T[]): void;
    shuffle<T>(values: Span_1<T>): void;
    static readonly shared: Random;
}


export type Random = Random$instance;

export class RankException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __RankException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RankException = RankException$instance & __RankException$views;


export class ResolveEventArgs$instance extends EventArgs$instance {
    constructor(name: string);
    constructor(name: string, requestingAssembly: Assembly);
    readonly name: string;
    readonly requestingAssembly: Assembly;
}


export type ResolveEventArgs = ResolveEventArgs$instance;

export class ResolveEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, args: ResolveEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): Assembly;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, args: ResolveEventArgs): Assembly;
}


export interface __ResolveEventHandler$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ResolveEventHandler = ResolveEventHandler$instance & __ResolveEventHandler$views;


export class SerializableAttribute$instance extends Attribute$instance {
    constructor();
}


export type SerializableAttribute = SerializableAttribute$instance;

export class StackOverflowException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __StackOverflowException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StackOverflowException = StackOverflowException$instance & __StackOverflowException$views;


export class STAThreadAttribute$instance extends Attribute$instance {
    constructor();
}


export type STAThreadAttribute = STAThreadAttribute$instance;

export class String$instance {
    constructor(value: char[]);
    constructor(value: char[], startIndex: int, length: int);
    constructor(value: ptr<char>);
    constructor(value: ptr<char>, startIndex: int, length: int);
    constructor(value: ptr<sbyte>);
    constructor(value: ptr<sbyte>, startIndex: int, length: int);
    constructor(value: ptr<sbyte>, startIndex: int, length: int, enc: Encoding);
    constructor(c: char, count: int);
    constructor(value: ReadOnlySpan_1<CLROf<char>>);
    readonly chars: char;
    readonly length: int;
    clone(): unknown;
    compareTo(value: unknown): int;
    compareTo(strB: string): int;
    contains(value: string): boolean;
    contains(value: string, comparisonType: StringComparison): boolean;
    contains(value: char): boolean;
    contains(value: char, comparisonType: StringComparison): boolean;
    copyTo(sourceIndex: int, destination: char[], destinationIndex: int, count: int): void;
    copyTo(destination: Span_1<CLROf<char>>): void;
    endsWith(value: string): boolean;
    endsWith(value: string, comparisonType: StringComparison): boolean;
    endsWith(value: string, ignoreCase: boolean, culture: CultureInfo): boolean;
    endsWith(value: char): boolean;
    enumerateRunes(): StringRuneEnumerator;
    equals(obj: unknown): boolean;
    equals(value: string): boolean;
    equals(value: string, comparisonType: StringComparison): boolean;
    getEnumerator(): CharEnumerator;
    getHashCode(): int;
    getHashCode(comparisonType: StringComparison): int;
    getPinnableReference(): ref<char>;
    getTypeCode(): TypeCode;
    indexOf(value: char): int;
    indexOf(value: char, startIndex: int): int;
    indexOf(value: char, comparisonType: StringComparison): int;
    indexOf(value: char, startIndex: int, count: int): int;
    indexOf(value: string): int;
    indexOf(value: string, startIndex: int): int;
    indexOf(value: string, startIndex: int, count: int): int;
    indexOf(value: string, comparisonType: StringComparison): int;
    indexOf(value: string, startIndex: int, comparisonType: StringComparison): int;
    indexOf(value: string, startIndex: int, count: int, comparisonType: StringComparison): int;
    indexOfAny(anyOf: char[]): int;
    indexOfAny(anyOf: char[], startIndex: int): int;
    indexOfAny(anyOf: char[], startIndex: int, count: int): int;
    insert(startIndex: int, value: string): string;
    isNormalized(): boolean;
    isNormalized(normalizationForm: NormalizationForm): boolean;
    lastIndexOf(value: char): int;
    lastIndexOf(value: char, startIndex: int): int;
    lastIndexOf(value: char, startIndex: int, count: int): int;
    lastIndexOf(value: string): int;
    lastIndexOf(value: string, startIndex: int): int;
    lastIndexOf(value: string, startIndex: int, count: int): int;
    lastIndexOf(value: string, comparisonType: StringComparison): int;
    lastIndexOf(value: string, startIndex: int, comparisonType: StringComparison): int;
    lastIndexOf(value: string, startIndex: int, count: int, comparisonType: StringComparison): int;
    lastIndexOfAny(anyOf: char[]): int;
    lastIndexOfAny(anyOf: char[], startIndex: int): int;
    lastIndexOfAny(anyOf: char[], startIndex: int, count: int): int;
    normalize(): string;
    normalize(normalizationForm: NormalizationForm): string;
    padLeft(totalWidth: int): string;
    padLeft(totalWidth: int, paddingChar: char): string;
    padRight(totalWidth: int): string;
    padRight(totalWidth: int, paddingChar: char): string;
    remove(startIndex: int, count: int): string;
    remove(startIndex: int): string;
    replace(oldValue: string, newValue: string, ignoreCase: boolean, culture: CultureInfo): string;
    replace(oldValue: string, newValue: string, comparisonType: StringComparison): string;
    replace(oldChar: char, newChar: char): string;
    replace(oldValue: string, newValue: string): string;
    replaceLineEndings(): string;
    replaceLineEndings(replacementText: string): string;
    split(separator: char, options?: StringSplitOptions): string[];
    split(separator: char, count: int, options?: StringSplitOptions): string[];
    split(separator: char[]): string[];
    split(separator: ReadOnlySpan_1<CLROf<char>>): string[];
    split(separator: char[], count: int): string[];
    split(separator: char[], options: StringSplitOptions): string[];
    split(separator: char[], count: int, options: StringSplitOptions): string[];
    split(separator: string, options?: StringSplitOptions): string[];
    split(separator: string, count: int, options?: StringSplitOptions): string[];
    split(separator: string[], options: StringSplitOptions): string[];
    split(separator: string[], count: int, options: StringSplitOptions): string[];
    startsWith(value: string): boolean;
    startsWith(value: string, comparisonType: StringComparison): boolean;
    startsWith(value: string, ignoreCase: boolean, culture: CultureInfo): boolean;
    startsWith(value: char): boolean;
    substring(startIndex: int): string;
    substring(startIndex: int, length: int): string;
    toCharArray(): char[];
    toCharArray(startIndex: int, length: int): char[];
    toLower(): string;
    toLower(culture: CultureInfo): string;
    toLowerInvariant(): string;
    toString(): string;
    toString(provider: IFormatProvider): string;
    toUpper(): string;
    toUpper(culture: CultureInfo): string;
    toUpperInvariant(): string;
    trim(): string;
    trim(trimChar: char): string;
    trim(trimChars: char[]): string;
    trim(trimChars: ReadOnlySpan_1<CLROf<char>>): string;
    trimEnd(): string;
    trimEnd(trimChar: char): string;
    trimEnd(trimChars: char[]): string;
    trimEnd(trimChars: ReadOnlySpan_1<CLROf<char>>): string;
    trimStart(): string;
    trimStart(trimChar: char): string;
    trimStart(trimChars: char[]): string;
    trimStart(trimChars: ReadOnlySpan_1<CLROf<char>>): string;
    tryCopyTo(destination: Span_1<CLROf<char>>): boolean;
    static readonly empty: string;
    static compare8(strA: string, indexA: int, strB: string, indexB: int, length: int, ignoreCase: boolean, culture: CultureInfo): int;
    static compare8(strA: string, indexA: int, strB: string, indexB: int, length: int, ignoreCase: boolean): int;
    static compare8(strA: string, indexA: int, strB: string, indexB: int, length: int, culture: CultureInfo, options: CompareOptions): int;
    static compare8(strA: string, indexA: int, strB: string, indexB: int, length: int, comparisonType: StringComparison): int;
    static compare8(strA: string, indexA: int, strB: string, indexB: int, length: int): int;
    static compare8(strA: string, strB: string, ignoreCase: boolean, culture: CultureInfo): int;
    static compare8(strA: string, strB: string, ignoreCase: boolean): int;
    static compare8(strA: string, strB: string, culture: CultureInfo, options: CompareOptions): int;
    static compare8(strA: string, strB: string, comparisonType: StringComparison): int;
    static compare8(strA: string, strB: string): int;
    static compareOrdinal2(strA: string, indexA: int, strB: string, indexB: int, length: int): int;
    static compareOrdinal2(strA: string, strB: string): int;
    static concat6<T>(values: IEnumerable_1<T>): string;
    static concat6(values: IEnumerable_1<CLROf<string>>): string;
    static concat6(arg0: unknown, arg1: unknown, arg2: unknown): string;
    static concat6(arg0: unknown, arg1: unknown): string;
    static concat6(arg0: unknown): string;
    static concat6(args: unknown[]): string;
    static concat6(str0: ReadOnlySpan_1<CLROf<char>>, str1: ReadOnlySpan_1<CLROf<char>>, str2: ReadOnlySpan_1<CLROf<char>>, str3: ReadOnlySpan_1<CLROf<char>>): string;
    static concat6(str0: ReadOnlySpan_1<CLROf<char>>, str1: ReadOnlySpan_1<CLROf<char>>, str2: ReadOnlySpan_1<CLROf<char>>): string;
    static concat6(str0: ReadOnlySpan_1<CLROf<char>>, str1: ReadOnlySpan_1<CLROf<char>>): string;
    static concat6(args: ReadOnlySpan_1<unknown>): string;
    static concat6(values: ReadOnlySpan_1<CLROf<string>>): string;
    static concat6(str0: string, str1: string, str2: string, str3: string): string;
    static concat6(str0: string, str1: string, str2: string): string;
    static concat6(str0: string, str1: string): string;
    static concat6(values: string[]): string;
    static copy(str: string): string;
    static create2(provider: IFormatProvider, handler: { value: ref<DefaultInterpolatedStringHandler> }): string;
    static create2(provider: IFormatProvider, initialBuffer: Span_1<CLROf<char>>, handler: { value: ref<DefaultInterpolatedStringHandler> }): string;
    static create2<TState>(length: int, state: TState, action: SpanAction_2<CLROf<char>, TState>): string;
    static equals2(a: string, b: string, comparisonType: StringComparison): boolean;
    static equals2(a: string, b: string): boolean;
    static format8(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown, arg2: unknown): string;
    static format8(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown): string;
    static format8(provider: IFormatProvider, format: string, arg0: unknown): string;
    static format8(provider: IFormatProvider, format: string, args: unknown[]): string;
    static format8(provider: IFormatProvider, format: string, args: ReadOnlySpan_1<unknown>): string;
    static format8(provider: IFormatProvider, format: CompositeFormat, args: unknown[]): string;
    static format8(provider: IFormatProvider, format: CompositeFormat, args: ReadOnlySpan_1<unknown>): string;
    static format8<TArg0, TArg1, TArg2>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): string;
    static format8<TArg0, TArg1>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1): string;
    static format8<TArg0>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0): string;
    static format8(format: string, arg0: unknown, arg1: unknown, arg2: unknown): string;
    static format8(format: string, arg0: unknown, arg1: unknown): string;
    static format8(format: string, arg0: unknown): string;
    static format8(format: string, args: unknown[]): string;
    static format8(format: string, args: ReadOnlySpan_1<unknown>): string;
    static getHashCode2(value: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): int;
    static getHashCode2(value: ReadOnlySpan_1<CLROf<char>>): int;
    static intern(str: string): string;
    static isInterned(str: string): string;
    static isNullOrEmpty(value: string): boolean;
    static isNullOrWhiteSpace(value: string): boolean;
    static join12<T>(separator: char, values: IEnumerable_1<T>): string;
    static join12(separator: char, values: unknown[]): string;
    static join12(separator: char, values: ReadOnlySpan_1<unknown>): string;
    static join12(separator: char, value: ReadOnlySpan_1<CLROf<string>>): string;
    static join12(separator: char, value: string[], startIndex: int, count: int): string;
    static join12(separator: char, value: string[]): string;
    static join12<T>(separator: string, values: IEnumerable_1<T>): string;
    static join12(separator: string, values: IEnumerable_1<CLROf<string>>): string;
    static join12(separator: string, values: unknown[]): string;
    static join12(separator: string, values: ReadOnlySpan_1<unknown>): string;
    static join12(separator: string, value: ReadOnlySpan_1<CLROf<string>>): string;
    static join12(separator: string, value: string[], startIndex: int, count: int): string;
    static join12(separator: string, value: string[]): string;
}


export interface __String$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CLROf<char>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): ICloneable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<CLROf<string>>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<CLROf<string>>;
    As_IParsable_1(): IParsable_1$instance<CLROf<string>>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<CLROf<string>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: String): boolean;
    CompareTo(obj: unknown): int;
}

export interface String$instance extends ICloneable$instance, IComparable$instance, ISpanParsable_1$instance<CLROf<string>> {}

export type String = String$instance & __String$views;


export abstract class StringComparer$instance {
    compare(x: unknown, y: unknown): int;
    compare(x: string, y: string): int;
    equals(x: unknown, y: unknown): boolean;
    equals(x: string, y: string): boolean;
    getHashCode(obj: unknown): int;
    getHashCode(obj: string): int;
    static readonly invariantCulture: StringComparer;
    static readonly invariantCultureIgnoreCase: StringComparer;
    static readonly currentCulture: StringComparer;
    static readonly currentCultureIgnoreCase: StringComparer;
    static readonly ordinal: StringComparer;
    static readonly ordinalIgnoreCase: StringComparer;
    static create(culture: CultureInfo, ignoreCase: boolean): StringComparer;
    static create(culture: CultureInfo, options: CompareOptions): StringComparer;
    static fromComparison(comparisonType: StringComparison): StringComparer;
    static isWellKnownCultureAwareComparer(comparer: IEqualityComparer_1<CLROf<string>>, compareInfo: { value: ref<CompareInfo> }, compareOptions: { value: ref<CompareOptions> }): boolean;
    static isWellKnownOrdinalComparer(comparer: IEqualityComparer_1<CLROf<string>>, ignoreCase: { value: ref<boolean> }): boolean;
}


export interface __StringComparer$views {
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<CLROf<string>>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<CLROf<string>>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export interface StringComparer$instance extends System_Collections_Internal.IComparer$instance {}

export type StringComparer = StringComparer$instance & __StringComparer$views;


export class SystemException$instance extends Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SystemException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SystemException = SystemException$instance & __SystemException$views;


export class ThreadStaticAttribute$instance extends Attribute$instance {
    constructor();
}


export type ThreadStaticAttribute = ThreadStaticAttribute$instance;

export class TimeoutException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TimeoutException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TimeoutException = TimeoutException$instance & __TimeoutException$views;


export abstract class TimeProvider$instance {
    readonly localTimeZone: TimeZoneInfo;
    readonly timestampFrequency: long;
    createTimer(callback: TimerCallback, state: unknown, dueTime: TimeSpan, period: TimeSpan): ITimer;
    getElapsedTime(startingTimestamp: long, endingTimestamp: long): TimeSpan;
    getElapsedTime(startingTimestamp: long): TimeSpan;
    getLocalNow(): DateTimeOffset;
    getTimestamp(): long;
    getUtcNow(): DateTimeOffset;
    static readonly system: TimeProvider;
}


export type TimeProvider = TimeProvider$instance;

export abstract class TimeZone$instance {
    readonly daylightName: string;
    readonly standardName: string;
    abstract getDaylightChanges(year: int): DaylightTime;
    abstract getUtcOffset(time: DateTime): TimeSpan;
    isDaylightSavingTime(time: DateTime): boolean;
    toLocalTime(time: DateTime): DateTime;
    toUniversalTime(time: DateTime): DateTime;
    static readonly currentTimeZone: TimeZone;
    static isDaylightSavingTime(time: DateTime, daylightTimes: DaylightTime): boolean;
}


export type TimeZone = TimeZone$instance;

export class TimeZoneInfo$instance {
    readonly baseUtcOffset: TimeSpan;
    readonly daylightName: string;
    readonly displayName: string;
    readonly hasIanaId: boolean;
    readonly id: string;
    readonly standardName: string;
    readonly supportsDaylightSavingTime: boolean;
    equals(other: TimeZoneInfo): boolean;
    equals(obj: unknown): boolean;
    getAdjustmentRules(): TimeZoneInfo_AdjustmentRule[];
    getAmbiguousTimeOffsets(dateTimeOffset: DateTimeOffset): TimeSpan[];
    getAmbiguousTimeOffsets(dateTime: DateTime): TimeSpan[];
    getHashCode(): int;
    getUtcOffset(dateTimeOffset: DateTimeOffset): TimeSpan;
    getUtcOffset(dateTime: DateTime): TimeSpan;
    hasSameRules(other: TimeZoneInfo): boolean;
    isAmbiguousTime(dateTimeOffset: DateTimeOffset): boolean;
    isAmbiguousTime(dateTime: DateTime): boolean;
    isDaylightSavingTime(dateTimeOffset: DateTimeOffset): boolean;
    isDaylightSavingTime(dateTime: DateTime): boolean;
    isInvalidTime(dateTime: DateTime): boolean;
    toSerializedString(): string;
    toString(): string;
    static readonly local: TimeZoneInfo;
    static readonly utc: TimeZoneInfo;
    static clearCachedData(): void;
    static convertTime3(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo): DateTime;
    static convertTime3(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime;
    static convertTime3(dateTimeOffset: DateTimeOffset, destinationTimeZone: TimeZoneInfo): DateTimeOffset;
    static convertTimeBySystemTimeZoneId3(dateTime: DateTime, sourceTimeZoneId: string, destinationTimeZoneId: string): DateTime;
    static convertTimeBySystemTimeZoneId3(dateTime: DateTime, destinationTimeZoneId: string): DateTime;
    static convertTimeBySystemTimeZoneId3(dateTimeOffset: DateTimeOffset, destinationTimeZoneId: string): DateTimeOffset;
    static convertTimeFromUtc(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime;
    static convertTimeToUtc2(dateTime: DateTime, sourceTimeZone: TimeZoneInfo): DateTime;
    static convertTimeToUtc2(dateTime: DateTime): DateTime;
    static createCustomTimeZone3(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: TimeZoneInfo_AdjustmentRule[], disableDaylightSavingTime: boolean): TimeZoneInfo;
    static createCustomTimeZone3(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: TimeZoneInfo_AdjustmentRule[]): TimeZoneInfo;
    static createCustomTimeZone3(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string): TimeZoneInfo;
    static findSystemTimeZoneById(id: string): TimeZoneInfo;
    static fromSerializedString(source: string): TimeZoneInfo;
    static getSystemTimeZones(): ReadOnlyCollection_1<TimeZoneInfo>;
    static getSystemTimeZones(skipSorting: boolean): ReadOnlyCollection_1<TimeZoneInfo>;
    static tryConvertIanaIdToWindowsId(ianaId: string, windowsId: { value: ref<string> }): boolean;
    static tryConvertWindowsIdToIanaId2(windowsId: string, region: string, ianaId: { value: ref<string> }): boolean;
    static tryConvertWindowsIdToIanaId2(windowsId: string, ianaId: { value: ref<string> }): boolean;
    static tryFindSystemTimeZoneById(id: string, timeZoneInfo: { value: ref<TimeZoneInfo> }): boolean;
}


export interface __TimeZoneInfo$views {
    As_IEquatable_1(): IEquatable_1$instance<TimeZoneInfo>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeZoneInfo): boolean;
}

export interface TimeZoneInfo$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TimeZoneInfo = TimeZoneInfo$instance & __TimeZoneInfo$views;


export class TimeZoneInfo_AdjustmentRule$instance {
    readonly baseUtcOffsetDelta: TimeSpan;
    readonly dateEnd: DateTime;
    readonly dateStart: DateTime;
    readonly daylightDelta: TimeSpan;
    readonly daylightTransitionEnd: TimeZoneInfo_TransitionTime;
    readonly daylightTransitionStart: TimeZoneInfo_TransitionTime;
    equals(other: TimeZoneInfo_AdjustmentRule): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static createAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TimeZoneInfo_TransitionTime, daylightTransitionEnd: TimeZoneInfo_TransitionTime, baseUtcOffsetDelta: TimeSpan): TimeZoneInfo_AdjustmentRule;
    static createAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TimeZoneInfo_TransitionTime, daylightTransitionEnd: TimeZoneInfo_TransitionTime): TimeZoneInfo_AdjustmentRule;
}


export interface __TimeZoneInfo_AdjustmentRule$views {
    As_IEquatable_1(): IEquatable_1$instance<TimeZoneInfo_AdjustmentRule>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeZoneInfo_AdjustmentRule): boolean;
}

export interface TimeZoneInfo_AdjustmentRule$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TimeZoneInfo_AdjustmentRule = TimeZoneInfo_AdjustmentRule$instance & __TimeZoneInfo_AdjustmentRule$views;


export class TimeZoneNotFoundException$instance extends Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TimeZoneNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TimeZoneNotFoundException = TimeZoneNotFoundException$instance & __TimeZoneNotFoundException$views;


export class Tuple_1$instance<T1> {
    constructor(item1: T1);
    readonly item1: T1;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_1$views<T1> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_1$instance<T1> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_1<T1> = Tuple_1$instance<T1> & __Tuple_1$views<T1>;


export class Tuple_2$instance<T1, T2> {
    constructor(item1: T1, item2: T2);
    readonly item1: T1;
    readonly item2: T2;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_2$views<T1, T2> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_2$instance<T1, T2> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_2<T1, T2> = Tuple_2$instance<T1, T2> & __Tuple_2$views<T1, T2>;


export class Tuple_3$instance<T1, T2, T3> {
    constructor(item1: T1, item2: T2, item3: T3);
    readonly item1: T1;
    readonly item2: T2;
    readonly item3: T3;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_3$views<T1, T2, T3> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_3$instance<T1, T2, T3> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_3<T1, T2, T3> = Tuple_3$instance<T1, T2, T3> & __Tuple_3$views<T1, T2, T3>;


export class Tuple_4$instance<T1, T2, T3, T4> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4);
    readonly item1: T1;
    readonly item2: T2;
    readonly item3: T3;
    readonly item4: T4;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_4$views<T1, T2, T3, T4> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_4$instance<T1, T2, T3, T4> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_4<T1, T2, T3, T4> = Tuple_4$instance<T1, T2, T3, T4> & __Tuple_4$views<T1, T2, T3, T4>;


export class Tuple_5$instance<T1, T2, T3, T4, T5> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5);
    readonly item1: T1;
    readonly item2: T2;
    readonly item3: T3;
    readonly item4: T4;
    readonly item5: T5;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_5$views<T1, T2, T3, T4, T5> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_5$instance<T1, T2, T3, T4, T5> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_5<T1, T2, T3, T4, T5> = Tuple_5$instance<T1, T2, T3, T4, T5> & __Tuple_5$views<T1, T2, T3, T4, T5>;


export class Tuple_6$instance<T1, T2, T3, T4, T5, T6> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6);
    readonly item1: T1;
    readonly item2: T2;
    readonly item3: T3;
    readonly item4: T4;
    readonly item5: T5;
    readonly item6: T6;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_6$views<T1, T2, T3, T4, T5, T6> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_6$instance<T1, T2, T3, T4, T5, T6> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_6<T1, T2, T3, T4, T5, T6> = Tuple_6$instance<T1, T2, T3, T4, T5, T6> & __Tuple_6$views<T1, T2, T3, T4, T5, T6>;


export class Tuple_7$instance<T1, T2, T3, T4, T5, T6, T7> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7);
    readonly item1: T1;
    readonly item2: T2;
    readonly item3: T3;
    readonly item4: T4;
    readonly item5: T5;
    readonly item6: T6;
    readonly item7: T7;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_7$views<T1, T2, T3, T4, T5, T6, T7> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_7$instance<T1, T2, T3, T4, T5, T6, T7> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_7<T1, T2, T3, T4, T5, T6, T7> = Tuple_7$instance<T1, T2, T3, T4, T5, T6, T7> & __Tuple_7$views<T1, T2, T3, T4, T5, T6, T7>;


export class Tuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> {
    constructor(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, rest: TRest);
    readonly item1: T1;
    readonly item2: T2;
    readonly item3: T3;
    readonly item4: T4;
    readonly item5: T5;
    readonly item6: T6;
    readonly item7: T7;
    readonly rest: TRest;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __Tuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_8<T1, T2, T3, T4, T5, T6, T7, TRest> = Tuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> & __Tuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest>;


export abstract class Type$instance extends System_Reflection_Internal.MemberInfo$instance {
    readonly assembly: Assembly;
    readonly assemblyQualifiedName: string;
    readonly attributes: TypeAttributes;
    readonly baseType: Type;
    readonly containsGenericParameters: boolean;
    readonly declaringMethod: MethodBase;
    readonly declaringType: Type;
    readonly fullName: string;
    readonly genericParameterAttributes: GenericParameterAttributes;
    readonly genericParameterPosition: int;
    readonly genericTypeArguments: Type[];
    readonly GUID: Guid;
    readonly hasElementType: boolean;
    readonly isAbstract: boolean;
    readonly isAnsiClass: boolean;
    readonly isArray: boolean;
    readonly isAutoClass: boolean;
    readonly isAutoLayout: boolean;
    readonly isByRef: boolean;
    readonly isByRefLike: boolean;
    readonly isClass: boolean;
    readonly isCOMObject: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isContextful: boolean;
    readonly isEnum: boolean;
    readonly isExplicitLayout: boolean;
    readonly isFunctionPointer: boolean;
    readonly isGenericMethodParameter: boolean;
    readonly isGenericParameter: boolean;
    readonly isGenericType: boolean;
    readonly isGenericTypeDefinition: boolean;
    readonly isGenericTypeParameter: boolean;
    readonly isImport: boolean;
    readonly isInterface: boolean;
    readonly isLayoutSequential: boolean;
    readonly isMarshalByRef: boolean;
    readonly isNested: boolean;
    readonly isNestedAssembly: boolean;
    readonly isNestedFamANDAssem: boolean;
    readonly isNestedFamily: boolean;
    readonly isNestedFamORAssem: boolean;
    readonly isNestedPrivate: boolean;
    readonly isNestedPublic: boolean;
    readonly isNotPublic: boolean;
    readonly isPointer: boolean;
    readonly isPrimitive: boolean;
    readonly isPublic: boolean;
    readonly isSealed: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly isSerializable: boolean;
    readonly isSignatureType: boolean;
    readonly isSpecialName: boolean;
    readonly isSZArray: boolean;
    readonly isTypeDefinition: boolean;
    readonly isUnicodeClass: boolean;
    readonly isUnmanagedFunctionPointer: boolean;
    readonly isValueType: boolean;
    readonly isVariableBoundArray: boolean;
    readonly isVisible: boolean;
    readonly memberType: MemberTypes;
    readonly module_: Module;
    readonly namespace_: string;
    readonly reflectedType: Type;
    readonly structLayoutAttribute: StructLayoutAttribute;
    readonly typeHandle: RuntimeTypeHandle;
    readonly typeInitializer: ConstructorInfo;
    readonly underlyingSystemType: Type;
    equals(o: unknown): boolean;
    findInterfaces(filter: TypeFilter, filterCriteria: unknown): Type[];
    findMembers(memberType: MemberTypes, bindingAttr: BindingFlags, filter: MemberFilter, filterCriteria: unknown): MemberInfo[];
    getArrayRank(): int;
    getConstructor(types: Type[]): ConstructorInfo;
    getConstructor(bindingAttr: BindingFlags, types: Type[]): ConstructorInfo;
    getConstructor(bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo;
    getConstructor(bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo;
    getConstructors(): ConstructorInfo[];
    getConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
    abstract getCustomAttributes(inherit: boolean): unknown[];
    abstract getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getDefaultMembers(): MemberInfo[];
    abstract getElementType(): Type;
    getEnumName(value: unknown): string;
    getEnumNames(): string[];
    getEnumUnderlyingType(): Type;
    getEnumValues(): Array;
    getEnumValuesAsUnderlyingType(): Array;
    getEvent(name: string): EventInfo;
    getEvent(name: string, bindingAttr: BindingFlags): EventInfo;
    getEvents(): EventInfo[];
    getEvents(bindingAttr: BindingFlags): EventInfo[];
    getField(name: string): FieldInfo;
    getField(name: string, bindingAttr: BindingFlags): FieldInfo;
    getFields(): FieldInfo[];
    getFields(bindingAttr: BindingFlags): FieldInfo[];
    getFunctionPointerCallingConventions(): Type[];
    getFunctionPointerParameterTypes(): Type[];
    getFunctionPointerReturnType(): Type;
    getGenericArguments(): Type[];
    getGenericParameterConstraints(): Type[];
    getGenericTypeDefinition(): Type;
    getHashCode(): int;
    getInterface(name: string): Type;
    getInterface(name: string, ignoreCase: boolean): Type;
    getInterfaceMap(interfaceType: Type): InterfaceMapping;
    abstract getInterfaces(): Type[];
    getMember(name: string): MemberInfo[];
    getMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    getMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    getMembers(): MemberInfo[];
    getMembers(bindingAttr: BindingFlags): MemberInfo[];
    getMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo;
    getMethod(name: string): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    getMethod(name: string, types: Type[]): MethodInfo;
    getMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethods(): MethodInfo[];
    getMethods(bindingAttr: BindingFlags): MethodInfo[];
    getNestedType(name: string): Type;
    getNestedType(name: string, bindingAttr: BindingFlags): Type;
    getNestedTypes(): Type[];
    getNestedTypes(bindingAttr: BindingFlags): Type[];
    getOptionalCustomModifiers(): Type[];
    getProperties(): PropertyInfo[];
    getProperties(bindingAttr: BindingFlags): PropertyInfo[];
    getProperty(name: string): PropertyInfo;
    getProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    getProperty(name: string, returnType: Type): PropertyInfo;
    getProperty(name: string, types: Type[]): PropertyInfo;
    getProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    getProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    getProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    getRequiredCustomModifiers(): Type[];
    getType(): Type;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[]): unknown;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], culture: CultureInfo): unknown;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
    isAssignableFrom(c: Type): boolean;
    isAssignableTo(targetType: Type): boolean;
    abstract isDefined(attributeType: Type, inherit: boolean): boolean;
    isEnumDefined(value: unknown): boolean;
    isEquivalentTo(other: Type): boolean;
    isInstanceOfType(o: unknown): boolean;
    isSubclassOf(c: Type): boolean;
    makeArrayType(): Type;
    makeArrayType(rank: int): Type;
    makeByRefType(): Type;
    makeGenericType(typeArguments: Type[]): Type;
    makePointerType(): Type;
    toString(): string;
    static readonly delimiter: char;
    static readonly emptyTypes: Type[];
    static readonly missing: unknown;
    static readonly filterAttribute: MemberFilter;
    static readonly filterName: MemberFilter;
    static readonly filterNameIgnoreCase: MemberFilter;
    static readonly defaultBinder: Binder;
    static getType(typeName: string, throwOnError: boolean, ignoreCase: boolean): Type;
    static getType(typeName: string, throwOnError: boolean): Type;
    static getType(typeName: string, assemblyResolver: Func_2<AssemblyName, Assembly>, typeResolver: Func_4<Assembly, CLROf<string>, CLROf<boolean>, Type>, throwOnError: boolean, ignoreCase: boolean): Type;
    static getType(typeName: string, assemblyResolver: Func_2<AssemblyName, Assembly>, typeResolver: Func_4<Assembly, CLROf<string>, CLROf<boolean>, Type>, throwOnError: boolean): Type;
    static getType(typeName: string, assemblyResolver: Func_2<AssemblyName, Assembly>, typeResolver: Func_4<Assembly, CLROf<string>, CLROf<boolean>, Type>): Type;
    static getType(typeName: string): Type;
    static getTypeArray(args: unknown[]): Type[];
    static getTypeCode(type_: Type): TypeCode;
    static getTypeFromCLSID2(clsid: Guid, throwOnError: boolean): Type;
    static getTypeFromCLSID2(clsid: Guid, server: string, throwOnError: boolean): Type;
    static getTypeFromCLSID2(clsid: Guid, server: string): Type;
    static getTypeFromCLSID2(clsid: Guid): Type;
    static getTypeFromHandle(handle: RuntimeTypeHandle): Type;
    static getTypeFromProgID2(progID: string, throwOnError: boolean): Type;
    static getTypeFromProgID2(progID: string, server: string, throwOnError: boolean): Type;
    static getTypeFromProgID2(progID: string, server: string): Type;
    static getTypeFromProgID2(progID: string): Type;
    static getTypeHandle(o: unknown): RuntimeTypeHandle;
    static makeGenericMethodParameter(position: int): Type;
    static makeGenericSignatureType(genericTypeDefinition: Type, typeArguments: Type[]): Type;
    static reflectionOnlyGetType(typeName: string, throwIfNotFound: boolean, ignoreCase: boolean): Type;
}


export interface __Type$views {
    As_ICustomAttributeProvider(): System_Reflection_Internal.ICustomAttributeProvider$instance;
    As_IReflect(): System_Reflection_Internal.IReflect$instance;
}

export type Type = Type$instance & __Type$views;


export class TypeAccessException$instance extends TypeLoadException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TypeAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeAccessException = TypeAccessException$instance & __TypeAccessException$views;


export class TypeInitializationException$instance extends SystemException$instance {
    constructor(fullTypeName: string, innerException: Exception);
    readonly typeName: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TypeInitializationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeInitializationException = TypeInitializationException$instance & __TypeInitializationException$views;


export class TypeLoadException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    readonly message: string;
    readonly typeName: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TypeLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeLoadException = TypeLoadException$instance & __TypeLoadException$views;


export class TypeUnloadedException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TypeUnloadedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeUnloadedException = TypeUnloadedException$instance & __TypeUnloadedException$views;


export class UnauthorizedAccessException$instance extends SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __UnauthorizedAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnauthorizedAccessException = UnauthorizedAccessException$instance & __UnauthorizedAccessException$views;


export class UnhandledExceptionEventArgs$instance extends EventArgs$instance {
    constructor(exception: unknown, isTerminating: boolean);
    readonly exceptionObject: unknown;
    readonly isTerminating: boolean;
}


export type UnhandledExceptionEventArgs = UnhandledExceptionEventArgs$instance;

export class UnhandledExceptionEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: UnhandledExceptionEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: UnhandledExceptionEventArgs): void;
}


export interface __UnhandledExceptionEventHandler$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnhandledExceptionEventHandler = UnhandledExceptionEventHandler$instance & __UnhandledExceptionEventHandler$views;


export class UnitySerializationHolder$instance {
    constructor(info: SerializationInfo, context: StreamingContext);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRealObject(context: StreamingContext): unknown;
}


export interface __UnitySerializationHolder$views {
    As_IObjectReference(): System_Runtime_Serialization_Internal.IObjectReference$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface UnitySerializationHolder$instance extends System_Runtime_Serialization_Internal.IObjectReference$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type UnitySerializationHolder = UnitySerializationHolder$instance & __UnitySerializationHolder$views;


export class Uri$instance {
    constructor(uriString: string);
    constructor(uriString: string, dontEscape: boolean);
    constructor(baseUri: Uri, relativeUri: string, dontEscape: boolean);
    constructor(uriString: string, uriKind: UriKind);
    constructor(uriString: string, creationOptions: ref<UriCreationOptions>);
    constructor(baseUri: Uri, relativeUri: string);
    constructor(baseUri: Uri, relativeUri: Uri);
    readonly absolutePath: string;
    readonly absoluteUri: string;
    readonly authority: string;
    readonly dnsSafeHost: string;
    readonly fragment: string;
    readonly host: string;
    readonly hostNameType: UriHostNameType;
    readonly idnHost: string;
    readonly isAbsoluteUri: boolean;
    readonly isDefaultPort: boolean;
    readonly isFile: boolean;
    readonly isLoopback: boolean;
    readonly isUnc: boolean;
    readonly localPath: string;
    readonly originalString: string;
    readonly pathAndQuery: string;
    readonly port: int;
    readonly query: string;
    readonly scheme: string;
    readonly segments: string[];
    readonly userEscaped: boolean;
    readonly userInfo: string;
    equals(comparand: unknown): boolean;
    equals(other: Uri): boolean;
    getComponents(components: UriComponents, format: UriFormat): string;
    getHashCode(): int;
    getLeftPart(part: UriPartial): string;
    isBaseOf(uri: Uri): boolean;
    isWellFormedOriginalString(): boolean;
    makeRelative(toUri: Uri): string;
    makeRelativeUri(uri: Uri): Uri;
    toString(): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static readonly uriSchemeFile: string;
    static readonly uriSchemeFtp: string;
    static readonly uriSchemeSftp: string;
    static readonly uriSchemeFtps: string;
    static readonly uriSchemeGopher: string;
    static readonly uriSchemeHttp: string;
    static readonly uriSchemeHttps: string;
    static readonly uriSchemeWs: string;
    static readonly uriSchemeWss: string;
    static readonly uriSchemeMailto: string;
    static readonly uriSchemeNews: string;
    static readonly uriSchemeNntp: string;
    static readonly uriSchemeSsh: string;
    static readonly uriSchemeTelnet: string;
    static readonly uriSchemeNetTcp: string;
    static readonly uriSchemeNetPipe: string;
    static readonly schemeDelimiter: string;
    static checkHostName(name: string): UriHostNameType;
    static checkSchemeName(schemeName: string): boolean;
    static compare(uri1: Uri, uri2: Uri, partsToCompare: UriComponents, compareFormat: UriFormat, comparisonType: StringComparison): int;
    static escapeDataString2(charsToEscape: ReadOnlySpan_1<CLROf<char>>): string;
    static escapeDataString2(stringToEscape: string): string;
    static escapeUriString(stringToEscape: string): string;
    static fromHex(digit: char): int;
    static hexEscape(character: char): string;
    static hexUnescape(pattern: string, index: { value: ref<int> }): char;
    static isHexDigit(character: char): boolean;
    static isHexEncoding(pattern: string, index: int): boolean;
    static isWellFormedUriString(uriString: string, uriKind: UriKind): boolean;
    static tryCreate2(uriString: string, creationOptions: { value: ref<UriCreationOptions> }, result: { value: ref<Uri> }): boolean;
    static tryCreate2(uriString: string, uriKind: UriKind, result: { value: ref<Uri> }): boolean;
    static tryCreate2(baseUri: Uri, relativeUri: string, result: { value: ref<Uri> }): boolean;
    static tryCreate2(baseUri: Uri, relativeUri: Uri, result: { value: ref<Uri> }): boolean;
    static tryEscapeDataString(charsToEscape: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static tryUnescapeDataString(charsToUnescape: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static unescapeDataString2(charsToUnescape: ReadOnlySpan_1<CLROf<char>>): string;
    static unescapeDataString2(stringToUnescape: string): string;
}


export interface __Uri$views {
    As_IEquatable_1(): IEquatable_1$instance<Uri>;
    As_IFormattable(): IFormattable$instance;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Uri): boolean;
}

export interface Uri$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Uri = Uri$instance & __Uri$views;


export class UriBuilder$instance {
    constructor();
    constructor(uri: string);
    constructor(uri: Uri);
    constructor(schemeName: string, hostName: string);
    constructor(scheme: string, host: string, portNumber: int);
    constructor(scheme: string, host: string, port: int, pathValue: string);
    constructor(scheme: string, host: string, port: int, path: string, extraValue: string);
    fragment: string;
    host: string;
    password: string;
    path: string;
    port: int;
    query: string;
    scheme: string;
    readonly uri: Uri;
    userName: string;
    equals(rparam: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export type UriBuilder = UriBuilder$instance;

export class UriFormatException$instance extends FormatException$instance {
    constructor();
    constructor(textString: string);
    constructor(textString: string, e: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __UriFormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UriFormatException = UriFormatException$instance & __UriFormatException$views;


export abstract class UriParser$instance {
    static isKnownScheme(schemeName: string): boolean;
    static register(uriParser: UriParser, schemeName: string, defaultPort: int): void;
}


export type UriParser = UriParser$instance;

export class UriTypeConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
    isValid(value: unknown): boolean;
}


export type UriTypeConverter = UriTypeConverter$instance;

export abstract class ValueType$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export type ValueType = ValueType$instance;

export class Version$instance {
    constructor(major: int, minor: int, build: int, revision: int);
    constructor(major: int, minor: int, build: int);
    constructor(major: int, minor: int);
    constructor(version: string);
    constructor();
    readonly build: int;
    readonly major: int;
    readonly majorRevision: short;
    readonly minor: int;
    readonly minorRevision: short;
    readonly revision: int;
    clone(): unknown;
    compareTo(version: unknown): int;
    compareTo(value: Version): int;
    equals(obj: unknown): boolean;
    equals(obj: Version): boolean;
    getHashCode(): int;
    toString(): string;
    toString(fieldCount: int): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryFormat(destination: Span_1<CLROf<char>>, fieldCount: int, charsWritten: { value: ref<int> }): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, fieldCount: int, bytesWritten: { value: ref<int> }): boolean;
    static parse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>): Version;
    static parse3(input: ReadOnlySpan_1<CLROf<char>>): Version;
    static parse3(input: string): Version;
    static tryParse3(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<Version> }): boolean;
    static tryParse3(input: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Version> }): boolean;
    static tryParse3(input: string, result: { value: ref<Version> }): boolean;
}


export interface __Version$views {
    As_ICloneable(): ICloneable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Version>;
    As_IEquatable_1(): IEquatable_1$instance<Version>;
    As_IFormattable(): IFormattable$instance;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Version>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Version): boolean;
    CompareTo(obj: unknown): int;
}

export interface Version$instance extends ICloneable$instance, IComparable$instance, IUtf8SpanParsable_1$instance<Version> {}

export type Version = Version$instance & __Version$views;


export class WeakReference$instance {
    constructor(target: unknown);
    constructor(target: unknown, trackResurrection: boolean);
    readonly isAlive: boolean;
    target: unknown;
    readonly trackResurrection: boolean;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __WeakReference$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WeakReference$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WeakReference = WeakReference$instance & __WeakReference$views;


export class WeakReference_1$instance<T> {
    constructor(target: T);
    constructor(target: T, trackResurrection: boolean);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    setTarget(target: T): void;
    tryGetTarget(target: { value: ref<T> }): boolean;
}


export interface __WeakReference_1$views<T> {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WeakReference_1$instance<T> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WeakReference_1<T> = WeakReference_1$instance<T> & __WeakReference_1$views<T>;


export abstract class Activator$instance {
    static createInstance10<T>(): T;
    static createInstance10(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): ObjectHandle;
    static createInstance10(assemblyName: string, typeName: string, activationAttributes: unknown[]): ObjectHandle;
    static createInstance10(assemblyName: string, typeName: string): ObjectHandle;
    static createInstance10(type_: Type, nonPublic: boolean): unknown;
    static createInstance10(type_: Type, args: unknown[], activationAttributes: unknown[]): unknown;
    static createInstance10(type_: Type, args: unknown[]): unknown;
    static createInstance10(type_: Type, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): unknown;
    static createInstance10(type_: Type, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo): unknown;
    static createInstance10(type_: Type): unknown;
    static createInstanceFrom3(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): ObjectHandle;
    static createInstanceFrom3(assemblyFile: string, typeName: string, activationAttributes: unknown[]): ObjectHandle;
    static createInstanceFrom3(assemblyFile: string, typeName: string): ObjectHandle;
}


export type Activator = Activator$instance;

export abstract class AppContext$instance {
    static readonly baseDirectory: string;
    static readonly targetFrameworkName: string;
    static getData(name: string): unknown;
    static setData(name: string, data: unknown): void;
    static setSwitch(switchName: string, isEnabled: boolean): void;
    static tryGetSwitch(switchName: string, isEnabled: { value: ref<boolean> }): boolean;
}


export type AppContext = AppContext$instance;

export abstract class BitConverter$instance {
    static readonly isLittleEndian: boolean;
    static doubleToInt64Bits(value: double): long;
    static doubleToUInt64Bits(value: double): ulong;
    static getBytes(value: boolean): byte[];
    static getBytes(value: char): byte[];
    static getBytes(value: double): byte[];
    static getBytes(value: half): byte[];
    static getBytes(value: int128): byte[];
    static getBytes(value: short): byte[];
    static getBytes(value: int): byte[];
    static getBytes(value: long): byte[];
    static getBytes(value: float): byte[];
    static getBytes(value: uint128): byte[];
    static getBytes(value: ushort): byte[];
    static getBytes(value: uint): byte[];
    static getBytes(value: ulong): byte[];
    static halfToInt16Bits(value: half): short;
    static halfToUInt16Bits(value: half): ushort;
    static int16BitsToHalf(value: short): half;
    static int32BitsToSingle(value: int): float;
    static int64BitsToDouble(value: long): double;
    static singleToInt32Bits(value: float): int;
    static singleToUInt32Bits(value: float): uint;
    static toBoolean(value: byte[], startIndex: int): boolean;
    static toBoolean(value: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static toChar(value: byte[], startIndex: int): char;
    static toChar(value: ReadOnlySpan_1<CLROf<byte>>): char;
    static toDouble(value: byte[], startIndex: int): double;
    static toDouble(value: ReadOnlySpan_1<CLROf<byte>>): double;
    static toHalf(value: byte[], startIndex: int): half;
    static toHalf(value: ReadOnlySpan_1<CLROf<byte>>): half;
    static toInt128(value: byte[], startIndex: int): int128;
    static toInt128(value: ReadOnlySpan_1<CLROf<byte>>): int128;
    static toInt16(value: byte[], startIndex: int): short;
    static toInt16(value: ReadOnlySpan_1<CLROf<byte>>): short;
    static toInt32(value: byte[], startIndex: int): int;
    static toInt32(value: ReadOnlySpan_1<CLROf<byte>>): int;
    static toInt64(value: byte[], startIndex: int): long;
    static toInt64(value: ReadOnlySpan_1<CLROf<byte>>): long;
    static toSingle(value: byte[], startIndex: int): float;
    static toSingle(value: ReadOnlySpan_1<CLROf<byte>>): float;
    static toString(value: byte[], startIndex: int, length: int): string;
    static toString(value: byte[], startIndex: int): string;
    static toString(value: byte[]): string;
    static toUInt128(value: byte[], startIndex: int): uint128;
    static toUInt128(value: ReadOnlySpan_1<CLROf<byte>>): uint128;
    static toUInt16(value: byte[], startIndex: int): ushort;
    static toUInt16(value: ReadOnlySpan_1<CLROf<byte>>): ushort;
    static toUInt32(value: byte[], startIndex: int): uint;
    static toUInt32(value: ReadOnlySpan_1<CLROf<byte>>): uint;
    static toUInt64(value: byte[], startIndex: int): ulong;
    static toUInt64(value: ReadOnlySpan_1<CLROf<byte>>): ulong;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: boolean): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: char): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: double): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: half): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: int128): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: short): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: int): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: long): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: float): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: uint128): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: ushort): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: uint): boolean;
    static tryWriteBytes(destination: Span_1<CLROf<byte>>, value: ulong): boolean;
    static uInt16BitsToHalf(value: ushort): half;
    static uInt32BitsToSingle(value: uint): float;
    static uInt64BitsToDouble(value: ulong): double;
}


export type BitConverter = BitConverter$instance;

export abstract class Buffer$instance {
    static blockCopy(src: Array, srcOffset: int, dst: Array, dstOffset: int, count: int): void;
    static byteLength(array: Array): int;
    static getByte(array: Array, index: int): byte;
    static memoryCopy(source: ptr<void>, destination: ptr<void>, destinationSizeInBytes: long, sourceBytesToCopy: long): void;
    static memoryCopy(source: ptr<void>, destination: ptr<void>, destinationSizeInBytes: ulong, sourceBytesToCopy: ulong): void;
    static setByte(array: Array, index: int, value: byte): void;
}


export type Buffer = Buffer$instance;

export abstract class Console$instance {
    static readonly in_: TextReader;
    static inputEncoding: Encoding;
    static outputEncoding: Encoding;
    static readonly keyAvailable: boolean;
    static readonly out: TextWriter;
    static readonly error: TextWriter;
    static readonly isInputRedirected: boolean;
    static readonly isOutputRedirected: boolean;
    static readonly isErrorRedirected: boolean;
    static cursorSize: int;
    static readonly numberLock: boolean;
    static readonly capsLock: boolean;
    static backgroundColor: ConsoleColor;
    static foregroundColor: ConsoleColor;
    static bufferWidth: int;
    static bufferHeight: int;
    static windowLeft: int;
    static windowTop: int;
    static windowWidth: int;
    static windowHeight: int;
    static readonly largestWindowWidth: int;
    static readonly largestWindowHeight: int;
    static cursorVisible: boolean;
    static cursorLeft: int;
    static cursorTop: int;
    static title: string;
    static treatControlCAsInput: boolean;
    static beep(): void;
    static beep(frequency: int, duration: int): void;
    static clear(): void;
    static getCursorPosition(): ValueTuple_2<CLROf<int>, CLROf<int>>;
    static moveBufferArea2(sourceLeft: int, sourceTop: int, sourceWidth: int, sourceHeight: int, targetLeft: int, targetTop: int, sourceChar: char, sourceForeColor: ConsoleColor, sourceBackColor: ConsoleColor): void;
    static moveBufferArea2(sourceLeft: int, sourceTop: int, sourceWidth: int, sourceHeight: int, targetLeft: int, targetTop: int): void;
    static openStandardError(): Stream;
    static openStandardError(bufferSize: int): Stream;
    static openStandardInput(): Stream;
    static openStandardInput(bufferSize: int): Stream;
    static openStandardOutput(): Stream;
    static openStandardOutput(bufferSize: int): Stream;
    static read(): int;
    static readKey(): ConsoleKeyInfo;
    static readKey(intercept: boolean): ConsoleKeyInfo;
    static readLine(): string;
    static resetColor(): void;
    static setBufferSize(width: int, height: int): void;
    static setCursorPosition(left: int, top: int): void;
    static setError(newError: TextWriter): void;
    static setIn(newIn: TextReader): void;
    static setOut(newOut: TextWriter): void;
    static setWindowPosition(left: int, top: int): void;
    static setWindowSize(width: int, height: int): void;
    static write6(value: boolean): void;
    static write6(value: char): void;
    static write6(buffer: char[], index: int, count: int): void;
    static write6(buffer: char[]): void;
    static write6(value: decimal): void;
    static write6(value: double): void;
    static write6(value: int): void;
    static write6(value: long): void;
    static write6(value: unknown): void;
    static write6(value: ReadOnlySpan_1<CLROf<char>>): void;
    static write6(value: float): void;
    static write6(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    static write6(format: string, arg0: unknown, arg1: unknown): void;
    static write6(format: string, arg0: unknown): void;
    static write6(format: string, arg: unknown[]): void;
    static write6(format: string, arg: ReadOnlySpan_1<unknown>): void;
    static write6(value: string): void;
    static write6(value: uint): void;
    static write6(value: ulong): void;
    static writeLine(): void;
    static writeLine(value: boolean): void;
    static writeLine(value: char): void;
    static writeLine(buffer: char[], index: int, count: int): void;
    static writeLine(buffer: char[]): void;
    static writeLine(value: decimal): void;
    static writeLine(value: double): void;
    static writeLine(value: int): void;
    static writeLine(value: long): void;
    static writeLine(value: unknown): void;
    static writeLine(value: ReadOnlySpan_1<CLROf<char>>): void;
    static writeLine(value: float): void;
    static writeLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    static writeLine(format: string, arg0: unknown, arg1: unknown): void;
    static writeLine(format: string, arg0: unknown): void;
    static writeLine(format: string, arg: unknown[]): void;
    static writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    static writeLine(value: string): void;
    static writeLine(value: uint): void;
    static writeLine(value: ulong): void;
}


export type Console = Console$instance;

export abstract class Convert$instance {
    static readonly dbNull: unknown;
    static changeType4(value: unknown, conversionType: Type, provider: IFormatProvider): unknown;
    static changeType4(value: unknown, conversionType: Type): unknown;
    static changeType4(value: unknown, typeCode: TypeCode, provider: IFormatProvider): unknown;
    static changeType4(value: unknown, typeCode: TypeCode): unknown;
    static fromBase64CharArray(inArray: char[], offset: int, length: int): byte[];
    static fromBase64String(s: string): byte[];
    static fromHexString6(utf8Source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }): OperationStatus;
    static fromHexString6(utf8Source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static fromHexString6(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, charsConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }): OperationStatus;
    static fromHexString6(chars: ReadOnlySpan_1<CLROf<char>>): byte[];
    static fromHexString6(source: string, destination: Span_1<CLROf<byte>>, charsConsumed: { value: ref<int> }, bytesWritten: { value: ref<int> }): OperationStatus;
    static fromHexString6(s: string): byte[];
    static getTypeCode(value: unknown): TypeCode;
    static isDBNull(value: unknown): boolean;
    static toBase64CharArray2(inArray: byte[], offsetIn: int, length: int, outArray: char[], offsetOut: int, options: Base64FormattingOptions): int;
    static toBase64CharArray2(inArray: byte[], offsetIn: int, length: int, outArray: char[], offsetOut: int): int;
    static toBase64String2(inArray: byte[], options: Base64FormattingOptions): string;
    static toBase64String2(inArray: byte[], offset: int, length: int, options: Base64FormattingOptions): string;
    static toBase64String2(inArray: byte[], offset: int, length: int): string;
    static toBase64String2(inArray: byte[]): string;
    static toBase64String2(bytes: ReadOnlySpan_1<CLROf<byte>>, options?: Base64FormattingOptions): string;
    static toBoolean3(value: boolean): boolean;
    static toBoolean3(value: byte): boolean;
    static toBoolean3(value: char): boolean;
    static toBoolean3(value: DateTime): boolean;
    static toBoolean3(value: decimal): boolean;
    static toBoolean3(value: double): boolean;
    static toBoolean3(value: short): boolean;
    static toBoolean3(value: int): boolean;
    static toBoolean3(value: long): boolean;
    static toBoolean3(value: unknown, provider: IFormatProvider): boolean;
    static toBoolean3(value: unknown): boolean;
    static toBoolean3(value: sbyte): boolean;
    static toBoolean3(value: float): boolean;
    static toBoolean3(value: string, provider: IFormatProvider): boolean;
    static toBoolean3(value: string): boolean;
    static toBoolean3(value: ushort): boolean;
    static toBoolean3(value: uint): boolean;
    static toBoolean3(value: ulong): boolean;
    static toByte3(value: boolean): byte;
    static toByte3(value: byte): byte;
    static toByte3(value: char): byte;
    static toByte3(value: DateTime): byte;
    static toByte3(value: decimal): byte;
    static toByte3(value: double): byte;
    static toByte3(value: short): byte;
    static toByte3(value: int): byte;
    static toByte3(value: long): byte;
    static toByte3(value: unknown, provider: IFormatProvider): byte;
    static toByte3(value: unknown): byte;
    static toByte3(value: sbyte): byte;
    static toByte3(value: float): byte;
    static toByte3(value: string, provider: IFormatProvider): byte;
    static toByte3(value: string, fromBase: int): byte;
    static toByte3(value: string): byte;
    static toByte3(value: ushort): byte;
    static toByte3(value: uint): byte;
    static toByte3(value: ulong): byte;
    static toChar3(value: boolean): char;
    static toChar3(value: byte): char;
    static toChar3(value: char): char;
    static toChar3(value: DateTime): char;
    static toChar3(value: decimal): char;
    static toChar3(value: double): char;
    static toChar3(value: short): char;
    static toChar3(value: int): char;
    static toChar3(value: long): char;
    static toChar3(value: unknown, provider: IFormatProvider): char;
    static toChar3(value: unknown): char;
    static toChar3(value: sbyte): char;
    static toChar3(value: float): char;
    static toChar3(value: string, provider: IFormatProvider): char;
    static toChar3(value: string): char;
    static toChar3(value: ushort): char;
    static toChar3(value: uint): char;
    static toChar3(value: ulong): char;
    static toDateTime14(value: boolean): DateTime;
    static toDateTime14(value: byte): DateTime;
    static toDateTime14(value: char): DateTime;
    static toDateTime14(value: DateTime): DateTime;
    static toDateTime14(value: decimal): DateTime;
    static toDateTime14(value: double): DateTime;
    static toDateTime14(value: short): DateTime;
    static toDateTime14(value: int): DateTime;
    static toDateTime14(value: long): DateTime;
    static toDateTime14(value: unknown, provider: IFormatProvider): DateTime;
    static toDateTime14(value: unknown): DateTime;
    static toDateTime14(value: sbyte): DateTime;
    static toDateTime14(value: float): DateTime;
    static toDateTime14(value: string, provider: IFormatProvider): DateTime;
    static toDateTime14(value: string): DateTime;
    static toDateTime14(value: ushort): DateTime;
    static toDateTime14(value: uint): DateTime;
    static toDateTime14(value: ulong): DateTime;
    static toDecimal17(value: boolean): decimal;
    static toDecimal17(value: byte): decimal;
    static toDecimal17(value: char): decimal;
    static toDecimal17(value: DateTime): decimal;
    static toDecimal17(value: decimal): decimal;
    static toDecimal17(value: double): decimal;
    static toDecimal17(value: short): decimal;
    static toDecimal17(value: int): decimal;
    static toDecimal17(value: long): decimal;
    static toDecimal17(value: unknown, provider: IFormatProvider): decimal;
    static toDecimal17(value: unknown): decimal;
    static toDecimal17(value: sbyte): decimal;
    static toDecimal17(value: float): decimal;
    static toDecimal17(value: string, provider: IFormatProvider): decimal;
    static toDecimal17(value: string): decimal;
    static toDecimal17(value: ushort): decimal;
    static toDecimal17(value: uint): decimal;
    static toDecimal17(value: ulong): decimal;
    static toDouble17(value: boolean): double;
    static toDouble17(value: byte): double;
    static toDouble17(value: char): double;
    static toDouble17(value: DateTime): double;
    static toDouble17(value: decimal): double;
    static toDouble17(value: double): double;
    static toDouble17(value: short): double;
    static toDouble17(value: int): double;
    static toDouble17(value: long): double;
    static toDouble17(value: unknown, provider: IFormatProvider): double;
    static toDouble17(value: unknown): double;
    static toDouble17(value: sbyte): double;
    static toDouble17(value: float): double;
    static toDouble17(value: string, provider: IFormatProvider): double;
    static toDouble17(value: string): double;
    static toDouble17(value: ushort): double;
    static toDouble17(value: uint): double;
    static toDouble17(value: ulong): double;
    static toHexString2(inArray: byte[], offset: int, length: int): string;
    static toHexString2(inArray: byte[]): string;
    static toHexString2(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    static toHexStringLower2(inArray: byte[], offset: int, length: int): string;
    static toHexStringLower2(inArray: byte[]): string;
    static toHexStringLower2(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    static toInt163(value: boolean): short;
    static toInt163(value: byte): short;
    static toInt163(value: char): short;
    static toInt163(value: DateTime): short;
    static toInt163(value: decimal): short;
    static toInt163(value: double): short;
    static toInt163(value: short): short;
    static toInt163(value: int): short;
    static toInt163(value: long): short;
    static toInt163(value: unknown, provider: IFormatProvider): short;
    static toInt163(value: unknown): short;
    static toInt163(value: sbyte): short;
    static toInt163(value: float): short;
    static toInt163(value: string, provider: IFormatProvider): short;
    static toInt163(value: string, fromBase: int): short;
    static toInt163(value: string): short;
    static toInt163(value: ushort): short;
    static toInt163(value: uint): short;
    static toInt163(value: ulong): short;
    static toInt323(value: boolean): int;
    static toInt323(value: byte): int;
    static toInt323(value: char): int;
    static toInt323(value: DateTime): int;
    static toInt323(value: decimal): int;
    static toInt323(value: double): int;
    static toInt323(value: short): int;
    static toInt323(value: int): int;
    static toInt323(value: long): int;
    static toInt323(value: unknown, provider: IFormatProvider): int;
    static toInt323(value: unknown): int;
    static toInt323(value: sbyte): int;
    static toInt323(value: float): int;
    static toInt323(value: string, provider: IFormatProvider): int;
    static toInt323(value: string, fromBase: int): int;
    static toInt323(value: string): int;
    static toInt323(value: ushort): int;
    static toInt323(value: uint): int;
    static toInt323(value: ulong): int;
    static toInt643(value: boolean): long;
    static toInt643(value: byte): long;
    static toInt643(value: char): long;
    static toInt643(value: DateTime): long;
    static toInt643(value: decimal): long;
    static toInt643(value: double): long;
    static toInt643(value: short): long;
    static toInt643(value: int): long;
    static toInt643(value: long): long;
    static toInt643(value: unknown, provider: IFormatProvider): long;
    static toInt643(value: unknown): long;
    static toInt643(value: sbyte): long;
    static toInt643(value: float): long;
    static toInt643(value: string, provider: IFormatProvider): long;
    static toInt643(value: string, fromBase: int): long;
    static toInt643(value: string): long;
    static toInt643(value: ushort): long;
    static toInt643(value: uint): long;
    static toInt643(value: ulong): long;
    static toSByte3(value: boolean): sbyte;
    static toSByte3(value: byte): sbyte;
    static toSByte3(value: char): sbyte;
    static toSByte3(value: DateTime): sbyte;
    static toSByte3(value: decimal): sbyte;
    static toSByte3(value: double): sbyte;
    static toSByte3(value: short): sbyte;
    static toSByte3(value: int): sbyte;
    static toSByte3(value: long): sbyte;
    static toSByte3(value: unknown, provider: IFormatProvider): sbyte;
    static toSByte3(value: unknown): sbyte;
    static toSByte3(value: sbyte): sbyte;
    static toSByte3(value: float): sbyte;
    static toSByte3(value: string, provider: IFormatProvider): sbyte;
    static toSByte3(value: string, fromBase: int): sbyte;
    static toSByte3(value: string): sbyte;
    static toSByte3(value: ushort): sbyte;
    static toSByte3(value: uint): sbyte;
    static toSByte3(value: ulong): sbyte;
    static toSingle17(value: boolean): float;
    static toSingle17(value: byte): float;
    static toSingle17(value: char): float;
    static toSingle17(value: DateTime): float;
    static toSingle17(value: decimal): float;
    static toSingle17(value: double): float;
    static toSingle17(value: short): float;
    static toSingle17(value: int): float;
    static toSingle17(value: long): float;
    static toSingle17(value: unknown, provider: IFormatProvider): float;
    static toSingle17(value: unknown): float;
    static toSingle17(value: sbyte): float;
    static toSingle17(value: float): float;
    static toSingle17(value: string, provider: IFormatProvider): float;
    static toSingle17(value: string): float;
    static toSingle17(value: ushort): float;
    static toSingle17(value: uint): float;
    static toSingle17(value: ulong): float;
    static toString4(value: boolean, provider: IFormatProvider): string;
    static toString4(value: boolean): string;
    static toString4(value: byte, provider: IFormatProvider): string;
    static toString4(value: byte, toBase: int): string;
    static toString4(value: byte): string;
    static toString4(value: char, provider: IFormatProvider): string;
    static toString4(value: char): string;
    static toString4(value: DateTime, provider: IFormatProvider): string;
    static toString4(value: DateTime): string;
    static toString4(value: decimal, provider: IFormatProvider): string;
    static toString4(value: decimal): string;
    static toString4(value: double, provider: IFormatProvider): string;
    static toString4(value: double): string;
    static toString4(value: short, provider: IFormatProvider): string;
    static toString4(value: short, toBase: int): string;
    static toString4(value: short): string;
    static toString4(value: int, provider: IFormatProvider): string;
    static toString4(value: int, toBase: int): string;
    static toString4(value: int): string;
    static toString4(value: long, provider: IFormatProvider): string;
    static toString4(value: long, toBase: int): string;
    static toString4(value: long): string;
    static toString4(value: unknown, provider: IFormatProvider): string;
    static toString4(value: unknown): string;
    static toString4(value: sbyte, provider: IFormatProvider): string;
    static toString4(value: sbyte): string;
    static toString4(value: float, provider: IFormatProvider): string;
    static toString4(value: float): string;
    static toString4(value: string, provider: IFormatProvider): string;
    static toString4(value: string): string;
    static toString4(value: ushort, provider: IFormatProvider): string;
    static toString4(value: ushort): string;
    static toString4(value: uint, provider: IFormatProvider): string;
    static toString4(value: uint): string;
    static toString4(value: ulong, provider: IFormatProvider): string;
    static toString4(value: ulong): string;
    static toUInt163(value: boolean): ushort;
    static toUInt163(value: byte): ushort;
    static toUInt163(value: char): ushort;
    static toUInt163(value: DateTime): ushort;
    static toUInt163(value: decimal): ushort;
    static toUInt163(value: double): ushort;
    static toUInt163(value: short): ushort;
    static toUInt163(value: int): ushort;
    static toUInt163(value: long): ushort;
    static toUInt163(value: unknown, provider: IFormatProvider): ushort;
    static toUInt163(value: unknown): ushort;
    static toUInt163(value: sbyte): ushort;
    static toUInt163(value: float): ushort;
    static toUInt163(value: string, provider: IFormatProvider): ushort;
    static toUInt163(value: string, fromBase: int): ushort;
    static toUInt163(value: string): ushort;
    static toUInt163(value: ushort): ushort;
    static toUInt163(value: uint): ushort;
    static toUInt163(value: ulong): ushort;
    static toUInt323(value: boolean): uint;
    static toUInt323(value: byte): uint;
    static toUInt323(value: char): uint;
    static toUInt323(value: DateTime): uint;
    static toUInt323(value: decimal): uint;
    static toUInt323(value: double): uint;
    static toUInt323(value: short): uint;
    static toUInt323(value: int): uint;
    static toUInt323(value: long): uint;
    static toUInt323(value: unknown, provider: IFormatProvider): uint;
    static toUInt323(value: unknown): uint;
    static toUInt323(value: sbyte): uint;
    static toUInt323(value: float): uint;
    static toUInt323(value: string, provider: IFormatProvider): uint;
    static toUInt323(value: string, fromBase: int): uint;
    static toUInt323(value: string): uint;
    static toUInt323(value: ushort): uint;
    static toUInt323(value: uint): uint;
    static toUInt323(value: ulong): uint;
    static toUInt643(value: boolean): ulong;
    static toUInt643(value: byte): ulong;
    static toUInt643(value: char): ulong;
    static toUInt643(value: DateTime): ulong;
    static toUInt643(value: decimal): ulong;
    static toUInt643(value: double): ulong;
    static toUInt643(value: short): ulong;
    static toUInt643(value: int): ulong;
    static toUInt643(value: long): ulong;
    static toUInt643(value: unknown, provider: IFormatProvider): ulong;
    static toUInt643(value: unknown): ulong;
    static toUInt643(value: sbyte): ulong;
    static toUInt643(value: float): ulong;
    static toUInt643(value: string, provider: IFormatProvider): ulong;
    static toUInt643(value: string, fromBase: int): ulong;
    static toUInt643(value: string): ulong;
    static toUInt643(value: ushort): ulong;
    static toUInt643(value: uint): ulong;
    static toUInt643(value: ulong): ulong;
    static tryFromBase64Chars(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryFromBase64String(s: string, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryToBase64Chars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, options?: Base64FormattingOptions): boolean;
    static tryToHexString2(source: ReadOnlySpan_1<CLROf<byte>>, utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryToHexString2(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static tryToHexStringLower2(source: ReadOnlySpan_1<CLROf<byte>>, utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static tryToHexStringLower2(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export type Convert = Convert$instance;

export abstract class Environment$instance {
    static readonly currentManagedThreadId: int;
    static exitCode: int;
    static readonly processorCount: int;
    static readonly isPrivilegedProcess: boolean;
    static readonly hasShutdownStarted: boolean;
    static readonly commandLine: string;
    static currentDirectory: string;
    static readonly processId: int;
    static readonly processPath: string;
    static readonly is64BitProcess: boolean;
    static readonly is64BitOperatingSystem: boolean;
    static readonly newLine: string;
    static readonly osVersion: OperatingSystem;
    static readonly stackTrace: string;
    static readonly systemPageSize: int;
    static readonly tickCount: int;
    static readonly userInteractive: boolean;
    static readonly systemDirectory: string;
    static readonly userDomainName: string;
    static readonly cpuUsage: Environment_ProcessCpuUsage;
    static readonly tickCount64: long;
    static readonly machineName: string;
    static readonly userName: string;
    static readonly workingSet: long;
    static readonly version: Version;
    static exit(exitCode: int): void;
    static expandEnvironmentVariables(name: string): string;
    static failFast2(message: string, exception: Exception): void;
    static failFast2(message: string): void;
    static getCommandLineArgs(): string[];
    static getEnvironmentVariable2(variable: string, target: EnvironmentVariableTarget): string;
    static getEnvironmentVariable2(variable: string): string;
    static getEnvironmentVariables2(): IDictionary;
    static getEnvironmentVariables2(target: EnvironmentVariableTarget): IDictionary;
    static getFolderPath2(folder: Environment_SpecialFolder, option: Environment_SpecialFolderOption): string;
    static getFolderPath2(folder: Environment_SpecialFolder): string;
    static getLogicalDrives(): string[];
    static setEnvironmentVariable2(variable: string, value: string, target: EnvironmentVariableTarget): void;
    static setEnvironmentVariable2(variable: string, value: string): void;
}


export type Environment = Environment$instance;

export abstract class GC$instance {
    static readonly maxGeneration: int;
    static addMemoryPressure(bytesAllocated: long): void;
    static allocateArray<T>(length: int, pinned?: boolean): T[];
    static allocateUninitializedArray<T>(length: int, pinned?: boolean): T[];
    static cancelFullGCNotification(): void;
    static collect2(): void;
    static collect2(generation: int, mode: GCCollectionMode, blocking: boolean, compacting: boolean): void;
    static collect2(generation: int, mode: GCCollectionMode, blocking: boolean): void;
    static collect2(generation: int, mode: GCCollectionMode): void;
    static collect2(generation: int): void;
    static collectionCount(generation: int): int;
    static endNoGCRegion(): void;
    static getAllocatedBytesForCurrentThread(): long;
    static getConfigurationVariables(): IReadOnlyDictionary_2<CLROf<string>, unknown>;
    static getGCMemoryInfo(): GCMemoryInfo;
    static getGCMemoryInfo(kind: GCKind): GCMemoryInfo;
    static getGeneration(obj: unknown): int;
    static getGeneration(wo: WeakReference): int;
    static getTotalAllocatedBytes(precise?: boolean): long;
    static getTotalMemory(forceFullCollection: boolean): long;
    static getTotalPauseDuration(): TimeSpan;
    static keepAlive(obj: unknown): void;
    static refreshMemoryLimit(): void;
    static registerForFullGCNotification(maxGenerationThreshold: int, largeObjectHeapThreshold: int): void;
    static registerNoGCRegionCallback(totalSize: long, callback: Action): void;
    static removeMemoryPressure(bytesAllocated: long): void;
    static reRegisterForFinalize(obj: unknown): void;
    static suppressFinalize(obj: unknown): void;
    static tryStartNoGCRegion3(totalSize: long, disallowFullBlockingGC: boolean): boolean;
    static tryStartNoGCRegion3(totalSize: long, lohSize: long, disallowFullBlockingGC: boolean): boolean;
    static tryStartNoGCRegion3(totalSize: long, lohSize: long): boolean;
    static tryStartNoGCRegion3(totalSize: long): boolean;
    static waitForFullGCApproach(): GCNotificationStatus;
    static waitForFullGCApproach(millisecondsTimeout: int): GCNotificationStatus;
    static waitForFullGCApproach(timeout: TimeSpan): GCNotificationStatus;
    static waitForFullGCComplete(): GCNotificationStatus;
    static waitForFullGCComplete(millisecondsTimeout: int): GCNotificationStatus;
    static waitForFullGCComplete(timeout: TimeSpan): GCNotificationStatus;
    static waitForPendingFinalizers(): void;
}


export type GC = GC$instance;

export abstract class Math$instance {
    static readonly E: double;
    static readonly PI: double;
    static readonly tau: double;
    static abs6(value: decimal): decimal;
    static abs6(value: double): double;
    static abs6(value: short): short;
    static abs6(value: int): int;
    static abs6(value: long): long;
    static abs6(value: nint): nint;
    static abs6(value: sbyte): sbyte;
    static abs6(value: float): float;
    static acos(d: double): double;
    static acosh(d: double): double;
    static asin(d: double): double;
    static asinh(d: double): double;
    static atan(d: double): double;
    static atan2(y: double, x: double): double;
    static atanh(d: double): double;
    static bigMul2(a: int, b: int): long;
    static bigMul2(a: long, b: long, low: { value: ref<long> }): long;
    static bigMul2(a: long, b: long): int128;
    static bigMul2(a: uint, b: uint): ulong;
    static bigMul2(a: ulong, b: ulong, low: { value: ref<ulong> }): ulong;
    static bigMul2(a: ulong, b: ulong): uint128;
    static bitDecrement(x: double): double;
    static bitIncrement(x: double): double;
    static cbrt(d: double): double;
    static ceiling2(d: decimal): decimal;
    static ceiling2(a: double): double;
    static clamp(value: byte, min: byte, max: byte): byte;
    static clamp(value: decimal, min: decimal, max: decimal): decimal;
    static clamp(value: double, min: double, max: double): double;
    static clamp(value: short, min: short, max: short): short;
    static clamp(value: int, min: int, max: int): int;
    static clamp(value: long, min: long, max: long): long;
    static clamp(value: nint, min: nint, max: nint): nint;
    static clamp(value: sbyte, min: sbyte, max: sbyte): sbyte;
    static clamp(value: float, min: float, max: float): float;
    static clamp(value: ushort, min: ushort, max: ushort): ushort;
    static clamp(value: uint, min: uint, max: uint): uint;
    static clamp(value: ulong, min: ulong, max: ulong): ulong;
    static clamp(value: nuint, min: nuint, max: nuint): nuint;
    static copySign(x: double, y: double): double;
    static cos(d: double): double;
    static cosh(value: double): double;
    static divRem4(left: byte, right: byte): ValueTuple_2<CLROf<byte>, CLROf<byte>>;
    static divRem4(left: short, right: short): ValueTuple_2<CLROf<short>, CLROf<short>>;
    static divRem4(a: int, b: int, result: { value: ref<int> }): int;
    static divRem4(left: int, right: int): ValueTuple_2<CLROf<int>, CLROf<int>>;
    static divRem4(a: long, b: long, result: { value: ref<long> }): long;
    static divRem4(left: long, right: long): ValueTuple_2<CLROf<long>, CLROf<long>>;
    static divRem4(left: nint, right: nint): ValueTuple_2<CLROf<nint>, CLROf<nint>>;
    static divRem4(left: sbyte, right: sbyte): ValueTuple_2<CLROf<sbyte>, CLROf<sbyte>>;
    static divRem4(left: ushort, right: ushort): ValueTuple_2<CLROf<ushort>, CLROf<ushort>>;
    static divRem4(left: uint, right: uint): ValueTuple_2<CLROf<uint>, CLROf<uint>>;
    static divRem4(left: ulong, right: ulong): ValueTuple_2<CLROf<ulong>, CLROf<ulong>>;
    static divRem4(left: nuint, right: nuint): ValueTuple_2<CLROf<nuint>, CLROf<nuint>>;
    static exp(d: double): double;
    static floor2(d: decimal): decimal;
    static floor2(d: double): double;
    static fusedMultiplyAdd(x: double, y: double, z: double): double;
    static ieeeRemainder(x: double, y: double): double;
    static iLogB(x: double): int;
    static log2(a: double, newBase: double): double;
    static log2(d: double): double;
    static log10(d: double): double;
    static log22(x: double): double;
    static max(val1: byte, val2: byte): byte;
    static max(val1: decimal, val2: decimal): decimal;
    static max(val1: double, val2: double): double;
    static max(val1: short, val2: short): short;
    static max(val1: int, val2: int): int;
    static max(val1: long, val2: long): long;
    static max(val1: nint, val2: nint): nint;
    static max(val1: sbyte, val2: sbyte): sbyte;
    static max(val1: float, val2: float): float;
    static max(val1: ushort, val2: ushort): ushort;
    static max(val1: uint, val2: uint): uint;
    static max(val1: ulong, val2: ulong): ulong;
    static max(val1: nuint, val2: nuint): nuint;
    static maxMagnitude(x: double, y: double): double;
    static min(val1: byte, val2: byte): byte;
    static min(val1: decimal, val2: decimal): decimal;
    static min(val1: double, val2: double): double;
    static min(val1: short, val2: short): short;
    static min(val1: int, val2: int): int;
    static min(val1: long, val2: long): long;
    static min(val1: nint, val2: nint): nint;
    static min(val1: sbyte, val2: sbyte): sbyte;
    static min(val1: float, val2: float): float;
    static min(val1: ushort, val2: ushort): ushort;
    static min(val1: uint, val2: uint): uint;
    static min(val1: ulong, val2: ulong): ulong;
    static min(val1: nuint, val2: nuint): nuint;
    static minMagnitude(x: double, y: double): double;
    static pow(x: double, y: double): double;
    static reciprocalEstimate(d: double): double;
    static reciprocalSqrtEstimate(d: double): double;
    static round4(d: decimal, decimals: int, mode: MidpointRounding): decimal;
    static round4(d: decimal, decimals: int): decimal;
    static round4(d: decimal, mode: MidpointRounding): decimal;
    static round4(d: decimal): decimal;
    static round4(value: double, digits: int, mode: MidpointRounding): double;
    static round4(value: double, digits: int): double;
    static round4(value: double, mode: MidpointRounding): double;
    static round4(a: double): double;
    static scaleB(x: double, n: int): double;
    static sign(value: decimal): int;
    static sign(value: double): int;
    static sign(value: short): int;
    static sign(value: int): int;
    static sign(value: long): int;
    static sign(value: nint): int;
    static sign(value: sbyte): int;
    static sign(value: float): int;
    static sin(a: double): double;
    static sinCos(x: double): ValueTuple_2<CLROf<double>, CLROf<double>>;
    static sinh(value: double): double;
    static sqrt(d: double): double;
    static tan(a: double): double;
    static tanh(value: double): double;
    static truncate(d: decimal): decimal;
    static truncate(d: double): double;
}


export type Math = Math$instance;

export abstract class MathF$instance {
    static readonly E: float;
    static readonly PI: float;
    static readonly tau: float;
    static abs(x: float): float;
    static acos(x: float): float;
    static acosh(x: float): float;
    static asin(x: float): float;
    static asinh(x: float): float;
    static atan(x: float): float;
    static atan2(y: float, x: float): float;
    static atanh(x: float): float;
    static bitDecrement(x: float): float;
    static bitIncrement(x: float): float;
    static cbrt(x: float): float;
    static ceiling(x: float): float;
    static copySign(x: float, y: float): float;
    static cos(x: float): float;
    static cosh(x: float): float;
    static exp(x: float): float;
    static floor(x: float): float;
    static fusedMultiplyAdd(x: float, y: float, z: float): float;
    static ieeeRemainder(x: float, y: float): float;
    static iLogB(x: float): int;
    static log2(x: float, y: float): float;
    static log2(x: float): float;
    static log10(x: float): float;
    static log22(x: float): float;
    static max(x: float, y: float): float;
    static maxMagnitude(x: float, y: float): float;
    static min(x: float, y: float): float;
    static minMagnitude(x: float, y: float): float;
    static pow(x: float, y: float): float;
    static reciprocalEstimate(x: float): float;
    static reciprocalSqrtEstimate(x: float): float;
    static round4(x: float, digits: int, mode: MidpointRounding): float;
    static round4(x: float, digits: int): float;
    static round4(x: float, mode: MidpointRounding): float;
    static round4(x: float): float;
    static scaleB(x: float, n: int): float;
    static sign(x: float): int;
    static sin(x: float): float;
    static sinCos(x: float): ValueTuple_2<CLROf<float>, CLROf<float>>;
    static sinh(x: float): float;
    static sqrt(x: float): float;
    static tan(x: float): float;
    static tanh(x: float): float;
    static truncate(x: float): float;
}


export type MathF = MathF$instance;

export abstract class MemoryExtensions$instance {
    static asMemory13<T>(segment: ArraySegment_1<T>, start: int, length: int): Memory_1<T>;
    static asMemory13<T>(segment: ArraySegment_1<T>, start: int): Memory_1<T>;
    static asMemory13<T>(segment: ArraySegment_1<T>): Memory_1<T>;
    static asMemory13(text: string, startIndex: Index): ReadOnlyMemory_1<CLROf<char>>;
    static asMemory13(text: string, start: int, length: int): ReadOnlyMemory_1<CLROf<char>>;
    static asMemory13(text: string, start: int): ReadOnlyMemory_1<CLROf<char>>;
    static asMemory13(text: string, range: Range): ReadOnlyMemory_1<CLROf<char>>;
    static asMemory13(text: string): ReadOnlyMemory_1<CLROf<char>>;
    static asMemory13<T>(array: T[], startIndex: Index): Memory_1<T>;
    static asMemory13<T>(array: T[], start: int, length: int): Memory_1<T>;
    static asMemory13<T>(array: T[], start: int): Memory_1<T>;
    static asMemory13<T>(array: T[], range: Range): Memory_1<T>;
    static asMemory13<T>(array: T[]): Memory_1<T>;
    static asSpan13<T>(segment: ArraySegment_1<T>, startIndex: Index): Span_1<T>;
    static asSpan13<T>(segment: ArraySegment_1<T>, start: int, length: int): Span_1<T>;
    static asSpan13<T>(segment: ArraySegment_1<T>, start: int): Span_1<T>;
    static asSpan13<T>(segment: ArraySegment_1<T>, range: Range): Span_1<T>;
    static asSpan13<T>(segment: ArraySegment_1<T>): Span_1<T>;
    static asSpan13(text: string, startIndex: Index): ReadOnlySpan_1<CLROf<char>>;
    static asSpan13(text: string, start: int, length: int): ReadOnlySpan_1<CLROf<char>>;
    static asSpan13(text: string, start: int): ReadOnlySpan_1<CLROf<char>>;
    static asSpan13(text: string, range: Range): ReadOnlySpan_1<CLROf<char>>;
    static asSpan13(text: string): ReadOnlySpan_1<CLROf<char>>;
    static asSpan13<T>(array: T[], startIndex: Index): Span_1<T>;
    static asSpan13<T>(array: T[], start: int, length: int): Span_1<T>;
    static asSpan13<T>(array: T[], start: int): Span_1<T>;
    static asSpan13<T>(array: T[], range: Range): Span_1<T>;
    static asSpan13<T>(array: T[]): Span_1<T>;
    static binarySearch4<T>(span: ReadOnlySpan_1<T>, comparable: IComparable_1<T>): int;
    static binarySearch4<T, TComparer extends IComparer_1<T>>(span: ReadOnlySpan_1<T>, value: T, comparer: TComparer): int;
    static binarySearch4<T, TComparable extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, comparable: TComparable): int;
    static binarySearch4<T>(span: Span_1<T>, comparable: IComparable_1<T>): int;
    static binarySearch4<T, TComparer extends IComparer_1<T>>(span: Span_1<T>, value: T, comparer: TComparer): int;
    static binarySearch4<T, TComparable extends IComparable_1<T>>(span: Span_1<T>, comparable: TComparable): int;
    static commonPrefixLength4<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, comparer: IEqualityComparer_1<T>): int;
    static commonPrefixLength4<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): int;
    static commonPrefixLength4<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>, comparer: IEqualityComparer_1<T>): int;
    static commonPrefixLength4<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>): int;
    static compareTo(span: ReadOnlySpan_1<CLROf<char>>, other: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): int;
    static contains3<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): boolean;
    static contains3<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static contains3<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): boolean;
    static contains3(span: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): boolean;
    static containsAny11<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): boolean;
    static containsAny11<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T>): boolean;
    static containsAny11<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T>): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): boolean;
    static containsAny11<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): boolean;
    static containsAny11(span: ReadOnlySpan_1<CLROf<char>>, values: SearchValues_1<CLROf<string>>): boolean;
    static containsAny11(span: Span_1<CLROf<char>>, values: SearchValues_1<CLROf<string>>): boolean;
    static containsAnyExcept13<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): boolean;
    static containsAnyExcept13<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): boolean;
    static containsAnyExcept13<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T>): boolean;
    static containsAnyExcept13<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T>): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): boolean;
    static containsAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): boolean;
    static containsAnyExceptInRange2<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static containsAnyExceptInRange2<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static containsAnyInRange2<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static containsAnyInRange2<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static copyTo2<T>(source: T[], destination: Memory_1<T>): void;
    static copyTo2<T>(source: T[], destination: Span_1<T>): void;
    static count6<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static count6<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): int;
    static count6<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): int;
    static count6<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static count6<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): int;
    static count6<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static countAny3<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static countAny3<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static countAny3<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static endsWith3<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): boolean;
    static endsWith3<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static endsWith3<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): boolean;
    static endsWith3<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static endsWith3<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static endsWith3(span: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): boolean;
    static enumerateLines(span: ReadOnlySpan_1<CLROf<char>>): SpanLineEnumerator;
    static enumerateLines(span: Span_1<CLROf<char>>): SpanLineEnumerator;
    static enumerateRunes(span: ReadOnlySpan_1<CLROf<char>>): SpanRuneEnumerator;
    static enumerateRunes(span: Span_1<CLROf<char>>): SpanRuneEnumerator;
    static equals(span: ReadOnlySpan_1<CLROf<char>>, other: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): boolean;
    static indexOf6<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static indexOf6<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): int;
    static indexOf6<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): int;
    static indexOf6<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static indexOf6<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): int;
    static indexOf6<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static indexOf6(span: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): int;
    static indexOfAny11<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static indexOfAny11<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T>): int;
    static indexOfAny11<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T>): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static indexOfAny11<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static indexOfAny11(span: ReadOnlySpan_1<CLROf<char>>, values: SearchValues_1<CLROf<string>>): int;
    static indexOfAny11(span: Span_1<CLROf<char>>, values: SearchValues_1<CLROf<string>>): int;
    static indexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static indexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): int;
    static indexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T>): int;
    static indexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T>): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static indexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static indexOfAnyExceptInRange2<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static indexOfAnyExceptInRange2<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static indexOfAnyInRange2<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static indexOfAnyInRange2<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static isWhiteSpace(span: ReadOnlySpan_1<CLROf<char>>): boolean;
    static lastIndexOf6<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOf6<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): int;
    static lastIndexOf6<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOf6<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static lastIndexOf6<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): int;
    static lastIndexOf6<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static lastIndexOf6(span: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): int;
    static lastIndexOfAny10<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static lastIndexOfAny10<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOfAny10<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static lastIndexOfAny10<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static lastIndexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static lastIndexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOfAnyExcept13<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T>): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static lastIndexOfAnyExcept13<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static lastIndexOfAnyExceptInRange2<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static lastIndexOfAnyExceptInRange2<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static lastIndexOfAnyInRange2<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static lastIndexOfAnyInRange2<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static overlaps4<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, elementOffset: { value: ref<int> }): boolean;
    static overlaps4<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static overlaps4<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>, elementOffset: { value: ref<int> }): boolean;
    static overlaps4<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static replace4<T>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, oldValue: T, newValue: T, comparer?: IEqualityComparer_1<T>): void;
    static replace4<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, oldValue: T, newValue: T): void;
    static replace4<T>(span: Span_1<T>, oldValue: T, newValue: T, comparer?: IEqualityComparer_1<T>): void;
    static replace4<T extends IEquatable_1<T>>(span: Span_1<T>, oldValue: T, newValue: T): void;
    static replaceAny<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static replaceAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static replaceAnyExcept<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static replaceAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static reverse<T>(span: Span_1<T>): void;
    static sequenceCompareTo3<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, comparer?: IComparer_1<T>): int;
    static sequenceCompareTo3<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): int;
    static sequenceCompareTo3<T extends IComparable_1<T>>(span: Span_1<T>, other: ReadOnlySpan_1<T>): int;
    static sequenceEqual4<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): boolean;
    static sequenceEqual4<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static sequenceEqual4<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): boolean;
    static sequenceEqual4<T extends IEquatable_1<T>>(span: Span_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static sort3<T>(span: Span_1<T>, comparison: Comparison_1<T>): void;
    static sort3<TKey, TValue>(keys: Span_1<TKey>, items: Span_1<TValue>, comparison: Comparison_1<TKey>): void;
    static sort3<TKey, TValue, TComparer extends IComparer_1<TKey>>(keys: Span_1<TKey>, items: Span_1<TValue>, comparer: TComparer): void;
    static sort3<TKey, TValue>(keys: Span_1<TKey>, items: Span_1<TValue>): void;
    static sort3<T, TComparer extends IComparer_1<T>>(span: Span_1<T>, comparer: TComparer): void;
    static sort3<T>(span: Span_1<T>): void;
    static split2<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separator: ReadOnlySpan_1<T>): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static split2<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separator: T): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static split2(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<Range>, separator: char, options?: StringSplitOptions): int;
    static split2(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<Range>, separator: ReadOnlySpan_1<CLROf<char>>, options?: StringSplitOptions): int;
    static splitAny<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separators: ReadOnlySpan_1<T>): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static splitAny<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separators: SearchValues_1<T>): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static splitAny(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<Range>, separators: ReadOnlySpan_1<CLROf<char>>, options?: StringSplitOptions): int;
    static splitAny(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<Range>, separators: ReadOnlySpan_1<CLROf<string>>, options?: StringSplitOptions): int;
    static startsWith3<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T>): boolean;
    static startsWith3<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static startsWith3<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T>): boolean;
    static startsWith3<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static startsWith3<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static startsWith3(span: ReadOnlySpan_1<CLROf<char>>, value: ReadOnlySpan_1<CLROf<char>>, comparisonType: StringComparison): boolean;
    static toLower(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, culture: CultureInfo): int;
    static toLowerInvariant(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>): int;
    static toUpper(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, culture: CultureInfo): int;
    static toUpperInvariant(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>): int;
    static trim5<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElements: ReadOnlySpan_1<T>): Memory_1<T>;
    static trim5<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElement: T): Memory_1<T>;
    static trim5<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlyMemory_1<T>;
    static trim5<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElement: T): ReadOnlyMemory_1<T>;
    static trim5<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static trim5<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElement: T): ReadOnlySpan_1<T>;
    static trim5<T extends IEquatable_1<T>>(span: Span_1<T>, trimElements: ReadOnlySpan_1<T>): Span_1<T>;
    static trim5<T extends IEquatable_1<T>>(span: Span_1<T>, trimElement: T): Span_1<T>;
    static trim5(memory: Memory_1<CLROf<char>>): Memory_1<CLROf<char>>;
    static trim5(memory: ReadOnlyMemory_1<CLROf<char>>): ReadOnlyMemory_1<CLROf<char>>;
    static trim5(span: ReadOnlySpan_1<CLROf<char>>, trimChar: char): ReadOnlySpan_1<CLROf<char>>;
    static trim5(span: ReadOnlySpan_1<CLROf<char>>, trimChars: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static trim5(span: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static trim5(span: Span_1<CLROf<char>>): Span_1<CLROf<char>>;
    static trimEnd5<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElements: ReadOnlySpan_1<T>): Memory_1<T>;
    static trimEnd5<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElement: T): Memory_1<T>;
    static trimEnd5<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlyMemory_1<T>;
    static trimEnd5<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElement: T): ReadOnlyMemory_1<T>;
    static trimEnd5<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static trimEnd5<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElement: T): ReadOnlySpan_1<T>;
    static trimEnd5<T extends IEquatable_1<T>>(span: Span_1<T>, trimElements: ReadOnlySpan_1<T>): Span_1<T>;
    static trimEnd5<T extends IEquatable_1<T>>(span: Span_1<T>, trimElement: T): Span_1<T>;
    static trimEnd5(memory: Memory_1<CLROf<char>>): Memory_1<CLROf<char>>;
    static trimEnd5(memory: ReadOnlyMemory_1<CLROf<char>>): ReadOnlyMemory_1<CLROf<char>>;
    static trimEnd5(span: ReadOnlySpan_1<CLROf<char>>, trimChar: char): ReadOnlySpan_1<CLROf<char>>;
    static trimEnd5(span: ReadOnlySpan_1<CLROf<char>>, trimChars: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static trimEnd5(span: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static trimEnd5(span: Span_1<CLROf<char>>): Span_1<CLROf<char>>;
    static trimStart5<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElements: ReadOnlySpan_1<T>): Memory_1<T>;
    static trimStart5<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElement: T): Memory_1<T>;
    static trimStart5<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlyMemory_1<T>;
    static trimStart5<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElement: T): ReadOnlyMemory_1<T>;
    static trimStart5<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static trimStart5<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElement: T): ReadOnlySpan_1<T>;
    static trimStart5<T extends IEquatable_1<T>>(span: Span_1<T>, trimElements: ReadOnlySpan_1<T>): Span_1<T>;
    static trimStart5<T extends IEquatable_1<T>>(span: Span_1<T>, trimElement: T): Span_1<T>;
    static trimStart5(memory: Memory_1<CLROf<char>>): Memory_1<CLROf<char>>;
    static trimStart5(memory: ReadOnlyMemory_1<CLROf<char>>): ReadOnlyMemory_1<CLROf<char>>;
    static trimStart5(span: ReadOnlySpan_1<CLROf<char>>, trimChar: char): ReadOnlySpan_1<CLROf<char>>;
    static trimStart5(span: ReadOnlySpan_1<CLROf<char>>, trimChars: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static trimStart5(span: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static trimStart5(span: Span_1<CLROf<char>>): Span_1<CLROf<char>>;
    static tryWrite2(destination: Span_1<CLROf<char>>, provider: IFormatProvider, handler: { value: ref<MemoryExtensions_TryWriteInterpolatedStringHandler> }, charsWritten: { value: ref<int> }): boolean;
    static tryWrite2(destination: Span_1<CLROf<char>>, provider: IFormatProvider, format: CompositeFormat, charsWritten: { value: ref<int> }, args: unknown[]): boolean;
    static tryWrite2(destination: Span_1<CLROf<char>>, provider: IFormatProvider, format: CompositeFormat, charsWritten: { value: ref<int> }, args: ReadOnlySpan_1<unknown>): boolean;
    static tryWrite2<TArg0, TArg1, TArg2>(destination: Span_1<CLROf<char>>, provider: IFormatProvider, format: CompositeFormat, charsWritten: { value: ref<int> }, arg0: TArg0, arg1: TArg1, arg2: TArg2): boolean;
    static tryWrite2<TArg0, TArg1>(destination: Span_1<CLROf<char>>, provider: IFormatProvider, format: CompositeFormat, charsWritten: { value: ref<int> }, arg0: TArg0, arg1: TArg1): boolean;
    static tryWrite2<TArg0>(destination: Span_1<CLROf<char>>, provider: IFormatProvider, format: CompositeFormat, charsWritten: { value: ref<int> }, arg0: TArg0): boolean;
    static tryWrite2(destination: Span_1<CLROf<char>>, handler: { value: ref<MemoryExtensions_TryWriteInterpolatedStringHandler> }, charsWritten: { value: ref<int> }): boolean;
}


export type MemoryExtensions = MemoryExtensions$instance;

export abstract class Nullable$instance {
    static compare<T extends unknown>(n1: Nullable_1<T>, n2: Nullable_1<T>): int;
    static equals<T extends unknown>(n1: Nullable_1<T>, n2: Nullable_1<T>): boolean;
    static getUnderlyingType(nullableType: Type): Type;
    static getValueRefOrDefaultRef<T extends unknown>(nullable: { value: ref<Nullable_1<T>> }): ref<T>;
}


export type Nullable = Nullable$instance;

export abstract class StringNormalizationExtensions$instance {
    static getNormalizedLength(source: ReadOnlySpan_1<CLROf<char>>, normalizationForm?: NormalizationForm): int;
    static isNormalized3(source: ReadOnlySpan_1<CLROf<char>>, normalizationForm?: NormalizationForm): boolean;
    static isNormalized3(strInput: string, normalizationForm: NormalizationForm): boolean;
    static isNormalized3(strInput: string): boolean;
    static normalize2(strInput: string, normalizationForm: NormalizationForm): string;
    static normalize2(strInput: string): string;
    static tryNormalize(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }, normalizationForm?: NormalizationForm): boolean;
}


export type StringNormalizationExtensions = StringNormalizationExtensions$instance;

export abstract class Tuple$instance {
    static create8<T1, T2, T3, T4, T5, T6, T7, T8>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8): Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>;
    static create8<T1, T2, T3, T4, T5, T6, T7>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): Tuple_7<T1, T2, T3, T4, T5, T6, T7>;
    static create8<T1, T2, T3, T4, T5, T6>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): Tuple_6<T1, T2, T3, T4, T5, T6>;
    static create8<T1, T2, T3, T4, T5>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): Tuple_5<T1, T2, T3, T4, T5>;
    static create8<T1, T2, T3, T4>(item1: T1, item2: T2, item3: T3, item4: T4): Tuple_4<T1, T2, T3, T4>;
    static create8<T1, T2, T3>(item1: T1, item2: T2, item3: T3): Tuple_3<T1, T2, T3>;
    static create8<T1, T2>(item1: T1, item2: T2): Tuple_2<T1, T2>;
    static create8<T1>(item1: T1): Tuple_1<T1>;
}


export type Tuple = Tuple$instance;

export abstract class TupleExtensions$instance {
    static deconstruct<T1>(value: Tuple_1<T1>, item1: { value: ref<T1> }): void;
    static deconstruct<T1, T2>(value: Tuple_2<T1, T2>, item1: { value: ref<T1> }, item2: { value: ref<T2> }): void;
    static deconstruct<T1, T2, T3>(value: Tuple_3<T1, T2, T3>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }): void;
    static deconstruct<T1, T2, T3, T4>(value: Tuple_4<T1, T2, T3, T4>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }): void;
    static deconstruct<T1, T2, T3, T4, T5>(value: Tuple_5<T1, T2, T3, T4, T5>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6>(value: Tuple_6<T1, T2, T3, T4, T5, T6>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7>(value: Tuple_7<T1, T2, T3, T4, T5, T6, T7>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_7<T15, T16, T17, T18, T19, T20, T21>>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }, item15: { value: ref<T15> }, item16: { value: ref<T16> }, item17: { value: ref<T17> }, item18: { value: ref<T18> }, item19: { value: ref<T19> }, item20: { value: ref<T20> }, item21: { value: ref<T21> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_6<T15, T16, T17, T18, T19, T20>>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }, item15: { value: ref<T15> }, item16: { value: ref<T16> }, item17: { value: ref<T17> }, item18: { value: ref<T18> }, item19: { value: ref<T19> }, item20: { value: ref<T20> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_5<T15, T16, T17, T18, T19>>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }, item15: { value: ref<T15> }, item16: { value: ref<T16> }, item17: { value: ref<T17> }, item18: { value: ref<T18> }, item19: { value: ref<T19> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_4<T15, T16, T17, T18>>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }, item15: { value: ref<T15> }, item16: { value: ref<T16> }, item17: { value: ref<T17> }, item18: { value: ref<T18> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_3<T15, T16, T17>>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }, item15: { value: ref<T15> }, item16: { value: ref<T16> }, item17: { value: ref<T17> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_2<T15, T16>>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }, item15: { value: ref<T15> }, item16: { value: ref<T16> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_1<T15>>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }, item15: { value: ref<T15> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_7<T8, T9, T10, T11, T12, T13, T14>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }, item14: { value: ref<T14> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_6<T8, T9, T10, T11, T12, T13>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }, item13: { value: ref<T13> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_5<T8, T9, T10, T11, T12>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }, item12: { value: ref<T12> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_4<T8, T9, T10, T11>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }, item11: { value: ref<T11> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_3<T8, T9, T10>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }, item10: { value: ref<T10> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_2<T8, T9>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }, item9: { value: ref<T9> }): void;
    static deconstruct<T1, T2, T3, T4, T5, T6, T7, T8>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>, item1: { value: ref<T1> }, item2: { value: ref<T2> }, item3: { value: ref<T3> }, item4: { value: ref<T4> }, item5: { value: ref<T5> }, item6: { value: ref<T6> }, item7: { value: ref<T7> }, item8: { value: ref<T8> }): void;
    static toTuple<T1>(value: ValueTuple_1<T1>): Tuple_1<T1>;
    static toTuple<T1, T2>(value: ValueTuple_2<T1, T2>): Tuple_2<T1, T2>;
    static toTuple<T1, T2, T3>(value: ValueTuple_3<T1, T2, T3>): Tuple_3<T1, T2, T3>;
    static toTuple<T1, T2, T3, T4>(value: ValueTuple_4<T1, T2, T3, T4>): Tuple_4<T1, T2, T3, T4>;
    static toTuple<T1, T2, T3, T4, T5>(value: ValueTuple_5<T1, T2, T3, T4, T5>): Tuple_5<T1, T2, T3, T4, T5>;
    static toTuple<T1, T2, T3, T4, T5, T6>(value: ValueTuple_6<T1, T2, T3, T4, T5, T6>): Tuple_6<T1, T2, T3, T4, T5, T6>;
    static toTuple<T1, T2, T3, T4, T5, T6, T7>(value: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): Tuple_7<T1, T2, T3, T4, T5, T6, T7>;
    static toTuple<T1, T2, T3, T4, T5, T6, T7, T8>(value: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, ValueTuple_1<T8>>): Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>;
    static toValueTuple<T1>(value: Tuple_1<T1>): ValueTuple_1<T1>;
    static toValueTuple<T1, T2>(value: Tuple_2<T1, T2>): ValueTuple_2<T1, T2>;
    static toValueTuple<T1, T2, T3>(value: Tuple_3<T1, T2, T3>): ValueTuple_3<T1, T2, T3>;
    static toValueTuple<T1, T2, T3, T4>(value: Tuple_4<T1, T2, T3, T4>): ValueTuple_4<T1, T2, T3, T4>;
    static toValueTuple<T1, T2, T3, T4, T5>(value: Tuple_5<T1, T2, T3, T4, T5>): ValueTuple_5<T1, T2, T3, T4, T5>;
    static toValueTuple<T1, T2, T3, T4, T5, T6>(value: Tuple_6<T1, T2, T3, T4, T5, T6>): ValueTuple_6<T1, T2, T3, T4, T5, T6>;
    static toValueTuple<T1, T2, T3, T4, T5, T6, T7>(value: Tuple_7<T1, T2, T3, T4, T5, T6, T7>): ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>;
    static toValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>): ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, ValueTuple_1<T8>>;
}


export type TupleExtensions = TupleExtensions$instance;

