// Generated by tsbindgen - Architecture
// Namespace: System.Buffers.Text
// Assembly: System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { OperationStatus, StandardFormat } from "../../System.Buffers/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Guid, Int16, Int32, Int64, Object as ClrObject, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, TimeSpan, Type, UInt16, UInt32, UInt64 } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export abstract class Base64$instance {
    static DecodeFromUtf8(utf8: ReadOnlySpan_1<CLROf<byte>>, bytes: Span_1<CLROf<byte>>, bytesConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, isFinalBlock?: boolean): OperationStatus;
    static DecodeFromUtf8InPlace(buffer: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static EncodeToUtf8(bytes: ReadOnlySpan_1<CLROf<byte>>, utf8: Span_1<CLROf<byte>>, bytesConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, isFinalBlock?: boolean): OperationStatus;
    static EncodeToUtf8InPlace(buffer: Span_1<CLROf<byte>>, dataLength: int, bytesWritten: { value: TSByRef<int> }): OperationStatus;
    static GetMaxDecodedFromUtf8Length(length: int): int;
    static GetMaxEncodedToUtf8Length(length: int): int;
    static IsValid(base64TextUtf8: ReadOnlySpan_1<CLROf<byte>>, decodedLength: { value: TSByRef<int> }): boolean;
    static IsValid(base64TextUtf8: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static IsValid(base64Text: ReadOnlySpan_1<CLROf<string>>, decodedLength: { value: TSByRef<int> }): boolean;
    static IsValid(base64Text: ReadOnlySpan_1<CLROf<string>>): boolean;
}


export type Base64 = Base64$instance;

export abstract class Base64Url$instance {
    static DecodeFromChars(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, charsConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, isFinalBlock?: boolean): OperationStatus;
    static DecodeFromChars(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>): int;
    static DecodeFromChars(source: ReadOnlySpan_1<CLROf<string>>): byte[];
    static DecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, isFinalBlock?: boolean): OperationStatus;
    static DecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static DecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static DecodeFromUtf8InPlace(buffer: Span_1<CLROf<byte>>): int;
    static EncodeToChars(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, bytesConsumed: { value: TSByRef<int> }, charsWritten: { value: TSByRef<int> }, isFinalBlock?: boolean): OperationStatus;
    static EncodeToChars(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>): int;
    static EncodeToChars(source: ReadOnlySpan_1<CLROf<byte>>): string[];
    static EncodeToString(source: ReadOnlySpan_1<CLROf<byte>>): string;
    static EncodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, isFinalBlock?: boolean): OperationStatus;
    static EncodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static EncodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static GetEncodedLength(bytesLength: int): int;
    static GetMaxDecodedLength(base64Length: int): int;
    static IsValid(utf8Base64UrlText: ReadOnlySpan_1<CLROf<byte>>, decodedLength: { value: TSByRef<int> }): boolean;
    static IsValid(utf8Base64UrlText: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static IsValid(base64UrlText: ReadOnlySpan_1<CLROf<string>>, decodedLength: { value: TSByRef<int> }): boolean;
    static IsValid(base64UrlText: ReadOnlySpan_1<CLROf<string>>): boolean;
    static TryDecodeFromChars(source: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static TryDecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static TryEncodeToChars(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    static TryEncodeToUtf8(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static TryEncodeToUtf8InPlace(buffer: Span_1<CLROf<byte>>, dataLength: int, bytesWritten: { value: TSByRef<int> }): boolean;
}


export type Base64Url = Base64Url$instance;

export abstract class Utf8Formatter$instance {
    static TryFormat(value: boolean, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: byte, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: DateTime, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: DateTimeOffset, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: decimal, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: double, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: Guid, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: short, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: int, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: long, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: sbyte, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: float, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: TimeSpan, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: ushort, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: uint, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
    static TryFormat(value: ulong, destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, format?: StandardFormat): boolean;
}


export type Utf8Formatter = Utf8Formatter$instance;

export abstract class Utf8Parser$instance {
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<boolean> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<byte> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<DateTime> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<DateTimeOffset> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<decimal> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<double> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<Guid> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<short> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<long> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<sbyte> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<float> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<TimeSpan> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<ushort> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<uint> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
    static TryParse(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<ulong> }, bytesConsumed: { value: TSByRef<int> }, standardFormat?: string): boolean;
}


export type Utf8Parser = Utf8Parser$instance;

