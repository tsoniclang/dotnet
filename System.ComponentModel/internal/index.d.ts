// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel
// Assembly: System.ComponentModel, System.ComponentModel.EventBasedAsync, System.ComponentModel.Primitives, System.ComponentModel.TypeConverter, System.ObjectModel, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { Hashtable, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase } from "../../System.Collections/internal/index.js";
import type { IDesigner } from "../../System.ComponentModel.Design/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { UnmanagedMemoryStream } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Resources_Internal from "../../System.Resources/internal/index.js";
import type { ResourceManager, ResourceSet } from "../../System.Resources/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ExternalException } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SendOrPostCallback, SynchronizationContext } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Delegate, Double, Enum, EventArgs, EventHandler, EventHandler_1, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IServiceProvider, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Nullable_1, Object as ClrObject, SByte, Single, String as ClrString, SystemException, Type, TypeCode, UInt16, UInt32, UInt64, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum BindableSupport {
    No = 0,
    Yes = 1,
    Default = 2
}


export enum BindingDirection {
    OneWay = 0,
    TwoWay = 1
}


export enum CollectionChangeAction {
    Add = 1,
    Remove = 2,
    Refresh = 3
}


export enum DataObjectMethodType {
    Fill = 0,
    Select = 1,
    Update = 2,
    Insert = 3,
    Delete = 4
}


export enum DesignerSerializationVisibility {
    Hidden = 0,
    Visible = 1,
    Content = 2
}


export enum EditorBrowsableState {
    Always = 0,
    Never = 1,
    Advanced = 2
}


export enum InheritanceLevel {
    Inherited = 1,
    InheritedReadOnly = 2,
    NotInherited = 3
}


export enum LicenseUsageMode {
    Runtime = 0,
    Designtime = 1
}


export enum ListChangedType {
    Reset = 0,
    ItemAdded = 1,
    ItemDeleted = 2,
    ItemMoved = 3,
    ItemChanged = 4,
    PropertyDescriptorAdded = 5,
    PropertyDescriptorDeleted = 6,
    PropertyDescriptorChanged = 7
}


export enum ListSortDirection {
    Ascending = 0,
    Descending = 1
}


export enum MaskedTextResultHint {
    Unknown = 0,
    CharacterEscaped = 1,
    NoEffect = 2,
    SideEffect = 3,
    Success = 4,
    AsciiCharacterExpected = -1,
    AlphanumericCharacterExpected = -2,
    DigitExpected = -3,
    LetterExpected = -4,
    SignedDigitExpected = -5,
    InvalidInput = -51,
    PromptCharNotAllowed = -52,
    UnavailableEditPosition = -53,
    NonEditPosition = -54,
    PositionOutOfRange = -55
}


export enum PropertyTabScope {
    Static = 0,
    Global = 1,
    Document = 2,
    Component = 3
}


export enum RefreshProperties {
    None = 0,
    All = 1,
    Repaint = 2
}


export enum ToolboxItemFilterType {
    Allow = 0,
    Custom = 1,
    Prevent = 2,
    Require = 3
}


export interface IBindingList$instance {
    readonly AllowNew: boolean;
    readonly AllowEdit: boolean;
    readonly AllowRemove: boolean;
    readonly SupportsChangeNotification: boolean;
    readonly SupportsSearching: boolean;
    readonly SupportsSorting: boolean;
    readonly IsSorted: boolean;
    readonly SortProperty: PropertyDescriptor;
    readonly SortDirection: ListSortDirection;
    Item: any;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(value: any): int;
    AddIndex(property: PropertyDescriptor): void;
    AddNew(): any;
    ApplySort(property: PropertyDescriptor, direction: ListSortDirection): void;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Find(property: PropertyDescriptor, key: any): int;
    GetEnumerator(): IEnumerator;
    Insert(index: int, value: any): void;
    Remove(value: any): void;
    RemoveAt(index: int): void;
    RemoveSort(): void;
}


export type IBindingList = IBindingList$instance;

export interface IBindingListView$instance {
    Filter: string;
    readonly SortDescriptions: ListSortDescriptionCollection;
    readonly SupportsAdvancedSorting: boolean;
    readonly SupportsFiltering: boolean;
    readonly AllowNew: boolean;
    readonly AllowEdit: boolean;
    readonly AllowRemove: boolean;
    readonly SupportsChangeNotification: boolean;
    readonly SupportsSearching: boolean;
    readonly SupportsSorting: boolean;
    readonly IsSorted: boolean;
    readonly SortProperty: PropertyDescriptor;
    readonly SortDirection: ListSortDirection;
    Item: any;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: any;
    readonly IsSynchronized: boolean;
    Add(value: any): int;
    AddIndex(property: PropertyDescriptor): void;
    AddNew(): any;
    ApplySort(property: PropertyDescriptor, direction: ListSortDirection): void;
    ApplySort(sorts: ListSortDescriptionCollection): void;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Find(property: PropertyDescriptor, key: any): int;
    GetEnumerator(): IEnumerator;
    Insert(index: int, value: any): void;
    Remove(value: any): void;
    RemoveAt(index: int): void;
    RemoveFilter(): void;
}


export type IBindingListView = IBindingListView$instance;

export interface ICancelAddNew$instance {
    CancelNew(itemIndex: int): void;
}


export type ICancelAddNew = ICancelAddNew$instance;

export interface IChangeTracking$instance {
    readonly IsChanged: boolean;
    AcceptChanges(): void;
}


export type IChangeTracking = IChangeTracking$instance;

export interface IComNativeDescriptorHandler$instance {
    GetAttributes(component: any): AttributeCollection;
    GetClassName(component: any): string;
    GetConverter(component: any): TypeConverter;
    GetDefaultEvent(component: any): EventDescriptor;
    GetDefaultProperty(component: any): PropertyDescriptor;
    GetEditor(component: any, baseEditorType: Type): any;
    GetEvents(component: any, attributes: Attribute[]): EventDescriptorCollection;
    GetEvents(component: any): EventDescriptorCollection;
    GetProperties(component: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertyValue(component: any, dispid: int, success: { value: ref<boolean> }): any;
    GetPropertyValue(component: any, propertyName: string, success: { value: ref<boolean> }): any;
}


export type IComNativeDescriptorHandler = IComNativeDescriptorHandler$instance;

export interface IComponent$instance {
    Site: ISite;
    Dispose(): void;
}


export type IComponent = IComponent$instance;

export interface IContainer$instance {
    readonly Components: ComponentCollection;
    Add(component: IComponent, name: string): void;
    Add(component: IComponent): void;
    Dispose(): void;
}


export type IContainer = IContainer$instance;

export interface ICustomTypeDescriptor$instance {
    readonly RequireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    GetAttributes(): AttributeCollection;
    GetClassName(): string;
    GetConverter(): TypeConverter;
    GetDefaultEvent(): EventDescriptor;
    GetDefaultProperty(): PropertyDescriptor;
    GetEditor(editorBaseType: Type): any;
    GetEvents(): EventDescriptorCollection;
    GetEvents(attributes: Attribute[]): EventDescriptorCollection;
    GetProperties(): PropertyDescriptorCollection;
    GetProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertyOwner(pd: PropertyDescriptor): any;
}


export type ICustomTypeDescriptor = ICustomTypeDescriptor$instance;

export interface IDataErrorInfo$instance {
    readonly Item: string;
    readonly Error: string;
}


export type IDataErrorInfo = IDataErrorInfo$instance;

export interface IEditableObject$instance {
    BeginEdit(): void;
}


export type IEditableObject = IEditableObject$instance;

export interface IExtenderProvider$instance {
    CanExtend(extendee: any): boolean;
}


export type IExtenderProvider = IExtenderProvider$instance;

export interface IIntellisenseBuilder$instance {
    readonly Name: string;
    Show(language: string, value: string, newValue: { value: ref<string> }): boolean;
}


export type IIntellisenseBuilder = IIntellisenseBuilder$instance;

export interface IListSource$instance {
    readonly ContainsListCollection: boolean;
    GetList(): IList;
}


export type IListSource = IListSource$instance;

export interface INestedContainer$instance {
    readonly Owner: IComponent;
    readonly Components: ComponentCollection;
    Add(component: IComponent, name: string): void;
    Add(component: IComponent): void;
    Dispose(): void;
}


export type INestedContainer = INestedContainer$instance;

export interface INestedSite$instance {
    readonly FullName: string;
    readonly Component: IComponent;
    readonly Container: IContainer;
    readonly DesignMode: boolean;
    Name: string;
    GetService(serviceType: Type): any;
}


export type INestedSite = INestedSite$instance;

export interface INotifyDataErrorInfo$instance {
    readonly HasErrors: boolean;
    GetErrors(propertyName: string): IEnumerable;
}


export type INotifyDataErrorInfo = INotifyDataErrorInfo$instance;

export interface INotifyPropertyChanged$instance {
}


export type INotifyPropertyChanged = INotifyPropertyChanged$instance;

export interface INotifyPropertyChanging$instance {
}


export type INotifyPropertyChanging = INotifyPropertyChanging$instance;

export interface IRaiseItemChangedEvents$instance {
    readonly RaisesItemChangedEvents: boolean;
}


export type IRaiseItemChangedEvents = IRaiseItemChangedEvents$instance;

export interface IRevertibleChangeTracking$instance {
    readonly IsChanged: boolean;
    RejectChanges(): void;
}


export type IRevertibleChangeTracking = IRevertibleChangeTracking$instance;

export interface ISite$instance {
    readonly Component: IComponent;
    readonly Container: IContainer;
    readonly DesignMode: boolean;
    Name: string;
    GetService(serviceType: Type): any;
}


export type ISite = ISite$instance;

export interface ISupportInitialize$instance {
    BeginInit(): void;
}


export type ISupportInitialize = ISupportInitialize$instance;

export interface ISupportInitializeNotification$instance {
    readonly IsInitialized: boolean;
    BeginInit(): void;
}


export type ISupportInitializeNotification = ISupportInitializeNotification$instance;

export interface ISynchronizeInvoke$instance {
    readonly InvokeRequired: boolean;
    BeginInvoke(method: Function, args: any[]): IAsyncResult;
    EndInvoke(result: IAsyncResult): any;
    Invoke(method: Function, args: any[]): any;
}


export type ISynchronizeInvoke = ISynchronizeInvoke$instance;

export interface ITypeDescriptorContext$instance {
    readonly Container: IContainer;
    readonly Instance: any;
    readonly PropertyDescriptor: PropertyDescriptor;
    GetService(serviceType: Type): any;
    OnComponentChanged(): void;
    OnComponentChanging(): boolean;
}


export type ITypeDescriptorContext = ITypeDescriptorContext$instance;

export interface ITypedList$instance {
    GetItemProperties(listAccessors: PropertyDescriptor[]): PropertyDescriptorCollection;
    GetListName(listAccessors: PropertyDescriptor[]): string;
}


export type ITypedList = ITypedList$instance;

export class AddingNewEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    constructor(newObject: any);
    NewObject: any;
}


export type AddingNewEventArgs = AddingNewEventArgs$instance;

export class AddingNewEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: AddingNewEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: AddingNewEventArgs): void;
}


export interface __AddingNewEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AddingNewEventHandler = AddingNewEventHandler$instance & __AddingNewEventHandler$views;


export class AmbientValueAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type, value: string);
    constructor(value: string);
    constructor(value: byte);
    constructor(value: short);
    constructor(value: int);
    constructor(value: long);
    constructor(value: float);
    constructor(value: double);
    constructor(value: boolean);
    constructor(value: string);
    constructor(value: any);
    readonly Value: any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type AmbientValueAttribute = AmbientValueAttribute$instance;

export class ArrayConverter$instance extends CollectionConverter$instance {
    constructor();
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    GetProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type ArrayConverter = ArrayConverter$instance;

export class AsyncCompletedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(error: Exception, cancelled: boolean, userState: any);
    readonly Cancelled: boolean;
    readonly Error: Exception;
    readonly UserState: any;
}


export type AsyncCompletedEventArgs = AsyncCompletedEventArgs$instance;

export class AsyncCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: AsyncCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: AsyncCompletedEventArgs): void;
}


export interface __AsyncCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AsyncCompletedEventHandler = AsyncCompletedEventHandler$instance & __AsyncCompletedEventHandler$views;


export class AsyncOperation$instance {
    readonly SynchronizationContext: SynchronizationContext;
    readonly UserSuppliedState: any;
    OperationCompleted(): void;
    Post(d: SendOrPostCallback, arg: any): void;
    PostOperationCompleted(d: SendOrPostCallback, arg: any): void;
}


export type AsyncOperation = AsyncOperation$instance;

export class AttributeCollection$instance {
    constructor(attributes: Attribute[]);
    readonly Count: int;
    Contains(attribute: Attribute): boolean;
    Contains(attributes: Attribute[]): boolean;
    CopyTo(array: ClrArray, index: int): void;
    get_Item(index: int): Attribute;
    get_Item(attributeType: Type): Attribute;
    GetEnumerator(): IEnumerator;
    Matches(attribute: Attribute): boolean;
    Matches(attributes: Attribute[]): boolean;
    static readonly Empty: AttributeCollection;
    static FromExisting(existing: AttributeCollection, newAttributes: Attribute[]): AttributeCollection;
}


export interface __AttributeCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type AttributeCollection = AttributeCollection$instance & __AttributeCollection$views;


export class AttributeProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(typeName: string);
    constructor(typeName: string, propertyName: string);
    constructor(type_: Type);
    readonly PropertyName: string;
    readonly TypeName: string;
}


export type AttributeProviderAttribute = AttributeProviderAttribute$instance;

export class BackgroundWorker$instance extends Component$instance {
    constructor();
    readonly CancellationPending: boolean;
    readonly IsBusy: boolean;
    WorkerReportsProgress: boolean;
    WorkerSupportsCancellation: boolean;
    CancelAsync(): void;
    Dispose(): void;
    ReportProgress(percentProgress: int): void;
    ReportProgress(percentProgress: int, userState: any): void;
    RunWorkerAsync(): void;
    RunWorkerAsync(argument: any): void;
}


export interface __BackgroundWorker$views {
    readonly As_IComponent: IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type BackgroundWorker = BackgroundWorker$instance & __BackgroundWorker$views;


export abstract class BaseNumberConverter$instance extends TypeConverter$instance {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type BaseNumberConverter = BaseNumberConverter$instance;

export class BindableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(bindable: boolean);
    constructor(bindable: boolean, direction: BindingDirection);
    constructor(flags: BindableSupport);
    constructor(flags: BindableSupport, direction: BindingDirection);
    readonly Bindable: boolean;
    readonly Direction: BindingDirection;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: BindableAttribute;
    static readonly No: BindableAttribute;
    static readonly Default: BindableAttribute;
}


export type BindableAttribute = BindableAttribute$instance;

export class BindingList_1$instance<T> extends System_Collections_ObjectModel_Internal.Collection_1$instance<T> {
    constructor();
    constructor(list: IList_1<T>);
    AllowEdit: boolean;
    AllowNew: boolean;
    AllowRemove: boolean;
    RaiseListChangedEvents: boolean;
    Add(item: T): void;
    Add(value: any): int;
    AddNew(): T;
    CancelNew(itemIndex: int): void;
    Clear(): void;
    Contains(item: T): boolean;
    Contains(value: any): boolean;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    EndNew(itemIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: T): int;
    Insert(index: int, item: T): void;
    Insert(index: int, value: any): void;
    Remove(item: T): boolean;
    Remove(value: any): void;
    RemoveAt(index: int): void;
    ResetBindings(): void;
    ResetItem(position: int): void;
}


export interface __BindingList_1$views<T> {
    readonly As_IBindingList: IBindingList$instance;
    readonly As_ICancelAddNew: ICancelAddNew$instance;
    readonly As_IRaiseItemChangedEvents: IRaiseItemChangedEvents$instance;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type BindingList_1<T> = BindingList_1$instance<T> & __BindingList_1$views<T>;


export class BooleanConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export type BooleanConverter = BooleanConverter$instance;

export class BrowsableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(browsable: boolean);
    readonly Browsable: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: BrowsableAttribute;
    static readonly No: BrowsableAttribute;
    static readonly Default: BrowsableAttribute;
}


export type BrowsableAttribute = BrowsableAttribute$instance;

export class ByteConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type ByteConverter = ByteConverter$instance;

export class CancelEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    constructor(cancel: boolean);
    Cancel: boolean;
}


export type CancelEventArgs = CancelEventArgs$instance;

export class CancelEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: CancelEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: CancelEventArgs): void;
}


export interface __CancelEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CancelEventHandler = CancelEventHandler$instance & __CancelEventHandler$views;


export class CategoryAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(category: string);
    readonly Category: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Action: CategoryAttribute;
    static readonly Appearance: CategoryAttribute;
    static readonly Asynchronous: CategoryAttribute;
    static readonly Behavior: CategoryAttribute;
    static readonly Data: CategoryAttribute;
    static readonly Default: CategoryAttribute;
    static readonly Design: CategoryAttribute;
    static readonly DragDrop: CategoryAttribute;
    static readonly Focus: CategoryAttribute;
    static readonly Format: CategoryAttribute;
    static readonly Key: CategoryAttribute;
    static readonly Layout: CategoryAttribute;
    static readonly Mouse: CategoryAttribute;
    static readonly WindowStyle: CategoryAttribute;
}


export type CategoryAttribute = CategoryAttribute$instance;

export class CharConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type CharConverter = CharConverter$instance;

export class CollectionChangeEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(action: CollectionChangeAction, element: any);
    readonly Action: CollectionChangeAction;
    readonly Element: any;
}


export type CollectionChangeEventArgs = CollectionChangeEventArgs$instance;

export class CollectionChangeEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: CollectionChangeEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: CollectionChangeEventArgs): void;
}


export interface __CollectionChangeEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CollectionChangeEventHandler = CollectionChangeEventHandler$instance & __CollectionChangeEventHandler$views;


export class CollectionConverter$instance extends TypeConverter$instance {
    constructor();
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    GetProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
}


export type CollectionConverter = CollectionConverter$instance;

export class ComplexBindingPropertiesAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(dataSource: string);
    constructor(dataSource: string, dataMember: string);
    readonly DataMember: string;
    readonly DataSource: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static readonly Default: ComplexBindingPropertiesAttribute;
}


export type ComplexBindingPropertiesAttribute = ComplexBindingPropertiesAttribute$instance;

export class Component$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    readonly Container: IContainer;
    Site: ISite;
    Dispose(): void;
    ToString(): string;
}


export interface __Component$views {
    readonly As_IComponent: IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Component = Component$instance & __Component$views;


export class ComponentCollection$instance extends System_Collections_Internal.ReadOnlyCollectionBase$instance {
    constructor(components: IComponent[]);
    CopyTo(array: ClrArray, index: int): void;
    get_Item(name: string): IComponent;
    get_Item(index: int): IComponent;
    GetEnumerator(): IEnumerator;
}


export interface __ComponentCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ComponentCollection = ComponentCollection$instance & __ComponentCollection$views;


export class ComponentConverter$instance extends ReferenceConverter$instance {
    constructor(type_: Type);
    GetProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type ComponentConverter = ComponentConverter$instance;

export abstract class ComponentEditor$instance {
    EditComponent(component: any): boolean;
    EditComponent(context: ITypeDescriptorContext, component: any): boolean;
}


export type ComponentEditor = ComponentEditor$instance;

export class ComponentResourceManager$instance extends System_Resources_Internal.ResourceManager$instance {
    constructor();
    constructor(t: Type);
    ApplyResources(value: any, objectName: string): void;
    ApplyResources(value: any, objectName: string, culture: CultureInfo): void;
    ApplyResourcesToRegisteredType(value: any, objectName: string, culture: CultureInfo): void;
}


export type ComponentResourceManager = ComponentResourceManager$instance;

export class Container$instance {
    constructor();
    readonly Components: ComponentCollection;
    Add(component: IComponent): void;
    Add(component: IComponent, name: string): void;
    Dispose(): void;
    Remove(component: IComponent): void;
}


export interface __Container$views {
    readonly As_IContainer: IContainer$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Container = Container$instance & __Container$views;


export abstract class ContainerFilterService$instance {
    FilterComponents(components: ComponentCollection): ComponentCollection;
}


export type ContainerFilterService = ContainerFilterService$instance;

export class CultureInfoConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export type CultureInfoConverter = CultureInfoConverter$instance;

export abstract class CustomTypeDescriptor$instance {
    readonly RequireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    GetAttributes(): AttributeCollection;
    GetClassName(): string;
    GetComponentName(): string;
    GetConverter(): TypeConverter;
    GetConverterFromRegisteredType(): TypeConverter;
    GetDefaultEvent(): EventDescriptor;
    GetDefaultProperty(): PropertyDescriptor;
    GetEditor(editorBaseType: Type): any;
    GetEvents(): EventDescriptorCollection;
    GetEvents(attributes: Attribute[]): EventDescriptorCollection;
    GetEventsFromRegisteredType(): EventDescriptorCollection;
    GetProperties(): PropertyDescriptorCollection;
    GetProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertiesFromRegisteredType(): PropertyDescriptorCollection;
    GetPropertyOwner(pd: PropertyDescriptor): any;
}


export interface __CustomTypeDescriptor$views {
    readonly As_ICustomTypeDescriptor: ICustomTypeDescriptor$instance;
}

export type CustomTypeDescriptor = CustomTypeDescriptor$instance & __CustomTypeDescriptor$views;


export class DataErrorsChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(propertyName: string);
    readonly PropertyName: string;
}


export type DataErrorsChangedEventArgs = DataErrorsChangedEventArgs$instance;

export class DataObjectAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(isDataObject: boolean);
    readonly IsDataObject: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly DataObject: DataObjectAttribute;
    static readonly NonDataObject: DataObjectAttribute;
    static readonly Default: DataObjectAttribute;
}


export type DataObjectAttribute = DataObjectAttribute$instance;

export class DataObjectFieldAttribute$instance extends System_Internal.Attribute$instance {
    constructor(primaryKey: boolean);
    constructor(primaryKey: boolean, isIdentity: boolean);
    constructor(primaryKey: boolean, isIdentity: boolean, isNullable: boolean);
    constructor(primaryKey: boolean, isIdentity: boolean, isNullable: boolean, length: int);
    readonly IsIdentity: boolean;
    readonly IsNullable: boolean;
    readonly Length: int;
    readonly PrimaryKey: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type DataObjectFieldAttribute = DataObjectFieldAttribute$instance;

export class DataObjectMethodAttribute$instance extends System_Internal.Attribute$instance {
    constructor(methodType: DataObjectMethodType);
    constructor(methodType: DataObjectMethodType, isDefault: boolean);
    readonly IsDefault: boolean;
    readonly MethodType: DataObjectMethodType;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    Match(obj: any): boolean;
}


export type DataObjectMethodAttribute = DataObjectMethodAttribute$instance;

export class DateOnlyConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type DateOnlyConverter = DateOnlyConverter$instance;

export class DateTimeConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type DateTimeConverter = DateTimeConverter$instance;

export class DateTimeOffsetConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type DateTimeOffsetConverter = DateTimeOffsetConverter$instance;

export class DecimalConverter$instance extends BaseNumberConverter$instance {
    constructor();
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type DecimalConverter = DecimalConverter$instance;

export class DefaultBindingPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(name: string);
    readonly Name: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static readonly Default: DefaultBindingPropertyAttribute;
}


export type DefaultBindingPropertyAttribute = DefaultBindingPropertyAttribute$instance;

export class DefaultEventAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly Name: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static readonly Default: DefaultEventAttribute;
}


export type DefaultEventAttribute = DefaultEventAttribute$instance;

export class DefaultPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly Name: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static readonly Default: DefaultPropertyAttribute;
}


export type DefaultPropertyAttribute = DefaultPropertyAttribute$instance;

export class DefaultValueAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type, value: string);
    constructor(value: string);
    constructor(value: byte);
    constructor(value: short);
    constructor(value: int);
    constructor(value: long);
    constructor(value: float);
    constructor(value: double);
    constructor(value: boolean);
    constructor(value: string);
    constructor(value: any);
    constructor(value: sbyte);
    constructor(value: ushort);
    constructor(value: uint);
    constructor(value: ulong);
    readonly Value: any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type DefaultValueAttribute = DefaultValueAttribute$instance;

export class DescriptionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(description: string);
    readonly Description: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Default: DescriptionAttribute;
}


export type DescriptionAttribute = DescriptionAttribute$instance;

export class DesignerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(designerTypeName: string);
    constructor(designerType: Type);
    constructor(designerTypeName: string, designerBaseTypeName: string);
    constructor(designerTypeName: string, designerBaseType: Type);
    constructor(designerType: Type, designerBaseType: Type);
    readonly DesignerBaseTypeName: string;
    readonly DesignerTypeName: string;
    readonly TypeId: any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type DesignerAttribute = DesignerAttribute$instance;

export class DesignerCategoryAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(category: string);
    readonly Category: string;
    readonly TypeId: any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Component: DesignerCategoryAttribute;
    static readonly Default: DesignerCategoryAttribute;
    static readonly Form: DesignerCategoryAttribute;
    static readonly Generic: DesignerCategoryAttribute;
}


export type DesignerCategoryAttribute = DesignerCategoryAttribute$instance;

export class DesignerSerializationVisibilityAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visibility: DesignerSerializationVisibility);
    readonly Visibility: DesignerSerializationVisibility;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Content: DesignerSerializationVisibilityAttribute;
    static readonly Hidden: DesignerSerializationVisibilityAttribute;
    static readonly Visible: DesignerSerializationVisibilityAttribute;
    static readonly Default: DesignerSerializationVisibilityAttribute;
}


export type DesignerSerializationVisibilityAttribute = DesignerSerializationVisibilityAttribute$instance;

export class DesignOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isDesignOnly: boolean);
    readonly IsDesignOnly: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: DesignOnlyAttribute;
    static readonly No: DesignOnlyAttribute;
    static readonly Default: DesignOnlyAttribute;
}


export type DesignOnlyAttribute = DesignOnlyAttribute$instance;

export class DesignTimeVisibleAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visible: boolean);
    constructor();
    readonly Visible: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: DesignTimeVisibleAttribute;
    static readonly No: DesignTimeVisibleAttribute;
    static readonly Default: DesignTimeVisibleAttribute;
}


export type DesignTimeVisibleAttribute = DesignTimeVisibleAttribute$instance;

export class DisplayNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(displayName: string);
    readonly DisplayName: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Default: DisplayNameAttribute;
}


export type DisplayNameAttribute = DisplayNameAttribute$instance;

export class DoubleConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type DoubleConverter = DoubleConverter$instance;

export class DoWorkEventArgs$instance extends CancelEventArgs$instance {
    constructor(argument: any);
    readonly Argument: any;
    Result: any;
}


export type DoWorkEventArgs = DoWorkEventArgs$instance;

export class DoWorkEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: DoWorkEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: DoWorkEventArgs): void;
}


export interface __DoWorkEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DoWorkEventHandler = DoWorkEventHandler$instance & __DoWorkEventHandler$views;


export class EditorAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(typeName: string, baseTypeName: string);
    constructor(typeName: string, baseType: Type);
    constructor(type_: Type, baseType: Type);
    readonly EditorBaseTypeName: string;
    readonly EditorTypeName: string;
    readonly TypeId: any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type EditorAttribute = EditorAttribute$instance;

export class EditorBrowsableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(state: EditorBrowsableState);
    constructor();
    readonly State: EditorBrowsableState;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type EditorBrowsableAttribute = EditorBrowsableAttribute$instance;

export class EnumConverter$instance extends TypeConverter$instance {
    constructor(type_: Type);
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
    IsValid(context: ITypeDescriptorContext, value: any): boolean;
    IsValid(value: any): boolean;
}


export type EnumConverter = EnumConverter$instance;

export abstract class EventDescriptor$instance extends MemberDescriptor$instance {
    readonly ComponentType: Type;
    readonly EventType: Type;
    readonly IsMulticast: boolean;
    abstract AddEventHandler(component: any, value: Function): void;
    abstract RemoveEventHandler(component: any, value: Function): void;
}


export type EventDescriptor = EventDescriptor$instance;

export class EventDescriptorCollection$instance {
    constructor(events: EventDescriptor[]);
    constructor(events: EventDescriptor[], readOnly: boolean);
    readonly Count: int;
    Add(value: EventDescriptor): int;
    Clear(): void;
    Contains(value: EventDescriptor): boolean;
    Find(name: string, ignoreCase: boolean): EventDescriptor;
    get_Item(index: int): EventDescriptor;
    get_Item(name: string): EventDescriptor;
    GetEnumerator(): IEnumerator;
    IndexOf(value: EventDescriptor): int;
    Insert(index: int, value: EventDescriptor): void;
    Remove(value: EventDescriptor): void;
    RemoveAt(index: int): void;
    Sort(): EventDescriptorCollection;
    Sort(names: string[]): EventDescriptorCollection;
    Sort(names: string[], comparer: IComparer): EventDescriptorCollection;
    Sort(comparer: IComparer): EventDescriptorCollection;
    static readonly Empty: EventDescriptorCollection;
}


export interface __EventDescriptorCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type EventDescriptorCollection = EventDescriptorCollection$instance & __EventDescriptorCollection$views;


export class EventHandlerList$instance {
    constructor();
    Item: Function;
    AddHandler(key: any, value: Function): void;
    AddHandlers(listToAddFrom: EventHandlerList): void;
    Dispose(): void;
    RemoveHandler(key: any, value: Function): void;
}


export interface __EventHandlerList$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type EventHandlerList = EventHandlerList$instance & __EventHandlerList$views;


export class ExpandableObjectConverter$instance extends TypeConverter$instance {
    constructor();
    GetProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type ExpandableObjectConverter = ExpandableObjectConverter$instance;

export class ExtenderProvidedPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    readonly ExtenderProperty: PropertyDescriptor;
    readonly Provider: IExtenderProvider;
    readonly ReceiverType: Type;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export type ExtenderProvidedPropertyAttribute = ExtenderProvidedPropertyAttribute$instance;

export class GuidConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type GuidConverter = GuidConverter$instance;

export class HalfConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type HalfConverter = HalfConverter$instance;

export class HandledEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    constructor(defaultHandledValue: boolean);
    Handled: boolean;
}


export type HandledEventArgs = HandledEventArgs$instance;

export class HandledEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: HandledEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: HandledEventArgs): void;
}


export interface __HandledEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HandledEventHandler = HandledEventHandler$instance & __HandledEventHandler$views;


export class ImmutableObjectAttribute$instance extends System_Internal.Attribute$instance {
    constructor(immutable: boolean);
    readonly Immutable: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: ImmutableObjectAttribute;
    static readonly No: ImmutableObjectAttribute;
    static readonly Default: ImmutableObjectAttribute;
}


export type ImmutableObjectAttribute = ImmutableObjectAttribute$instance;

export class InheritanceAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(inheritanceLevel: InheritanceLevel);
    readonly InheritanceLevel: InheritanceLevel;
    Equals(value: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    ToString(): string;
    static readonly Inherited: InheritanceAttribute;
    static readonly InheritedReadOnly: InheritanceAttribute;
    static readonly NotInherited: InheritanceAttribute;
    static readonly Default: InheritanceAttribute;
}


export type InheritanceAttribute = InheritanceAttribute$instance;

export class InitializationEventAttribute$instance extends System_Internal.Attribute$instance {
    constructor(eventName: string);
    readonly EventName: string;
}


export type InitializationEventAttribute = InitializationEventAttribute$instance;

export class InstallerTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(installerType: Type);
    constructor(typeName: string);
    readonly InstallerType: Type;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type InstallerTypeAttribute = InstallerTypeAttribute$instance;

export abstract class InstanceCreationEditor$instance {
    readonly Text: string;
    abstract CreateInstance(context: ITypeDescriptorContext, instanceType: Type): any;
}


export type InstanceCreationEditor = InstanceCreationEditor$instance;

export class Int128Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int128Converter = Int128Converter$instance;

export class Int16Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int16Converter = Int16Converter$instance;

export class Int32Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int32Converter = Int32Converter$instance;

export class Int64Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int64Converter = Int64Converter$instance;

export class InvalidAsynchronousStateException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidAsynchronousStateException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidAsynchronousStateException = InvalidAsynchronousStateException$instance & __InvalidAsynchronousStateException$views;


export class InvalidEnumArgumentException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(argumentName: string, invalidValue: int, enumClass: Type);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidEnumArgumentException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidEnumArgumentException = InvalidEnumArgumentException$instance & __InvalidEnumArgumentException$views;


export abstract class License$instance {
    readonly LicenseKey: string;
    abstract Dispose(): void;
}


export interface __License$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type License = License$instance & __License$views;


export class LicenseContext$instance {
    constructor();
    readonly UsageMode: LicenseUsageMode;
    GetSavedLicenseKey(type_: Type, resourceAssembly: Assembly): string;
    GetService(type_: Type): any;
    SetSavedLicenseKey(type_: Type, key: string): void;
}


export interface __LicenseContext$views {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
}

export type LicenseContext = LicenseContext$instance & __LicenseContext$views;


export class LicenseException$instance extends System_Internal.SystemException$instance {
    constructor(type_: Type);
    constructor(type_: Type, instance: any);
    constructor(type_: Type, instance: any, message: string);
    constructor(type_: Type, instance: any, message: string, innerException: Exception);
    readonly LicensedType: Type;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __LicenseException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LicenseException = LicenseException$instance & __LicenseException$views;


export class LicenseManager$instance {
    static CurrentContext: LicenseContext;
    static readonly UsageMode: LicenseUsageMode;
    static CreateWithContext(type_: Type, creationContext: LicenseContext, args: any[]): any;
    static CreateWithContext(type_: Type, creationContext: LicenseContext): any;
    static IsLicensed(type_: Type): boolean;
    static IsValid(type_: Type, instance: any, license: { value: ref<License> }): boolean;
    static IsValid(type_: Type): boolean;
    static LockContext(contextUser: any): void;
    static UnlockContext(contextUser: any): void;
    static Validate(type_: Type, instance: any): License;
    static Validate(type_: Type): void;
}


export type LicenseManager = LicenseManager$instance;

export abstract class LicenseProvider$instance {
    abstract GetLicense(context: LicenseContext, type_: Type, instance: any, allowExceptions: boolean): License;
}


export type LicenseProvider = LicenseProvider$instance;

export class LicenseProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(typeName: string);
    constructor(type_: Type);
    readonly LicenseProvider: Type;
    readonly TypeId: any;
    Equals(value: any): boolean;
    GetHashCode(): int;
    static readonly Default: LicenseProviderAttribute;
}


export type LicenseProviderAttribute = LicenseProviderAttribute$instance;

export class LicFileLicenseProvider$instance extends LicenseProvider$instance {
    constructor();
    GetLicense(context: LicenseContext, type_: Type, instance: any, allowExceptions: boolean): License;
}


export type LicFileLicenseProvider = LicFileLicenseProvider$instance;

export class ListBindableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(listBindable: boolean);
    constructor(flags: BindableSupport);
    readonly ListBindable: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: ListBindableAttribute;
    static readonly No: ListBindableAttribute;
    static readonly Default: ListBindableAttribute;
}


export type ListBindableAttribute = ListBindableAttribute$instance;

export class ListChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(listChangedType: ListChangedType, newIndex: int);
    constructor(listChangedType: ListChangedType, newIndex: int, propDesc: PropertyDescriptor);
    constructor(listChangedType: ListChangedType, propDesc: PropertyDescriptor);
    constructor(listChangedType: ListChangedType, newIndex: int, oldIndex: int);
    readonly ListChangedType: ListChangedType;
    readonly NewIndex: int;
    readonly OldIndex: int;
    readonly PropertyDescriptor: PropertyDescriptor;
}


export type ListChangedEventArgs = ListChangedEventArgs$instance;

export class ListChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: ListChangedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: ListChangedEventArgs): void;
}


export interface __ListChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ListChangedEventHandler = ListChangedEventHandler$instance & __ListChangedEventHandler$views;


export class ListSortDescription$instance {
    constructor(property: PropertyDescriptor, direction: ListSortDirection);
    PropertyDescriptor: PropertyDescriptor;
    SortDirection: ListSortDirection;
}


export type ListSortDescription = ListSortDescription$instance;

export class ListSortDescriptionCollection$instance {
    constructor();
    constructor(sorts: ListSortDescription[]);
    readonly Count: int;
    Item: ListSortDescription;
    Contains(value: any): boolean;
    CopyTo(array: ClrArray, index: int): void;
    IndexOf(value: any): int;
}


export interface __ListSortDescriptionCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type ListSortDescriptionCollection = ListSortDescriptionCollection$instance & __ListSortDescriptionCollection$views;


export class LocalizableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isLocalizable: boolean);
    readonly IsLocalizable: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: LocalizableAttribute;
    static readonly No: LocalizableAttribute;
    static readonly Default: LocalizableAttribute;
}


export type LocalizableAttribute = LocalizableAttribute$instance;

export class LookupBindingPropertiesAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(dataSource: string, displayMember: string, valueMember: string, lookupMember: string);
    readonly DataSource: string;
    readonly DisplayMember: string;
    readonly LookupMember: string;
    readonly ValueMember: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static readonly Default: LookupBindingPropertiesAttribute;
}


export type LookupBindingPropertiesAttribute = LookupBindingPropertiesAttribute$instance;

export class MarshalByValueComponent$instance {
    constructor();
    readonly Container: IContainer;
    readonly DesignMode: boolean;
    Site: ISite;
    Dispose(): void;
    GetService(service: Type): any;
    ToString(): string;
}


export interface __MarshalByValueComponent$views {
    readonly As_IServiceProvider: System_Internal.IServiceProvider$instance;
    readonly As_IComponent: IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MarshalByValueComponent = MarshalByValueComponent$instance & __MarshalByValueComponent$views;


export class MaskedTextProvider$instance {
    constructor(mask: string);
    constructor(mask: string, restrictToAscii: boolean);
    constructor(mask: string, culture: CultureInfo);
    constructor(mask: string, culture: CultureInfo, restrictToAscii: boolean);
    constructor(mask: string, passwordChar: string, allowPromptAsInput: boolean);
    constructor(mask: string, culture: CultureInfo, passwordChar: string, allowPromptAsInput: boolean);
    constructor(mask: string, culture: CultureInfo, allowPromptAsInput: boolean, promptChar: string, passwordChar: string, restrictToAscii: boolean);
    readonly AllowPromptAsInput: boolean;
    readonly AsciiOnly: boolean;
    readonly AssignedEditPositionCount: int;
    readonly AvailableEditPositionCount: int;
    readonly Culture: CultureInfo;
    readonly EditPositionCount: int;
    readonly EditPositions: IEnumerator;
    IncludeLiterals: boolean;
    IncludePrompt: boolean;
    IsPassword: boolean;
    readonly Item: string;
    readonly LastAssignedPosition: int;
    readonly Length: int;
    readonly Mask: string;
    readonly MaskCompleted: boolean;
    readonly MaskFull: boolean;
    PasswordChar: string;
    PromptChar: string;
    ResetOnPrompt: boolean;
    ResetOnSpace: boolean;
    SkipLiterals: boolean;
    Add(input: string): boolean;
    Add(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Add(input: string): boolean;
    Add(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Clear(): void;
    Clear(resultHint: { value: ref<MaskedTextResultHint> }): void;
    Clone(): any;
    FindAssignedEditPositionFrom(position: int, direction: boolean): int;
    FindAssignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    FindEditPositionFrom(position: int, direction: boolean): int;
    FindEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    FindNonEditPositionFrom(position: int, direction: boolean): int;
    FindNonEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    FindUnassignedEditPositionFrom(position: int, direction: boolean): int;
    FindUnassignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    InsertAt(input: string, position: int): boolean;
    InsertAt(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    InsertAt(input: string, position: int): boolean;
    InsertAt(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    IsAvailablePosition(position: int): boolean;
    IsEditPosition(position: int): boolean;
    Remove(): boolean;
    Remove(testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    RemoveAt(position: int): boolean;
    RemoveAt(startPosition: int, endPosition: int): boolean;
    RemoveAt(startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: string, position: int): boolean;
    Replace(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: string, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: string, position: int): boolean;
    Replace(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: string, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Set(input: string): boolean;
    Set(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    ToDisplayString(): string;
    ToString(): string;
    ToString(ignorePasswordChar: boolean): string;
    ToString(startPosition: int, length: int): string;
    ToString(ignorePasswordChar: boolean, startPosition: int, length: int): string;
    ToString(includePrompt: boolean, includeLiterals: boolean): string;
    ToString(includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    ToString(ignorePasswordChar: boolean, includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    VerifyChar(input: string, position: int, hint: { value: ref<MaskedTextResultHint> }): boolean;
    VerifyEscapeChar(input: string, position: int): boolean;
    VerifyString(input: string): boolean;
    VerifyString(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    static readonly DefaultPasswordChar: string;
    static readonly InvalidIndex: int;
    static GetOperationResultFromHint(hint: MaskedTextResultHint): boolean;
    static IsValidInputChar(c: string): boolean;
    static IsValidMaskChar(c: string): boolean;
    static IsValidPasswordChar(c: string): boolean;
}


export interface __MaskedTextProvider$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type MaskedTextProvider = MaskedTextProvider$instance & __MaskedTextProvider$views;


export abstract class MemberDescriptor$instance {
    readonly Attributes: AttributeCollection;
    readonly Category: string;
    readonly Description: string;
    readonly DesignTimeOnly: boolean;
    readonly DisplayName: string;
    readonly IsBrowsable: boolean;
    readonly Name: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type MemberDescriptor = MemberDescriptor$instance;

export class MergablePropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(allowMerge: boolean);
    readonly AllowMerge: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: MergablePropertyAttribute;
    static readonly No: MergablePropertyAttribute;
    static readonly Default: MergablePropertyAttribute;
}


export type MergablePropertyAttribute = MergablePropertyAttribute$instance;

export class MultilineStringConverter$instance extends TypeConverter$instance {
    constructor();
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    GetProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type MultilineStringConverter = MultilineStringConverter$instance;

export class NestedContainer$instance extends Container$instance {
    constructor(owner: IComponent);
    readonly Owner: IComponent;
    Add(component: IComponent): void;
    Add(component: IComponent, name: string): void;
    Dispose(): void;
}


export interface __NestedContainer$views {
    readonly As_IContainer: IContainer$instance;
    readonly As_INestedContainer: INestedContainer$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type NestedContainer = NestedContainer$instance & __NestedContainer$views;


export class NotifyParentPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(notifyParent: boolean);
    readonly NotifyParent: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: NotifyParentPropertyAttribute;
    static readonly No: NotifyParentPropertyAttribute;
    static readonly Default: NotifyParentPropertyAttribute;
}


export type NotifyParentPropertyAttribute = NotifyParentPropertyAttribute$instance;

export class NullableConverter$instance extends TypeConverter$instance {
    constructor(type_: Type);
    readonly NullableType: Type;
    readonly UnderlyingType: Type;
    readonly UnderlyingTypeConverter: TypeConverter;
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): any;
    CreateInstance(propertyValues: IDictionary): any;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
    IsValid(context: ITypeDescriptorContext, value: any): boolean;
    IsValid(value: any): boolean;
}


export type NullableConverter = NullableConverter$instance;

export class ParenthesizePropertyNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(needParenthesis: boolean);
    readonly NeedParenthesis: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Default: ParenthesizePropertyNameAttribute;
}


export type ParenthesizePropertyNameAttribute = ParenthesizePropertyNameAttribute$instance;

export class PasswordPropertyTextAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(password: boolean);
    readonly Password: boolean;
    Equals(o: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: PasswordPropertyTextAttribute;
    static readonly No: PasswordPropertyTextAttribute;
    static readonly Default: PasswordPropertyTextAttribute;
}


export type PasswordPropertyTextAttribute = PasswordPropertyTextAttribute$instance;

export class ProgressChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(progressPercentage: int, userState: any);
    readonly ProgressPercentage: int;
    readonly UserState: any;
}


export type ProgressChangedEventArgs = ProgressChangedEventArgs$instance;

export class ProgressChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: ProgressChangedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: ProgressChangedEventArgs): void;
}


export interface __ProgressChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ProgressChangedEventHandler = ProgressChangedEventHandler$instance & __ProgressChangedEventHandler$views;


export class PropertyChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(propertyName: string);
    readonly PropertyName: string;
}


export type PropertyChangedEventArgs = PropertyChangedEventArgs$instance;

export class PropertyChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: PropertyChangedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: PropertyChangedEventArgs): void;
}


export interface __PropertyChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PropertyChangedEventHandler = PropertyChangedEventHandler$instance & __PropertyChangedEventHandler$views;


export class PropertyChangingEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(propertyName: string);
    readonly PropertyName: string;
}


export type PropertyChangingEventArgs = PropertyChangingEventArgs$instance;

export class PropertyChangingEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: PropertyChangingEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: PropertyChangingEventArgs): void;
}


export interface __PropertyChangingEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PropertyChangingEventHandler = PropertyChangingEventHandler$instance & __PropertyChangingEventHandler$views;


export abstract class PropertyDescriptor$instance extends MemberDescriptor$instance {
    readonly ComponentType: Type;
    readonly Converter: TypeConverter;
    readonly ConverterFromRegisteredType: TypeConverter;
    readonly IsLocalizable: boolean;
    readonly IsReadOnly: boolean;
    readonly PropertyType: Type;
    readonly SerializationVisibility: DesignerSerializationVisibility;
    readonly SupportsChangeEvents: boolean;
    AddValueChanged(component: any, handler: EventHandler): void;
    abstract CanResetValue(component: any): boolean;
    Equals(obj: any): boolean;
    GetChildProperties(): PropertyDescriptorCollection;
    GetChildProperties(filter: Attribute[]): PropertyDescriptorCollection;
    GetChildProperties(instance: any): PropertyDescriptorCollection;
    GetChildProperties(instance: any, filter: Attribute[]): PropertyDescriptorCollection;
    GetEditor(editorBaseType: Type): any;
    GetHashCode(): int;
    abstract GetValue(component: any): any;
    RemoveValueChanged(component: any, handler: EventHandler): void;
    abstract ResetValue(component: any): void;
    abstract SetValue(component: any, value: any): void;
    abstract ShouldSerializeValue(component: any): boolean;
}


export type PropertyDescriptor = PropertyDescriptor$instance;

export class PropertyDescriptorCollection$instance {
    constructor(properties: PropertyDescriptor[]);
    constructor(properties: PropertyDescriptor[], readOnly: boolean);
    readonly Count: int;
    Add(value: PropertyDescriptor): int;
    Clear(): void;
    Contains(value: PropertyDescriptor): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Find(name: string, ignoreCase: boolean): PropertyDescriptor;
    get_Item(index: int): PropertyDescriptor;
    get_Item(name: string): PropertyDescriptor;
    GetEnumerator(): IEnumerator;
    IndexOf(value: PropertyDescriptor): int;
    Insert(index: int, value: PropertyDescriptor): void;
    Remove(value: PropertyDescriptor): void;
    RemoveAt(index: int): void;
    Sort(): PropertyDescriptorCollection;
    Sort(names: string[]): PropertyDescriptorCollection;
    Sort(names: string[], comparer: IComparer): PropertyDescriptorCollection;
    Sort(comparer: IComparer): PropertyDescriptorCollection;
    static readonly Empty: PropertyDescriptorCollection;
}


export interface __PropertyDescriptorCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type PropertyDescriptorCollection = PropertyDescriptorCollection$instance & __PropertyDescriptorCollection$views;


export class PropertyTabAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(tabClass: Type);
    constructor(tabClassName: string);
    constructor(tabClass: Type, tabScope: PropertyTabScope);
    constructor(tabClassName: string, tabScope: PropertyTabScope);
    readonly TabClasses: Type[];
    readonly TabScopes: PropertyTabScope[];
    Equals(other: any): boolean;
    Equals(other: PropertyTabAttribute): boolean;
    GetHashCode(): int;
}


export type PropertyTabAttribute = PropertyTabAttribute$instance;

export class ProvidePropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(propertyName: string, receiverType: Type);
    constructor(propertyName: string, receiverTypeName: string);
    readonly PropertyName: string;
    readonly ReceiverTypeName: string;
    readonly TypeId: any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
}


export type ProvidePropertyAttribute = ProvidePropertyAttribute$instance;

export class ReadOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isReadOnly: boolean);
    readonly IsReadOnly: boolean;
    Equals(value: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: ReadOnlyAttribute;
    static readonly No: ReadOnlyAttribute;
    static readonly Default: ReadOnlyAttribute;
}


export type ReadOnlyAttribute = ReadOnlyAttribute$instance;

export class RecommendedAsConfigurableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(recommendedAsConfigurable: boolean);
    readonly RecommendedAsConfigurable: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly No: RecommendedAsConfigurableAttribute;
    static readonly Yes: RecommendedAsConfigurableAttribute;
    static readonly Default: RecommendedAsConfigurableAttribute;
}


export type RecommendedAsConfigurableAttribute = RecommendedAsConfigurableAttribute$instance;

export class ReferenceConverter$instance extends TypeConverter$instance {
    constructor(type_: Type);
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export type ReferenceConverter = ReferenceConverter$instance;

export class RefreshEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(componentChanged: any);
    constructor(typeChanged: Type);
    readonly ComponentChanged: any;
    readonly TypeChanged: Type;
}


export type RefreshEventArgs = RefreshEventArgs$instance;

export class RefreshEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(e: RefreshEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(e: RefreshEventArgs): void;
}


export interface __RefreshEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RefreshEventHandler = RefreshEventHandler$instance & __RefreshEventHandler$views;


export class RefreshPropertiesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(refresh: RefreshProperties);
    readonly RefreshProperties: RefreshProperties;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly All: RefreshPropertiesAttribute;
    static readonly Repaint: RefreshPropertiesAttribute;
    static readonly Default: RefreshPropertiesAttribute;
}


export type RefreshPropertiesAttribute = RefreshPropertiesAttribute$instance;

export class RunInstallerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(runInstaller: boolean);
    readonly RunInstaller: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Yes: RunInstallerAttribute;
    static readonly No: RunInstallerAttribute;
    static readonly Default: RunInstallerAttribute;
}


export type RunInstallerAttribute = RunInstallerAttribute$instance;

export class RunWorkerCompletedEventArgs$instance extends AsyncCompletedEventArgs$instance {
    constructor(result: any, error: Exception, cancelled: boolean);
    readonly Result: any;
    readonly UserState: any;
}


export type RunWorkerCompletedEventArgs = RunWorkerCompletedEventArgs$instance;

export class RunWorkerCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: RunWorkerCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: RunWorkerCompletedEventArgs): void;
}


export interface __RunWorkerCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RunWorkerCompletedEventHandler = RunWorkerCompletedEventHandler$instance & __RunWorkerCompletedEventHandler$views;


export class SByteConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type SByteConverter = SByteConverter$instance;

export class SettingsBindableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(bindable: boolean);
    readonly Bindable: boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static readonly Yes: SettingsBindableAttribute;
    static readonly No: SettingsBindableAttribute;
}


export type SettingsBindableAttribute = SettingsBindableAttribute$instance;

export class SingleConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type SingleConverter = SingleConverter$instance;

export class StringConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
}


export type StringConverter = StringConverter$instance;

export class TimeOnlyConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type TimeOnlyConverter = TimeOnlyConverter$instance;

export class TimeSpanConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
}


export type TimeSpanConverter = TimeSpanConverter$instance;

export class ToolboxItemAttribute$instance extends System_Internal.Attribute$instance {
    constructor(defaultType: boolean);
    constructor(toolboxItemTypeName: string);
    constructor(toolboxItemType: Type);
    readonly ToolboxItemType: Type;
    readonly ToolboxItemTypeName: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    static readonly Default: ToolboxItemAttribute;
    static readonly None: ToolboxItemAttribute;
}


export type ToolboxItemAttribute = ToolboxItemAttribute$instance;

export class ToolboxItemFilterAttribute$instance extends System_Internal.Attribute$instance {
    constructor(filterString: string);
    constructor(filterString: string, filterType: ToolboxItemFilterType);
    readonly FilterString: string;
    readonly FilterType: ToolboxItemFilterType;
    readonly TypeId: any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    Match(obj: any): boolean;
    ToString(): string;
}


export type ToolboxItemFilterAttribute = ToolboxItemFilterAttribute$instance;

export class TypeConverter$instance {
    constructor();
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    ConvertFrom(value: any): any;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFromInvariantString(text: string): any;
    ConvertFromInvariantString(context: ITypeDescriptorContext, text: string): any;
    ConvertFromString(text: string): any;
    ConvertFromString(context: ITypeDescriptorContext, text: string): any;
    ConvertFromString(context: ITypeDescriptorContext, culture: CultureInfo, text: string): any;
    ConvertTo(value: any, destinationType: Type): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertToInvariantString(value: any): string;
    ConvertToInvariantString(context: ITypeDescriptorContext, value: any): string;
    ConvertToString(value: any): string;
    ConvertToString(context: ITypeDescriptorContext, value: any): string;
    ConvertToString(context: ITypeDescriptorContext, culture: CultureInfo, value: any): string;
    CreateInstance(propertyValues: IDictionary): any;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): any;
    GetCreateInstanceSupported(): boolean;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetProperties(value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertiesSupported(): boolean;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValues(): ICollection;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    IsValid(value: any): boolean;
    IsValid(context: ITypeDescriptorContext, value: any): boolean;
}


export type TypeConverter = TypeConverter$instance;

export class TypeConverter_StandardValuesCollection$instance {
    constructor(values: ICollection);
    readonly Count: int;
    readonly Item: any;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
}


export interface __TypeConverter_StandardValuesCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type TypeConverter_StandardValuesCollection = TypeConverter_StandardValuesCollection$instance & __TypeConverter_StandardValuesCollection$views;


export class TypeConverterAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(type_: Type);
    constructor(typeName: string);
    readonly ConverterTypeName: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static readonly Default: TypeConverterAttribute;
}


export type TypeConverterAttribute = TypeConverterAttribute$instance;

export abstract class TypeDescriptionProvider$instance {
    readonly RequireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    CreateInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: any[]): any;
    GetCache(instance: any): IDictionary;
    GetExtendedTypeDescriptor(instance: any): ICustomTypeDescriptor;
    GetExtendedTypeDescriptorFromRegisteredType(instance: any): ICustomTypeDescriptor;
    GetFullComponentName(component: any): string;
    GetReflectionType(objectType: Type): Type;
    GetReflectionType(instance: any): Type;
    GetReflectionType(objectType: Type, instance: any): Type;
    GetRuntimeType(reflectionType: Type): Type;
    GetTypeDescriptor(objectType: Type): ICustomTypeDescriptor;
    GetTypeDescriptor(instance: any): ICustomTypeDescriptor;
    GetTypeDescriptor(objectType: Type, instance: any): ICustomTypeDescriptor;
    GetTypeDescriptorFromRegisteredType(objectType: Type): ICustomTypeDescriptor;
    GetTypeDescriptorFromRegisteredType(instance: any): ICustomTypeDescriptor;
    GetTypeDescriptorFromRegisteredType(objectType: Type, instance: any): ICustomTypeDescriptor;
    IsRegisteredType(type_: Type): boolean;
    IsSupportedType(type_: Type): boolean;
    RegisterType<T>(): void;
}


export type TypeDescriptionProvider = TypeDescriptionProvider$instance;

export class TypeDescriptionProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(typeName: string);
    constructor(type_: Type);
    readonly TypeName: string;
}


export type TypeDescriptionProviderAttribute = TypeDescriptionProviderAttribute$instance;

export class TypeDescriptor$instance {
    static readonly InterfaceType: Type;
    static readonly ComObjectType: Type;
    static ComNativeDescriptorHandler: IComNativeDescriptorHandler;
    static AddAttributes(instance: any, attributes: Attribute[]): TypeDescriptionProvider;
    static AddAttributes(type_: Type, attributes: Attribute[]): TypeDescriptionProvider;
    static AddEditorTable(editorBaseType: Type, table: Hashtable): void;
    static AddProvider(provider: TypeDescriptionProvider, instance: any): void;
    static AddProvider(provider: TypeDescriptionProvider, type_: Type): void;
    static AddProviderTransparent(provider: TypeDescriptionProvider, instance: any): void;
    static AddProviderTransparent(provider: TypeDescriptionProvider, type_: Type): void;
    static CreateAssociation(primary: any, secondary: any): void;
    static CreateDesigner(component: IComponent, designerBaseType: Type): IDesigner;
    static CreateEvent(componentType: Type, oldEventDescriptor: EventDescriptor, attributes: Attribute[]): EventDescriptor;
    static CreateEvent(componentType: Type, name: string, type_: Type, attributes: Attribute[]): EventDescriptor;
    static CreateInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: any[]): any;
    static CreateProperty(componentType: Type, oldPropertyDescriptor: PropertyDescriptor, attributes: Attribute[]): PropertyDescriptor;
    static CreateProperty(componentType: Type, name: string, type_: Type, attributes: Attribute[]): PropertyDescriptor;
    static GetAssociation(type_: Type, primary: any): any;
    static GetAttributes(component: any, noCustomTypeDesc: boolean): AttributeCollection;
    static GetAttributes(component: any): AttributeCollection;
    static GetAttributes(componentType: Type): AttributeCollection;
    static GetClassName(component: any, noCustomTypeDesc: boolean): string;
    static GetClassName(component: any): string;
    static GetClassName(componentType: Type): string;
    static GetComponentName(component: any, noCustomTypeDesc: boolean): string;
    static GetComponentName(component: any): string;
    static GetConverter(component: any, noCustomTypeDesc: boolean): TypeConverter;
    static GetConverter(component: any): TypeConverter;
    static GetConverter(type_: Type): TypeConverter;
    static GetConverterFromRegisteredType(component: any): TypeConverter;
    static GetConverterFromRegisteredType(type_: Type): TypeConverter;
    static GetDefaultEvent(component: any, noCustomTypeDesc: boolean): EventDescriptor;
    static GetDefaultEvent(component: any): EventDescriptor;
    static GetDefaultEvent(componentType: Type): EventDescriptor;
    static GetDefaultProperty(component: any, noCustomTypeDesc: boolean): PropertyDescriptor;
    static GetDefaultProperty(component: any): PropertyDescriptor;
    static GetDefaultProperty(componentType: Type): PropertyDescriptor;
    static GetEditor(component: any, editorBaseType: Type, noCustomTypeDesc: boolean): any;
    static GetEditor(component: any, editorBaseType: Type): any;
    static GetEditor(type_: Type, editorBaseType: Type): any;
    static GetEvents(component: any, attributes: Attribute[], noCustomTypeDesc: boolean): EventDescriptorCollection;
    static GetEvents(component: any, attributes: Attribute[]): EventDescriptorCollection;
    static GetEvents(component: any, noCustomTypeDesc: boolean): EventDescriptorCollection;
    static GetEvents(component: any): EventDescriptorCollection;
    static GetEvents(componentType: Type, attributes: Attribute[]): EventDescriptorCollection;
    static GetEvents(componentType: Type): EventDescriptorCollection;
    static GetEventsFromRegisteredType(componentType: Type): EventDescriptorCollection;
    static GetFullComponentName(component: any): string;
    static GetProperties(component: any, attributes: Attribute[], noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    static GetProperties(component: any, attributes: Attribute[]): PropertyDescriptorCollection;
    static GetProperties(component: any, noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    static GetProperties(component: any): PropertyDescriptorCollection;
    static GetProperties(componentType: Type, attributes: Attribute[]): PropertyDescriptorCollection;
    static GetProperties(componentType: Type): PropertyDescriptorCollection;
    static GetPropertiesFromRegisteredType(component: any): PropertyDescriptorCollection;
    static GetPropertiesFromRegisteredType(componentType: Type): PropertyDescriptorCollection;
    static GetProvider(instance: any): TypeDescriptionProvider;
    static GetProvider(type_: Type): TypeDescriptionProvider;
    static GetReflectionType(instance: any): Type;
    static GetReflectionType(type_: Type): Type;
    static Refresh(component: any): void;
    static Refresh(assembly: Assembly): void;
    static Refresh(module_: Module): void;
    static Refresh(type_: Type): void;
    static RegisterType<T>(): void;
    static RemoveAssociation(primary: any, secondary: any): void;
    static RemoveAssociations(primary: any): void;
    static RemoveProvider(provider: TypeDescriptionProvider, instance: any): void;
    static RemoveProvider(provider: TypeDescriptionProvider, type_: Type): void;
    static RemoveProviderTransparent(provider: TypeDescriptionProvider, instance: any): void;
    static RemoveProviderTransparent(provider: TypeDescriptionProvider, type_: Type): void;
    static SortDescriptorArray(infos: IList): void;
}


export type TypeDescriptor = TypeDescriptor$instance;

export abstract class TypeListConverter$instance extends TypeConverter$instance {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export type TypeListConverter = TypeListConverter$instance;

export class UInt128Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt128Converter = UInt128Converter$instance;

export class UInt16Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt16Converter = UInt16Converter$instance;

export class UInt32Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt32Converter = UInt32Converter$instance;

export class UInt64Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt64Converter = UInt64Converter$instance;

export class VersionConverter$instance extends TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    ConvertFrom(value: any): any;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    ConvertTo(value: any, destinationType: Type): any;
    IsValid(context: ITypeDescriptorContext, value: any): boolean;
    IsValid(value: any): boolean;
}


export type VersionConverter = VersionConverter$instance;

export class WarningException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, helpUrl: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, helpUrl: string, helpTopic: string);
    readonly HelpTopic: string;
    readonly HelpUrl: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __WarningException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WarningException = WarningException$instance & __WarningException$views;


export class Win32Exception$instance extends System_Runtime_InteropServices_Internal.ExternalException$instance {
    constructor();
    constructor(error: int);
    constructor(error: int, message: string);
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly NativeErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export interface __Win32Exception$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Win32Exception = Win32Exception$instance & __Win32Exception$views;


export abstract class AsyncOperationManager$instance {
    static SynchronizationContext: SynchronizationContext;
    static CreateOperation(userSuppliedState: any): AsyncOperation;
}


export type AsyncOperationManager = AsyncOperationManager$instance;

export abstract class SyntaxCheck$instance {
    static CheckMachineName(value: string): boolean;
    static CheckPath(value: string): boolean;
    static CheckRootedPath(value: string): boolean;
}


export type SyntaxCheck = SyntaxCheck$instance;

