// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel
// Assembly: System.ComponentModel, System.ComponentModel.EventBasedAsync, System.ComponentModel.Primitives, System.ComponentModel.TypeConverter, System.ObjectModel, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { Hashtable, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase } from "../../System.Collections/internal/index.js";
import type { IDesigner } from "../../System.ComponentModel.Design/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { UnmanagedMemoryStream } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Resources_Internal from "../../System.Resources/internal/index.js";
import type { ResourceManager, ResourceSet } from "../../System.Resources/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ExternalException } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SendOrPostCallback, SynchronizationContext } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Delegate, Double, Enum, EventArgs, EventHandler, EventHandler_1, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IServiceProvider, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Nullable_1, Object as ClrObject, SByte, Single, String as ClrString, SystemException, Type, TypeCode, UInt16, UInt32, UInt64, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum BindableSupport {
    no = 0,
    yes = 1,
    default_ = 2
}


export enum BindingDirection {
    oneWay = 0,
    twoWay = 1
}


export enum CollectionChangeAction {
    add = 1,
    remove = 2,
    refresh = 3
}


export enum DataObjectMethodType {
    fill = 0,
    select = 1,
    update = 2,
    insert = 3,
    delete_ = 4
}


export enum DesignerSerializationVisibility {
    hidden = 0,
    visible = 1,
    content = 2
}


export enum EditorBrowsableState {
    always = 0,
    never_ = 1,
    advanced = 2
}


export enum InheritanceLevel {
    inherited = 1,
    inheritedReadOnly = 2,
    notInherited = 3
}


export enum LicenseUsageMode {
    runtime = 0,
    designtime = 1
}


export enum ListChangedType {
    reset = 0,
    itemAdded = 1,
    itemDeleted = 2,
    itemMoved = 3,
    itemChanged = 4,
    propertyDescriptorAdded = 5,
    propertyDescriptorDeleted = 6,
    propertyDescriptorChanged = 7
}


export enum ListSortDirection {
    ascending = 0,
    descending = 1
}


export enum MaskedTextResultHint {
    unknown_ = 0,
    characterEscaped = 1,
    noEffect = 2,
    sideEffect = 3,
    success = 4,
    asciiCharacterExpected = -1,
    alphanumericCharacterExpected = -2,
    digitExpected = -3,
    letterExpected = -4,
    signedDigitExpected = -5,
    invalidInput = -51,
    promptCharNotAllowed = -52,
    unavailableEditPosition = -53,
    nonEditPosition = -54,
    positionOutOfRange = -55
}


export enum PropertyTabScope {
    static_ = 0,
    global = 1,
    document = 2,
    component = 3
}


export enum RefreshProperties {
    none = 0,
    all = 1,
    repaint = 2
}


export enum ToolboxItemFilterType {
    allow = 0,
    custom = 1,
    prevent = 2,
    require = 3
}


export interface IBindingList$instance extends IList, ICollection, IEnumerable {
    readonly allowNew: boolean;
    readonly allowEdit: boolean;
    readonly allowRemove: boolean;
    readonly supportsChangeNotification: boolean;
    readonly supportsSearching: boolean;
    readonly supportsSorting: boolean;
    readonly isSorted: boolean;
    readonly sortProperty: PropertyDescriptor;
    readonly sortDirection: ListSortDirection;
    item: unknown;
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(value: unknown): int;
    addIndex(property: PropertyDescriptor): void;
    addNew(): unknown;
    applySort(property: PropertyDescriptor, direction: ListSortDirection): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    find(property: PropertyDescriptor, key: unknown): int;
    getEnumerator(): IEnumerator;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
    removeSort(): void;
}


export type IBindingList = IBindingList$instance;

export interface IBindingListView$instance extends IBindingList, IList, ICollection, IEnumerable {
    filter: string;
    readonly sortDescriptions: ListSortDescriptionCollection;
    readonly supportsAdvancedSorting: boolean;
    readonly supportsFiltering: boolean;
    readonly allowNew: boolean;
    readonly allowEdit: boolean;
    readonly allowRemove: boolean;
    readonly supportsChangeNotification: boolean;
    readonly supportsSearching: boolean;
    readonly supportsSorting: boolean;
    readonly isSorted: boolean;
    readonly sortProperty: PropertyDescriptor;
    readonly sortDirection: ListSortDirection;
    item: unknown;
    readonly isReadOnly: boolean;
    readonly isFixedSize: boolean;
    readonly count: int;
    readonly syncRoot: unknown;
    readonly isSynchronized: boolean;
    add(value: unknown): int;
    addIndex(property: PropertyDescriptor): void;
    addNew(): unknown;
    applySort2(property: PropertyDescriptor, direction: ListSortDirection): void;
    applySort2(sorts: ListSortDescriptionCollection): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    find(property: PropertyDescriptor, key: unknown): int;
    getEnumerator(): IEnumerator;
    insert(index: int, value: unknown): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
    removeFilter(): void;
}


export type IBindingListView = IBindingListView$instance;

export interface ICancelAddNew$instance {
    cancelNew(itemIndex: int): void;
}


export type ICancelAddNew = ICancelAddNew$instance;

export interface IChangeTracking$instance {
    readonly isChanged: boolean;
    acceptChanges(): void;
}


export type IChangeTracking = IChangeTracking$instance;

export interface IComNativeDescriptorHandler$instance {
    getAttributes(component: unknown): AttributeCollection;
    getClassName(component: unknown): string;
    getConverter(component: unknown): TypeConverter;
    getDefaultEvent(component: unknown): EventDescriptor;
    getDefaultProperty(component: unknown): PropertyDescriptor;
    getEditor(component: unknown, baseEditorType: Type): unknown;
    getEvents2(component: unknown, attributes: Attribute[]): EventDescriptorCollection;
    getEvents2(component: unknown): EventDescriptorCollection;
    getProperties(component: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertyValue2(component: unknown, dispid: int, success: { value: ref<boolean> }): unknown;
    getPropertyValue2(component: unknown, propertyName: string, success: { value: ref<boolean> }): unknown;
}


export type IComNativeDescriptorHandler = IComNativeDescriptorHandler$instance;

export interface IComponent$instance extends IDisposable {
    site: ISite;
    dispose(): void;
}


export interface IComponent$instance extends System_Internal.IDisposable$instance {}

export type IComponent = IComponent$instance;

export interface IContainer$instance extends IDisposable {
    readonly components: ComponentCollection;
    add2(component: IComponent, name: string): void;
    add2(component: IComponent): void;
    dispose(): void;
}


export interface IContainer$instance extends System_Internal.IDisposable$instance {}

export type IContainer = IContainer$instance;

export interface ICustomTypeDescriptor$instance {
    readonly requireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    getAttributes(): AttributeCollection;
    getClassName(): string;
    getConverter(): TypeConverter;
    getDefaultEvent(): EventDescriptor;
    getDefaultProperty(): PropertyDescriptor;
    getEditor(editorBaseType: Type): unknown;
    getEvents(): EventDescriptorCollection;
    getEvents(attributes: Attribute[]): EventDescriptorCollection;
    getProperties(): PropertyDescriptorCollection;
    getProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertyOwner(pd: PropertyDescriptor): unknown;
}


export type ICustomTypeDescriptor = ICustomTypeDescriptor$instance;

export interface IDataErrorInfo$instance {
    readonly item: string;
    readonly error: string;
}


export type IDataErrorInfo = IDataErrorInfo$instance;

export interface IEditableObject$instance {
    beginEdit(): void;
}


export type IEditableObject = IEditableObject$instance;

export interface IExtenderProvider$instance {
    canExtend(extendee: unknown): boolean;
}


export type IExtenderProvider = IExtenderProvider$instance;

export interface IIntellisenseBuilder$instance {
    readonly name: string;
    show(language: string, value: string, newValue: { value: ref<string> }): boolean;
}


export type IIntellisenseBuilder = IIntellisenseBuilder$instance;

export interface IListSource$instance {
    readonly containsListCollection: boolean;
    getList(): IList;
}


export type IListSource = IListSource$instance;

export interface INestedContainer$instance extends IContainer, IDisposable {
    readonly owner: IComponent;
    readonly components: ComponentCollection;
    add2(component: IComponent, name: string): void;
    add2(component: IComponent): void;
    dispose(): void;
}


export type INestedContainer = INestedContainer$instance;

export interface INestedSite$instance extends ISite, IServiceProvider {
    readonly fullName: string;
    readonly component: IComponent;
    readonly container: IContainer;
    readonly designMode: boolean;
    name: string;
    getService(serviceType: Type): unknown;
}


export type INestedSite = INestedSite$instance;

export interface INotifyDataErrorInfo$instance {
    readonly hasErrors: boolean;
    getErrors(propertyName: string): IEnumerable;
}


export type INotifyDataErrorInfo = INotifyDataErrorInfo$instance;

export interface INotifyPropertyChanged$instance {
}


export type INotifyPropertyChanged = INotifyPropertyChanged$instance;

export interface INotifyPropertyChanging$instance {
}


export type INotifyPropertyChanging = INotifyPropertyChanging$instance;

export interface IRaiseItemChangedEvents$instance {
    readonly raisesItemChangedEvents: boolean;
}


export type IRaiseItemChangedEvents = IRaiseItemChangedEvents$instance;

export interface IRevertibleChangeTracking$instance extends IChangeTracking {
    readonly isChanged: boolean;
    rejectChanges(): void;
}


export interface IRevertibleChangeTracking$instance extends IChangeTracking$instance {}

export type IRevertibleChangeTracking = IRevertibleChangeTracking$instance;

export interface ISite$instance extends IServiceProvider {
    readonly component: IComponent;
    readonly container: IContainer;
    readonly designMode: boolean;
    name: string;
    getService(serviceType: Type): unknown;
}


export interface ISite$instance extends System_Internal.IServiceProvider$instance {}

export type ISite = ISite$instance;

export interface ISupportInitialize$instance {
    beginInit(): void;
}


export type ISupportInitialize = ISupportInitialize$instance;

export interface ISupportInitializeNotification$instance extends ISupportInitialize {
    readonly isInitialized: boolean;
    beginInit(): void;
}


export interface ISupportInitializeNotification$instance extends ISupportInitialize$instance {}

export type ISupportInitializeNotification = ISupportInitializeNotification$instance;

export interface ISynchronizeInvoke$instance {
    readonly invokeRequired: boolean;
    beginInvoke(method: Function, args: unknown[]): IAsyncResult;
    endInvoke(result: IAsyncResult): unknown;
    invoke(method: Function, args: unknown[]): unknown;
}


export type ISynchronizeInvoke = ISynchronizeInvoke$instance;

export interface ITypeDescriptorContext$instance extends IServiceProvider {
    readonly container: IContainer;
    readonly instance: unknown;
    readonly propertyDescriptor: PropertyDescriptor;
    getService(serviceType: Type): unknown;
    onComponentChanged(): void;
    onComponentChanging(): boolean;
}


export interface ITypeDescriptorContext$instance extends System_Internal.IServiceProvider$instance {}

export type ITypeDescriptorContext = ITypeDescriptorContext$instance;

export interface ITypedList$instance {
    getItemProperties(listAccessors: PropertyDescriptor[]): PropertyDescriptorCollection;
    getListName(listAccessors: PropertyDescriptor[]): string;
}


export type ITypedList = ITypedList$instance;

export class AddingNewEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    constructor(newObject: unknown);
    newObject: unknown;
}


export type AddingNewEventArgs = AddingNewEventArgs$instance;

export class AddingNewEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: AddingNewEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: AddingNewEventArgs): void;
}


export interface __AddingNewEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AddingNewEventHandler = AddingNewEventHandler$instance & __AddingNewEventHandler$views;


export class AmbientValueAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type, value: string);
    constructor(value: char);
    constructor(value: byte);
    constructor(value: short);
    constructor(value: int);
    constructor(value: long);
    constructor(value: float);
    constructor(value: double);
    constructor(value: boolean);
    constructor(value: string);
    constructor(value: unknown);
    readonly value: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type AmbientValueAttribute = AmbientValueAttribute$instance;

export class ArrayConverter$instance extends CollectionConverter$instance {
    constructor();
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type ArrayConverter = ArrayConverter$instance;

export class AsyncCompletedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(error: Exception, cancelled: boolean, userState: unknown);
    readonly cancelled: boolean;
    readonly error: Exception;
    readonly userState: unknown;
}


export type AsyncCompletedEventArgs = AsyncCompletedEventArgs$instance;

export class AsyncCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: AsyncCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: AsyncCompletedEventArgs): void;
}


export interface __AsyncCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AsyncCompletedEventHandler = AsyncCompletedEventHandler$instance & __AsyncCompletedEventHandler$views;


export class AsyncOperation$instance {
    readonly synchronizationContext: SynchronizationContext;
    readonly userSuppliedState: unknown;
    operationCompleted(): void;
    post(d: SendOrPostCallback, arg: unknown): void;
    postOperationCompleted(d: SendOrPostCallback, arg: unknown): void;
}


export type AsyncOperation = AsyncOperation$instance;

export class AttributeCollection$instance {
    constructor(attributes: Attribute[]);
    readonly count: int;
    contains(attribute: Attribute): boolean;
    contains(attributes: Attribute[]): boolean;
    copyTo(array: ClrArray, index: int): void;
    get_Item(index: int): Attribute;
    get_Item(attributeType: Type): Attribute;
    getEnumerator(): IEnumerator;
    matches(attribute: Attribute): boolean;
    matches(attributes: Attribute[]): boolean;
    static readonly empty: AttributeCollection;
    static fromExisting(existing: AttributeCollection, newAttributes: Attribute[]): AttributeCollection;
}


export interface __AttributeCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AttributeCollection = AttributeCollection$instance & __AttributeCollection$views;


export class AttributeProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(typeName: string);
    constructor(typeName: string, propertyName: string);
    constructor(type_: Type);
    readonly propertyName: string;
    readonly typeName: string;
}


export type AttributeProviderAttribute = AttributeProviderAttribute$instance;

export class BackgroundWorker$instance extends Component$instance {
    constructor();
    readonly cancellationPending: boolean;
    readonly isBusy: boolean;
    workerReportsProgress: boolean;
    workerSupportsCancellation: boolean;
    cancelAsync(): void;
    dispose(): void;
    reportProgress(percentProgress: int): void;
    reportProgress(percentProgress: int, userState: unknown): void;
    runWorkerAsync(): void;
    runWorkerAsync(argument: unknown): void;
}


export interface __BackgroundWorker$views {
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BackgroundWorker$instance extends IComponent$instance {}

export type BackgroundWorker = BackgroundWorker$instance & __BackgroundWorker$views;


export abstract class BaseNumberConverter$instance extends TypeConverter$instance {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type BaseNumberConverter = BaseNumberConverter$instance;

export class BindableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(bindable: boolean);
    constructor(bindable: boolean, direction: BindingDirection);
    constructor(flags: BindableSupport);
    constructor(flags: BindableSupport, direction: BindingDirection);
    readonly bindable: boolean;
    readonly direction: BindingDirection;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: BindableAttribute;
    static readonly no: BindableAttribute;
    static readonly default_: BindableAttribute;
}


export type BindableAttribute = BindableAttribute$instance;

export class BindingList_1$instance<T> extends System_Collections_ObjectModel_Internal.Collection_1$instance<T> {
    constructor();
    constructor(list: IList_1<T>);
    allowEdit: boolean;
    allowNew: boolean;
    allowRemove: boolean;
    raiseListChangedEvents: boolean;
    add(item: T): void;
    add(value: unknown): int;
    addNew(): T;
    cancelNew(itemIndex: int): void;
    clear(): void;
    contains(item: T): boolean;
    contains(value: unknown): boolean;
    copyTo(array: T[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    endNew(itemIndex: int): void;
    getEnumerator(): IEnumerator_1<T>;
    getEnumerator(): IEnumerator;
    indexOf(item: T): int;
    insert(index: int, item: T): void;
    insert(index: int, value: unknown): void;
    remove(item: T): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
    resetBindings(): void;
    resetItem(position: int): void;
}


export interface __BindingList_1$views<T> {
    As_IBindingList(): IBindingList$instance;
    As_ICancelAddNew(): ICancelAddNew$instance;
    As_IRaiseItemChangedEvents(): IRaiseItemChangedEvents$instance;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export interface BindingList_1$instance<T> extends ICancelAddNew$instance, IRaiseItemChangedEvents$instance {}

export type BindingList_1<T> = BindingList_1$instance<T> & __BindingList_1$views<T>;


export class BooleanConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export type BooleanConverter = BooleanConverter$instance;

export class BrowsableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(browsable: boolean);
    readonly browsable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: BrowsableAttribute;
    static readonly no: BrowsableAttribute;
    static readonly default_: BrowsableAttribute;
}


export type BrowsableAttribute = BrowsableAttribute$instance;

export class ByteConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type ByteConverter = ByteConverter$instance;

export class CancelEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    constructor(cancel: boolean);
    cancel: boolean;
}


export type CancelEventArgs = CancelEventArgs$instance;

export class CancelEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: CancelEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: CancelEventArgs): void;
}


export interface __CancelEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CancelEventHandler = CancelEventHandler$instance & __CancelEventHandler$views;


export class CategoryAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(category: string);
    readonly category: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly action: CategoryAttribute;
    static readonly appearance: CategoryAttribute;
    static readonly asynchronous: CategoryAttribute;
    static readonly behavior: CategoryAttribute;
    static readonly data: CategoryAttribute;
    static readonly default_: CategoryAttribute;
    static readonly design: CategoryAttribute;
    static readonly dragDrop: CategoryAttribute;
    static readonly focus: CategoryAttribute;
    static readonly format: CategoryAttribute;
    static readonly key: CategoryAttribute;
    static readonly layout: CategoryAttribute;
    static readonly mouse: CategoryAttribute;
    static readonly windowStyle: CategoryAttribute;
}


export type CategoryAttribute = CategoryAttribute$instance;

export class CharConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type CharConverter = CharConverter$instance;

export class CollectionChangeEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(action: CollectionChangeAction, element: unknown);
    readonly action: CollectionChangeAction;
    readonly element: unknown;
}


export type CollectionChangeEventArgs = CollectionChangeEventArgs$instance;

export class CollectionChangeEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: CollectionChangeEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: CollectionChangeEventArgs): void;
}


export interface __CollectionChangeEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CollectionChangeEventHandler = CollectionChangeEventHandler$instance & __CollectionChangeEventHandler$views;


export class CollectionConverter$instance extends TypeConverter$instance {
    constructor();
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
}


export type CollectionConverter = CollectionConverter$instance;

export class ComplexBindingPropertiesAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(dataSource: string);
    constructor(dataSource: string, dataMember: string);
    readonly dataMember: string;
    readonly dataSource: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static readonly default_: ComplexBindingPropertiesAttribute;
}


export type ComplexBindingPropertiesAttribute = ComplexBindingPropertiesAttribute$instance;

export class Component$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    readonly container: IContainer;
    site: ISite;
    dispose(): void;
    toString(): string;
}


export interface __Component$views {
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Component = Component$instance & __Component$views;


export class ComponentCollection$instance extends System_Collections_Internal.ReadOnlyCollectionBase$instance {
    constructor(components: IComponent[]);
    copyTo(array: ClrArray, index: int): void;
    get_Item(name: string): IComponent;
    get_Item(index: int): IComponent;
    getEnumerator(): IEnumerator;
}


export interface __ComponentCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ComponentCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type ComponentCollection = ComponentCollection$instance & __ComponentCollection$views;


export class ComponentConverter$instance extends ReferenceConverter$instance {
    constructor(type_: Type);
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type ComponentConverter = ComponentConverter$instance;

export abstract class ComponentEditor$instance {
    editComponent(component: unknown): boolean;
    editComponent(context: ITypeDescriptorContext, component: unknown): boolean;
}


export type ComponentEditor = ComponentEditor$instance;

export class ComponentResourceManager$instance extends System_Resources_Internal.ResourceManager$instance {
    constructor();
    constructor(t: Type);
    applyResources(value: unknown, objectName: string): void;
    applyResources(value: unknown, objectName: string, culture: CultureInfo): void;
    applyResourcesToRegisteredType(value: unknown, objectName: string, culture: CultureInfo): void;
}


export type ComponentResourceManager = ComponentResourceManager$instance;

export class Container$instance {
    constructor();
    readonly components: ComponentCollection;
    add(component: IComponent): void;
    add(component: IComponent, name: string): void;
    dispose(): void;
    remove(component: IComponent): void;
}


export interface __Container$views {
    As_IContainer(): IContainer$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Container = Container$instance & __Container$views;


export abstract class ContainerFilterService$instance {
    filterComponents(components: ComponentCollection): ComponentCollection;
}


export type ContainerFilterService = ContainerFilterService$instance;

export class CultureInfoConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export type CultureInfoConverter = CultureInfoConverter$instance;

export abstract class CustomTypeDescriptor$instance {
    readonly requireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    getAttributes(): AttributeCollection;
    getClassName(): string;
    getComponentName(): string;
    getConverter(): TypeConverter;
    getConverterFromRegisteredType(): TypeConverter;
    getDefaultEvent(): EventDescriptor;
    getDefaultProperty(): PropertyDescriptor;
    getEditor(editorBaseType: Type): unknown;
    getEvents(): EventDescriptorCollection;
    getEvents(attributes: Attribute[]): EventDescriptorCollection;
    getEventsFromRegisteredType(): EventDescriptorCollection;
    getProperties(): PropertyDescriptorCollection;
    getProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertiesFromRegisteredType(): PropertyDescriptorCollection;
    getPropertyOwner(pd: PropertyDescriptor): unknown;
}


export interface __CustomTypeDescriptor$views {
    As_ICustomTypeDescriptor(): ICustomTypeDescriptor$instance;
}

export interface CustomTypeDescriptor$instance extends ICustomTypeDescriptor$instance {}

export type CustomTypeDescriptor = CustomTypeDescriptor$instance & __CustomTypeDescriptor$views;


export class DataErrorsChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(propertyName: string);
    readonly propertyName: string;
}


export type DataErrorsChangedEventArgs = DataErrorsChangedEventArgs$instance;

export class DataObjectAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(isDataObject: boolean);
    readonly isDataObject: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly dataObject: DataObjectAttribute;
    static readonly nonDataObject: DataObjectAttribute;
    static readonly default_: DataObjectAttribute;
}


export type DataObjectAttribute = DataObjectAttribute$instance;

export class DataObjectFieldAttribute$instance extends System_Internal.Attribute$instance {
    constructor(primaryKey: boolean);
    constructor(primaryKey: boolean, isIdentity: boolean);
    constructor(primaryKey: boolean, isIdentity: boolean, isNullable: boolean);
    constructor(primaryKey: boolean, isIdentity: boolean, isNullable: boolean, length: int);
    readonly isIdentity: boolean;
    readonly isNullable: boolean;
    readonly length: int;
    readonly primaryKey: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type DataObjectFieldAttribute = DataObjectFieldAttribute$instance;

export class DataObjectMethodAttribute$instance extends System_Internal.Attribute$instance {
    constructor(methodType: DataObjectMethodType);
    constructor(methodType: DataObjectMethodType, isDefault: boolean);
    readonly isDefault: boolean;
    readonly methodType: DataObjectMethodType;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    match(obj: unknown): boolean;
}


export type DataObjectMethodAttribute = DataObjectMethodAttribute$instance;

export class DateOnlyConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type DateOnlyConverter = DateOnlyConverter$instance;

export class DateTimeConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type DateTimeConverter = DateTimeConverter$instance;

export class DateTimeOffsetConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type DateTimeOffsetConverter = DateTimeOffsetConverter$instance;

export class DecimalConverter$instance extends BaseNumberConverter$instance {
    constructor();
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type DecimalConverter = DecimalConverter$instance;

export class DefaultBindingPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(name: string);
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static readonly default_: DefaultBindingPropertyAttribute;
}


export type DefaultBindingPropertyAttribute = DefaultBindingPropertyAttribute$instance;

export class DefaultEventAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static readonly default_: DefaultEventAttribute;
}


export type DefaultEventAttribute = DefaultEventAttribute$instance;

export class DefaultPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(name: string);
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static readonly default_: DefaultPropertyAttribute;
}


export type DefaultPropertyAttribute = DefaultPropertyAttribute$instance;

export class DefaultValueAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type, value: string);
    constructor(value: char);
    constructor(value: byte);
    constructor(value: short);
    constructor(value: int);
    constructor(value: long);
    constructor(value: float);
    constructor(value: double);
    constructor(value: boolean);
    constructor(value: string);
    constructor(value: unknown);
    constructor(value: sbyte);
    constructor(value: ushort);
    constructor(value: uint);
    constructor(value: ulong);
    readonly value: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type DefaultValueAttribute = DefaultValueAttribute$instance;

export class DescriptionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(description: string);
    readonly description: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly default_: DescriptionAttribute;
}


export type DescriptionAttribute = DescriptionAttribute$instance;

export class DesignerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(designerTypeName: string);
    constructor(designerType: Type);
    constructor(designerTypeName: string, designerBaseTypeName: string);
    constructor(designerTypeName: string, designerBaseType: Type);
    constructor(designerType: Type, designerBaseType: Type);
    readonly designerBaseTypeName: string;
    readonly designerTypeName: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type DesignerAttribute = DesignerAttribute$instance;

export class DesignerCategoryAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(category: string);
    readonly category: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly component: DesignerCategoryAttribute;
    static readonly default_: DesignerCategoryAttribute;
    static readonly form: DesignerCategoryAttribute;
    static readonly generic: DesignerCategoryAttribute;
}


export type DesignerCategoryAttribute = DesignerCategoryAttribute$instance;

export class DesignerSerializationVisibilityAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visibility: DesignerSerializationVisibility);
    readonly visibility: DesignerSerializationVisibility;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly content: DesignerSerializationVisibilityAttribute;
    static readonly hidden: DesignerSerializationVisibilityAttribute;
    static readonly visible: DesignerSerializationVisibilityAttribute;
    static readonly default_: DesignerSerializationVisibilityAttribute;
}


export type DesignerSerializationVisibilityAttribute = DesignerSerializationVisibilityAttribute$instance;

export class DesignOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isDesignOnly: boolean);
    readonly isDesignOnly: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: DesignOnlyAttribute;
    static readonly no: DesignOnlyAttribute;
    static readonly default_: DesignOnlyAttribute;
}


export type DesignOnlyAttribute = DesignOnlyAttribute$instance;

export class DesignTimeVisibleAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visible: boolean);
    constructor();
    readonly visible: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: DesignTimeVisibleAttribute;
    static readonly no: DesignTimeVisibleAttribute;
    static readonly default_: DesignTimeVisibleAttribute;
}


export type DesignTimeVisibleAttribute = DesignTimeVisibleAttribute$instance;

export class DisplayNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(displayName: string);
    readonly displayName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly default_: DisplayNameAttribute;
}


export type DisplayNameAttribute = DisplayNameAttribute$instance;

export class DoubleConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type DoubleConverter = DoubleConverter$instance;

export class DoWorkEventArgs$instance extends CancelEventArgs$instance {
    constructor(argument: unknown);
    readonly argument: unknown;
    result: unknown;
}


export type DoWorkEventArgs = DoWorkEventArgs$instance;

export class DoWorkEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: DoWorkEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: DoWorkEventArgs): void;
}


export interface __DoWorkEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DoWorkEventHandler = DoWorkEventHandler$instance & __DoWorkEventHandler$views;


export class EditorAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(typeName: string, baseTypeName: string);
    constructor(typeName: string, baseType: Type);
    constructor(type_: Type, baseType: Type);
    readonly editorBaseTypeName: string;
    readonly editorTypeName: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type EditorAttribute = EditorAttribute$instance;

export class EditorBrowsableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(state: EditorBrowsableState);
    constructor();
    readonly state: EditorBrowsableState;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type EditorBrowsableAttribute = EditorBrowsableAttribute$instance;

export class EnumConverter$instance extends TypeConverter$instance {
    constructor(type_: Type);
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
    isValid(value: unknown): boolean;
}


export type EnumConverter = EnumConverter$instance;

export abstract class EventDescriptor$instance extends MemberDescriptor$instance {
    readonly componentType: Type;
    readonly eventType: Type;
    readonly isMulticast: boolean;
    abstract addEventHandler(component: unknown, value: Function): void;
    abstract removeEventHandler(component: unknown, value: Function): void;
}


export type EventDescriptor = EventDescriptor$instance;

export class EventDescriptorCollection$instance {
    constructor(events: EventDescriptor[]);
    constructor(events: EventDescriptor[], readOnly: boolean);
    readonly count: int;
    add(value: EventDescriptor): int;
    clear(): void;
    contains(value: EventDescriptor): boolean;
    find(name: string, ignoreCase: boolean): EventDescriptor;
    get_Item(index: int): EventDescriptor;
    get_Item(name: string): EventDescriptor;
    getEnumerator(): IEnumerator;
    indexOf(value: EventDescriptor): int;
    insert(index: int, value: EventDescriptor): void;
    remove(value: EventDescriptor): void;
    removeAt(index: int): void;
    sort(): EventDescriptorCollection;
    sort(names: string[]): EventDescriptorCollection;
    sort(names: string[], comparer: IComparer): EventDescriptorCollection;
    sort(comparer: IComparer): EventDescriptorCollection;
    static readonly empty: EventDescriptorCollection;
}


export interface __EventDescriptorCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type EventDescriptorCollection = EventDescriptorCollection$instance & __EventDescriptorCollection$views;


export class EventHandlerList$instance {
    constructor();
    item: Function;
    addHandler(key: unknown, value: Function): void;
    addHandlers(listToAddFrom: EventHandlerList): void;
    dispose(): void;
    removeHandler(key: unknown, value: Function): void;
}


export interface __EventHandlerList$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventHandlerList$instance extends System_Internal.IDisposable$instance {}

export type EventHandlerList = EventHandlerList$instance & __EventHandlerList$views;


export class ExpandableObjectConverter$instance extends TypeConverter$instance {
    constructor();
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type ExpandableObjectConverter = ExpandableObjectConverter$instance;

export class ExtenderProvidedPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    readonly extenderProperty: PropertyDescriptor;
    readonly provider: IExtenderProvider;
    readonly receiverType: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
}


export type ExtenderProvidedPropertyAttribute = ExtenderProvidedPropertyAttribute$instance;

export class GuidConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type GuidConverter = GuidConverter$instance;

export class HalfConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type HalfConverter = HalfConverter$instance;

export class HandledEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    constructor(defaultHandledValue: boolean);
    handled: boolean;
}


export type HandledEventArgs = HandledEventArgs$instance;

export class HandledEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: HandledEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: HandledEventArgs): void;
}


export interface __HandledEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HandledEventHandler = HandledEventHandler$instance & __HandledEventHandler$views;


export class ImmutableObjectAttribute$instance extends System_Internal.Attribute$instance {
    constructor(immutable: boolean);
    readonly immutable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: ImmutableObjectAttribute;
    static readonly no: ImmutableObjectAttribute;
    static readonly default_: ImmutableObjectAttribute;
}


export type ImmutableObjectAttribute = ImmutableObjectAttribute$instance;

export class InheritanceAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(inheritanceLevel: InheritanceLevel);
    readonly inheritanceLevel: InheritanceLevel;
    equals(value: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    toString(): string;
    static readonly inherited: InheritanceAttribute;
    static readonly inheritedReadOnly: InheritanceAttribute;
    static readonly notInherited: InheritanceAttribute;
    static readonly default_: InheritanceAttribute;
}


export type InheritanceAttribute = InheritanceAttribute$instance;

export class InitializationEventAttribute$instance extends System_Internal.Attribute$instance {
    constructor(eventName: string);
    readonly eventName: string;
}


export type InitializationEventAttribute = InitializationEventAttribute$instance;

export class InstallerTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(installerType: Type);
    constructor(typeName: string);
    readonly installerType: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type InstallerTypeAttribute = InstallerTypeAttribute$instance;

export abstract class InstanceCreationEditor$instance {
    readonly text: string;
    abstract createInstance(context: ITypeDescriptorContext, instanceType: Type): unknown;
}


export type InstanceCreationEditor = InstanceCreationEditor$instance;

export class Int128Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int128Converter = Int128Converter$instance;

export class Int16Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int16Converter = Int16Converter$instance;

export class Int32Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int32Converter = Int32Converter$instance;

export class Int64Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type Int64Converter = Int64Converter$instance;

export class InvalidAsynchronousStateException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidAsynchronousStateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidAsynchronousStateException = InvalidAsynchronousStateException$instance & __InvalidAsynchronousStateException$views;


export class InvalidEnumArgumentException$instance extends System_Internal.ArgumentException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(argumentName: string, invalidValue: int, enumClass: Type);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidEnumArgumentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidEnumArgumentException = InvalidEnumArgumentException$instance & __InvalidEnumArgumentException$views;


export abstract class License$instance {
    readonly licenseKey: string;
    abstract dispose(): void;
}


export interface __License$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface License$instance extends System_Internal.IDisposable$instance {}

export type License = License$instance & __License$views;


export class LicenseContext$instance {
    constructor();
    readonly usageMode: LicenseUsageMode;
    getSavedLicenseKey(type_: Type, resourceAssembly: Assembly): string;
    getService(type_: Type): unknown;
    setSavedLicenseKey(type_: Type, key: string): void;
}


export interface __LicenseContext$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
}

export interface LicenseContext$instance extends System_Internal.IServiceProvider$instance {}

export type LicenseContext = LicenseContext$instance & __LicenseContext$views;


export class LicenseException$instance extends System_Internal.SystemException$instance {
    constructor(type_: Type);
    constructor(type_: Type, instance: unknown);
    constructor(type_: Type, instance: unknown, message: string);
    constructor(type_: Type, instance: unknown, message: string, innerException: Exception);
    readonly licensedType: Type;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __LicenseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LicenseException = LicenseException$instance & __LicenseException$views;


export class LicenseManager$instance {
    static currentContext: LicenseContext;
    static readonly usageMode: LicenseUsageMode;
    static createWithContext2(type_: Type, creationContext: LicenseContext, args: unknown[]): unknown;
    static createWithContext2(type_: Type, creationContext: LicenseContext): unknown;
    static isLicensed(type_: Type): boolean;
    static isValid2(type_: Type, instance: unknown, license: { value: ref<License> }): boolean;
    static isValid2(type_: Type): boolean;
    static lockContext(contextUser: unknown): void;
    static unlockContext(contextUser: unknown): void;
    static validate2(type_: Type, instance: unknown): License;
    static validate2(type_: Type): void;
}


export type LicenseManager = LicenseManager$instance;

export abstract class LicenseProvider$instance {
    abstract getLicense(context: LicenseContext, type_: Type, instance: unknown, allowExceptions: boolean): License;
}


export type LicenseProvider = LicenseProvider$instance;

export class LicenseProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(typeName: string);
    constructor(type_: Type);
    readonly licenseProvider: Type;
    readonly typeId: unknown;
    equals(value: unknown): boolean;
    getHashCode(): int;
    static readonly default_: LicenseProviderAttribute;
}


export type LicenseProviderAttribute = LicenseProviderAttribute$instance;

export class LicFileLicenseProvider$instance extends LicenseProvider$instance {
    constructor();
    getLicense(context: LicenseContext, type_: Type, instance: unknown, allowExceptions: boolean): License;
}


export type LicFileLicenseProvider = LicFileLicenseProvider$instance;

export class ListBindableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(listBindable: boolean);
    constructor(flags: BindableSupport);
    readonly listBindable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: ListBindableAttribute;
    static readonly no: ListBindableAttribute;
    static readonly default_: ListBindableAttribute;
}


export type ListBindableAttribute = ListBindableAttribute$instance;

export class ListChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(listChangedType: ListChangedType, newIndex: int);
    constructor(listChangedType: ListChangedType, newIndex: int, propDesc: PropertyDescriptor);
    constructor(listChangedType: ListChangedType, propDesc: PropertyDescriptor);
    constructor(listChangedType: ListChangedType, newIndex: int, oldIndex: int);
    readonly listChangedType: ListChangedType;
    readonly newIndex: int;
    readonly oldIndex: int;
    readonly propertyDescriptor: PropertyDescriptor;
}


export type ListChangedEventArgs = ListChangedEventArgs$instance;

export class ListChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: ListChangedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: ListChangedEventArgs): void;
}


export interface __ListChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ListChangedEventHandler = ListChangedEventHandler$instance & __ListChangedEventHandler$views;


export class ListSortDescription$instance {
    constructor(property: PropertyDescriptor, direction: ListSortDirection);
    propertyDescriptor: PropertyDescriptor;
    sortDirection: ListSortDirection;
}


export type ListSortDescription = ListSortDescription$instance;

export class ListSortDescriptionCollection$instance {
    constructor();
    constructor(sorts: ListSortDescription[]);
    readonly count: int;
    item: ListSortDescription;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    indexOf(value: unknown): int;
}


export interface __ListSortDescriptionCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ListSortDescriptionCollection = ListSortDescriptionCollection$instance & __ListSortDescriptionCollection$views;


export class LocalizableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isLocalizable: boolean);
    readonly isLocalizable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: LocalizableAttribute;
    static readonly no: LocalizableAttribute;
    static readonly default_: LocalizableAttribute;
}


export type LocalizableAttribute = LocalizableAttribute$instance;

export class LookupBindingPropertiesAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(dataSource: string, displayMember: string, valueMember: string, lookupMember: string);
    readonly dataSource: string;
    readonly displayMember: string;
    readonly lookupMember: string;
    readonly valueMember: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static readonly default_: LookupBindingPropertiesAttribute;
}


export type LookupBindingPropertiesAttribute = LookupBindingPropertiesAttribute$instance;

export class MarshalByValueComponent$instance {
    constructor();
    readonly container: IContainer;
    readonly designMode: boolean;
    site: ISite;
    dispose(): void;
    getService(service: Type): unknown;
    toString(): string;
}


export interface __MarshalByValueComponent$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MarshalByValueComponent$instance extends System_Internal.IServiceProvider$instance {}

export type MarshalByValueComponent = MarshalByValueComponent$instance & __MarshalByValueComponent$views;


export class MaskedTextProvider$instance {
    constructor(mask: string);
    constructor(mask: string, restrictToAscii: boolean);
    constructor(mask: string, culture: CultureInfo);
    constructor(mask: string, culture: CultureInfo, restrictToAscii: boolean);
    constructor(mask: string, passwordChar: char, allowPromptAsInput: boolean);
    constructor(mask: string, culture: CultureInfo, passwordChar: char, allowPromptAsInput: boolean);
    constructor(mask: string, culture: CultureInfo, allowPromptAsInput: boolean, promptChar: char, passwordChar: char, restrictToAscii: boolean);
    readonly allowPromptAsInput: boolean;
    readonly asciiOnly: boolean;
    readonly assignedEditPositionCount: int;
    readonly availableEditPositionCount: int;
    readonly culture: CultureInfo;
    readonly editPositionCount: int;
    readonly editPositions: IEnumerator;
    includeLiterals: boolean;
    includePrompt: boolean;
    isPassword: boolean;
    readonly item: char;
    readonly lastAssignedPosition: int;
    readonly length: int;
    readonly mask: string;
    readonly maskCompleted: boolean;
    readonly maskFull: boolean;
    passwordChar: char;
    promptChar: char;
    resetOnPrompt: boolean;
    resetOnSpace: boolean;
    skipLiterals: boolean;
    add(input: char): boolean;
    add(input: char, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    add(input: string): boolean;
    add(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    clear(): void;
    clear(resultHint: { value: ref<MaskedTextResultHint> }): void;
    clone(): unknown;
    findAssignedEditPositionFrom(position: int, direction: boolean): int;
    findAssignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    findEditPositionFrom(position: int, direction: boolean): int;
    findEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    findNonEditPositionFrom(position: int, direction: boolean): int;
    findNonEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    findUnassignedEditPositionFrom(position: int, direction: boolean): int;
    findUnassignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    insertAt(input: char, position: int): boolean;
    insertAt(input: char, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    insertAt(input: string, position: int): boolean;
    insertAt(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    isAvailablePosition(position: int): boolean;
    isEditPosition(position: int): boolean;
    remove(): boolean;
    remove(testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    removeAt(position: int): boolean;
    removeAt(startPosition: int, endPosition: int): boolean;
    removeAt(startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: char, position: int): boolean;
    replace(input: char, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: char, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: string, position: int): boolean;
    replace(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    replace(input: string, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    set_(input: string): boolean;
    set_(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    toDisplayString(): string;
    toString(): string;
    toString(ignorePasswordChar: boolean): string;
    toString(startPosition: int, length: int): string;
    toString(ignorePasswordChar: boolean, startPosition: int, length: int): string;
    toString(includePrompt: boolean, includeLiterals: boolean): string;
    toString(includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    toString(ignorePasswordChar: boolean, includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    verifyChar(input: char, position: int, hint: { value: ref<MaskedTextResultHint> }): boolean;
    verifyEscapeChar(input: char, position: int): boolean;
    verifyString(input: string): boolean;
    verifyString(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    static readonly defaultPasswordChar: char;
    static readonly invalidIndex: int;
    static getOperationResultFromHint(hint: MaskedTextResultHint): boolean;
    static isValidInputChar(c: char): boolean;
    static isValidMaskChar(c: char): boolean;
    static isValidPasswordChar(c: char): boolean;
}


export interface __MaskedTextProvider$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface MaskedTextProvider$instance extends System_Internal.ICloneable$instance {}

export type MaskedTextProvider = MaskedTextProvider$instance & __MaskedTextProvider$views;


export abstract class MemberDescriptor$instance {
    readonly attributes: AttributeCollection;
    readonly category: string;
    readonly description: string;
    readonly designTimeOnly: boolean;
    readonly displayName: string;
    readonly isBrowsable: boolean;
    readonly name: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type MemberDescriptor = MemberDescriptor$instance;

export class MergablePropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(allowMerge: boolean);
    readonly allowMerge: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: MergablePropertyAttribute;
    static readonly no: MergablePropertyAttribute;
    static readonly default_: MergablePropertyAttribute;
}


export type MergablePropertyAttribute = MergablePropertyAttribute$instance;

export class MultilineStringConverter$instance extends TypeConverter$instance {
    constructor();
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type MultilineStringConverter = MultilineStringConverter$instance;

export class NestedContainer$instance extends Container$instance {
    constructor(owner: IComponent);
    readonly owner: IComponent;
    add(component: IComponent): void;
    add(component: IComponent, name: string): void;
    dispose(): void;
}


export interface __NestedContainer$views {
    As_IContainer(): IContainer$instance;
    As_INestedContainer(): INestedContainer$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NestedContainer = NestedContainer$instance & __NestedContainer$views;


export class NotifyParentPropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(notifyParent: boolean);
    readonly notifyParent: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: NotifyParentPropertyAttribute;
    static readonly no: NotifyParentPropertyAttribute;
    static readonly default_: NotifyParentPropertyAttribute;
}


export type NotifyParentPropertyAttribute = NotifyParentPropertyAttribute$instance;

export class NullableConverter$instance extends TypeConverter$instance {
    constructor(type_: Type);
    readonly nullableType: Type;
    readonly underlyingType: Type;
    readonly underlyingTypeConverter: TypeConverter;
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
    isValid(value: unknown): boolean;
}


export type NullableConverter = NullableConverter$instance;

export class ParenthesizePropertyNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(needParenthesis: boolean);
    readonly needParenthesis: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly default_: ParenthesizePropertyNameAttribute;
}


export type ParenthesizePropertyNameAttribute = ParenthesizePropertyNameAttribute$instance;

export class PasswordPropertyTextAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(password: boolean);
    readonly password: boolean;
    equals(o: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: PasswordPropertyTextAttribute;
    static readonly no: PasswordPropertyTextAttribute;
    static readonly default_: PasswordPropertyTextAttribute;
}


export type PasswordPropertyTextAttribute = PasswordPropertyTextAttribute$instance;

export class ProgressChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(progressPercentage: int, userState: unknown);
    readonly progressPercentage: int;
    readonly userState: unknown;
}


export type ProgressChangedEventArgs = ProgressChangedEventArgs$instance;

export class ProgressChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: ProgressChangedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: ProgressChangedEventArgs): void;
}


export interface __ProgressChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ProgressChangedEventHandler = ProgressChangedEventHandler$instance & __ProgressChangedEventHandler$views;


export class PropertyChangedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(propertyName: string);
    readonly propertyName: string;
}


export type PropertyChangedEventArgs = PropertyChangedEventArgs$instance;

export class PropertyChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: PropertyChangedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: PropertyChangedEventArgs): void;
}


export interface __PropertyChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PropertyChangedEventHandler = PropertyChangedEventHandler$instance & __PropertyChangedEventHandler$views;


export class PropertyChangingEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(propertyName: string);
    readonly propertyName: string;
}


export type PropertyChangingEventArgs = PropertyChangingEventArgs$instance;

export class PropertyChangingEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: PropertyChangingEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: PropertyChangingEventArgs): void;
}


export interface __PropertyChangingEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PropertyChangingEventHandler = PropertyChangingEventHandler$instance & __PropertyChangingEventHandler$views;


export abstract class PropertyDescriptor$instance extends MemberDescriptor$instance {
    readonly componentType: Type;
    readonly converter: TypeConverter;
    readonly converterFromRegisteredType: TypeConverter;
    readonly isLocalizable: boolean;
    readonly isReadOnly: boolean;
    readonly propertyType: Type;
    readonly serializationVisibility: DesignerSerializationVisibility;
    readonly supportsChangeEvents: boolean;
    addValueChanged(component: unknown, handler: EventHandler): void;
    abstract canResetValue(component: unknown): boolean;
    equals(obj: unknown): boolean;
    getChildProperties(): PropertyDescriptorCollection;
    getChildProperties(filter: Attribute[]): PropertyDescriptorCollection;
    getChildProperties(instance: unknown): PropertyDescriptorCollection;
    getChildProperties(instance: unknown, filter: Attribute[]): PropertyDescriptorCollection;
    getEditor(editorBaseType: Type): unknown;
    getHashCode(): int;
    abstract getValue(component: unknown): unknown;
    removeValueChanged(component: unknown, handler: EventHandler): void;
    abstract resetValue(component: unknown): void;
    abstract setValue(component: unknown, value: unknown): void;
    abstract shouldSerializeValue(component: unknown): boolean;
}


export type PropertyDescriptor = PropertyDescriptor$instance;

export class PropertyDescriptorCollection$instance {
    constructor(properties: PropertyDescriptor[]);
    constructor(properties: PropertyDescriptor[], readOnly: boolean);
    readonly count: int;
    add(value: PropertyDescriptor): int;
    clear(): void;
    contains(value: PropertyDescriptor): boolean;
    copyTo(array: ClrArray, index: int): void;
    find(name: string, ignoreCase: boolean): PropertyDescriptor;
    get_Item(index: int): PropertyDescriptor;
    get_Item(name: string): PropertyDescriptor;
    getEnumerator(): IEnumerator;
    indexOf(value: PropertyDescriptor): int;
    insert(index: int, value: PropertyDescriptor): void;
    remove(value: PropertyDescriptor): void;
    removeAt(index: int): void;
    sort(): PropertyDescriptorCollection;
    sort(names: string[]): PropertyDescriptorCollection;
    sort(names: string[], comparer: IComparer): PropertyDescriptorCollection;
    sort(comparer: IComparer): PropertyDescriptorCollection;
    static readonly empty: PropertyDescriptorCollection;
}


export interface __PropertyDescriptorCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type PropertyDescriptorCollection = PropertyDescriptorCollection$instance & __PropertyDescriptorCollection$views;


export class PropertyTabAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(tabClass: Type);
    constructor(tabClassName: string);
    constructor(tabClass: Type, tabScope: PropertyTabScope);
    constructor(tabClassName: string, tabScope: PropertyTabScope);
    readonly tabClasses: Type[];
    readonly tabScopes: PropertyTabScope[];
    equals(other: unknown): boolean;
    equals(other: PropertyTabAttribute): boolean;
    getHashCode(): int;
}


export type PropertyTabAttribute = PropertyTabAttribute$instance;

export class ProvidePropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(propertyName: string, receiverType: Type);
    constructor(propertyName: string, receiverTypeName: string);
    readonly propertyName: string;
    readonly receiverTypeName: string;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type ProvidePropertyAttribute = ProvidePropertyAttribute$instance;

export class ReadOnlyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isReadOnly: boolean);
    readonly isReadOnly: boolean;
    equals(value: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: ReadOnlyAttribute;
    static readonly no: ReadOnlyAttribute;
    static readonly default_: ReadOnlyAttribute;
}


export type ReadOnlyAttribute = ReadOnlyAttribute$instance;

export class RecommendedAsConfigurableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(recommendedAsConfigurable: boolean);
    readonly recommendedAsConfigurable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly no: RecommendedAsConfigurableAttribute;
    static readonly yes: RecommendedAsConfigurableAttribute;
    static readonly default_: RecommendedAsConfigurableAttribute;
}


export type RecommendedAsConfigurableAttribute = RecommendedAsConfigurableAttribute$instance;

export class ReferenceConverter$instance extends TypeConverter$instance {
    constructor(type_: Type);
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export type ReferenceConverter = ReferenceConverter$instance;

export class RefreshEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(componentChanged: unknown);
    constructor(typeChanged: Type);
    readonly componentChanged: unknown;
    readonly typeChanged: Type;
}


export type RefreshEventArgs = RefreshEventArgs$instance;

export class RefreshEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(e: RefreshEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(e: RefreshEventArgs): void;
}


export interface __RefreshEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RefreshEventHandler = RefreshEventHandler$instance & __RefreshEventHandler$views;


export class RefreshPropertiesAttribute$instance extends System_Internal.Attribute$instance {
    constructor(refresh: RefreshProperties);
    readonly refreshProperties: RefreshProperties;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly all: RefreshPropertiesAttribute;
    static readonly repaint: RefreshPropertiesAttribute;
    static readonly default_: RefreshPropertiesAttribute;
}


export type RefreshPropertiesAttribute = RefreshPropertiesAttribute$instance;

export class RunInstallerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(runInstaller: boolean);
    readonly runInstaller: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly yes: RunInstallerAttribute;
    static readonly no: RunInstallerAttribute;
    static readonly default_: RunInstallerAttribute;
}


export type RunInstallerAttribute = RunInstallerAttribute$instance;

export class RunWorkerCompletedEventArgs$instance extends AsyncCompletedEventArgs$instance {
    constructor(result: unknown, error: Exception, cancelled: boolean);
    readonly result: unknown;
    readonly userState: unknown;
}


export type RunWorkerCompletedEventArgs = RunWorkerCompletedEventArgs$instance;

export class RunWorkerCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: RunWorkerCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: RunWorkerCompletedEventArgs): void;
}


export interface __RunWorkerCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RunWorkerCompletedEventHandler = RunWorkerCompletedEventHandler$instance & __RunWorkerCompletedEventHandler$views;


export class SByteConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type SByteConverter = SByteConverter$instance;

export class SettingsBindableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(bindable: boolean);
    readonly bindable: boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static readonly yes: SettingsBindableAttribute;
    static readonly no: SettingsBindableAttribute;
}


export type SettingsBindableAttribute = SettingsBindableAttribute$instance;

export class SingleConverter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type SingleConverter = SingleConverter$instance;

export class StringConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
}


export type StringConverter = StringConverter$instance;

export class TimeOnlyConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type TimeOnlyConverter = TimeOnlyConverter$instance;

export class TimeSpanConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
}


export type TimeSpanConverter = TimeSpanConverter$instance;

export class ToolboxItemAttribute$instance extends System_Internal.Attribute$instance {
    constructor(defaultType: boolean);
    constructor(toolboxItemTypeName: string);
    constructor(toolboxItemType: Type);
    readonly toolboxItemType: Type;
    readonly toolboxItemTypeName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    isDefaultAttribute(): boolean;
    static readonly default_: ToolboxItemAttribute;
    static readonly none: ToolboxItemAttribute;
}


export type ToolboxItemAttribute = ToolboxItemAttribute$instance;

export class ToolboxItemFilterAttribute$instance extends System_Internal.Attribute$instance {
    constructor(filterString: string);
    constructor(filterString: string, filterType: ToolboxItemFilterType);
    readonly filterString: string;
    readonly filterType: ToolboxItemFilterType;
    readonly typeId: unknown;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    match(obj: unknown): boolean;
    toString(): string;
}


export type ToolboxItemFilterAttribute = ToolboxItemFilterAttribute$instance;

export class TypeConverter$instance {
    constructor();
    canConvertFrom(sourceType: Type): boolean;
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    convertFrom(value: unknown): unknown;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFromInvariantString(text: string): unknown;
    convertFromInvariantString(context: ITypeDescriptorContext, text: string): unknown;
    convertFromString(text: string): unknown;
    convertFromString(context: ITypeDescriptorContext, text: string): unknown;
    convertFromString(context: ITypeDescriptorContext, culture: CultureInfo, text: string): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertToInvariantString(value: unknown): string;
    convertToInvariantString(context: ITypeDescriptorContext, value: unknown): string;
    convertToString(value: unknown): string;
    convertToString(context: ITypeDescriptorContext, value: unknown): string;
    convertToString(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): string;
    createInstance(propertyValues: IDictionary): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(): boolean;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getPropertiesSupported(): boolean;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValues(): ICollection;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValuesExclusive(): boolean;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    isValid(value: unknown): boolean;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
}


export type TypeConverter = TypeConverter$instance;

export class TypeConverter_StandardValuesCollection$instance {
    constructor(values: ICollection);
    readonly count: int;
    readonly item: unknown;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
}


export interface __TypeConverter_StandardValuesCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type TypeConverter_StandardValuesCollection = TypeConverter_StandardValuesCollection$instance & __TypeConverter_StandardValuesCollection$views;


export class TypeConverterAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(type_: Type);
    constructor(typeName: string);
    readonly converterTypeName: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static readonly default_: TypeConverterAttribute;
}


export type TypeConverterAttribute = TypeConverterAttribute$instance;

export abstract class TypeDescriptionProvider$instance {
    readonly requireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    createInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: unknown[]): unknown;
    getCache(instance: unknown): IDictionary;
    getExtendedTypeDescriptor(instance: unknown): ICustomTypeDescriptor;
    getExtendedTypeDescriptorFromRegisteredType(instance: unknown): ICustomTypeDescriptor;
    getFullComponentName(component: unknown): string;
    getReflectionType(objectType: Type): Type;
    getReflectionType(instance: unknown): Type;
    getReflectionType(objectType: Type, instance: unknown): Type;
    getRuntimeType(reflectionType: Type): Type;
    getTypeDescriptor(objectType: Type): ICustomTypeDescriptor;
    getTypeDescriptor(instance: unknown): ICustomTypeDescriptor;
    getTypeDescriptor(objectType: Type, instance: unknown): ICustomTypeDescriptor;
    getTypeDescriptorFromRegisteredType(objectType: Type): ICustomTypeDescriptor;
    getTypeDescriptorFromRegisteredType(instance: unknown): ICustomTypeDescriptor;
    getTypeDescriptorFromRegisteredType(objectType: Type, instance: unknown): ICustomTypeDescriptor;
    isRegisteredType(type_: Type): boolean;
    isSupportedType(type_: Type): boolean;
    registerType<T>(): void;
}


export type TypeDescriptionProvider = TypeDescriptionProvider$instance;

export class TypeDescriptionProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(typeName: string);
    constructor(type_: Type);
    readonly typeName: string;
}


export type TypeDescriptionProviderAttribute = TypeDescriptionProviderAttribute$instance;

export class TypeDescriptor$instance {
    static readonly interfaceType: Type;
    static readonly comObjectType: Type;
    static comNativeDescriptorHandler: IComNativeDescriptorHandler;
    static addAttributes2(instance: unknown, attributes: Attribute[]): TypeDescriptionProvider;
    static addAttributes2(type_: Type, attributes: Attribute[]): TypeDescriptionProvider;
    static addEditorTable(editorBaseType: Type, table: Hashtable): void;
    static addProvider2(provider: TypeDescriptionProvider, instance: unknown): void;
    static addProvider2(provider: TypeDescriptionProvider, type_: Type): void;
    static addProviderTransparent2(provider: TypeDescriptionProvider, instance: unknown): void;
    static addProviderTransparent2(provider: TypeDescriptionProvider, type_: Type): void;
    static createAssociation(primary: unknown, secondary: unknown): void;
    static createDesigner(component: IComponent, designerBaseType: Type): IDesigner;
    static createEvent2(componentType: Type, oldEventDescriptor: EventDescriptor, attributes: Attribute[]): EventDescriptor;
    static createEvent2(componentType: Type, name: string, type_: Type, attributes: Attribute[]): EventDescriptor;
    static createInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: unknown[]): unknown;
    static createProperty2(componentType: Type, oldPropertyDescriptor: PropertyDescriptor, attributes: Attribute[]): PropertyDescriptor;
    static createProperty2(componentType: Type, name: string, type_: Type, attributes: Attribute[]): PropertyDescriptor;
    static getAssociation(type_: Type, primary: unknown): unknown;
    static getAttributes3(component: unknown, noCustomTypeDesc: boolean): AttributeCollection;
    static getAttributes3(component: unknown): AttributeCollection;
    static getAttributes3(componentType: Type): AttributeCollection;
    static getClassName2(component: unknown, noCustomTypeDesc: boolean): string;
    static getClassName2(component: unknown): string;
    static getClassName2(componentType: Type): string;
    static getComponentName2(component: unknown, noCustomTypeDesc: boolean): string;
    static getComponentName2(component: unknown): string;
    static getConverter2(component: unknown, noCustomTypeDesc: boolean): TypeConverter;
    static getConverter2(component: unknown): TypeConverter;
    static getConverter2(type_: Type): TypeConverter;
    static getConverterFromRegisteredType(component: unknown): TypeConverter;
    static getConverterFromRegisteredType(type_: Type): TypeConverter;
    static getDefaultEvent3(component: unknown, noCustomTypeDesc: boolean): EventDescriptor;
    static getDefaultEvent3(component: unknown): EventDescriptor;
    static getDefaultEvent3(componentType: Type): EventDescriptor;
    static getDefaultProperty3(component: unknown, noCustomTypeDesc: boolean): PropertyDescriptor;
    static getDefaultProperty3(component: unknown): PropertyDescriptor;
    static getDefaultProperty3(componentType: Type): PropertyDescriptor;
    static getEditor2(component: unknown, editorBaseType: Type, noCustomTypeDesc: boolean): unknown;
    static getEditor2(component: unknown, editorBaseType: Type): unknown;
    static getEditor2(type_: Type, editorBaseType: Type): unknown;
    static getEvents6(component: unknown, attributes: Attribute[], noCustomTypeDesc: boolean): EventDescriptorCollection;
    static getEvents6(component: unknown, attributes: Attribute[]): EventDescriptorCollection;
    static getEvents6(component: unknown, noCustomTypeDesc: boolean): EventDescriptorCollection;
    static getEvents6(component: unknown): EventDescriptorCollection;
    static getEvents6(componentType: Type, attributes: Attribute[]): EventDescriptorCollection;
    static getEvents6(componentType: Type): EventDescriptorCollection;
    static getEventsFromRegisteredType(componentType: Type): EventDescriptorCollection;
    static getFullComponentName(component: unknown): string;
    static getProperties6(component: unknown, attributes: Attribute[], noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    static getProperties6(component: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    static getProperties6(component: unknown, noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    static getProperties6(component: unknown): PropertyDescriptorCollection;
    static getProperties6(componentType: Type, attributes: Attribute[]): PropertyDescriptorCollection;
    static getProperties6(componentType: Type): PropertyDescriptorCollection;
    static getPropertiesFromRegisteredType2(component: unknown): PropertyDescriptorCollection;
    static getPropertiesFromRegisteredType2(componentType: Type): PropertyDescriptorCollection;
    static getProvider2(instance: unknown): TypeDescriptionProvider;
    static getProvider2(type_: Type): TypeDescriptionProvider;
    static getReflectionType2(instance: unknown): Type;
    static getReflectionType2(type_: Type): Type;
    static refresh(component: unknown): void;
    static refresh(assembly: Assembly): void;
    static refresh(module_: Module): void;
    static refresh(type_: Type): void;
    static registerType<T>(): void;
    static removeAssociation(primary: unknown, secondary: unknown): void;
    static removeAssociations(primary: unknown): void;
    static removeProvider2(provider: TypeDescriptionProvider, instance: unknown): void;
    static removeProvider2(provider: TypeDescriptionProvider, type_: Type): void;
    static removeProviderTransparent2(provider: TypeDescriptionProvider, instance: unknown): void;
    static removeProviderTransparent2(provider: TypeDescriptionProvider, type_: Type): void;
    static sortDescriptorArray(infos: IList): void;
}


export type TypeDescriptor = TypeDescriptor$instance;

export abstract class TypeListConverter$instance extends TypeConverter$instance {
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    getStandardValuesExclusive(): boolean;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export type TypeListConverter = TypeListConverter$instance;

export class UInt128Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt128Converter = UInt128Converter$instance;

export class UInt16Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt16Converter = UInt16Converter$instance;

export class UInt32Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt32Converter = UInt32Converter$instance;

export class UInt64Converter$instance extends BaseNumberConverter$instance {
    constructor();
}


export type UInt64Converter = UInt64Converter$instance;

export class VersionConverter$instance extends TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    isValid(context: ITypeDescriptorContext, value: unknown): boolean;
    isValid(value: unknown): boolean;
}


export type VersionConverter = VersionConverter$instance;

export class WarningException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, helpUrl: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, helpUrl: string, helpTopic: string);
    readonly helpTopic: string;
    readonly helpUrl: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __WarningException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WarningException = WarningException$instance & __WarningException$views;


export class Win32Exception$instance extends System_Runtime_InteropServices_Internal.ExternalException$instance {
    constructor();
    constructor(error: int);
    constructor(error: int, message: string);
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly nativeErrorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __Win32Exception$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Win32Exception = Win32Exception$instance & __Win32Exception$views;


export abstract class AsyncOperationManager$instance {
    static synchronizationContext: SynchronizationContext;
    static createOperation(userSuppliedState: unknown): AsyncOperation;
}


export type AsyncOperationManager = AsyncOperationManager$instance;

export abstract class SyntaxCheck$instance {
    static checkMachineName(value: string): boolean;
    static checkPath(value: string): boolean;
    static checkRootedPath(value: string): boolean;
}


export type SyntaxCheck = SyntaxCheck$instance;

