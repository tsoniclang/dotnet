// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Xsl
// Assembly: System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Stream, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IXPathNavigable, XPathNavigator, XPathResultType } from "../../System.Xml.XPath/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { IXmlNamespaceResolver, XmlNamespaceManager, XmlNamespaceScope, XmlNameTable, XmlReader, XmlResolver, XmlWriter, XmlWriterSettings } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, EventArgs, Exception, IAsyncResult, ICloneable, Int32, IntPtr, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IXsltContextFunction$instance {
    readonly Minargs: int;
    readonly Maxargs: int;
    readonly ReturnType: XPathResultType;
    readonly ArgTypes: XPathResultType[];
    Invoke(xsltContext: XsltContext, args: unknown[], docContext: XPathNavigator): unknown;
}


export type IXsltContextFunction = IXsltContextFunction$instance;

export interface IXsltContextVariable$instance {
    readonly IsLocal: boolean;
    readonly IsParam: boolean;
    readonly VariableType: XPathResultType;
    Evaluate(xsltContext: XsltContext): unknown;
}


export type IXsltContextVariable = IXsltContextVariable$instance;

export class XslCompiledTransform$instance {
    constructor();
    constructor(enableDebug: boolean);
    readonly OutputSettings: XmlWriterSettings;
    Load(stylesheet: XmlReader): void;
    Load(stylesheet: XmlReader, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    Load(stylesheet: IXPathNavigable): void;
    Load(stylesheet: IXPathNavigable, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    Load(stylesheetUri: string): void;
    Load(stylesheetUri: string, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    Load(compiledStylesheet: Type): void;
    Load(executeMethod: MethodInfo, queryData: byte[], earlyBoundTypes: Type[]): void;
    Transform(input: IXPathNavigable, results: XmlWriter): void;
    Transform(input: IXPathNavigable, arguments: XsltArgumentList, results: XmlWriter): void;
    Transform(input: IXPathNavigable, arguments: XsltArgumentList, results: TextWriter): void;
    Transform(input: IXPathNavigable, arguments: XsltArgumentList, results: Stream): void;
    Transform(input: XmlReader, results: XmlWriter): void;
    Transform(input: XmlReader, arguments: XsltArgumentList, results: XmlWriter): void;
    Transform(input: XmlReader, arguments: XsltArgumentList, results: TextWriter): void;
    Transform(input: XmlReader, arguments: XsltArgumentList, results: Stream): void;
    Transform(inputUri: string, results: XmlWriter): void;
    Transform(inputUri: string, arguments: XsltArgumentList, results: XmlWriter): void;
    Transform(inputUri: string, arguments: XsltArgumentList, results: TextWriter): void;
    Transform(inputUri: string, arguments: XsltArgumentList, results: Stream): void;
    Transform(inputUri: string, resultsFile: string): void;
    Transform(input: XmlReader, arguments: XsltArgumentList, results: XmlWriter, documentResolver: XmlResolver): void;
    Transform(input: IXPathNavigable, arguments: XsltArgumentList, results: XmlWriter, documentResolver: XmlResolver): void;
}


export type XslCompiledTransform = XslCompiledTransform$instance;

export class XsltArgumentList$instance {
    constructor();
    AddExtensionObject(namespaceUri: string, extension: unknown): void;
    AddParam(name: string, namespaceUri: string, parameter: unknown): void;
    Clear(): void;
    GetExtensionObject(namespaceUri: string): unknown;
    GetParam(name: string, namespaceUri: string): unknown;
    RemoveExtensionObject(namespaceUri: string): unknown;
    RemoveParam(name: string, namespaceUri: string): unknown;
}


export type XsltArgumentList = XsltArgumentList$instance;

export class XsltCompileException$instance extends XsltException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(inner: Exception, sourceUri: string, lineNumber: int, linePosition: int);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XsltCompileException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltCompileException = XsltCompileException$instance & __XsltCompileException$views;


export abstract class XsltContext$instance extends System_Xml_Internal.XmlNamespaceManager$instance {
    readonly Whitespace: boolean;
    abstract CompareDocument(baseUri: string, nextbaseUri: string): int;
    GetEnumerator(): IEnumerator;
    GetNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    LookupNamespace(prefix: string): string;
    abstract PreserveWhitespace(node: XPathNavigator): boolean;
    abstract ResolveFunction(prefix: string, name: string, ArgTypes: XPathResultType[]): IXsltContextFunction;
    abstract ResolveVariable(prefix: string, name: string): IXsltContextVariable;
}


export interface __XsltContext$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IXmlNamespaceResolver(): System_Xml_Internal.IXmlNamespaceResolver$instance;
}

export type XsltContext = XsltContext$instance & __XsltContext$views;


export class XsltException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly LineNumber: int;
    readonly LinePosition: int;
    readonly Message: string;
    readonly SourceUri: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XsltException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltException = XsltException$instance & __XsltException$views;


export abstract class XsltMessageEncounteredEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly Message: string;
}


export type XsltMessageEncounteredEventArgs = XsltMessageEncounteredEventArgs$instance;

export class XsltMessageEncounteredEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(sender: unknown, e: XsltMessageEncounteredEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: unknown, e: XsltMessageEncounteredEventArgs): void;
}


export interface __XsltMessageEncounteredEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltMessageEncounteredEventHandler = XsltMessageEncounteredEventHandler$instance & __XsltMessageEncounteredEventHandler$views;


export class XslTransform$instance {
    constructor();
    XmlResolver: XmlResolver;
    Load(stylesheet: XmlReader): void;
    Load(stylesheet: XmlReader, resolver: XmlResolver): void;
    Load(stylesheet: IXPathNavigable): void;
    Load(stylesheet: IXPathNavigable, resolver: XmlResolver): void;
    Load(stylesheet: XPathNavigator): void;
    Load(stylesheet: XPathNavigator, resolver: XmlResolver): void;
    Load(url: string): void;
    Load(url: string, resolver: XmlResolver): void;
    Transform(input: XPathNavigator, args: XsltArgumentList, resolver: XmlResolver): XmlReader;
    Transform(input: XPathNavigator, args: XsltArgumentList): XmlReader;
    Transform(input: XPathNavigator, args: XsltArgumentList, output: XmlWriter, resolver: XmlResolver): void;
    Transform(input: XPathNavigator, args: XsltArgumentList, output: XmlWriter): void;
    Transform(input: XPathNavigator, args: XsltArgumentList, output: Stream, resolver: XmlResolver): void;
    Transform(input: XPathNavigator, args: XsltArgumentList, output: Stream): void;
    Transform(input: XPathNavigator, args: XsltArgumentList, output: TextWriter, resolver: XmlResolver): void;
    Transform(input: XPathNavigator, args: XsltArgumentList, output: TextWriter): void;
    Transform(input: IXPathNavigable, args: XsltArgumentList, resolver: XmlResolver): XmlReader;
    Transform(input: IXPathNavigable, args: XsltArgumentList): XmlReader;
    Transform(input: IXPathNavigable, args: XsltArgumentList, output: TextWriter, resolver: XmlResolver): void;
    Transform(input: IXPathNavigable, args: XsltArgumentList, output: TextWriter): void;
    Transform(input: IXPathNavigable, args: XsltArgumentList, output: Stream, resolver: XmlResolver): void;
    Transform(input: IXPathNavigable, args: XsltArgumentList, output: Stream): void;
    Transform(input: IXPathNavigable, args: XsltArgumentList, output: XmlWriter, resolver: XmlResolver): void;
    Transform(input: IXPathNavigable, args: XsltArgumentList, output: XmlWriter): void;
    Transform(inputfile: string, outputfile: string, resolver: XmlResolver): void;
    Transform(inputfile: string, outputfile: string): void;
}


export type XslTransform = XslTransform$instance;

export class XsltSettings$instance {
    constructor();
    constructor(enableDocumentFunction: boolean, enableScript: boolean);
    EnableDocumentFunction: boolean;
    EnableScript: boolean;
    static readonly Default: XsltSettings;
    static readonly TrustedXslt: XsltSettings;
}


export type XsltSettings = XsltSettings$instance;

