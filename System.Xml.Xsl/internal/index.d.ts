// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Xsl
// Assembly: System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Stream, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IXPathNavigable, XPathNavigator, XPathResultType } from "../../System.Xml.XPath/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { IXmlNamespaceResolver, XmlNamespaceManager, XmlNamespaceScope, XmlNameTable, XmlReader, XmlResolver, XmlWriter, XmlWriterSettings } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, EventArgs, Exception, IAsyncResult, ICloneable, Int32, IntPtr, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IXsltContextFunction$instance {
    readonly Minargs: int;
    readonly Maxargs: int;
    readonly ReturnType: XPathResultType;
    readonly ArgTypes: XPathResultType[];
    Invoke(xsltContext: XsltContext, args: any[], docContext: XPathNavigator): any;
}


export type IXsltContextFunction = IXsltContextFunction$instance;

export interface IXsltContextVariable$instance {
    readonly IsLocal: boolean;
    readonly IsParam: boolean;
    readonly VariableType: XPathResultType;
    Evaluate(xsltContext: XsltContext): any;
}


export type IXsltContextVariable = IXsltContextVariable$instance;

export class XslCompiledTransform$instance {
    constructor();
    constructor(enableDebug: boolean);
    readonly outputSettings: XmlWriterSettings;
    load(stylesheet: XmlReader): void;
    load(stylesheet: XmlReader, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    load(stylesheet: IXPathNavigable): void;
    load(stylesheet: IXPathNavigable, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    load(stylesheetUri: string): void;
    load(stylesheetUri: string, settings: XsltSettings, stylesheetResolver: XmlResolver): void;
    load(compiledStylesheet: Type): void;
    load(executeMethod: MethodInfo, queryData: byte[], earlyBoundTypes: Type[]): void;
    transform(input: IXPathNavigable, results: XmlWriter): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: XmlWriter): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: TextWriter): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: Stream): void;
    transform(input: XmlReader, results: XmlWriter): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: XmlWriter): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: TextWriter): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: Stream): void;
    transform(inputUri: string, results: XmlWriter): void;
    transform(inputUri: string, arguments: XsltArgumentList, results: XmlWriter): void;
    transform(inputUri: string, arguments: XsltArgumentList, results: TextWriter): void;
    transform(inputUri: string, arguments: XsltArgumentList, results: Stream): void;
    transform(inputUri: string, resultsFile: string): void;
    transform(input: XmlReader, arguments: XsltArgumentList, results: XmlWriter, documentResolver: XmlResolver): void;
    transform(input: IXPathNavigable, arguments: XsltArgumentList, results: XmlWriter, documentResolver: XmlResolver): void;
}


export type XslCompiledTransform = XslCompiledTransform$instance;

export class XsltArgumentList$instance {
    constructor();
    addExtensionObject(namespaceUri: string, extension: any): void;
    addParam(name: string, namespaceUri: string, parameter: any): void;
    clear(): void;
    getExtensionObject(namespaceUri: string): any;
    getParam(name: string, namespaceUri: string): any;
    removeExtensionObject(namespaceUri: string): any;
    removeParam(name: string, namespaceUri: string): any;
}


export type XsltArgumentList = XsltArgumentList$instance;

export class XsltCompileException$instance extends XsltException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(inner: Exception, sourceUri: string, lineNumber: int, linePosition: int);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XsltCompileException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltCompileException = XsltCompileException$instance & __XsltCompileException$views;


export abstract class XsltContext$instance extends System_Xml_Internal.XmlNamespaceManager$instance {
    readonly whitespace: boolean;
    abstract compareDocument(baseUri: string, nextbaseUri: string): int;
    getEnumerator(): IEnumerator;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    lookupNamespace(prefix: string): string;
    abstract preserveWhitespace(node: XPathNavigator): boolean;
    abstract resolveFunction(prefix: string, name: string, ArgTypes: XPathResultType[]): IXsltContextFunction;
    abstract resolveVariable(prefix: string, name: string): IXsltContextVariable;
}


export interface __XsltContext$views {
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IXmlNamespaceResolver: System_Xml_Internal.IXmlNamespaceResolver$instance;
}

export type XsltContext = XsltContext$instance & __XsltContext$views;


export class XsltException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly lineNumber: int;
    readonly linePosition: int;
    readonly message: string;
    readonly sourceUri: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XsltException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltException = XsltException$instance & __XsltException$views;


export abstract class XsltMessageEncounteredEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly message: string;
}


export type XsltMessageEncounteredEventArgs = XsltMessageEncounteredEventArgs$instance;

export class XsltMessageEncounteredEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: XsltMessageEncounteredEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: XsltMessageEncounteredEventArgs): void;
}


export interface __XsltMessageEncounteredEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XsltMessageEncounteredEventHandler = XsltMessageEncounteredEventHandler$instance & __XsltMessageEncounteredEventHandler$views;


export class XslTransform$instance {
    constructor();
    xmlResolver: XmlResolver;
    load(stylesheet: XmlReader): void;
    load(stylesheet: XmlReader, resolver: XmlResolver): void;
    load(stylesheet: IXPathNavigable): void;
    load(stylesheet: IXPathNavigable, resolver: XmlResolver): void;
    load(stylesheet: XPathNavigator): void;
    load(stylesheet: XPathNavigator, resolver: XmlResolver): void;
    load(url: string): void;
    load(url: string, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, resolver: XmlResolver): XmlReader;
    transform(input: XPathNavigator, args: XsltArgumentList): XmlReader;
    transform(input: XPathNavigator, args: XsltArgumentList, output: XmlWriter, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: XmlWriter): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: Stream, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: Stream): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: TextWriter, resolver: XmlResolver): void;
    transform(input: XPathNavigator, args: XsltArgumentList, output: TextWriter): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, resolver: XmlResolver): XmlReader;
    transform(input: IXPathNavigable, args: XsltArgumentList): XmlReader;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: TextWriter, resolver: XmlResolver): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: TextWriter): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: Stream, resolver: XmlResolver): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: Stream): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: XmlWriter, resolver: XmlResolver): void;
    transform(input: IXPathNavigable, args: XsltArgumentList, output: XmlWriter): void;
    transform(inputfile: string, outputfile: string, resolver: XmlResolver): void;
    transform(inputfile: string, outputfile: string): void;
}


export type XslTransform = XslTransform$instance;

export class XsltSettings$instance {
    constructor();
    constructor(enableDocumentFunction: boolean, enableScript: boolean);
    enableDocumentFunction: boolean;
    enableScript: boolean;
    static readonly Default: XsltSettings;
    static readonly TrustedXslt: XsltSettings;
}


export type XsltSettings = XsltSettings$instance;

