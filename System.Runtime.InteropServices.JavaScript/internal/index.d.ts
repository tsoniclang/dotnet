// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.JavaScript
// Assembly: System.Runtime.InteropServices.JavaScript

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, Action_3, ArraySegment_1, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Delegate, Double, Exception, Func_1, Func_2, Func_3, Func_4, IAsyncResult, ICloneable, IDisposable, Int16, Int32, Int64, IntPtr, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlySpan_1, Single, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export class JSMarshalerArgument$instance {
    initialize(): void;
    toJS(value: boolean): void;
    toJS(value: Nullable_1<CLROf<boolean>>): void;
    toJS(value: byte): void;
    toJS(value: Nullable_1<CLROf<byte>>): void;
    toJS(value: byte[]): void;
    toJS(value: string): void;
    toJS(value: Nullable_1<CLROf<string>>): void;
    toJS(value: short): void;
    toJS(value: Nullable_1<CLROf<short>>): void;
    toJS(value: int): void;
    toJS(value: Nullable_1<CLROf<int>>): void;
    toJS(value: int[]): void;
    toJS(value: long): void;
    toJS(value: Nullable_1<CLROf<long>>): void;
    toJS(value: float): void;
    toJS(value: Nullable_1<CLROf<float>>): void;
    toJS(value: double): void;
    toJS(value: Nullable_1<CLROf<double>>): void;
    toJS(value: double[]): void;
    toJS(value: nint): void;
    toJS(value: Nullable_1<CLROf<nint>>): void;
    toJS(value: DateTimeOffset): void;
    toJS(value: Nullable_1<DateTimeOffset>): void;
    toJS(value: DateTime): void;
    toJS(value: Nullable_1<DateTime>): void;
    toJS(value: string): void;
    toJS(value: string[]): void;
    toJS(value: Exception): void;
    toJS(value: any): void;
    toJS(value: any[]): void;
    toJS(value: JSObject): void;
    toJS(value: JSObject[]): void;
    toJS(value: Task): void;
    toJS<T>(value: Task_1<T>, marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T>): void;
    toJS(value: Action): void;
    toJS<T>(value: Action_1<T>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T>): void;
    toJS<T1, T2>(value: Action_2<T1, T2>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>): void;
    toJS<T1, T2, T3>(value: Action_3<T1, T2, T3>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T3>): void;
    toJS<TResult>(value: Func_1<TResult>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    toJS<T, TResult>(value: Func_2<T, TResult>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    toJS<T1, T2, TResult>(value: Func_3<T1, T2, TResult>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    toJS<T1, T2, T3, TResult>(value: Func_4<T1, T2, T3, TResult>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T3>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    toJS(value: ptr<void>): void;
    toJS(value: Span_1<CLROf<byte>>): void;
    toJS(value: ArraySegment_1<CLROf<byte>>): void;
    toJS(value: Span_1<CLROf<int>>): void;
    toJS(value: Span_1<CLROf<double>>): void;
    toJS(value: ArraySegment_1<CLROf<int>>): void;
    toJS(value: ArraySegment_1<CLROf<double>>): void;
    toJSBig(value: long): void;
    toJSBig(value: Nullable_1<CLROf<long>>): void;
    toManaged(value: { value: ref<boolean> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<boolean>>> }): void;
    toManaged(value: { value: ref<byte> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<byte>>> }): void;
    toManaged(value: { value: ref<byte[]> }): void;
    toManaged(value: { value: ref<string> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<string>>> }): void;
    toManaged(value: { value: ref<short> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<short>>> }): void;
    toManaged(value: { value: ref<int> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<int>>> }): void;
    toManaged(value: { value: ref<int[]> }): void;
    toManaged(value: { value: ref<long> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<long>>> }): void;
    toManaged(value: { value: ref<float> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<float>>> }): void;
    toManaged(value: { value: ref<double> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<double>>> }): void;
    toManaged(value: { value: ref<double[]> }): void;
    toManaged(value: { value: ref<nint> }): void;
    toManaged(value: { value: ref<Nullable_1<CLROf<nint>>> }): void;
    toManaged(value: { value: ref<DateTimeOffset> }): void;
    toManaged(value: { value: ref<Nullable_1<DateTimeOffset>> }): void;
    toManaged(value: { value: ref<DateTime> }): void;
    toManaged(value: { value: ref<Nullable_1<DateTime>> }): void;
    toManaged(value: { value: ref<string> }): void;
    toManaged(value: { value: ref<string[]> }): void;
    toManaged(value: { value: ref<Exception> }): void;
    toManaged(value: { value: ref<any> }): void;
    toManaged(value: { value: ref<any[]> }): void;
    toManaged(value: { value: ref<JSObject> }): void;
    toManaged(value: { value: ref<JSObject[]> }): void;
    toManaged(value: { value: ref<Task> }): void;
    toManaged<T>(value: { value: ref<Task_1<T>> }, marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T>): void;
    toManaged(value: { value: ref<Action> }): void;
    toManaged<T>(value: { value: ref<Action_1<T>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T>): void;
    toManaged<T1, T2>(value: { value: ref<Action_2<T1, T2>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>): void;
    toManaged<T1, T2, T3>(value: { value: ref<Action_3<T1, T2, T3>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T3>): void;
    toManaged<TResult>(value: { value: ref<Func_1<TResult>> }, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    toManaged<T, TResult>(value: { value: ref<Func_2<T, TResult>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T>, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    toManaged<T1, T2, TResult>(value: { value: ref<Func_3<T1, T2, TResult>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    toManaged<T1, T2, T3, TResult>(value: { value: ref<Func_4<T1, T2, T3, TResult>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T3>, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    toManaged(value: { value: ref<ptr<void>> }): void;
    toManaged(value: { value: ref<Span_1<CLROf<byte>>> }): void;
    toManaged(value: { value: ref<ArraySegment_1<CLROf<byte>>> }): void;
    toManaged(value: { value: ref<Span_1<CLROf<int>>> }): void;
    toManaged(value: { value: ref<Span_1<CLROf<double>>> }): void;
    toManaged(value: { value: ref<ArraySegment_1<CLROf<int>>> }): void;
    toManaged(value: { value: ref<ArraySegment_1<CLROf<double>>> }): void;
    toManagedBig(value: { value: ref<long> }): void;
    toManagedBig(value: { value: ref<Nullable_1<CLROf<long>>> }): void;
}


export type JSMarshalerArgument = JSMarshalerArgument$instance;

export class JSException$instance extends System_Internal.Exception$instance {
    constructor(msg: string);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __JSException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type JSException = JSException$instance & __JSException$views;


export class JSExportAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type JSExportAttribute = JSExportAttribute$instance;

export class JSFunctionBinding$instance {
    static BindJSFunction(functionName: string, moduleName: string, signatures: ReadOnlySpan_1<JSMarshalerType>): JSFunctionBinding;
    static BindManagedFunction(fullyQualifiedName: string, signatureHash: int, signatures: ReadOnlySpan_1<JSMarshalerType>): JSFunctionBinding;
    static InvokeJS(signature: JSFunctionBinding, arguments: Span_1<JSMarshalerArgument>): void;
}


export type JSFunctionBinding = JSFunctionBinding$instance;

export class JSImportAttribute$instance extends System_Internal.Attribute$instance {
    constructor(functionName: string);
    constructor(functionName: string, moduleName: string);
    readonly functionName: string;
    readonly moduleName: string;
}


export type JSImportAttribute = JSImportAttribute$instance;

export class JSMarshalAsAttribute_1$instance<T extends JSType> extends System_Internal.Attribute$instance {
    constructor();
}


export type JSMarshalAsAttribute_1<T extends JSType> = JSMarshalAsAttribute_1$instance<T>;

export class JSMarshalerArgument_ArgumentToJSCallback_1$instance<T> extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(arg: { value: ref<JSMarshalerArgument> }, value: T, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(arg: { value: ref<JSMarshalerArgument> }, result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg: { value: ref<JSMarshalerArgument> }, value: T): void;
}


export interface __JSMarshalerArgument_ArgumentToJSCallback_1$views<T> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type JSMarshalerArgument_ArgumentToJSCallback_1<T> = JSMarshalerArgument_ArgumentToJSCallback_1$instance<T> & __JSMarshalerArgument_ArgumentToJSCallback_1$views<T>;


export class JSMarshalerArgument_ArgumentToManagedCallback_1$instance<T> extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(arg: { value: ref<JSMarshalerArgument> }, value: { value: ref<T> }, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(arg: { value: ref<JSMarshalerArgument> }, value: { value: ref<T> }, result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(arg: { value: ref<JSMarshalerArgument> }, value: { value: ref<T> }): void;
}


export interface __JSMarshalerArgument_ArgumentToManagedCallback_1$views<T> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type JSMarshalerArgument_ArgumentToManagedCallback_1<T> = JSMarshalerArgument_ArgumentToManagedCallback_1$instance<T> & __JSMarshalerArgument_ArgumentToManagedCallback_1$views<T>;


export class JSMarshalerType$instance {
    static readonly Void: JSMarshalerType;
    static readonly Discard: JSMarshalerType;
    static readonly Boolean: JSMarshalerType;
    static readonly Byte: JSMarshalerType;
    static readonly Char: JSMarshalerType;
    static readonly Int16: JSMarshalerType;
    static readonly Int32: JSMarshalerType;
    static readonly Int52: JSMarshalerType;
    static readonly BigInt64: JSMarshalerType;
    static readonly Double: JSMarshalerType;
    static readonly Single: JSMarshalerType;
    static readonly IntPtr: JSMarshalerType;
    static readonly JSObject: JSMarshalerType;
    static readonly Object: JSMarshalerType;
    static readonly String: JSMarshalerType;
    static readonly Exception: JSMarshalerType;
    static readonly DateTime: JSMarshalerType;
    static readonly DateTimeOffset: JSMarshalerType;
    static Action(): JSMarshalerType;
    static Action(arg1: JSMarshalerType, arg2: JSMarshalerType, arg3: JSMarshalerType): JSMarshalerType;
    static Action(arg1: JSMarshalerType, arg2: JSMarshalerType): JSMarshalerType;
    static Action(arg1: JSMarshalerType): JSMarshalerType;
    static Array(element: JSMarshalerType): JSMarshalerType;
    static ArraySegment(element: JSMarshalerType): JSMarshalerType;
    static Function(arg1: JSMarshalerType, arg2: JSMarshalerType, arg3: JSMarshalerType, result: JSMarshalerType): JSMarshalerType;
    static Function(arg1: JSMarshalerType, arg2: JSMarshalerType, result: JSMarshalerType): JSMarshalerType;
    static Function(arg1: JSMarshalerType, result: JSMarshalerType): JSMarshalerType;
    static Function(result: JSMarshalerType): JSMarshalerType;
    static Nullable(primitive: JSMarshalerType): JSMarshalerType;
    static Span(element: JSMarshalerType): JSMarshalerType;
    static Task(): JSMarshalerType;
    static Task(result: JSMarshalerType): JSMarshalerType;
}


export type JSMarshalerType = JSMarshalerType$instance;

export class JSObject$instance {
    readonly isDisposed: boolean;
    dispose(): void;
    getPropertyAsBoolean(propertyName: string): boolean;
    getPropertyAsByteArray(propertyName: string): byte[];
    getPropertyAsDouble(propertyName: string): double;
    getPropertyAsInt32(propertyName: string): int;
    getPropertyAsJSObject(propertyName: string): JSObject;
    getPropertyAsString(propertyName: string): string;
    getTypeOfProperty(propertyName: string): string;
    hasProperty(propertyName: string): boolean;
    setProperty(propertyName: string, value: boolean): void;
    setProperty(propertyName: string, value: int): void;
    setProperty(propertyName: string, value: double): void;
    setProperty(propertyName: string, value: string): void;
    setProperty(propertyName: string, value: JSObject): void;
    setProperty(propertyName: string, value: byte[]): void;
}


export interface __JSObject$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type JSObject = JSObject$instance & __JSObject$views;


export abstract class JSType$instance {
}


export type JSType = JSType$instance;

export class JSType_Any$instance extends JSType$instance {
}


export type JSType_Any = JSType_Any$instance;

export class JSType_Array_1$instance<T extends JSType> extends JSType$instance {
}


export type JSType_Array_1<T extends JSType> = JSType_Array_1$instance<T>;

export class JSType_BigInt$instance extends JSType$instance {
}


export type JSType_BigInt = JSType_BigInt$instance;

export class JSType_Boolean$instance extends JSType$instance {
}


export type JSType_Boolean = JSType_Boolean$instance;

export class JSType_Date$instance extends JSType$instance {
}


export type JSType_Date = JSType_Date$instance;

export class JSType_Discard$instance extends JSType$instance {
}


export type JSType_Discard = JSType_Discard$instance;

export class JSType_Error$instance extends JSType$instance {
}


export type JSType_Error = JSType_Error$instance;

export class JSType_Function$instance extends JSType$instance {
}


export type JSType_Function = JSType_Function$instance;

export class JSType_Function_1$instance<T extends JSType> extends JSType$instance {
}


export type JSType_Function_1<T extends JSType> = JSType_Function_1$instance<T>;

export class JSType_Function_2$instance<T1 extends JSType, T2 extends JSType> extends JSType$instance {
}


export type JSType_Function_2<T1 extends JSType, T2 extends JSType> = JSType_Function_2$instance<T1, T2>;

export class JSType_Function_3$instance<T1 extends JSType, T2 extends JSType, T3 extends JSType> extends JSType$instance {
}


export type JSType_Function_3<T1 extends JSType, T2 extends JSType, T3 extends JSType> = JSType_Function_3$instance<T1, T2, T3>;

export class JSType_Function_4$instance<T1 extends JSType, T2 extends JSType, T3 extends JSType, T4 extends JSType> extends JSType$instance {
}


export type JSType_Function_4<T1 extends JSType, T2 extends JSType, T3 extends JSType, T4 extends JSType> = JSType_Function_4$instance<T1, T2, T3, T4>;

export class JSType_MemoryView$instance extends JSType$instance {
}


export type JSType_MemoryView = JSType_MemoryView$instance;

export class JSType_Number$instance extends JSType$instance {
}


export type JSType_Number = JSType_Number$instance;

export class JSType_Object$instance extends JSType$instance {
}


export type JSType_Object = JSType_Object$instance;

export class JSType_Promise_1$instance<T extends JSType> extends JSType$instance {
}


export type JSType_Promise_1<T extends JSType> = JSType_Promise_1$instance<T>;

export class JSType_String$instance extends JSType$instance {
}


export type JSType_String = JSType_String$instance;

export class JSType_Void$instance extends JSType$instance {
}


export type JSType_Void = JSType_Void$instance;

export abstract class JSHost$instance {
    static readonly GlobalThis: JSObject;
    static readonly DotnetInstance: JSObject;
    static ImportAsync(moduleName: string, moduleUrl: string, cancellationToken?: CancellationToken): Task_1<JSObject>;
}


export type JSHost = JSHost$instance;

