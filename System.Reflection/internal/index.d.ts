// Generated by tsbindgen - Architecture
// Namespace: System.Reflection
// Assembly: System.ObjectModel, System.Private.CoreLib, System.Reflection.DispatchProxy, System.Reflection.Metadata, System.Reflection.TypeExtensions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { AssemblyHashAlgorithm as AssemblyHashAlgorithm_Assemblies, AssemblyVersionCompatibility } from "../../System.Configuration.Assemblies/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { FileStream, Stream } from "../../System.IO/internal/index.js";
import type { StructLayoutAttribute } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, IObjectReference, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecurityRuleSet } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ApplicationException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Delegate, Enum, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, ModuleHandle, MulticastDelegate, Object as ClrObject, ResolveEventArgs, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, SystemException, Type, TypeCode, TypedReference, UInt32, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AssemblyContentType {
    default_ = 0,
    windowsRuntime = 1
}


export enum AssemblyFlags {
    publicKey = 1,
    retargetable = 256,
    windowsRuntime = 512,
    contentTypeMask = 3584,
    disableJitCompileOptimizer = 16384,
    enableJitCompileTracking = 32768
}


export enum AssemblyHashAlgorithm {
    none = 0,
    md5 = 32771,
    sha1 = 32772,
    sha256 = 32780,
    sha384 = 32781,
    sha512 = 32782
}


export enum AssemblyNameFlags {
    none = 0,
    publicKey = 1,
    enableJITcompileOptimizer = 16384,
    enableJITcompileTracking = 32768,
    retargetable = 256
}


export enum BindingFlags {
    default_ = 0,
    ignoreCase = 1,
    declaredOnly = 2,
    instance = 4,
    static_ = 8,
    public_ = 16,
    nonPublic = 32,
    flattenHierarchy = 64,
    invokeMethod = 256,
    createInstance = 512,
    getField = 1024,
    setField = 2048,
    getProperty = 4096,
    setProperty = 8192,
    putDispProperty = 16384,
    putRefDispProperty = 32768,
    exactBinding = 65536,
    suppressChangeType = 131072,
    optionalParamBinding = 262144,
    ignoreReturn = 16777216,
    doNotWrapExceptions = 33554432
}


export enum CallingConventions {
    standard = 1,
    varArgs = 2,
    any_ = 3,
    hasThis = 32,
    explicitThis = 64
}


export enum DeclarativeSecurityAction {
    none = 0,
    demand = 2,
    assert = 3,
    deny = 4,
    permitOnly = 5,
    linkDemand = 6,
    inheritanceDemand = 7,
    requestMinimum = 8,
    requestOptional = 9,
    requestRefuse = 10
}


export enum EventAttributes {
    none = 0,
    specialName = 512,
    rtSpecialName = 1024,
    reservedMask = 1024
}


export enum ExceptionHandlingClauseOptions {
    clause = 0,
    filter = 1,
    finally_ = 2,
    fault = 4
}


export enum FieldAttributes {
    fieldAccessMask = 7,
    privateScope = 0,
    private_ = 1,
    famANDAssem = 2,
    assembly = 3,
    family = 4,
    famORAssem = 5,
    public_ = 6,
    static_ = 16,
    initOnly = 32,
    literal = 64,
    notSerialized = 128,
    specialName = 512,
    pinvokeImpl = 8192,
    rtSpecialName = 1024,
    hasFieldMarshal = 4096,
    hasDefault = 32768,
    hasFieldRVA = 256,
    reservedMask = 38144
}


export enum GenericParameterAttributes {
    none = 0,
    varianceMask = 3,
    covariant = 1,
    contravariant = 2,
    specialConstraintMask = 28,
    referenceTypeConstraint = 4,
    notNullableValueTypeConstraint = 8,
    defaultConstructorConstraint = 16,
    allowByRefLike = 32
}


export enum ImageFileMachine {
    i386 = 332,
    ia64 = 512,
    amd64 = 34404,
    arm = 452
}


export enum ManifestResourceAttributes {
    public_ = 1,
    private_ = 2,
    visibilityMask = 7
}


export enum MemberTypes {
    constructor_ = 1,
    event = 2,
    field = 4,
    method = 8,
    property = 16,
    typeInfo = 32,
    custom = 64,
    nestedType = 128,
    all = 191
}


export enum MethodAttributes {
    memberAccessMask = 7,
    privateScope = 0,
    private_ = 1,
    famANDAssem = 2,
    assembly = 3,
    family = 4,
    famORAssem = 5,
    public_ = 6,
    static_ = 16,
    final = 32,
    virtual = 64,
    hideBySig = 128,
    checkAccessOnOverride = 512,
    vtableLayoutMask = 256,
    reuseSlot = 0,
    newSlot = 256,
    abstract_ = 1024,
    specialName = 2048,
    pinvokeImpl = 8192,
    unmanagedExport = 8,
    rtSpecialName = 4096,
    hasSecurity = 16384,
    requireSecObject = 32768,
    reservedMask = 53248
}


export enum MethodImplAttributes {
    codeTypeMask = 3,
    il = 0,
    native = 1,
    optil = 2,
    runtime = 3,
    managedMask = 4,
    unmanaged = 4,
    managed = 0,
    forwardRef = 16,
    preserveSig = 128,
    internalCall = 4096,
    synchronized = 32,
    noInlining = 8,
    aggressiveInlining = 256,
    noOptimization = 64,
    aggressiveOptimization = 512,
    async_ = 8192,
    maxMethodImplVal = 65535
}


export enum MethodImportAttributes {
    none = 0,
    exactSpelling = 1,
    bestFitMappingDisable = 32,
    bestFitMappingEnable = 16,
    bestFitMappingMask = 48,
    charSetAnsi = 2,
    charSetUnicode = 4,
    charSetAuto = 6,
    charSetMask = 6,
    throwOnUnmappableCharEnable = 4096,
    throwOnUnmappableCharDisable = 8192,
    throwOnUnmappableCharMask = 12288,
    setLastError = 64,
    callingConventionWinApi = 256,
    callingConventionCDecl = 512,
    callingConventionStdCall = 768,
    callingConventionThisCall = 1024,
    callingConventionFastCall = 1280,
    callingConventionMask = 1792
}


export enum MethodSemanticsAttributes {
    setter = 1,
    getter = 2,
    other = 4,
    adder = 8,
    remover = 16,
    raiser = 32
}


export enum NullabilityState {
    unknown_ = 0,
    notNull = 1,
    nullable = 2
}


export enum ParameterAttributes {
    none = 0,
    in_ = 1,
    out = 2,
    lcid = 4,
    retval = 8,
    optional = 16,
    hasDefault = 4096,
    hasFieldMarshal = 8192,
    reserved3 = 16384,
    reserved4 = 32768,
    reservedMask = 61440
}


export enum PortableExecutableKinds {
    notAPortableExecutableImage = 0,
    ilOnly = 1,
    required32Bit = 2,
    pe32Plus = 4,
    unmanaged32Bit = 8,
    preferred32Bit = 16
}


export enum ProcessorArchitecture {
    none = 0,
    msil = 1,
    x86 = 2,
    ia64 = 3,
    amd64 = 4,
    arm = 5
}


export enum PropertyAttributes {
    none = 0,
    specialName = 512,
    rtSpecialName = 1024,
    hasDefault = 4096,
    reserved2 = 8192,
    reserved3 = 16384,
    reserved4 = 32768,
    reservedMask = 62464
}


export enum ResourceAttributes {
    public_ = 1,
    private_ = 2
}


export enum ResourceLocation {
    containedInAnotherAssembly = 2,
    containedInManifestFile = 4,
    embedded = 1
}


export enum TypeAttributes {
    visibilityMask = 7,
    notPublic = 0,
    public_ = 1,
    nestedPublic = 2,
    nestedPrivate = 3,
    nestedFamily = 4,
    nestedAssembly = 5,
    nestedFamANDAssem = 6,
    nestedFamORAssem = 7,
    layoutMask = 24,
    autoLayout = 0,
    sequentialLayout = 8,
    explicitLayout = 16,
    classSemanticsMask = 32,
    class_ = 0,
    interface_ = 32,
    abstract_ = 128,
    sealed = 256,
    specialName = 1024,
    import_ = 4096,
    serializable = 8192,
    windowsRuntime = 16384,
    stringFormatMask = 196608,
    ansiClass = 0,
    unicodeClass = 65536,
    autoClass = 131072,
    customFormatClass = 196608,
    customFormatMask = 12582912,
    beforeFieldInit = 1048576,
    rtSpecialName = 2048,
    hasSecurity = 262144,
    reservedMask = 264192
}


export interface ICustomAttributeProvider$instance {
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
}


export type ICustomAttributeProvider = ICustomAttributeProvider$instance;

export interface ICustomTypeProvider$instance {
    getCustomType(): Type;
}


export type ICustomTypeProvider = ICustomTypeProvider$instance;

export interface IReflect$instance {
    readonly underlyingSystemType: Type;
    getField(name: string, bindingAttr: BindingFlags): FieldInfo;
    getFields(bindingAttr: BindingFlags): FieldInfo[];
    getMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    getMembers(bindingAttr: BindingFlags): MemberInfo[];
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    getMethods(bindingAttr: BindingFlags): MethodInfo[];
    getProperties(bindingAttr: BindingFlags): PropertyInfo[];
    getProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    getProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    invokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
}


export type IReflect = IReflect$instance;

export interface IReflectableType$instance {
    getTypeInfo(): TypeInfo;
}


export type IReflectableType = IReflectableType$instance;

export class CustomAttributeNamedArgument$instance {
    constructor(memberInfo: MemberInfo, value: unknown);
    constructor(memberInfo: MemberInfo, typedArgument: CustomAttributeTypedArgument);
    readonly isField: boolean;
    readonly memberInfo: MemberInfo;
    readonly memberName: string;
    readonly typedValue: CustomAttributeTypedArgument;
    equals(obj: unknown): boolean;
    equals(other: CustomAttributeNamedArgument): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __CustomAttributeNamedArgument$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomAttributeNamedArgument>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomAttributeNamedArgument): boolean;
}

export type CustomAttributeNamedArgument = CustomAttributeNamedArgument$instance & __CustomAttributeNamedArgument$views;


export class CustomAttributeTypedArgument$instance {
    constructor(argumentType: Type, value: unknown);
    constructor(value: unknown);
    readonly argumentType: Type;
    readonly value: unknown;
    equals(obj: unknown): boolean;
    equals(other: CustomAttributeTypedArgument): boolean;
    getHashCode(): int;
    toString(): string;
}


export interface __CustomAttributeTypedArgument$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomAttributeTypedArgument>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomAttributeTypedArgument): boolean;
}

export type CustomAttributeTypedArgument = CustomAttributeTypedArgument$instance & __CustomAttributeTypedArgument$views;


export class InterfaceMapping$instance {
    targetType: Type;
    interfaceType: Type;
    targetMethods: MethodInfo[];
    interfaceMethods: MethodInfo[];
}


export type InterfaceMapping = InterfaceMapping$instance;

export class ParameterModifier$instance {
    constructor(parameterCount: int);
    item: boolean;
}


export type ParameterModifier = ParameterModifier$instance;

export class AmbiguousMatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AmbiguousMatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface AmbiguousMatchException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type AmbiguousMatchException = AmbiguousMatchException$instance & __AmbiguousMatchException$views;


export abstract class Assembly$instance {
    readonly codeBase: string;
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly definedTypes: IEnumerable_1<TypeInfo>;
    readonly entryPoint: MethodInfo;
    readonly escapedCodeBase: string;
    readonly exportedTypes: IEnumerable_1<Type>;
    readonly fullName: string;
    readonly globalAssemblyCache: boolean;
    readonly hostContext: long;
    readonly imageRuntimeVersion: string;
    readonly isCollectible: boolean;
    readonly isDynamic: boolean;
    readonly isFullyTrusted: boolean;
    readonly location: string;
    readonly manifestModule: Module;
    readonly modules: IEnumerable_1<Module>;
    readonly reflectionOnly: boolean;
    readonly securityRuleSet: SecurityRuleSet;
    createInstance(typeName: string): unknown;
    createInstance(typeName: string, ignoreCase: boolean): unknown;
    createInstance(typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): unknown;
    equals(o: unknown): boolean;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getExportedTypes(): Type[];
    getFile(name: string): FileStream;
    getFiles(): FileStream[];
    getFiles(getResourceModules: boolean): FileStream[];
    getForwardedTypes(): Type[];
    getHashCode(): int;
    getLoadedModules(): Module[];
    getLoadedModules(getResourceModules: boolean): Module[];
    getManifestResourceInfo(resourceName: string): ManifestResourceInfo;
    getManifestResourceNames(): string[];
    getManifestResourceStream(name: string): Stream;
    getManifestResourceStream(type_: Type, name: string): Stream;
    getModule(name: string): Module;
    getModules(): Module[];
    getModules(getResourceModules: boolean): Module[];
    getName(): AssemblyName;
    getName(copiedName: boolean): AssemblyName;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getReferencedAssemblies(): AssemblyName[];
    getSatelliteAssembly(culture: CultureInfo): Assembly;
    getSatelliteAssembly(culture: CultureInfo, version: Version): Assembly;
    getType(name: string): Type;
    getType(name: string, throwOnError: boolean): Type;
    getType(name: string, throwOnError: boolean, ignoreCase: boolean): Type;
    getTypes(): Type[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
    loadModule(moduleName: string, rawModule: byte[]): Module;
    loadModule(moduleName: string, rawModule: byte[], rawSymbolStore: byte[]): Module;
    toString(): string;
    static createQualifiedName(assemblyName: string, typeName: string): string;
    static getAssembly(type_: Type): Assembly;
    static getCallingAssembly(): Assembly;
    static getEntryAssembly(): Assembly;
    static getExecutingAssembly(): Assembly;
    static load(rawAssembly: byte[], rawSymbolStore: byte[]): Assembly;
    static load(rawAssembly: byte[]): Assembly;
    static load(assemblyRef: AssemblyName): Assembly;
    static load(assemblyString: string): Assembly;
    static loadFile(path: string): Assembly;
    static loadFrom(assemblyFile: string, hashValue: byte[], hashAlgorithm: AssemblyHashAlgorithm_Assemblies): Assembly;
    static loadFrom(assemblyFile: string): Assembly;
    static loadWithPartialName(partialName: string): Assembly;
    static reflectionOnlyLoad(rawAssembly: byte[]): Assembly;
    static reflectionOnlyLoad(assemblyString: string): Assembly;
    static reflectionOnlyLoadFrom(assemblyFile: string): Assembly;
    static setEntryAssembly(assembly: Assembly): void;
    static unsafeLoadFrom(assemblyFile: string): Assembly;
}


export interface __Assembly$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Assembly$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Assembly = Assembly$instance & __Assembly$views;


export class AssemblyAlgorithmIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(algorithmId: AssemblyHashAlgorithm_Assemblies);
    constructor(algorithmId: uint);
    readonly algorithmId: uint;
}


export type AssemblyAlgorithmIdAttribute = AssemblyAlgorithmIdAttribute$instance;

export class AssemblyCompanyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(company: string);
    readonly company: string;
}


export type AssemblyCompanyAttribute = AssemblyCompanyAttribute$instance;

export class AssemblyConfigurationAttribute$instance extends System_Internal.Attribute$instance {
    constructor(configuration: string);
    readonly configuration: string;
}


export type AssemblyConfigurationAttribute = AssemblyConfigurationAttribute$instance;

export class AssemblyCopyrightAttribute$instance extends System_Internal.Attribute$instance {
    constructor(copyright: string);
    readonly copyright: string;
}


export type AssemblyCopyrightAttribute = AssemblyCopyrightAttribute$instance;

export class AssemblyCultureAttribute$instance extends System_Internal.Attribute$instance {
    constructor(culture: string);
    readonly culture: string;
}


export type AssemblyCultureAttribute = AssemblyCultureAttribute$instance;

export class AssemblyDefaultAliasAttribute$instance extends System_Internal.Attribute$instance {
    constructor(defaultAlias: string);
    readonly defaultAlias: string;
}


export type AssemblyDefaultAliasAttribute = AssemblyDefaultAliasAttribute$instance;

export class AssemblyDelaySignAttribute$instance extends System_Internal.Attribute$instance {
    constructor(delaySign: boolean);
    readonly delaySign: boolean;
}


export type AssemblyDelaySignAttribute = AssemblyDelaySignAttribute$instance;

export class AssemblyDescriptionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(description: string);
    readonly description: string;
}


export type AssemblyDescriptionAttribute = AssemblyDescriptionAttribute$instance;

export class AssemblyFileVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(version: string);
    readonly version: string;
}


export type AssemblyFileVersionAttribute = AssemblyFileVersionAttribute$instance;

export class AssemblyFlagsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: uint);
    constructor(assemblyFlags: int);
    constructor(assemblyFlags: AssemblyNameFlags);
    readonly assemblyFlags: int;
    readonly flags: uint;
}


export type AssemblyFlagsAttribute = AssemblyFlagsAttribute$instance;

export class AssemblyInformationalVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(informationalVersion: string);
    readonly informationalVersion: string;
}


export type AssemblyInformationalVersionAttribute = AssemblyInformationalVersionAttribute$instance;

export class AssemblyKeyFileAttribute$instance extends System_Internal.Attribute$instance {
    constructor(keyFile: string);
    readonly keyFile: string;
}


export type AssemblyKeyFileAttribute = AssemblyKeyFileAttribute$instance;

export class AssemblyKeyNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(keyName: string);
    readonly keyName: string;
}


export type AssemblyKeyNameAttribute = AssemblyKeyNameAttribute$instance;

export class AssemblyMetadataAttribute$instance extends System_Internal.Attribute$instance {
    constructor(key: string, value: string);
    readonly key: string;
    readonly value: string;
}


export type AssemblyMetadataAttribute = AssemblyMetadataAttribute$instance;

export class AssemblyName$instance {
    constructor(assemblyName: string);
    constructor();
    codeBase: string;
    contentType: AssemblyContentType;
    cultureInfo: CultureInfo;
    cultureName: string;
    readonly escapedCodeBase: string;
    flags: AssemblyNameFlags;
    readonly fullName: string;
    hashAlgorithm: AssemblyHashAlgorithm_Assemblies;
    keyPair: StrongNameKeyPair;
    name: string;
    processorArchitecture: ProcessorArchitecture;
    version: Version;
    versionCompatibility: AssemblyVersionCompatibility;
    clone(): unknown;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getPublicKey(): byte[];
    getPublicKeyToken(): byte[];
    onDeserialization(sender: unknown): void;
    setPublicKey(publicKey: byte[]): void;
    setPublicKeyToken(publicKeyToken: byte[]): void;
    toString(): string;
    static getAssemblyName(assemblyFile: string): AssemblyName;
    static referenceMatchesDefinition(reference: AssemblyName, definition: AssemblyName): boolean;
}


export interface __AssemblyName$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface AssemblyName$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type AssemblyName = AssemblyName$instance & __AssemblyName$views;


export class AssemblyNameProxy$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    getAssemblyName(assemblyFile: string): AssemblyName;
}


export type AssemblyNameProxy = AssemblyNameProxy$instance;

export class AssemblyProductAttribute$instance extends System_Internal.Attribute$instance {
    constructor(product: string);
    readonly product: string;
}


export type AssemblyProductAttribute = AssemblyProductAttribute$instance;

export class AssemblySignatureKeyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(publicKey: string, countersignature: string);
    readonly countersignature: string;
    readonly publicKey: string;
}


export type AssemblySignatureKeyAttribute = AssemblySignatureKeyAttribute$instance;

export class AssemblyTitleAttribute$instance extends System_Internal.Attribute$instance {
    constructor(title: string);
    readonly title: string;
}


export type AssemblyTitleAttribute = AssemblyTitleAttribute$instance;

export class AssemblyTrademarkAttribute$instance extends System_Internal.Attribute$instance {
    constructor(trademark: string);
    readonly trademark: string;
}


export type AssemblyTrademarkAttribute = AssemblyTrademarkAttribute$instance;

export class AssemblyVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(version: string);
    readonly version: string;
}


export type AssemblyVersionAttribute = AssemblyVersionAttribute$instance;

export abstract class Binder$instance {
    abstract bindToField(bindingAttr: BindingFlags, match: FieldInfo[], value: unknown, culture: CultureInfo): FieldInfo;
    abstract bindToMethod(bindingAttr: BindingFlags, match: MethodBase[], args: { value: ref<unknown[]> }, modifiers: ParameterModifier[], culture: CultureInfo, names: string[], state: { value: ref<unknown> }): MethodBase;
    abstract changeType(value: unknown, type_: Type, culture: CultureInfo): unknown;
    abstract reorderArgumentArray(args: { value: ref<unknown[]> }, state: unknown): void;
    abstract selectMethod(bindingAttr: BindingFlags, match: MethodBase[], types: Type[], modifiers: ParameterModifier[]): MethodBase;
    abstract selectProperty(bindingAttr: BindingFlags, match: PropertyInfo[], returnType: Type, indexes: Type[], modifiers: ParameterModifier[]): PropertyInfo;
}


export type Binder = Binder$instance;

export abstract class ConstructorInfo$instance extends MethodBase$instance {
    readonly memberType: MemberTypes;
    equals(obj: unknown): boolean;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getHashCode(): int;
    invoke(obj: unknown, parameters: unknown[]): unknown;
    invoke(obj: unknown, invokeAttr: BindingFlags, binder: Binder, parameters: unknown[], culture: CultureInfo): unknown;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    static readonly constructorName: string;
    static readonly typeConstructorName: string;
}


export interface __ConstructorInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface ConstructorInfo$instance extends ICustomAttributeProvider$instance {}

export type ConstructorInfo = ConstructorInfo$instance & __ConstructorInfo$views;


export class ConstructorInvoker$instance {
    invoke(): unknown;
    invoke(arg1: unknown): unknown;
    invoke(arg1: unknown, arg2: unknown): unknown;
    invoke(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    invoke(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    invoke(arguments: Span_1<unknown>): unknown;
    static create(constructor_: ConstructorInfo): ConstructorInvoker;
}


export type ConstructorInvoker = ConstructorInvoker$instance;

export class CustomAttributeData$instance {
    readonly attributeType: Type;
    readonly constructor_: ConstructorInfo;
    readonly constructorArguments: IList_1<CustomAttributeTypedArgument>;
    readonly namedArguments: IList_1<CustomAttributeNamedArgument>;
    toString(): string;
    static getCustomAttributes(target: Assembly): IList_1<CustomAttributeData>;
    static getCustomAttributes(target: MemberInfo): IList_1<CustomAttributeData>;
    static getCustomAttributes(target: Module): IList_1<CustomAttributeData>;
    static getCustomAttributes(target: ParameterInfo): IList_1<CustomAttributeData>;
}


export type CustomAttributeData = CustomAttributeData$instance;

export class CustomAttributeFormatException$instance extends System_Internal.FormatException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CustomAttributeFormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CustomAttributeFormatException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CustomAttributeFormatException = CustomAttributeFormatException$instance & __CustomAttributeFormatException$views;


export class DefaultMemberAttribute$instance extends System_Internal.Attribute$instance {
    constructor(memberName: string);
    readonly memberName: string;
}


export type DefaultMemberAttribute = DefaultMemberAttribute$instance;

export abstract class DispatchProxy$instance {
    static create<T, TProxy extends DispatchProxy>(): T;
    static create(interfaceType: Type, proxyType: Type): unknown;
}


export type DispatchProxy = DispatchProxy$instance;

export abstract class EventInfo$instance extends MemberInfo$instance {
    readonly addMethod: MethodInfo;
    readonly attributes: EventAttributes;
    readonly eventHandlerType: Type;
    readonly isMulticast: boolean;
    readonly isSpecialName: boolean;
    readonly memberType: MemberTypes;
    readonly raiseMethod: MethodInfo;
    readonly removeMethod: MethodInfo;
    addEventHandler(target: unknown, handler: Function): void;
    equals(obj: unknown): boolean;
    getAddMethod(): MethodInfo;
    getAddMethod(nonPublic: boolean): MethodInfo;
    abstract getCustomAttributes(inherit: boolean): unknown[];
    abstract getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getHashCode(): int;
    getOtherMethods(): MethodInfo[];
    getOtherMethods(nonPublic: boolean): MethodInfo[];
    getRaiseMethod(): MethodInfo;
    getRaiseMethod(nonPublic: boolean): MethodInfo;
    getRemoveMethod(): MethodInfo;
    getRemoveMethod(nonPublic: boolean): MethodInfo;
    abstract isDefined(attributeType: Type, inherit: boolean): boolean;
    removeEventHandler(target: unknown, handler: Function): void;
}


export interface __EventInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface EventInfo$instance extends ICustomAttributeProvider$instance {}

export type EventInfo = EventInfo$instance & __EventInfo$views;


export class ExceptionHandlingClause$instance {
    readonly catchType: Type;
    readonly filterOffset: int;
    readonly flags: ExceptionHandlingClauseOptions;
    readonly handlerLength: int;
    readonly handlerOffset: int;
    readonly tryLength: int;
    readonly tryOffset: int;
    toString(): string;
}


export type ExceptionHandlingClause = ExceptionHandlingClause$instance;

export abstract class FieldInfo$instance extends MemberInfo$instance {
    readonly attributes: FieldAttributes;
    readonly fieldHandle: RuntimeFieldHandle;
    readonly fieldType: Type;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isInitOnly: boolean;
    readonly isLiteral: boolean;
    readonly isNotSerialized: boolean;
    readonly isPinvokeImpl: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly memberType: MemberTypes;
    equals(obj: unknown): boolean;
    abstract getCustomAttributes(inherit: boolean): unknown[];
    abstract getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getHashCode(): int;
    getModifiedFieldType(): Type;
    getOptionalCustomModifiers(): Type[];
    getRawConstantValue(): unknown;
    getRequiredCustomModifiers(): Type[];
    abstract getValue(obj: unknown): unknown;
    getValueDirect(obj: TypedReference): unknown;
    abstract isDefined(attributeType: Type, inherit: boolean): boolean;
    setValue(obj: unknown, value: unknown): void;
    setValue(obj: unknown, value: unknown, invokeAttr: BindingFlags, binder: Binder, culture: CultureInfo): void;
    setValueDirect(obj: TypedReference, value: unknown): void;
    static getFieldFromHandle(handle: RuntimeFieldHandle, declaringType: RuntimeTypeHandle): FieldInfo;
    static getFieldFromHandle(handle: RuntimeFieldHandle): FieldInfo;
}


export interface __FieldInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface FieldInfo$instance extends ICustomAttributeProvider$instance {}

export type FieldInfo = FieldInfo$instance & __FieldInfo$views;


export class InvalidFilterCriteriaException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidFilterCriteriaException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface InvalidFilterCriteriaException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type InvalidFilterCriteriaException = InvalidFilterCriteriaException$instance & __InvalidFilterCriteriaException$views;


export class LocalVariableInfo$instance {
    readonly isPinned: boolean;
    readonly localIndex: int;
    readonly localType: Type;
    toString(): string;
}


export type LocalVariableInfo = LocalVariableInfo$instance;

export class ManifestResourceInfo$instance {
    constructor(containingAssembly: Assembly, containingFileName: string, resourceLocation: ResourceLocation);
    readonly fileName: string;
    readonly referencedAssembly: Assembly;
    readonly resourceLocation: ResourceLocation;
}


export type ManifestResourceInfo = ManifestResourceInfo$instance;

export class MemberFilter$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(m: MemberInfo, filterCriteria: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    endInvoke(result: IAsyncResult): boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(m: MemberInfo, filterCriteria: unknown): boolean;
}


export interface __MemberFilter$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface MemberFilter$instance extends System_Internal.ICloneable$instance {}

export type MemberFilter = MemberFilter$instance & __MemberFilter$views;


export abstract class MemberInfo$instance {
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly declaringType: Type;
    readonly isCollectible: boolean;
    readonly memberType: MemberTypes;
    readonly metadataToken: int;
    readonly module_: Module;
    readonly name: string;
    readonly reflectedType: Type;
    equals(obj: unknown): boolean;
    abstract getCustomAttributes(inherit: boolean): unknown[];
    abstract getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getHashCode(): int;
    hasSameMetadataDefinitionAs(other: MemberInfo): boolean;
    abstract isDefined(attributeType: Type, inherit: boolean): boolean;
}


export interface __MemberInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface MemberInfo$instance extends ICustomAttributeProvider$instance {}

export type MemberInfo = MemberInfo$instance & __MemberInfo$views;


export abstract class MethodBase$instance extends MemberInfo$instance {
    readonly attributes: MethodAttributes;
    readonly callingConvention: CallingConventions;
    readonly containsGenericParameters: boolean;
    readonly isAbstract: boolean;
    readonly isAssembly: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isConstructor: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isFinal: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly isHideBySig: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly methodHandle: RuntimeMethodHandle;
    readonly methodImplementationFlags: MethodImplAttributes;
    equals(obj: unknown): boolean;
    abstract getCustomAttributes(inherit: boolean): unknown[];
    abstract getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getGenericArguments(): Type[];
    getHashCode(): int;
    getMethodBody(): MethodBody;
    abstract getMethodImplementationFlags(): MethodImplAttributes;
    abstract getParameters(): ParameterInfo[];
    invoke(obj: unknown, parameters: unknown[]): unknown;
    invoke(obj: unknown, invokeAttr: BindingFlags, binder: Binder, parameters: unknown[], culture: CultureInfo): unknown;
    abstract isDefined(attributeType: Type, inherit: boolean): boolean;
    static getCurrentMethod(): MethodBase;
    static getMethodFromHandle(handle: RuntimeMethodHandle, declaringType: RuntimeTypeHandle): MethodBase;
    static getMethodFromHandle(handle: RuntimeMethodHandle): MethodBase;
}


export interface __MethodBase$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface MethodBase$instance extends ICustomAttributeProvider$instance {}

export type MethodBase = MethodBase$instance & __MethodBase$views;


export class MethodBody$instance {
    readonly exceptionHandlingClauses: IList_1<ExceptionHandlingClause>;
    readonly initLocals: boolean;
    readonly localSignatureMetadataToken: int;
    readonly localVariables: IList_1<LocalVariableInfo>;
    readonly maxStackSize: int;
    getILAsByteArray(): byte[];
}


export type MethodBody = MethodBody$instance;

export abstract class MethodInfo$instance extends MethodBase$instance {
    readonly memberType: MemberTypes;
    readonly returnParameter: ParameterInfo;
    readonly returnType: Type;
    readonly returnTypeCustomAttributes: ICustomAttributeProvider;
    createDelegate(delegateType: Type): Function;
    createDelegate(delegateType: Type, target: unknown): Function;
    createDelegate<T extends Function>(): T;
    createDelegate<T extends Function>(target: unknown): T;
    equals(obj: unknown): boolean;
    abstract getBaseDefinition(): MethodInfo;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getGenericArguments(): Type[];
    getGenericMethodDefinition(): MethodInfo;
    getHashCode(): int;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    makeGenericMethod(typeArguments: Type[]): MethodInfo;
}


export interface __MethodInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface MethodInfo$instance extends ICustomAttributeProvider$instance {}

export type MethodInfo = MethodInfo$instance & __MethodInfo$views;


export class MethodInvoker$instance {
    invoke(obj: unknown): unknown;
    invoke(obj: unknown, arg1: unknown): unknown;
    invoke(obj: unknown, arg1: unknown, arg2: unknown): unknown;
    invoke(obj: unknown, arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    invoke(obj: unknown, arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    invoke(obj: unknown, arguments: Span_1<unknown>): unknown;
    static create(method: MethodBase): MethodInvoker;
}


export type MethodInvoker = MethodInvoker$instance;

export class Missing$instance {
    static readonly value: Missing;
}


export interface __Missing$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Missing$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Missing = Missing$instance & __Missing$views;


export abstract class Module$instance {
    readonly assembly: Assembly;
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly fullyQualifiedName: string;
    readonly mdStreamVersion: int;
    readonly metadataToken: int;
    readonly moduleHandle: ModuleHandle;
    readonly moduleVersionId: Guid;
    readonly name: string;
    readonly scopeName: string;
    equals(o: unknown): boolean;
    findTypes(filter: TypeFilter, filterCriteria: unknown): Type[];
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getField(name: string): FieldInfo;
    getField(name: string, bindingAttr: BindingFlags): FieldInfo;
    getFields(): FieldInfo[];
    getFields(bindingFlags: BindingFlags): FieldInfo[];
    getHashCode(): int;
    getMethod(name: string): MethodInfo;
    getMethod(name: string, types: Type[]): MethodInfo;
    getMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    getMethods(): MethodInfo[];
    getMethods(bindingFlags: BindingFlags): MethodInfo[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getPEKind(peKind: { value: ref<PortableExecutableKinds> }, machine: { value: ref<ImageFileMachine> }): void;
    getType(className: string): Type;
    getType(className: string, ignoreCase: boolean): Type;
    getType(className: string, throwOnError: boolean, ignoreCase: boolean): Type;
    getTypes(): Type[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
    isResource(): boolean;
    resolveField(metadataToken: int): FieldInfo;
    resolveField(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo;
    resolveMember(metadataToken: int): MemberInfo;
    resolveMember(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MemberInfo;
    resolveMethod(metadataToken: int): MethodBase;
    resolveMethod(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MethodBase;
    resolveSignature(metadataToken: int): byte[];
    resolveString(metadataToken: int): string;
    resolveType(metadataToken: int): Type;
    resolveType(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): Type;
    toString(): string;
    static readonly filterTypeName: TypeFilter;
    static readonly filterTypeNameIgnoreCase: TypeFilter;
}


export interface __Module$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Module$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Module = Module$instance & __Module$views;


export class ModuleResolveEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: ResolveEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    endInvoke(result: IAsyncResult): Module;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: ResolveEventArgs): Module;
}


export interface __ModuleResolveEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface ModuleResolveEventHandler$instance extends System_Internal.ICloneable$instance {}

export type ModuleResolveEventHandler = ModuleResolveEventHandler$instance & __ModuleResolveEventHandler$views;


export class NullabilityInfo$instance {
    readonly elementType: NullabilityInfo;
    readonly genericTypeArguments: NullabilityInfo[];
    readonly readState: NullabilityState;
    readonly type_: Type;
    readonly writeState: NullabilityState;
}


export type NullabilityInfo = NullabilityInfo$instance;

export class NullabilityInfoContext$instance {
    constructor();
    create(parameterInfo: ParameterInfo): NullabilityInfo;
    create(propertyInfo: PropertyInfo): NullabilityInfo;
    create(eventInfo: EventInfo): NullabilityInfo;
    create(fieldInfo: FieldInfo): NullabilityInfo;
}


export type NullabilityInfoContext = NullabilityInfoContext$instance;

export class ObfuscateAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(assemblyIsPrivate: boolean);
    readonly assemblyIsPrivate: boolean;
    stripAfterObfuscation: boolean;
}


export type ObfuscateAssemblyAttribute = ObfuscateAssemblyAttribute$instance;

export class ObfuscationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    applyToMembers: boolean;
    exclude: boolean;
    feature: string;
    stripAfterObfuscation: boolean;
}


export type ObfuscationAttribute = ObfuscationAttribute$instance;

export class ParameterInfo$instance {
    readonly attributes: ParameterAttributes;
    readonly customAttributes: IEnumerable_1<CustomAttributeData>;
    readonly defaultValue: unknown;
    readonly hasDefaultValue: boolean;
    readonly isIn: boolean;
    readonly isLcid: boolean;
    readonly isOptional: boolean;
    readonly isOut: boolean;
    readonly isRetval: boolean;
    readonly member: MemberInfo;
    readonly metadataToken: int;
    readonly name: string;
    readonly parameterType: Type;
    readonly position: int;
    readonly rawDefaultValue: unknown;
    getCustomAttributes(inherit: boolean): unknown[];
    getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getCustomAttributesData(): IList_1<CustomAttributeData>;
    getModifiedParameterType(): Type;
    getOptionalCustomModifiers(): Type[];
    getRealObject(context: StreamingContext): unknown;
    getRequiredCustomModifiers(): Type[];
    isDefined(attributeType: Type, inherit: boolean): boolean;
    toString(): string;
}


export interface __ParameterInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IObjectReference(): System_Runtime_Serialization_Internal.IObjectReference$instance;
}

export interface ParameterInfo$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.IObjectReference$instance {}

export type ParameterInfo = ParameterInfo$instance & __ParameterInfo$views;


export class Pointer$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
    static box(ptr: ptr<void>, type_: Type): unknown;
    static unbox(ptr: unknown): ptr<void>;
}


export interface __Pointer$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Pointer$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Pointer = Pointer$instance & __Pointer$views;


export abstract class PropertyInfo$instance extends MemberInfo$instance {
    readonly attributes: PropertyAttributes;
    readonly canRead: boolean;
    readonly canWrite: boolean;
    readonly getMethod: MethodInfo;
    readonly isSpecialName: boolean;
    readonly memberType: MemberTypes;
    readonly propertyType: Type;
    readonly setMethod: MethodInfo;
    equals(obj: unknown): boolean;
    getAccessors(): MethodInfo[];
    getAccessors(nonPublic: boolean): MethodInfo[];
    getConstantValue(): unknown;
    abstract getCustomAttributes(inherit: boolean): unknown[];
    abstract getCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getGetMethod(): MethodInfo;
    getGetMethod(nonPublic: boolean): MethodInfo;
    getHashCode(): int;
    abstract getIndexParameters(): ParameterInfo[];
    getModifiedPropertyType(): Type;
    getOptionalCustomModifiers(): Type[];
    getRawConstantValue(): unknown;
    getRequiredCustomModifiers(): Type[];
    getSetMethod(): MethodInfo;
    getSetMethod(nonPublic: boolean): MethodInfo;
    getValue(obj: unknown): unknown;
    getValue(obj: unknown, index: unknown[]): unknown;
    getValue(obj: unknown, invokeAttr: BindingFlags, binder: Binder, index: unknown[], culture: CultureInfo): unknown;
    abstract isDefined(attributeType: Type, inherit: boolean): boolean;
    setValue(obj: unknown, value: unknown): void;
    setValue(obj: unknown, value: unknown, index: unknown[]): void;
    setValue(obj: unknown, value: unknown, invokeAttr: BindingFlags, binder: Binder, index: unknown[], culture: CultureInfo): void;
}


export interface __PropertyInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface PropertyInfo$instance extends ICustomAttributeProvider$instance {}

export type PropertyInfo = PropertyInfo$instance & __PropertyInfo$views;


export abstract class ReflectionContext$instance {
    getTypeForObject(value: unknown): TypeInfo;
    abstract mapAssembly(assembly: Assembly): Assembly;
    abstract mapType(type_: TypeInfo): TypeInfo;
}


export type ReflectionContext = ReflectionContext$instance;

export class ReflectionTypeLoadException$instance extends System_Internal.SystemException$instance {
    constructor(classes: Type[], exceptions: Exception[]);
    constructor(classes: Type[], exceptions: Exception[], message: string);
    readonly loaderExceptions: Exception[];
    readonly message: string;
    readonly types: Type[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __ReflectionTypeLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReflectionTypeLoadException = ReflectionTypeLoadException$instance & __ReflectionTypeLoadException$views;


export class StrongNameKeyPair$instance {
    constructor(keyPairFile: FileStream);
    constructor(keyPairArray: byte[]);
    constructor(keyPairContainer: string);
    readonly publicKey: byte[];
}


export interface __StrongNameKeyPair$views {
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface StrongNameKeyPair$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type StrongNameKeyPair = StrongNameKeyPair$instance & __StrongNameKeyPair$views;


export class TargetException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TargetException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface TargetException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TargetException = TargetException$instance & __TargetException$views;


export class TargetInvocationException$instance extends System_Internal.ApplicationException$instance {
    constructor(inner: Exception);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TargetInvocationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface TargetInvocationException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TargetInvocationException = TargetInvocationException$instance & __TargetInvocationException$views;


export class TargetParameterCountException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TargetParameterCountException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface TargetParameterCountException$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TargetParameterCountException = TargetParameterCountException$instance & __TargetParameterCountException$views;


export class TypeDelegator$instance extends TypeInfo$instance {
    constructor(delegatingType: Type);
    readonly assembly: Assembly;
    readonly assemblyQualifiedName: string;
    readonly baseType: Type;
    readonly fullName: string;
    readonly guid: Guid;
    readonly isByRefLike: boolean;
    readonly isCollectible: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isFunctionPointer: boolean;
    readonly isGenericMethodParameter: boolean;
    readonly isGenericTypeParameter: boolean;
    readonly isSZArray: boolean;
    readonly isTypeDefinition: boolean;
    readonly isUnmanagedFunctionPointer: boolean;
    readonly isVariableBoundArray: boolean;
    readonly metadataToken: int;
    readonly module_: Module;
    readonly name: string;
    readonly namespace_: string;
    readonly typeHandle: RuntimeTypeHandle;
    readonly underlyingSystemType: Type;
    getArrayRank(): int;
    GetConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
    GetConstructors(): ConstructorInfo[];
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getElementType(): Type;
    GetEvent(name: string, bindingAttr: BindingFlags): EventInfo;
    GetEvent(name: string): EventInfo;
    getEvents(): EventInfo[];
    getEvents(bindingAttr: BindingFlags): EventInfo[];
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetField(name: string): FieldInfo;
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetFields(): FieldInfo[];
    getFunctionPointerCallingConventions(): Type[];
    getFunctionPointerParameterTypes(): Type[];
    getFunctionPointerReturnType(): Type;
    GetInterface(name: string, ignoreCase: boolean): Type;
    GetInterface(name: string): Type;
    getInterfaceMap(interfaceType: Type): InterfaceMapping;
    getInterfaces(): Type[];
    getMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    getMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    getMember(name: string): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(): MemberInfo[];
    getMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetMethods(): MethodInfo[];
    GetNestedType(name: string, bindingAttr: BindingFlags): Type;
    GetNestedType(name: string): Type;
    GetNestedTypes(bindingAttr: BindingFlags): Type[];
    GetNestedTypes(): Type[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperties(): PropertyInfo[];
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string): PropertyInfo;
    GetProperty(name: string, returnType: Type): PropertyInfo;
    GetProperty(name: string, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetTypeInfo(): TypeInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[]): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], culture: CultureInfo): unknown;
    isAssignableFrom(typeInfo: TypeInfo): boolean;
    isAssignableFrom(c: Type): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export interface __TypeDelegator$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IReflect(): IReflect$instance;
    As_IReflectableType(): IReflectableType$instance;
}

export interface TypeDelegator$instance extends IReflectableType$instance {}

export type TypeDelegator = TypeDelegator$instance & __TypeDelegator$views;


export class TypeFilter$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(m: Type, filterCriteria: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    endInvoke(result: IAsyncResult): boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(m: Type, filterCriteria: unknown): boolean;
}


export interface __TypeFilter$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface TypeFilter$instance extends System_Internal.ICloneable$instance {}

export type TypeFilter = TypeFilter$instance & __TypeFilter$views;


export abstract class TypeInfo$instance extends System_Internal.Type$instance {
    readonly declaredConstructors: IEnumerable_1<ConstructorInfo>;
    readonly declaredEvents: IEnumerable_1<EventInfo>;
    readonly declaredFields: IEnumerable_1<FieldInfo>;
    readonly declaredMembers: IEnumerable_1<MemberInfo>;
    readonly declaredMethods: IEnumerable_1<MethodInfo>;
    readonly declaredNestedTypes: IEnumerable_1<TypeInfo>;
    readonly declaredProperties: IEnumerable_1<PropertyInfo>;
    readonly genericTypeParameters: Type[];
    readonly implementedInterfaces: IEnumerable_1<Type>;
    asType(): Type;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    getDeclaredEvent(name: string): EventInfo;
    getDeclaredField(name: string): FieldInfo;
    getDeclaredMethod(name: string): MethodInfo;
    getDeclaredMethods(name: string): IEnumerable_1<MethodInfo>;
    getDeclaredNestedType(name: string): TypeInfo;
    getDeclaredProperty(name: string): PropertyInfo;
    GetField(name: string): FieldInfo;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetFields(): FieldInfo[];
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetMember(name: string): MemberInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(): MethodInfo[];
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetProperties(): PropertyInfo[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperty(name: string): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    GetProperty(name: string, returnType: Type): PropertyInfo;
    GetProperty(name: string, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[]): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], culture: CultureInfo): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
    isAssignableFrom(c: Type): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export interface __TypeInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IReflect(): IReflect$instance;
    As_IReflectableType(): IReflectableType$instance;
}

export interface TypeInfo$instance extends ICustomAttributeProvider$instance, IReflectableType$instance {}

export type TypeInfo = TypeInfo$instance & __TypeInfo$views;


export abstract class AssemblyExtensions$instance {
    static getExportedTypes(assembly: Assembly): Type[];
    static getModules(assembly: Assembly): Module[];
    static getTypes(assembly: Assembly): Type[];
}


export type AssemblyExtensions = AssemblyExtensions$instance;

export abstract class CustomAttributeExtensions$instance {
    static getCustomAttribute(element: Assembly, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: Assembly): T;
    static getCustomAttribute<T extends Attribute>(element: MemberInfo, inherit: boolean): T;
    static getCustomAttribute(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute(element: MemberInfo, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: MemberInfo): T;
    static getCustomAttribute(element: Module, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: Module): T;
    static getCustomAttribute<T extends Attribute>(element: ParameterInfo, inherit: boolean): T;
    static getCustomAttribute(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute;
    static getCustomAttribute(element: ParameterInfo, attributeType: Type): Attribute;
    static getCustomAttribute<T extends Attribute>(element: ParameterInfo): T;
    static getCustomAttributes(element: Assembly, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: Assembly): IEnumerable_1<T>;
    static getCustomAttributes(element: Assembly): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: MemberInfo, inherit: boolean): IEnumerable_1<T>;
    static getCustomAttributes(element: MemberInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: MemberInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: MemberInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: MemberInfo): IEnumerable_1<T>;
    static getCustomAttributes(element: MemberInfo): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: Module, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: Module): IEnumerable_1<T>;
    static getCustomAttributes(element: Module): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: ParameterInfo, inherit: boolean): IEnumerable_1<T>;
    static getCustomAttributes(element: ParameterInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: ParameterInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static getCustomAttributes(element: ParameterInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static getCustomAttributes<T extends Attribute>(element: ParameterInfo): IEnumerable_1<T>;
    static getCustomAttributes(element: ParameterInfo): IEnumerable_1<Attribute>;
    static isDefined(element: Assembly, attributeType: Type): boolean;
    static isDefined(element: MemberInfo, attributeType: Type, inherit: boolean): boolean;
    static isDefined(element: MemberInfo, attributeType: Type): boolean;
    static isDefined(element: Module, attributeType: Type): boolean;
    static isDefined(element: ParameterInfo, attributeType: Type, inherit: boolean): boolean;
    static isDefined(element: ParameterInfo, attributeType: Type): boolean;
}


export type CustomAttributeExtensions = CustomAttributeExtensions$instance;

export abstract class EventInfoExtensions$instance {
    static getAddMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static getAddMethod(eventInfo: EventInfo): MethodInfo;
    static getRaiseMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static getRaiseMethod(eventInfo: EventInfo): MethodInfo;
    static getRemoveMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static getRemoveMethod(eventInfo: EventInfo): MethodInfo;
}


export type EventInfoExtensions = EventInfoExtensions$instance;

export abstract class IntrospectionExtensions$instance {
    static getTypeInfo(type_: Type): TypeInfo;
}


export type IntrospectionExtensions = IntrospectionExtensions$instance;

export abstract class MemberInfoExtensions$instance {
    static getMetadataToken(member: MemberInfo): int;
    static hasMetadataToken(member: MemberInfo): boolean;
}


export type MemberInfoExtensions = MemberInfoExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static getBaseDefinition(method: MethodInfo): MethodInfo;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class ModuleExtensions$instance {
    static getModuleVersionId(module_: Module): Guid;
    static hasModuleVersionId(module_: Module): boolean;
}


export type ModuleExtensions = ModuleExtensions$instance;

export abstract class PropertyInfoExtensions$instance {
    static getAccessors(property: PropertyInfo, nonPublic: boolean): MethodInfo[];
    static getAccessors(property: PropertyInfo): MethodInfo[];
    static getGetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static getGetMethod(property: PropertyInfo): MethodInfo;
    static getSetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static getSetMethod(property: PropertyInfo): MethodInfo;
}


export type PropertyInfoExtensions = PropertyInfoExtensions$instance;

export abstract class RuntimeReflectionExtensions$instance {
    static getMethodInfo(del: Function): MethodInfo;
    static getRuntimeBaseDefinition(method: MethodInfo): MethodInfo;
    static getRuntimeEvent(type_: Type, name: string): EventInfo;
    static getRuntimeEvents(type_: Type): IEnumerable_1<EventInfo>;
    static getRuntimeField(type_: Type, name: string): FieldInfo;
    static getRuntimeFields(type_: Type): IEnumerable_1<FieldInfo>;
    static getRuntimeInterfaceMap(typeInfo: TypeInfo, interfaceType: Type): InterfaceMapping;
    static getRuntimeMethod(type_: Type, name: string, parameters: Type[]): MethodInfo;
    static getRuntimeMethods(type_: Type): IEnumerable_1<MethodInfo>;
    static getRuntimeProperties(type_: Type): IEnumerable_1<PropertyInfo>;
    static getRuntimeProperty(type_: Type, name: string): PropertyInfo;
}


export type RuntimeReflectionExtensions = RuntimeReflectionExtensions$instance;

export abstract class TypeExtensions$instance {
    static getConstructor(type_: Type, types: Type[]): ConstructorInfo;
    static getConstructors(type_: Type, bindingAttr: BindingFlags): ConstructorInfo[];
    static getConstructors(type_: Type): ConstructorInfo[];
    static getDefaultMembers(type_: Type): MemberInfo[];
    static getEvent(type_: Type, name: string, bindingAttr: BindingFlags): EventInfo;
    static getEvent(type_: Type, name: string): EventInfo;
    static getEvents(type_: Type, bindingAttr: BindingFlags): EventInfo[];
    static getEvents(type_: Type): EventInfo[];
    static getField(type_: Type, name: string, bindingAttr: BindingFlags): FieldInfo;
    static getField(type_: Type, name: string): FieldInfo;
    static getFields(type_: Type, bindingAttr: BindingFlags): FieldInfo[];
    static getFields(type_: Type): FieldInfo[];
    static getGenericArguments(type_: Type): Type[];
    static getInterfaces(type_: Type): Type[];
    static getMember(type_: Type, name: string, bindingAttr: BindingFlags): MemberInfo[];
    static getMember(type_: Type, name: string): MemberInfo[];
    static getMembers(type_: Type, bindingAttr: BindingFlags): MemberInfo[];
    static getMembers(type_: Type): MemberInfo[];
    static getMethod(type_: Type, name: string, bindingAttr: BindingFlags): MethodInfo;
    static getMethod(type_: Type, name: string, types: Type[]): MethodInfo;
    static getMethod(type_: Type, name: string): MethodInfo;
    static getMethods(type_: Type, bindingAttr: BindingFlags): MethodInfo[];
    static getMethods(type_: Type): MethodInfo[];
    static getNestedType(type_: Type, name: string, bindingAttr: BindingFlags): Type;
    static getNestedTypes(type_: Type, bindingAttr: BindingFlags): Type[];
    static getProperties(type_: Type, bindingAttr: BindingFlags): PropertyInfo[];
    static getProperties(type_: Type): PropertyInfo[];
    static getProperty(type_: Type, name: string, bindingAttr: BindingFlags): PropertyInfo;
    static getProperty(type_: Type, name: string, returnType: Type, types: Type[]): PropertyInfo;
    static getProperty(type_: Type, name: string, returnType: Type): PropertyInfo;
    static getProperty(type_: Type, name: string): PropertyInfo;
    static isAssignableFrom(type_: Type, c: Type): boolean;
    static isInstanceOfType(type_: Type, o: unknown): boolean;
}


export type TypeExtensions = TypeExtensions$instance;

