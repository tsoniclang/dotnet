// Generated by tsbindgen - Architecture
// Namespace: System.Reflection
// Assembly: System.Reflection.DispatchProxy, System.Reflection.TypeExtensions, System.Private.CoreLib, System.ObjectModel, System.Reflection.Metadata

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IEnumerable_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { AssemblyHashAlgorithm as AssemblyHashAlgorithm_Assemblies, AssemblyVersionCompatibility } from "../../System.Configuration.Assemblies/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { FileStream, Stream } from "../../System.IO/internal/index.js";
import type { StructLayoutAttribute } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, IObjectReference, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecurityRuleSet } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ApplicationException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Delegate, Enum, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, ModuleHandle, MulticastDelegate, Object as ClrObject, ResolveEventArgs, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, SystemException, Type, TypeCode, TypedReference, UInt32, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AssemblyContentType {
    Default = 0,
    WindowsRuntime = 1
}


export enum AssemblyFlags {
    PublicKey = 1,
    Retargetable = 256,
    WindowsRuntime = 512,
    ContentTypeMask = 3584,
    DisableJitCompileOptimizer = 16384,
    EnableJitCompileTracking = 32768
}


export enum AssemblyHashAlgorithm {
    None = 0,
    MD5 = 32771,
    Sha1 = 32772,
    Sha256 = 32780,
    Sha384 = 32781,
    Sha512 = 32782
}


export enum AssemblyNameFlags {
    None = 0,
    PublicKey = 1,
    EnableJITcompileOptimizer = 16384,
    EnableJITcompileTracking = 32768,
    Retargetable = 256
}


export enum BindingFlags {
    Default = 0,
    IgnoreCase = 1,
    DeclaredOnly = 2,
    Instance = 4,
    Static = 8,
    Public = 16,
    NonPublic = 32,
    FlattenHierarchy = 64,
    InvokeMethod = 256,
    CreateInstance = 512,
    GetField = 1024,
    SetField = 2048,
    GetProperty = 4096,
    SetProperty = 8192,
    PutDispProperty = 16384,
    PutRefDispProperty = 32768,
    ExactBinding = 65536,
    SuppressChangeType = 131072,
    OptionalParamBinding = 262144,
    IgnoreReturn = 16777216,
    DoNotWrapExceptions = 33554432
}


export enum CallingConventions {
    Standard = 1,
    VarArgs = 2,
    Any = 3,
    HasThis = 32,
    ExplicitThis = 64
}


export enum DeclarativeSecurityAction {
    None = 0,
    Demand = 2,
    Assert = 3,
    Deny = 4,
    PermitOnly = 5,
    LinkDemand = 6,
    InheritanceDemand = 7,
    RequestMinimum = 8,
    RequestOptional = 9,
    RequestRefuse = 10
}


export enum EventAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    ReservedMask = 1024
}


export enum ExceptionHandlingClauseOptions {
    Clause = 0,
    Filter = 1,
    Finally = 2,
    Fault = 4
}


export enum FieldAttributes {
    FieldAccessMask = 7,
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    Static = 16,
    InitOnly = 32,
    Literal = 64,
    NotSerialized = 128,
    SpecialName = 512,
    PinvokeImpl = 8192,
    RTSpecialName = 1024,
    HasFieldMarshal = 4096,
    HasDefault = 32768,
    HasFieldRVA = 256,
    ReservedMask = 38144
}


export enum GenericParameterAttributes {
    None = 0,
    VarianceMask = 3,
    Covariant = 1,
    Contravariant = 2,
    SpecialConstraintMask = 28,
    ReferenceTypeConstraint = 4,
    NotNullableValueTypeConstraint = 8,
    DefaultConstructorConstraint = 16,
    AllowByRefLike = 32
}


export enum ImageFileMachine {
    I386 = 332,
    IA64 = 512,
    AMD64 = 34404,
    ARM = 452
}


export enum ManifestResourceAttributes {
    Public = 1,
    Private = 2,
    VisibilityMask = 7
}


export enum MemberTypes {
    Constructor = 1,
    Event = 2,
    Field = 4,
    Method = 8,
    Property = 16,
    TypeInfo = 32,
    Custom = 64,
    NestedType = 128,
    All = 191
}


export enum MethodAttributes {
    MemberAccessMask = 7,
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    Static = 16,
    Final = 32,
    Virtual = 64,
    HideBySig = 128,
    CheckAccessOnOverride = 512,
    VtableLayoutMask = 256,
    ReuseSlot = 0,
    NewSlot = 256,
    Abstract = 1024,
    SpecialName = 2048,
    PinvokeImpl = 8192,
    UnmanagedExport = 8,
    RTSpecialName = 4096,
    HasSecurity = 16384,
    RequireSecObject = 32768,
    ReservedMask = 53248
}


export enum MethodImplAttributes {
    CodeTypeMask = 3,
    IL = 0,
    Native = 1,
    OPTIL = 2,
    Runtime = 3,
    ManagedMask = 4,
    Unmanaged = 4,
    Managed = 0,
    ForwardRef = 16,
    PreserveSig = 128,
    InternalCall = 4096,
    Synchronized = 32,
    NoInlining = 8,
    AggressiveInlining = 256,
    NoOptimization = 64,
    AggressiveOptimization = 512,
    Async = 8192,
    MaxMethodImplVal = 65535
}


export enum MethodImportAttributes {
    None = 0,
    ExactSpelling = 1,
    BestFitMappingDisable = 32,
    BestFitMappingEnable = 16,
    BestFitMappingMask = 48,
    CharSetAnsi = 2,
    CharSetUnicode = 4,
    CharSetAuto = 6,
    CharSetMask = 6,
    ThrowOnUnmappableCharEnable = 4096,
    ThrowOnUnmappableCharDisable = 8192,
    ThrowOnUnmappableCharMask = 12288,
    SetLastError = 64,
    CallingConventionWinApi = 256,
    CallingConventionCDecl = 512,
    CallingConventionStdCall = 768,
    CallingConventionThisCall = 1024,
    CallingConventionFastCall = 1280,
    CallingConventionMask = 1792
}


export enum MethodSemanticsAttributes {
    Setter = 1,
    Getter = 2,
    Other = 4,
    Adder = 8,
    Remover = 16,
    Raiser = 32
}


export enum NullabilityState {
    Unknown = 0,
    NotNull = 1,
    Nullable = 2
}


export enum ParameterAttributes {
    None = 0,
    In = 1,
    Out = 2,
    Lcid = 4,
    Retval = 8,
    Optional = 16,
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 61440
}


export enum PortableExecutableKinds {
    NotAPortableExecutableImage = 0,
    ILOnly = 1,
    Required32Bit = 2,
    PE32Plus = 4,
    Unmanaged32Bit = 8,
    Preferred32Bit = 16
}


export enum ProcessorArchitecture {
    None = 0,
    MSIL = 1,
    X86 = 2,
    IA64 = 3,
    Amd64 = 4,
    Arm = 5
}


export enum PropertyAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    HasDefault = 4096,
    Reserved2 = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 62464
}


export enum ResourceAttributes {
    Public = 1,
    Private = 2
}


export enum ResourceLocation {
    ContainedInAnotherAssembly = 2,
    ContainedInManifestFile = 4,
    Embedded = 1
}


export enum TypeAttributes {
    VisibilityMask = 7,
    NotPublic = 0,
    Public = 1,
    NestedPublic = 2,
    NestedPrivate = 3,
    NestedFamily = 4,
    NestedAssembly = 5,
    NestedFamANDAssem = 6,
    NestedFamORAssem = 7,
    LayoutMask = 24,
    AutoLayout = 0,
    SequentialLayout = 8,
    ExplicitLayout = 16,
    ClassSemanticsMask = 32,
    Class = 0,
    Interface = 32,
    Abstract = 128,
    Sealed = 256,
    SpecialName = 1024,
    Import = 4096,
    Serializable = 8192,
    WindowsRuntime = 16384,
    StringFormatMask = 196608,
    AnsiClass = 0,
    UnicodeClass = 65536,
    AutoClass = 131072,
    CustomFormatClass = 196608,
    CustomFormatMask = 12582912,
    BeforeFieldInit = 1048576,
    RTSpecialName = 2048,
    HasSecurity = 262144,
    ReservedMask = 264192
}


export interface ICustomAttributeProvider$instance {
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export type ICustomAttributeProvider = ICustomAttributeProvider$instance;

export interface ICustomTypeProvider$instance {
    GetCustomType(): Type;
}


export type ICustomTypeProvider = ICustomTypeProvider$instance;

export interface IReflect$instance {
    readonly UnderlyingSystemType: Type;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): any;
}


export type IReflect = IReflect$instance;

export interface IReflectableType$instance {
    GetTypeInfo(): TypeInfo;
}


export type IReflectableType = IReflectableType$instance;

export class CustomAttributeNamedArgument$instance {
    constructor(memberInfo: MemberInfo, value: any);
    constructor(memberInfo: MemberInfo, typedArgument: CustomAttributeTypedArgument);
    readonly IsField: boolean;
    readonly MemberInfo: MemberInfo;
    readonly MemberName: string;
    readonly TypedValue: CustomAttributeTypedArgument;
    Equals(obj: any): boolean;
    Equals(other: CustomAttributeNamedArgument): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export interface __CustomAttributeNamedArgument$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CustomAttributeNamedArgument>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomAttributeNamedArgument): boolean;
}

export type CustomAttributeNamedArgument = CustomAttributeNamedArgument$instance & __CustomAttributeNamedArgument$views;


export class CustomAttributeTypedArgument$instance {
    constructor(argumentType: Type, value: any);
    constructor(value: any);
    readonly ArgumentType: Type;
    readonly Value: any;
    Equals(obj: any): boolean;
    Equals(other: CustomAttributeTypedArgument): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export interface __CustomAttributeTypedArgument$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CustomAttributeTypedArgument>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CustomAttributeTypedArgument): boolean;
}

export type CustomAttributeTypedArgument = CustomAttributeTypedArgument$instance & __CustomAttributeTypedArgument$views;


export class InterfaceMapping$instance {
    TargetType: Type;
    InterfaceType: Type;
    TargetMethods: MethodInfo[];
    InterfaceMethods: MethodInfo[];
}


export type InterfaceMapping = InterfaceMapping$instance;

export class ParameterModifier$instance {
    constructor(parameterCount: int);
    Item: boolean;
}


export type ParameterModifier = ParameterModifier$instance;

export class AmbiguousMatchException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AmbiguousMatchException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AmbiguousMatchException = AmbiguousMatchException$instance & __AmbiguousMatchException$views;


export abstract class Assembly$instance {
    readonly CodeBase: string;
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly DefinedTypes: IEnumerable_1<TypeInfo>;
    readonly EntryPoint: MethodInfo;
    readonly EscapedCodeBase: string;
    readonly ExportedTypes: IEnumerable_1<Type>;
    readonly FullName: string;
    readonly GlobalAssemblyCache: boolean;
    readonly HostContext: long;
    readonly ImageRuntimeVersion: string;
    readonly IsCollectible: boolean;
    readonly IsDynamic: boolean;
    readonly IsFullyTrusted: boolean;
    readonly Location: string;
    readonly ManifestModule: Module;
    readonly Modules: IEnumerable_1<Module>;
    readonly ReflectionOnly: boolean;
    readonly SecurityRuleSet: SecurityRuleSet;
    CreateInstance(typeName: string): any;
    CreateInstance(typeName: string, ignoreCase: boolean): any;
    CreateInstance(typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: any[], culture: CultureInfo, activationAttributes: any[]): any;
    Equals(o: any): boolean;
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetExportedTypes(): Type[];
    GetFile(name: string): FileStream;
    GetFiles(): FileStream[];
    GetFiles(getResourceModules: boolean): FileStream[];
    GetForwardedTypes(): Type[];
    GetHashCode(): int;
    GetLoadedModules(): Module[];
    GetLoadedModules(getResourceModules: boolean): Module[];
    GetManifestResourceInfo(resourceName: string): ManifestResourceInfo;
    GetManifestResourceNames(): string[];
    GetManifestResourceStream(name: string): Stream;
    GetManifestResourceStream(type_: Type, name: string): Stream;
    GetModule(name: string): Module;
    GetModules(): Module[];
    GetModules(getResourceModules: boolean): Module[];
    GetName(): AssemblyName;
    GetName(copiedName: boolean): AssemblyName;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetReferencedAssemblies(): AssemblyName[];
    GetSatelliteAssembly(culture: CultureInfo): Assembly;
    GetSatelliteAssembly(culture: CultureInfo, version: Version): Assembly;
    GetType(name: string): Type;
    GetType(name: string, throwOnError: boolean): Type;
    GetType(name: string, throwOnError: boolean, ignoreCase: boolean): Type;
    GetTypes(): Type[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    LoadModule(moduleName: string, rawModule: byte[]): Module;
    LoadModule(moduleName: string, rawModule: byte[], rawSymbolStore: byte[]): Module;
    ToString(): string;
    static CreateQualifiedName(assemblyName: string, typeName: string): string;
    static GetAssembly(type_: Type): Assembly;
    static GetCallingAssembly(): Assembly;
    static GetEntryAssembly(): Assembly;
    static GetExecutingAssembly(): Assembly;
    static Load(rawAssembly: byte[], rawSymbolStore: byte[]): Assembly;
    static Load(rawAssembly: byte[]): Assembly;
    static Load(assemblyRef: AssemblyName): Assembly;
    static Load(assemblyString: string): Assembly;
    static LoadFile(path: string): Assembly;
    static LoadFrom(assemblyFile: string, hashValue: byte[], hashAlgorithm: AssemblyHashAlgorithm_Assemblies): Assembly;
    static LoadFrom(assemblyFile: string): Assembly;
    static LoadWithPartialName(partialName: string): Assembly;
    static ReflectionOnlyLoad(rawAssembly: byte[]): Assembly;
    static ReflectionOnlyLoad(assemblyString: string): Assembly;
    static ReflectionOnlyLoadFrom(assemblyFile: string): Assembly;
    static SetEntryAssembly(assembly: Assembly): void;
    static UnsafeLoadFrom(assemblyFile: string): Assembly;
}


export interface __Assembly$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Assembly = Assembly$instance & __Assembly$views;


export class AssemblyAlgorithmIdAttribute$instance extends System_Internal.Attribute$instance {
    constructor(algorithmId: AssemblyHashAlgorithm_Assemblies);
    constructor(algorithmId: uint);
    readonly AlgorithmId: uint;
}


export type AssemblyAlgorithmIdAttribute = AssemblyAlgorithmIdAttribute$instance;

export class AssemblyCompanyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(company: string);
    readonly Company: string;
}


export type AssemblyCompanyAttribute = AssemblyCompanyAttribute$instance;

export class AssemblyConfigurationAttribute$instance extends System_Internal.Attribute$instance {
    constructor(configuration: string);
    readonly Configuration: string;
}


export type AssemblyConfigurationAttribute = AssemblyConfigurationAttribute$instance;

export class AssemblyCopyrightAttribute$instance extends System_Internal.Attribute$instance {
    constructor(copyright: string);
    readonly Copyright: string;
}


export type AssemblyCopyrightAttribute = AssemblyCopyrightAttribute$instance;

export class AssemblyCultureAttribute$instance extends System_Internal.Attribute$instance {
    constructor(culture: string);
    readonly Culture: string;
}


export type AssemblyCultureAttribute = AssemblyCultureAttribute$instance;

export class AssemblyDefaultAliasAttribute$instance extends System_Internal.Attribute$instance {
    constructor(defaultAlias: string);
    readonly DefaultAlias: string;
}


export type AssemblyDefaultAliasAttribute = AssemblyDefaultAliasAttribute$instance;

export class AssemblyDelaySignAttribute$instance extends System_Internal.Attribute$instance {
    constructor(delaySign: boolean);
    readonly DelaySign: boolean;
}


export type AssemblyDelaySignAttribute = AssemblyDelaySignAttribute$instance;

export class AssemblyDescriptionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(description: string);
    readonly Description: string;
}


export type AssemblyDescriptionAttribute = AssemblyDescriptionAttribute$instance;

export class AssemblyFileVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(version: string);
    readonly Version: string;
}


export type AssemblyFileVersionAttribute = AssemblyFileVersionAttribute$instance;

export class AssemblyFlagsAttribute$instance extends System_Internal.Attribute$instance {
    constructor(flags: uint);
    constructor(assemblyFlags: int);
    constructor(assemblyFlags: AssemblyNameFlags);
    readonly AssemblyFlags: int;
    readonly Flags: uint;
}


export type AssemblyFlagsAttribute = AssemblyFlagsAttribute$instance;

export class AssemblyInformationalVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(informationalVersion: string);
    readonly InformationalVersion: string;
}


export type AssemblyInformationalVersionAttribute = AssemblyInformationalVersionAttribute$instance;

export class AssemblyKeyFileAttribute$instance extends System_Internal.Attribute$instance {
    constructor(keyFile: string);
    readonly KeyFile: string;
}


export type AssemblyKeyFileAttribute = AssemblyKeyFileAttribute$instance;

export class AssemblyKeyNameAttribute$instance extends System_Internal.Attribute$instance {
    constructor(keyName: string);
    readonly KeyName: string;
}


export type AssemblyKeyNameAttribute = AssemblyKeyNameAttribute$instance;

export class AssemblyMetadataAttribute$instance extends System_Internal.Attribute$instance {
    constructor(key: string, value: string);
    readonly Key: string;
    readonly Value: string;
}


export type AssemblyMetadataAttribute = AssemblyMetadataAttribute$instance;

export class AssemblyName$instance {
    constructor(assemblyName: string);
    constructor();
    CodeBase: string;
    ContentType: AssemblyContentType;
    CultureInfo: CultureInfo;
    CultureName: string;
    readonly EscapedCodeBase: string;
    Flags: AssemblyNameFlags;
    readonly FullName: string;
    HashAlgorithm: AssemblyHashAlgorithm_Assemblies;
    KeyPair: StrongNameKeyPair;
    Name: string;
    ProcessorArchitecture: ProcessorArchitecture;
    Version: Version;
    VersionCompatibility: AssemblyVersionCompatibility;
    Clone(): any;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetPublicKey(): byte[];
    GetPublicKeyToken(): byte[];
    OnDeserialization(sender: any): void;
    SetPublicKey(publicKey: byte[]): void;
    SetPublicKeyToken(publicKeyToken: byte[]): void;
    ToString(): string;
    static GetAssemblyName(assemblyFile: string): AssemblyName;
    static ReferenceMatchesDefinition(reference: AssemblyName, definition: AssemblyName): boolean;
}


export interface __AssemblyName$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AssemblyName = AssemblyName$instance & __AssemblyName$views;


export class AssemblyNameProxy$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    GetAssemblyName(assemblyFile: string): AssemblyName;
}


export type AssemblyNameProxy = AssemblyNameProxy$instance;

export class AssemblyProductAttribute$instance extends System_Internal.Attribute$instance {
    constructor(product: string);
    readonly Product: string;
}


export type AssemblyProductAttribute = AssemblyProductAttribute$instance;

export class AssemblySignatureKeyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(publicKey: string, countersignature: string);
    readonly Countersignature: string;
    readonly PublicKey: string;
}


export type AssemblySignatureKeyAttribute = AssemblySignatureKeyAttribute$instance;

export class AssemblyTitleAttribute$instance extends System_Internal.Attribute$instance {
    constructor(title: string);
    readonly Title: string;
}


export type AssemblyTitleAttribute = AssemblyTitleAttribute$instance;

export class AssemblyTrademarkAttribute$instance extends System_Internal.Attribute$instance {
    constructor(trademark: string);
    readonly Trademark: string;
}


export type AssemblyTrademarkAttribute = AssemblyTrademarkAttribute$instance;

export class AssemblyVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor(version: string);
    readonly Version: string;
}


export type AssemblyVersionAttribute = AssemblyVersionAttribute$instance;

export abstract class Binder$instance {
    abstract BindToField(bindingAttr: BindingFlags, match: FieldInfo[], value: any, culture: CultureInfo): FieldInfo;
    abstract BindToMethod(bindingAttr: BindingFlags, match: MethodBase[], args: { value: TSByRef<any[]> }, modifiers: ParameterModifier[], culture: CultureInfo, names: string[], state: { value: TSByRef<any> }): MethodBase;
    abstract ChangeType(value: any, type_: Type, culture: CultureInfo): any;
    abstract ReorderArgumentArray(args: { value: TSByRef<any[]> }, state: any): void;
    abstract SelectMethod(bindingAttr: BindingFlags, match: MethodBase[], types: Type[], modifiers: ParameterModifier[]): MethodBase;
    abstract SelectProperty(bindingAttr: BindingFlags, match: PropertyInfo[], returnType: Type, indexes: Type[], modifiers: ParameterModifier[]): PropertyInfo;
}


export type Binder = Binder$instance;

export abstract class ConstructorInfo$instance extends MethodBase$instance {
    readonly MemberType: MemberTypes;
    Equals(obj: any): boolean;
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetHashCode(): int;
    Invoke(obj: any, parameters: any[]): any;
    Invoke(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    static readonly ConstructorName: string;
    static readonly TypeConstructorName: string;
}


export interface __ConstructorInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
}

export type ConstructorInfo = ConstructorInfo$instance & __ConstructorInfo$views;


export class ConstructorInvoker$instance {
    Invoke(): any;
    Invoke(arg1: any): any;
    Invoke(arg1: any, arg2: any): any;
    Invoke(arg1: any, arg2: any, arg3: any): any;
    Invoke(arg1: any, arg2: any, arg3: any, arg4: any): any;
    Invoke(arguments: Span_1<any>): any;
    static Create(constructor_: ConstructorInfo): ConstructorInvoker;
}


export type ConstructorInvoker = ConstructorInvoker$instance;

export class CustomAttributeData$instance {
    readonly AttributeType: Type;
    readonly Constructor: ConstructorInfo;
    readonly ConstructorArguments: IList_1<CustomAttributeTypedArgument>;
    readonly NamedArguments: IList_1<CustomAttributeNamedArgument>;
    ToString(): string;
    static GetCustomAttributes(target: Assembly): IList_1<CustomAttributeData>;
    static GetCustomAttributes(target: MemberInfo): IList_1<CustomAttributeData>;
    static GetCustomAttributes(target: Module): IList_1<CustomAttributeData>;
    static GetCustomAttributes(target: ParameterInfo): IList_1<CustomAttributeData>;
}


export type CustomAttributeData = CustomAttributeData$instance;

export class CustomAttributeFormatException$instance extends System_Internal.FormatException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __CustomAttributeFormatException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CustomAttributeFormatException = CustomAttributeFormatException$instance & __CustomAttributeFormatException$views;


export class DefaultMemberAttribute$instance extends System_Internal.Attribute$instance {
    constructor(memberName: string);
    readonly MemberName: string;
}


export type DefaultMemberAttribute = DefaultMemberAttribute$instance;

export abstract class DispatchProxy$instance {
    static Create<T, TProxy extends DispatchProxy>(): T;
    static Create(interfaceType: Type, proxyType: Type): any;
}


export type DispatchProxy = DispatchProxy$instance;

export abstract class EventInfo$instance extends MemberInfo$instance {
    readonly AddMethod: MethodInfo;
    readonly Attributes: EventAttributes;
    readonly EventHandlerType: Type;
    readonly IsMulticast: boolean;
    readonly IsSpecialName: boolean;
    readonly MemberType: MemberTypes;
    readonly RaiseMethod: MethodInfo;
    readonly RemoveMethod: MethodInfo;
    AddEventHandler(target: any, handler: Function): void;
    Equals(obj: any): boolean;
    GetAddMethod(): MethodInfo;
    GetAddMethod(nonPublic: boolean): MethodInfo;
    abstract GetCustomAttributes(inherit: boolean): any[];
    abstract GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetHashCode(): int;
    GetOtherMethods(): MethodInfo[];
    GetOtherMethods(nonPublic: boolean): MethodInfo[];
    GetRaiseMethod(): MethodInfo;
    GetRaiseMethod(nonPublic: boolean): MethodInfo;
    GetRemoveMethod(): MethodInfo;
    GetRemoveMethod(nonPublic: boolean): MethodInfo;
    abstract IsDefined(attributeType: Type, inherit: boolean): boolean;
    RemoveEventHandler(target: any, handler: Function): void;
}


export interface __EventInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
}

export type EventInfo = EventInfo$instance & __EventInfo$views;


export class ExceptionHandlingClause$instance {
    readonly CatchType: Type;
    readonly FilterOffset: int;
    readonly Flags: ExceptionHandlingClauseOptions;
    readonly HandlerLength: int;
    readonly HandlerOffset: int;
    readonly TryLength: int;
    readonly TryOffset: int;
    ToString(): string;
}


export type ExceptionHandlingClause = ExceptionHandlingClause$instance;

export abstract class FieldInfo$instance extends MemberInfo$instance {
    readonly Attributes: FieldAttributes;
    readonly FieldHandle: RuntimeFieldHandle;
    readonly FieldType: Type;
    readonly IsAssembly: boolean;
    readonly IsFamily: boolean;
    readonly IsFamilyAndAssembly: boolean;
    readonly IsFamilyOrAssembly: boolean;
    readonly IsInitOnly: boolean;
    readonly IsLiteral: boolean;
    readonly IsNotSerialized: boolean;
    readonly IsPinvokeImpl: boolean;
    readonly IsPrivate: boolean;
    readonly IsPublic: boolean;
    readonly IsSecurityCritical: boolean;
    readonly IsSecuritySafeCritical: boolean;
    readonly IsSecurityTransparent: boolean;
    readonly IsSpecialName: boolean;
    readonly IsStatic: boolean;
    readonly MemberType: MemberTypes;
    Equals(obj: any): boolean;
    abstract GetCustomAttributes(inherit: boolean): any[];
    abstract GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetHashCode(): int;
    GetModifiedFieldType(): Type;
    GetOptionalCustomModifiers(): Type[];
    GetRawConstantValue(): any;
    GetRequiredCustomModifiers(): Type[];
    abstract GetValue(obj: any): any;
    GetValueDirect(obj: TypedReference): any;
    abstract IsDefined(attributeType: Type, inherit: boolean): boolean;
    SetValue(obj: any, value: any): void;
    SetValue(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, culture: CultureInfo): void;
    SetValueDirect(obj: TypedReference, value: any): void;
    static GetFieldFromHandle(handle: RuntimeFieldHandle, declaringType: RuntimeTypeHandle): FieldInfo;
    static GetFieldFromHandle(handle: RuntimeFieldHandle): FieldInfo;
}


export interface __FieldInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
}

export type FieldInfo = FieldInfo$instance & __FieldInfo$views;


export class InvalidFilterCriteriaException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidFilterCriteriaException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidFilterCriteriaException = InvalidFilterCriteriaException$instance & __InvalidFilterCriteriaException$views;


export class LocalVariableInfo$instance {
    readonly IsPinned: boolean;
    readonly LocalIndex: int;
    readonly LocalType: Type;
    ToString(): string;
}


export type LocalVariableInfo = LocalVariableInfo$instance;

export class ManifestResourceInfo$instance {
    constructor(containingAssembly: Assembly, containingFileName: string, resourceLocation: ResourceLocation);
    readonly FileName: string;
    readonly ReferencedAssembly: Assembly;
    readonly ResourceLocation: ResourceLocation;
}


export type ManifestResourceInfo = ManifestResourceInfo$instance;

export class MemberFilter$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(m: MemberInfo, filterCriteria: any, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(m: MemberInfo, filterCriteria: any): boolean;
}


export interface __MemberFilter$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MemberFilter = MemberFilter$instance & __MemberFilter$views;


export abstract class MemberInfo$instance {
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly DeclaringType: Type;
    readonly IsCollectible: boolean;
    readonly MemberType: MemberTypes;
    readonly MetadataToken: int;
    readonly Module: Module;
    readonly Name: string;
    readonly ReflectedType: Type;
    Equals(obj: any): boolean;
    abstract GetCustomAttributes(inherit: boolean): any[];
    abstract GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetHashCode(): int;
    HasSameMetadataDefinitionAs(other: MemberInfo): boolean;
    abstract IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export interface __MemberInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
}

export type MemberInfo = MemberInfo$instance & __MemberInfo$views;


export abstract class MethodBase$instance extends MemberInfo$instance {
    readonly Attributes: MethodAttributes;
    readonly CallingConvention: CallingConventions;
    readonly ContainsGenericParameters: boolean;
    readonly IsAbstract: boolean;
    readonly IsAssembly: boolean;
    readonly IsConstructedGenericMethod: boolean;
    readonly IsConstructor: boolean;
    readonly IsFamily: boolean;
    readonly IsFamilyAndAssembly: boolean;
    readonly IsFamilyOrAssembly: boolean;
    readonly IsFinal: boolean;
    readonly IsGenericMethod: boolean;
    readonly IsGenericMethodDefinition: boolean;
    readonly IsHideBySig: boolean;
    readonly IsPrivate: boolean;
    readonly IsPublic: boolean;
    readonly IsSecurityCritical: boolean;
    readonly IsSecuritySafeCritical: boolean;
    readonly IsSecurityTransparent: boolean;
    readonly IsSpecialName: boolean;
    readonly IsStatic: boolean;
    readonly IsVirtual: boolean;
    readonly MethodHandle: RuntimeMethodHandle;
    readonly MethodImplementationFlags: MethodImplAttributes;
    Equals(obj: any): boolean;
    abstract GetCustomAttributes(inherit: boolean): any[];
    abstract GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetGenericArguments(): Type[];
    GetHashCode(): int;
    GetMethodBody(): MethodBody;
    abstract GetMethodImplementationFlags(): MethodImplAttributes;
    abstract GetParameters(): ParameterInfo[];
    Invoke(obj: any, parameters: any[]): any;
    Invoke(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any;
    abstract IsDefined(attributeType: Type, inherit: boolean): boolean;
    static GetCurrentMethod(): MethodBase;
    static GetMethodFromHandle(handle: RuntimeMethodHandle, declaringType: RuntimeTypeHandle): MethodBase;
    static GetMethodFromHandle(handle: RuntimeMethodHandle): MethodBase;
}


export interface __MethodBase$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
}

export type MethodBase = MethodBase$instance & __MethodBase$views;


export class MethodBody$instance {
    readonly ExceptionHandlingClauses: IList_1<ExceptionHandlingClause>;
    readonly InitLocals: boolean;
    readonly LocalSignatureMetadataToken: int;
    readonly LocalVariables: IList_1<LocalVariableInfo>;
    readonly MaxStackSize: int;
    GetILAsByteArray(): byte[];
}


export type MethodBody = MethodBody$instance;

export abstract class MethodInfo$instance extends MethodBase$instance {
    readonly MemberType: MemberTypes;
    readonly ReturnParameter: ParameterInfo;
    readonly ReturnType: Type;
    readonly ReturnTypeCustomAttributes: ICustomAttributeProvider;
    CreateDelegate(delegateType: Type): Function;
    CreateDelegate(delegateType: Type, target: any): Function;
    CreateDelegate<T extends Function>(): T;
    CreateDelegate<T extends Function>(target: any): T;
    Equals(obj: any): boolean;
    abstract GetBaseDefinition(): MethodInfo;
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetGenericArguments(): Type[];
    GetGenericMethodDefinition(): MethodInfo;
    GetHashCode(): int;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    MakeGenericMethod(typeArguments: Type[]): MethodInfo;
}


export interface __MethodInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
}

export type MethodInfo = MethodInfo$instance & __MethodInfo$views;


export class MethodInvoker$instance {
    Invoke(obj: any): any;
    Invoke(obj: any, arg1: any): any;
    Invoke(obj: any, arg1: any, arg2: any): any;
    Invoke(obj: any, arg1: any, arg2: any, arg3: any): any;
    Invoke(obj: any, arg1: any, arg2: any, arg3: any, arg4: any): any;
    Invoke(obj: any, arguments: Span_1<any>): any;
    static Create(method: MethodBase): MethodInvoker;
}


export type MethodInvoker = MethodInvoker$instance;

export class Missing$instance {
    static readonly Value: Missing;
}


export interface __Missing$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Missing = Missing$instance & __Missing$views;


export abstract class Module$instance {
    readonly Assembly: Assembly;
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly FullyQualifiedName: string;
    readonly MDStreamVersion: int;
    readonly MetadataToken: int;
    readonly ModuleHandle: ModuleHandle;
    readonly ModuleVersionId: Guid;
    readonly Name: string;
    readonly ScopeName: string;
    Equals(o: any): boolean;
    FindTypes(filter: TypeFilter, filterCriteria: any): Type[];
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetField(name: string): FieldInfo;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetFields(): FieldInfo[];
    GetFields(bindingFlags: BindingFlags): FieldInfo[];
    GetHashCode(): int;
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(): MethodInfo[];
    GetMethods(bindingFlags: BindingFlags): MethodInfo[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetPEKind(peKind: { value: TSByRef<PortableExecutableKinds> }, machine: { value: TSByRef<ImageFileMachine> }): void;
    GetType(className: string): Type;
    GetType(className: string, ignoreCase: boolean): Type;
    GetType(className: string, throwOnError: boolean, ignoreCase: boolean): Type;
    GetTypes(): Type[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    IsResource(): boolean;
    ResolveField(metadataToken: int): FieldInfo;
    ResolveField(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo;
    ResolveMember(metadataToken: int): MemberInfo;
    ResolveMember(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MemberInfo;
    ResolveMethod(metadataToken: int): MethodBase;
    ResolveMethod(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MethodBase;
    ResolveSignature(metadataToken: int): byte[];
    ResolveString(metadataToken: int): string;
    ResolveType(metadataToken: int): Type;
    ResolveType(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): Type;
    ToString(): string;
    static readonly FilterTypeName: TypeFilter;
    static readonly FilterTypeNameIgnoreCase: TypeFilter;
}


export interface __Module$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Module = Module$instance & __Module$views;


export class ModuleResolveEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: ResolveEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): Module;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: ResolveEventArgs): Module;
}


export interface __ModuleResolveEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ModuleResolveEventHandler = ModuleResolveEventHandler$instance & __ModuleResolveEventHandler$views;


export class NullabilityInfo$instance {
    readonly ElementType: NullabilityInfo;
    readonly GenericTypeArguments: NullabilityInfo[];
    readonly ReadState: NullabilityState;
    readonly Type: Type;
    readonly WriteState: NullabilityState;
}


export type NullabilityInfo = NullabilityInfo$instance;

export class NullabilityInfoContext$instance {
    constructor();
    Create(parameterInfo: ParameterInfo): NullabilityInfo;
    Create(propertyInfo: PropertyInfo): NullabilityInfo;
    Create(eventInfo: EventInfo): NullabilityInfo;
    Create(fieldInfo: FieldInfo): NullabilityInfo;
}


export type NullabilityInfoContext = NullabilityInfoContext$instance;

export class ObfuscateAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(assemblyIsPrivate: boolean);
    readonly AssemblyIsPrivate: boolean;
    StripAfterObfuscation: boolean;
}


export type ObfuscateAssemblyAttribute = ObfuscateAssemblyAttribute$instance;

export class ObfuscationAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    ApplyToMembers: boolean;
    Exclude: boolean;
    Feature: string;
    StripAfterObfuscation: boolean;
}


export type ObfuscationAttribute = ObfuscationAttribute$instance;

export class ParameterInfo$instance {
    readonly Attributes: ParameterAttributes;
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly DefaultValue: any;
    readonly HasDefaultValue: boolean;
    readonly IsIn: boolean;
    readonly IsLcid: boolean;
    readonly IsOptional: boolean;
    readonly IsOut: boolean;
    readonly IsRetval: boolean;
    readonly Member: MemberInfo;
    readonly MetadataToken: int;
    readonly Name: string;
    readonly ParameterType: Type;
    readonly Position: int;
    readonly RawDefaultValue: any;
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetModifiedParameterType(): Type;
    GetOptionalCustomModifiers(): Type[];
    GetRealObject(context: StreamingContext): any;
    GetRequiredCustomModifiers(): Type[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    ToString(): string;
}


export interface __ParameterInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
    readonly As_IObjectReference: System_Runtime_Serialization_Internal.IObjectReference$instance;
}

export type ParameterInfo = ParameterInfo$instance & __ParameterInfo$views;


export class Pointer$instance {
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static Box(ptr: TSUnsafePointer<void>, type_: Type): any;
    static Unbox(ptr: any): TSUnsafePointer<void>;
}


export interface __Pointer$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Pointer = Pointer$instance & __Pointer$views;


export abstract class PropertyInfo$instance extends MemberInfo$instance {
    readonly Attributes: PropertyAttributes;
    readonly CanRead: boolean;
    readonly CanWrite: boolean;
    readonly GetMethod: MethodInfo;
    readonly IsSpecialName: boolean;
    readonly MemberType: MemberTypes;
    readonly PropertyType: Type;
    readonly SetMethod: MethodInfo;
    Equals(obj: any): boolean;
    GetAccessors(): MethodInfo[];
    GetAccessors(nonPublic: boolean): MethodInfo[];
    GetConstantValue(): any;
    abstract GetCustomAttributes(inherit: boolean): any[];
    abstract GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetGetMethod(): MethodInfo;
    GetGetMethod(nonPublic: boolean): MethodInfo;
    GetHashCode(): int;
    abstract GetIndexParameters(): ParameterInfo[];
    GetModifiedPropertyType(): Type;
    GetOptionalCustomModifiers(): Type[];
    GetRawConstantValue(): any;
    GetRequiredCustomModifiers(): Type[];
    GetSetMethod(): MethodInfo;
    GetSetMethod(nonPublic: boolean): MethodInfo;
    GetValue(obj: any): any;
    GetValue(obj: any, index: any[]): any;
    GetValue(obj: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: CultureInfo): any;
    abstract IsDefined(attributeType: Type, inherit: boolean): boolean;
    SetValue(obj: any, value: any): void;
    SetValue(obj: any, value: any, index: any[]): void;
    SetValue(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: CultureInfo): void;
}


export interface __PropertyInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
}

export type PropertyInfo = PropertyInfo$instance & __PropertyInfo$views;


export abstract class ReflectionContext$instance {
    GetTypeForObject(value: any): TypeInfo;
    abstract MapAssembly(assembly: Assembly): Assembly;
    abstract MapType(type_: TypeInfo): TypeInfo;
}


export type ReflectionContext = ReflectionContext$instance;

export class ReflectionTypeLoadException$instance extends System_Internal.SystemException$instance {
    constructor(classes: Type[], exceptions: Exception[]);
    constructor(classes: Type[], exceptions: Exception[], message: string);
    readonly LoaderExceptions: Exception[];
    readonly Message: string;
    readonly Types: Type[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export interface __ReflectionTypeLoadException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReflectionTypeLoadException = ReflectionTypeLoadException$instance & __ReflectionTypeLoadException$views;


export class StrongNameKeyPair$instance {
    constructor(keyPairFile: FileStream);
    constructor(keyPairArray: byte[]);
    constructor(keyPairContainer: string);
    readonly PublicKey: byte[];
}


export interface __StrongNameKeyPair$views {
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StrongNameKeyPair = StrongNameKeyPair$instance & __StrongNameKeyPair$views;


export class TargetException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TargetException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetException = TargetException$instance & __TargetException$views;


export class TargetInvocationException$instance extends System_Internal.ApplicationException$instance {
    constructor(inner: Exception);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TargetInvocationException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetInvocationException = TargetInvocationException$instance & __TargetInvocationException$views;


export class TargetParameterCountException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __TargetParameterCountException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetParameterCountException = TargetParameterCountException$instance & __TargetParameterCountException$views;


export class TypeDelegator$instance extends TypeInfo$instance {
    constructor(delegatingType: Type);
    readonly Assembly: Assembly;
    readonly AssemblyQualifiedName: string;
    readonly BaseType: Type;
    readonly FullName: string;
    readonly GUID: Guid;
    readonly IsByRefLike: boolean;
    readonly IsCollectible: boolean;
    readonly IsConstructedGenericType: boolean;
    readonly IsFunctionPointer: boolean;
    readonly IsGenericMethodParameter: boolean;
    readonly IsGenericTypeParameter: boolean;
    readonly IsSZArray: boolean;
    readonly IsTypeDefinition: boolean;
    readonly IsUnmanagedFunctionPointer: boolean;
    readonly IsVariableBoundArray: boolean;
    readonly MetadataToken: int;
    readonly Module: Module;
    readonly Name: string;
    readonly Namespace: string;
    readonly TypeHandle: RuntimeTypeHandle;
    readonly UnderlyingSystemType: Type;
    GetArrayRank(): int;
    GetConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
    GetConstructors(): ConstructorInfo[];
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetElementType(): Type;
    GetEvent(name: string, bindingAttr: BindingFlags): EventInfo;
    GetEvent(name: string): EventInfo;
    GetEvents(): EventInfo[];
    GetEvents(bindingAttr: BindingFlags): EventInfo[];
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetField(name: string): FieldInfo;
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetFields(): FieldInfo[];
    GetFunctionPointerCallingConventions(): Type[];
    GetFunctionPointerParameterTypes(): Type[];
    GetFunctionPointerReturnType(): Type;
    GetInterface(name: string, ignoreCase: boolean): Type;
    GetInterface(name: string): Type;
    GetInterfaceMap(interfaceType: Type): InterfaceMapping;
    GetInterfaces(): Type[];
    GetMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(): MemberInfo[];
    GetMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetMethods(): MethodInfo[];
    GetNestedType(name: string, bindingAttr: BindingFlags): Type;
    GetNestedType(name: string): Type;
    GetNestedTypes(bindingAttr: BindingFlags): Type[];
    GetNestedTypes(): Type[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperties(): PropertyInfo[];
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string): PropertyInfo;
    GetProperty(name: string, returnType: Type): PropertyInfo;
    GetProperty(name: string, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetTypeInfo(): TypeInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): any;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[]): any;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], culture: CultureInfo): any;
    IsAssignableFrom(typeInfo: TypeInfo): boolean;
    IsAssignableFrom(c: Type): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export interface __TypeDelegator$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
    readonly As_IReflect: IReflect$instance;
    readonly As_IReflectableType: IReflectableType$instance;
}

export type TypeDelegator = TypeDelegator$instance & __TypeDelegator$views;


export class TypeFilter$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(m: Type, filterCriteria: any, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(m: Type, filterCriteria: any): boolean;
}


export interface __TypeFilter$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeFilter = TypeFilter$instance & __TypeFilter$views;


export abstract class TypeInfo$instance extends System_Internal.Type$instance {
    readonly DeclaredConstructors: IEnumerable_1<ConstructorInfo>;
    readonly DeclaredEvents: IEnumerable_1<EventInfo>;
    readonly DeclaredFields: IEnumerable_1<FieldInfo>;
    readonly DeclaredMembers: IEnumerable_1<MemberInfo>;
    readonly DeclaredMethods: IEnumerable_1<MethodInfo>;
    readonly DeclaredNestedTypes: IEnumerable_1<TypeInfo>;
    readonly DeclaredProperties: IEnumerable_1<PropertyInfo>;
    readonly GenericTypeParameters: Type[];
    readonly ImplementedInterfaces: IEnumerable_1<Type>;
    AsType(): Type;
    GetCustomAttributes(inherit: boolean): any[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
    GetDeclaredEvent(name: string): EventInfo;
    GetDeclaredField(name: string): FieldInfo;
    GetDeclaredMethod(name: string): MethodInfo;
    GetDeclaredMethods(name: string): IEnumerable_1<MethodInfo>;
    GetDeclaredNestedType(name: string): TypeInfo;
    GetDeclaredProperty(name: string): PropertyInfo;
    GetField(name: string): FieldInfo;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetFields(): FieldInfo[];
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetMember(name: string): MemberInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(): MethodInfo[];
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetProperties(): PropertyInfo[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperty(name: string): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    GetProperty(name: string, returnType: Type): PropertyInfo;
    GetProperty(name: string, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[]): any;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], culture: CultureInfo): any;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): any;
    IsAssignableFrom(c: Type): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export interface __TypeInfo$views {
    readonly As_ICustomAttributeProvider: ICustomAttributeProvider$instance;
    readonly As_IReflect: IReflect$instance;
    readonly As_IReflectableType: IReflectableType$instance;
}

export type TypeInfo = TypeInfo$instance & __TypeInfo$views;


export abstract class AssemblyExtensions$instance {
    static GetExportedTypes(assembly: Assembly): Type[];
    static GetModules(assembly: Assembly): Module[];
    static GetTypes(assembly: Assembly): Type[];
}


export type AssemblyExtensions = AssemblyExtensions$instance;

export abstract class CustomAttributeExtensions$instance {
    static GetCustomAttribute(element: Assembly, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: Assembly): T;
    static GetCustomAttribute<T extends Attribute>(element: MemberInfo, inherit: boolean): T;
    static GetCustomAttribute(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute;
    static GetCustomAttribute(element: MemberInfo, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: MemberInfo): T;
    static GetCustomAttribute(element: Module, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: Module): T;
    static GetCustomAttribute<T extends Attribute>(element: ParameterInfo, inherit: boolean): T;
    static GetCustomAttribute(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute;
    static GetCustomAttribute(element: ParameterInfo, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: ParameterInfo): T;
    static GetCustomAttributes(element: Assembly, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: Assembly): IEnumerable_1<T>;
    static GetCustomAttributes(element: Assembly): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: MemberInfo, inherit: boolean): IEnumerable_1<T>;
    static GetCustomAttributes(element: MemberInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: MemberInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: MemberInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: MemberInfo): IEnumerable_1<T>;
    static GetCustomAttributes(element: MemberInfo): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: Module, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: Module): IEnumerable_1<T>;
    static GetCustomAttributes(element: Module): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: ParameterInfo, inherit: boolean): IEnumerable_1<T>;
    static GetCustomAttributes(element: ParameterInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: ParameterInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: ParameterInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: ParameterInfo): IEnumerable_1<T>;
    static GetCustomAttributes(element: ParameterInfo): IEnumerable_1<Attribute>;
    static IsDefined(element: Assembly, attributeType: Type): boolean;
    static IsDefined(element: MemberInfo, attributeType: Type, inherit: boolean): boolean;
    static IsDefined(element: MemberInfo, attributeType: Type): boolean;
    static IsDefined(element: Module, attributeType: Type): boolean;
    static IsDefined(element: ParameterInfo, attributeType: Type, inherit: boolean): boolean;
    static IsDefined(element: ParameterInfo, attributeType: Type): boolean;
}


export type CustomAttributeExtensions = CustomAttributeExtensions$instance;

export abstract class EventInfoExtensions$instance {
    static GetAddMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static GetAddMethod(eventInfo: EventInfo): MethodInfo;
    static GetRaiseMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static GetRaiseMethod(eventInfo: EventInfo): MethodInfo;
    static GetRemoveMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static GetRemoveMethod(eventInfo: EventInfo): MethodInfo;
}


export type EventInfoExtensions = EventInfoExtensions$instance;

export abstract class IntrospectionExtensions$instance {
    static GetTypeInfo(type_: Type): TypeInfo;
}


export type IntrospectionExtensions = IntrospectionExtensions$instance;

export abstract class MemberInfoExtensions$instance {
    static GetMetadataToken(member: MemberInfo): int;
    static HasMetadataToken(member: MemberInfo): boolean;
}


export type MemberInfoExtensions = MemberInfoExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static GetBaseDefinition(method: MethodInfo): MethodInfo;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class ModuleExtensions$instance {
    static GetModuleVersionId(module_: Module): Guid;
    static HasModuleVersionId(module_: Module): boolean;
}


export type ModuleExtensions = ModuleExtensions$instance;

export abstract class PropertyInfoExtensions$instance {
    static GetAccessors(property: PropertyInfo, nonPublic: boolean): MethodInfo[];
    static GetAccessors(property: PropertyInfo): MethodInfo[];
    static GetGetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static GetGetMethod(property: PropertyInfo): MethodInfo;
    static GetSetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static GetSetMethod(property: PropertyInfo): MethodInfo;
}


export type PropertyInfoExtensions = PropertyInfoExtensions$instance;

export abstract class RuntimeReflectionExtensions$instance {
    static GetMethodInfo(del: Function): MethodInfo;
    static GetRuntimeBaseDefinition(method: MethodInfo): MethodInfo;
    static GetRuntimeEvent(type_: Type, name: string): EventInfo;
    static GetRuntimeEvents(type_: Type): IEnumerable_1<EventInfo>;
    static GetRuntimeField(type_: Type, name: string): FieldInfo;
    static GetRuntimeFields(type_: Type): IEnumerable_1<FieldInfo>;
    static GetRuntimeInterfaceMap(typeInfo: TypeInfo, interfaceType: Type): InterfaceMapping;
    static GetRuntimeMethod(type_: Type, name: string, parameters: Type[]): MethodInfo;
    static GetRuntimeMethods(type_: Type): IEnumerable_1<MethodInfo>;
    static GetRuntimeProperties(type_: Type): IEnumerable_1<PropertyInfo>;
    static GetRuntimeProperty(type_: Type, name: string): PropertyInfo;
}


export type RuntimeReflectionExtensions = RuntimeReflectionExtensions$instance;

export abstract class TypeExtensions$instance {
    static GetConstructor(type_: Type, types: Type[]): ConstructorInfo;
    static GetConstructors(type_: Type, bindingAttr: BindingFlags): ConstructorInfo[];
    static GetConstructors(type_: Type): ConstructorInfo[];
    static GetDefaultMembers(type_: Type): MemberInfo[];
    static GetEvent(type_: Type, name: string, bindingAttr: BindingFlags): EventInfo;
    static GetEvent(type_: Type, name: string): EventInfo;
    static GetEvents(type_: Type, bindingAttr: BindingFlags): EventInfo[];
    static GetEvents(type_: Type): EventInfo[];
    static GetField(type_: Type, name: string, bindingAttr: BindingFlags): FieldInfo;
    static GetField(type_: Type, name: string): FieldInfo;
    static GetFields(type_: Type, bindingAttr: BindingFlags): FieldInfo[];
    static GetFields(type_: Type): FieldInfo[];
    static GetGenericArguments(type_: Type): Type[];
    static GetInterfaces(type_: Type): Type[];
    static GetMember(type_: Type, name: string, bindingAttr: BindingFlags): MemberInfo[];
    static GetMember(type_: Type, name: string): MemberInfo[];
    static GetMembers(type_: Type, bindingAttr: BindingFlags): MemberInfo[];
    static GetMembers(type_: Type): MemberInfo[];
    static GetMethod(type_: Type, name: string, bindingAttr: BindingFlags): MethodInfo;
    static GetMethod(type_: Type, name: string, types: Type[]): MethodInfo;
    static GetMethod(type_: Type, name: string): MethodInfo;
    static GetMethods(type_: Type, bindingAttr: BindingFlags): MethodInfo[];
    static GetMethods(type_: Type): MethodInfo[];
    static GetNestedType(type_: Type, name: string, bindingAttr: BindingFlags): Type;
    static GetNestedTypes(type_: Type, bindingAttr: BindingFlags): Type[];
    static GetProperties(type_: Type, bindingAttr: BindingFlags): PropertyInfo[];
    static GetProperties(type_: Type): PropertyInfo[];
    static GetProperty(type_: Type, name: string, bindingAttr: BindingFlags): PropertyInfo;
    static GetProperty(type_: Type, name: string, returnType: Type, types: Type[]): PropertyInfo;
    static GetProperty(type_: Type, name: string, returnType: Type): PropertyInfo;
    static GetProperty(type_: Type, name: string): PropertyInfo;
    static IsAssignableFrom(type_: Type, c: Type): boolean;
    static IsInstanceOfType(type_: Type, o: any): boolean;
}


export type TypeExtensions = TypeExtensions$instance;

