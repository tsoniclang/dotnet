// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel.Design.Serialization
// Assembly: System.ComponentModel.TypeConverter, System.ComponentModel.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection } from "../../System.Collections/internal/index.js";
import type { DesignerTransaction, DesignerTransactionCloseEventHandler, IDesigner, ServiceCreatorCallback } from "../../System.ComponentModel.Design/internal/index.js";
import type { IComponent, IContainer, MemberDescriptor, PropertyDescriptorCollection } from "../../System.ComponentModel/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MemberInfo, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Attribute, Boolean as ClrBoolean, Delegate, EventArgs, EventHandler, IAsyncResult, ICloneable, IDisposable, IEquatable_1, Int32, IntPtr, MulticastDelegate, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDesignerLoaderHost$instance {
    readonly Loading: boolean;
    readonly InTransaction: boolean;
    readonly Container: IContainer;
    readonly RootComponent: IComponent;
    readonly RootComponentClassName: string;
    readonly TransactionDescription: string;
    AddService(serviceType: Type, callback: ServiceCreatorCallback, promote: boolean): void;
    AddService(serviceType: Type, callback: ServiceCreatorCallback): void;
    AddService(serviceType: Type, serviceInstance: any, promote: boolean): void;
    AddService(serviceType: Type, serviceInstance: any): void;
    CreateComponent(componentClass: Type, name: string): IComponent;
    CreateComponent(componentClass: Type): IComponent;
    CreateTransaction(): DesignerTransaction;
    CreateTransaction(description: string): DesignerTransaction;
    DestroyComponent(component: IComponent): void;
    EndLoad(baseClassName: string, successful: boolean, errorCollection: ICollection): void;
    GetDesigner(component: IComponent): IDesigner;
    GetService(serviceType: Type): any;
    GetType(typeName: string): Type;
    Reload(): void;
    RemoveService(serviceType: Type, promote: boolean): void;
    RemoveService(serviceType: Type): void;
}


export type IDesignerLoaderHost = IDesignerLoaderHost$instance;

export interface IDesignerLoaderHost2$instance {
    IgnoreErrorsDuringReload: boolean;
    CanReloadWithErrors: boolean;
    readonly Loading: boolean;
    readonly InTransaction: boolean;
    readonly Container: IContainer;
    readonly RootComponent: IComponent;
    readonly RootComponentClassName: string;
    readonly TransactionDescription: string;
    AddService(serviceType: Type, callback: ServiceCreatorCallback, promote: boolean): void;
    AddService(serviceType: Type, callback: ServiceCreatorCallback): void;
    AddService(serviceType: Type, serviceInstance: any, promote: boolean): void;
    AddService(serviceType: Type, serviceInstance: any): void;
    CreateComponent(componentClass: Type, name: string): IComponent;
    CreateComponent(componentClass: Type): IComponent;
    CreateTransaction(): DesignerTransaction;
    CreateTransaction(description: string): DesignerTransaction;
    DestroyComponent(component: IComponent): void;
    EndLoad(baseClassName: string, successful: boolean, errorCollection: ICollection): void;
    GetDesigner(component: IComponent): IDesigner;
    GetService(serviceType: Type): any;
    GetType(typeName: string): Type;
    Reload(): void;
    RemoveService(serviceType: Type, promote: boolean): void;
    RemoveService(serviceType: Type): void;
}


export type IDesignerLoaderHost2 = IDesignerLoaderHost2$instance;

export interface IDesignerLoaderService$instance {
    AddLoadDependency(): void;
    DependentLoadComplete(successful: boolean, errorCollection: ICollection): void;
    Reload(): boolean;
}


export type IDesignerLoaderService = IDesignerLoaderService$instance;

export interface IDesignerSerializationManager$instance {
    readonly Context: ContextStack;
    readonly Properties: PropertyDescriptorCollection;
    AddSerializationProvider(provider: IDesignerSerializationProvider): void;
    CreateInstance(type_: Type, arguments: ICollection, name: string, addToContainer: boolean): any;
    GetInstance(name: string): any;
    GetName(value: any): string;
    GetSerializer(objectType: Type, serializerType: Type): any;
    GetService(serviceType: Type): any;
    GetType(typeName: string): Type;
    ReportError(errorInformation: any): void;
    SetName(instance: any, name: string): void;
}


export type IDesignerSerializationManager = IDesignerSerializationManager$instance;

export interface IDesignerSerializationProvider$instance {
    GetSerializer(manager: IDesignerSerializationManager, currentSerializer: any, objectType: Type, serializerType: Type): any;
}


export type IDesignerSerializationProvider = IDesignerSerializationProvider$instance;

export interface IDesignerSerializationService$instance {
    Deserialize(serializationData: any): ICollection;
    Serialize(objects: ICollection): any;
}


export type IDesignerSerializationService = IDesignerSerializationService$instance;

export interface INameCreationService$instance {
    CreateName(container: IContainer, dataType: Type): string;
    IsValidName(name: string): boolean;
    ValidateName(name: string): void;
}


export type INameCreationService = INameCreationService$instance;

export class MemberRelationship$instance {
    constructor(owner: any, member: MemberDescriptor);
    readonly IsEmpty: boolean;
    readonly Member: MemberDescriptor;
    readonly Owner: any;
    Equals(obj: any): boolean;
    Equals(other: MemberRelationship): boolean;
    GetHashCode(): int;
    static readonly Empty: MemberRelationship;
}


export interface __MemberRelationship$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<MemberRelationship>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MemberRelationship): boolean;
}

export type MemberRelationship = MemberRelationship$instance & __MemberRelationship$views;


export abstract class ComponentSerializationService$instance {
    abstract CreateStore(): SerializationStore;
    abstract Deserialize(store: SerializationStore): ICollection;
    abstract Deserialize(store: SerializationStore, container: IContainer): ICollection;
    DeserializeTo(store: SerializationStore, container: IContainer, validateRecycledTypes: boolean, applyDefaults: boolean): void;
    DeserializeTo(store: SerializationStore, container: IContainer): void;
    DeserializeTo(store: SerializationStore, container: IContainer, validateRecycledTypes: boolean): void;
    abstract LoadStore(stream: Stream): SerializationStore;
    abstract Serialize(store: SerializationStore, value: any): void;
    abstract SerializeAbsolute(store: SerializationStore, value: any): void;
    abstract SerializeMember(store: SerializationStore, owningObject: any, member: MemberDescriptor): void;
    abstract SerializeMemberAbsolute(store: SerializationStore, owningObject: any, member: MemberDescriptor): void;
}


export type ComponentSerializationService = ComponentSerializationService$instance;

export class ContextStack$instance {
    constructor();
    readonly Current: any;
    Append(context: any): void;
    get_Item(level: int): any;
    get_Item(type_: Type): any;
    Pop(): any;
    Push(context: any): void;
}


export type ContextStack = ContextStack$instance;

export class DefaultSerializationProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(providerType: Type);
    constructor(providerTypeName: string);
    readonly ProviderTypeName: string;
}


export type DefaultSerializationProviderAttribute = DefaultSerializationProviderAttribute$instance;

export abstract class DesignerLoader$instance {
    readonly Loading: boolean;
    abstract BeginLoad(host: IDesignerLoaderHost): void;
    abstract Dispose(): void;
    Flush(): void;
}


export type DesignerLoader = DesignerLoader$instance;

export class DesignerSerializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(serializerType: Type, baseSerializerType: Type);
    constructor(serializerTypeName: string, baseSerializerType: Type);
    constructor(serializerTypeName: string, baseSerializerTypeName: string);
    readonly SerializerBaseTypeName: string;
    readonly SerializerTypeName: string;
    readonly TypeId: any;
}


export type DesignerSerializerAttribute = DesignerSerializerAttribute$instance;

export class InstanceDescriptor$instance {
    constructor(member: MemberInfo, arguments: ICollection);
    constructor(member: MemberInfo, arguments: ICollection, isComplete: boolean);
    readonly Arguments: ICollection;
    readonly IsComplete: boolean;
    readonly MemberInfo: MemberInfo;
    Invoke(): any;
}


export type InstanceDescriptor = InstanceDescriptor$instance;

export abstract class MemberRelationshipService$instance {
    get_Item(source: MemberRelationship): MemberRelationship;
    get_Item(sourceOwner: any, sourceMember: MemberDescriptor): MemberRelationship;
    set_Item(source: MemberRelationship, value: MemberRelationship): void;
    set_Item(sourceOwner: any, sourceMember: MemberDescriptor, value: MemberRelationship): void;
    abstract SupportsRelationship(source: MemberRelationship, relationship: MemberRelationship): boolean;
}


export type MemberRelationshipService = MemberRelationshipService$instance;

export class ResolveNameEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(name: string);
    readonly Name: string;
    Value: any;
}


export type ResolveNameEventArgs = ResolveNameEventArgs$instance;

export class ResolveNameEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: ResolveNameEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: ResolveNameEventArgs): void;
}


export interface __ResolveNameEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ResolveNameEventHandler = ResolveNameEventHandler$instance & __ResolveNameEventHandler$views;


export class RootDesignerSerializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(serializerType: Type, baseSerializerType: Type, reloadable: boolean);
    constructor(serializerTypeName: string, baseSerializerType: Type, reloadable: boolean);
    constructor(serializerTypeName: string, baseSerializerTypeName: string, reloadable: boolean);
    readonly Reloadable: boolean;
    readonly SerializerBaseTypeName: string;
    readonly SerializerTypeName: string;
    readonly TypeId: any;
}


export type RootDesignerSerializerAttribute = RootDesignerSerializerAttribute$instance;

export abstract class SerializationStore$instance {
    readonly Errors: ICollection;
    abstract Close(): void;
    abstract Save(stream: Stream): void;
}


export interface __SerializationStore$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SerializationStore = SerializationStore$instance & __SerializationStore$views;


