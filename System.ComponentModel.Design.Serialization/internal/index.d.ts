// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel.Design.Serialization
// Assembly: System.ComponentModel.Primitives, System.ComponentModel.TypeConverter

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection } from "../../System.Collections/internal/index.js";
import type { DesignerTransaction, DesignerTransactionCloseEventHandler, IDesigner, ServiceCreatorCallback } from "../../System.ComponentModel.Design/internal/index.js";
import type { IComponent, IContainer, MemberDescriptor, PropertyDescriptorCollection } from "../../System.ComponentModel/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MemberInfo, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Attribute, Boolean as ClrBoolean, Delegate, EventArgs, EventHandler, IAsyncResult, ICloneable, IDisposable, IEquatable_1, Int32, IntPtr, MulticastDelegate, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDesignerLoaderHost$instance {
    readonly Loading: boolean;
    readonly InTransaction: boolean;
    readonly Container: IContainer;
    readonly RootComponent: IComponent;
    readonly RootComponentClassName: string;
    readonly TransactionDescription: string;
    AddService(serviceType: Type, callback: ServiceCreatorCallback, promote: boolean): void;
    AddService(serviceType: Type, callback: ServiceCreatorCallback): void;
    AddService(serviceType: Type, serviceInstance: any, promote: boolean): void;
    AddService(serviceType: Type, serviceInstance: any): void;
    CreateComponent(componentClass: Type, name: string): IComponent;
    CreateComponent(componentClass: Type): IComponent;
    CreateTransaction(): DesignerTransaction;
    CreateTransaction(description: string): DesignerTransaction;
    DestroyComponent(component: IComponent): void;
    EndLoad(baseClassName: string, successful: boolean, errorCollection: ICollection): void;
    GetDesigner(component: IComponent): IDesigner;
    GetService(serviceType: Type): any;
    GetType(typeName: string): Type;
    Reload(): void;
    RemoveService(serviceType: Type, promote: boolean): void;
    RemoveService(serviceType: Type): void;
}


export type IDesignerLoaderHost = IDesignerLoaderHost$instance;

export interface IDesignerLoaderHost2$instance {
    IgnoreErrorsDuringReload: boolean;
    CanReloadWithErrors: boolean;
    readonly Loading: boolean;
    readonly InTransaction: boolean;
    readonly Container: IContainer;
    readonly RootComponent: IComponent;
    readonly RootComponentClassName: string;
    readonly TransactionDescription: string;
    AddService(serviceType: Type, callback: ServiceCreatorCallback, promote: boolean): void;
    AddService(serviceType: Type, callback: ServiceCreatorCallback): void;
    AddService(serviceType: Type, serviceInstance: any, promote: boolean): void;
    AddService(serviceType: Type, serviceInstance: any): void;
    CreateComponent(componentClass: Type, name: string): IComponent;
    CreateComponent(componentClass: Type): IComponent;
    CreateTransaction(): DesignerTransaction;
    CreateTransaction(description: string): DesignerTransaction;
    DestroyComponent(component: IComponent): void;
    EndLoad(baseClassName: string, successful: boolean, errorCollection: ICollection): void;
    GetDesigner(component: IComponent): IDesigner;
    GetService(serviceType: Type): any;
    GetType(typeName: string): Type;
    Reload(): void;
    RemoveService(serviceType: Type, promote: boolean): void;
    RemoveService(serviceType: Type): void;
}


export type IDesignerLoaderHost2 = IDesignerLoaderHost2$instance;

export interface IDesignerLoaderService$instance {
    AddLoadDependency(): void;
    DependentLoadComplete(successful: boolean, errorCollection: ICollection): void;
    Reload(): boolean;
}


export type IDesignerLoaderService = IDesignerLoaderService$instance;

export interface IDesignerSerializationManager$instance {
    readonly Context: ContextStack;
    readonly Properties: PropertyDescriptorCollection;
    AddSerializationProvider(provider: IDesignerSerializationProvider): void;
    CreateInstance(type_: Type, arguments: ICollection, name: string, addToContainer: boolean): any;
    GetInstance(name: string): any;
    GetName(value: any): string;
    GetSerializer(objectType: Type, serializerType: Type): any;
    GetService(serviceType: Type): any;
    GetType(typeName: string): Type;
    ReportError(errorInformation: any): void;
    SetName(instance: any, name: string): void;
}


export type IDesignerSerializationManager = IDesignerSerializationManager$instance;

export interface IDesignerSerializationProvider$instance {
    GetSerializer(manager: IDesignerSerializationManager, currentSerializer: any, objectType: Type, serializerType: Type): any;
}


export type IDesignerSerializationProvider = IDesignerSerializationProvider$instance;

export interface IDesignerSerializationService$instance {
    Deserialize(serializationData: any): ICollection;
    Serialize(objects: ICollection): any;
}


export type IDesignerSerializationService = IDesignerSerializationService$instance;

export interface INameCreationService$instance {
    CreateName(container: IContainer, dataType: Type): string;
    IsValidName(name: string): boolean;
    ValidateName(name: string): void;
}


export type INameCreationService = INameCreationService$instance;

export class MemberRelationship$instance {
    constructor(owner: any, member: MemberDescriptor);
    readonly isEmpty: boolean;
    readonly member: MemberDescriptor;
    readonly owner: any;
    equals(obj: any): boolean;
    equals(other: MemberRelationship): boolean;
    getHashCode(): int;
    static readonly empty: MemberRelationship;
}


export interface __MemberRelationship$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<MemberRelationship>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MemberRelationship): boolean;
}

export type MemberRelationship = MemberRelationship$instance & __MemberRelationship$views;


export abstract class ComponentSerializationService$instance {
    abstract createStore(): SerializationStore;
    abstract deserialize(store: SerializationStore): ICollection;
    abstract deserialize(store: SerializationStore, container: IContainer): ICollection;
    deserializeTo(store: SerializationStore, container: IContainer, validateRecycledTypes: boolean, applyDefaults: boolean): void;
    deserializeTo(store: SerializationStore, container: IContainer): void;
    deserializeTo(store: SerializationStore, container: IContainer, validateRecycledTypes: boolean): void;
    abstract loadStore(stream: Stream): SerializationStore;
    abstract serialize(store: SerializationStore, value: any): void;
    abstract serializeAbsolute(store: SerializationStore, value: any): void;
    abstract serializeMember(store: SerializationStore, owningObject: any, member: MemberDescriptor): void;
    abstract serializeMemberAbsolute(store: SerializationStore, owningObject: any, member: MemberDescriptor): void;
}


export type ComponentSerializationService = ComponentSerializationService$instance;

export class ContextStack$instance {
    constructor();
    readonly current: any;
    append(context: any): void;
    get_Item(level: int): any;
    get_Item(type_: Type): any;
    pop(): any;
    push(context: any): void;
}


export type ContextStack = ContextStack$instance;

export class DefaultSerializationProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(providerType: Type);
    constructor(providerTypeName: string);
    readonly providerTypeName: string;
}


export type DefaultSerializationProviderAttribute = DefaultSerializationProviderAttribute$instance;

export abstract class DesignerLoader$instance {
    readonly loading: boolean;
    abstract beginLoad(host: IDesignerLoaderHost): void;
    abstract dispose(): void;
    flush(): void;
}


export type DesignerLoader = DesignerLoader$instance;

export class DesignerSerializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(serializerType: Type, baseSerializerType: Type);
    constructor(serializerTypeName: string, baseSerializerType: Type);
    constructor(serializerTypeName: string, baseSerializerTypeName: string);
    readonly serializerBaseTypeName: string;
    readonly serializerTypeName: string;
    readonly typeId: any;
}


export type DesignerSerializerAttribute = DesignerSerializerAttribute$instance;

export class InstanceDescriptor$instance {
    constructor(member: MemberInfo, arguments: ICollection);
    constructor(member: MemberInfo, arguments: ICollection, isComplete: boolean);
    readonly arguments: ICollection;
    readonly isComplete: boolean;
    readonly memberInfo: MemberInfo;
    invoke(): any;
}


export type InstanceDescriptor = InstanceDescriptor$instance;

export abstract class MemberRelationshipService$instance {
    get_Item(source: MemberRelationship): MemberRelationship;
    get_Item(sourceOwner: any, sourceMember: MemberDescriptor): MemberRelationship;
    set_Item(source: MemberRelationship, value: MemberRelationship): void;
    set_Item(sourceOwner: any, sourceMember: MemberDescriptor, value: MemberRelationship): void;
    abstract supportsRelationship(source: MemberRelationship, relationship: MemberRelationship): boolean;
}


export type MemberRelationshipService = MemberRelationshipService$instance;

export class ResolveNameEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(name: string);
    readonly name: string;
    value: any;
}


export type ResolveNameEventArgs = ResolveNameEventArgs$instance;

export class ResolveNameEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: ResolveNameEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: ResolveNameEventArgs): void;
}


export interface __ResolveNameEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ResolveNameEventHandler = ResolveNameEventHandler$instance & __ResolveNameEventHandler$views;


export class RootDesignerSerializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(serializerType: Type, baseSerializerType: Type, reloadable: boolean);
    constructor(serializerTypeName: string, baseSerializerType: Type, reloadable: boolean);
    constructor(serializerTypeName: string, baseSerializerTypeName: string, reloadable: boolean);
    readonly reloadable: boolean;
    readonly serializerBaseTypeName: string;
    readonly serializerTypeName: string;
    readonly typeId: any;
}


export type RootDesignerSerializerAttribute = RootDesignerSerializerAttribute$instance;

export abstract class SerializationStore$instance {
    readonly errors: ICollection;
    abstract close(): void;
    abstract save(stream: Stream): void;
}


export interface __SerializationStore$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SerializationStore = SerializationStore$instance & __SerializationStore$views;


