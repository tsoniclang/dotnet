// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel.Design.Serialization
// Assembly: System.ComponentModel.Primitives, System.ComponentModel.TypeConverter

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Design_Internal from "../../System.ComponentModel.Design/internal/index.js";
import type { DesignerTransaction, DesignerTransactionCloseEventHandler, IDesigner, IDesignerHost, IServiceContainer, ServiceCreatorCallback } from "../../System.ComponentModel.Design/internal/index.js";
import type { IComponent, IContainer, MemberDescriptor, PropertyDescriptorCollection } from "../../System.ComponentModel/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MemberInfo, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Attribute, Boolean as ClrBoolean, Delegate, EventArgs, EventHandler, IAsyncResult, ICloneable, IDisposable, IEquatable_1, Int32, IntPtr, IServiceProvider, MulticastDelegate, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDesignerLoaderHost$instance extends IDesignerHost, IServiceContainer, IServiceProvider {
    readonly loading: boolean;
    readonly inTransaction: boolean;
    readonly container: IContainer;
    readonly rootComponent: IComponent;
    readonly rootComponentClassName: string;
    readonly transactionDescription: string;
    addService4(serviceType: Type, callback: ServiceCreatorCallback, promote: boolean): void;
    addService4(serviceType: Type, callback: ServiceCreatorCallback): void;
    addService4(serviceType: Type, serviceInstance: unknown, promote: boolean): void;
    addService4(serviceType: Type, serviceInstance: unknown): void;
    createComponent2(componentClass: Type, name: string): IComponent;
    createComponent2(componentClass: Type): IComponent;
    createTransaction(): DesignerTransaction;
    createTransaction(description: string): DesignerTransaction;
    destroyComponent(component: IComponent): void;
    endLoad(baseClassName: string, successful: boolean, errorCollection: ICollection): void;
    getDesigner(component: IComponent): IDesigner;
    getService(serviceType: Type): unknown;
    getType(typeName: string): Type;
    reload(): void;
    removeService2(serviceType: Type, promote: boolean): void;
    removeService2(serviceType: Type): void;
}


export type IDesignerLoaderHost = IDesignerLoaderHost$instance;

export interface IDesignerLoaderHost2$instance extends IDesignerLoaderHost, IDesignerHost, IServiceContainer, IServiceProvider {
    ignoreErrorsDuringReload: boolean;
    canReloadWithErrors: boolean;
    readonly loading: boolean;
    readonly inTransaction: boolean;
    readonly container: IContainer;
    readonly rootComponent: IComponent;
    readonly rootComponentClassName: string;
    readonly transactionDescription: string;
    addService4(serviceType: Type, callback: ServiceCreatorCallback, promote: boolean): void;
    addService4(serviceType: Type, callback: ServiceCreatorCallback): void;
    addService4(serviceType: Type, serviceInstance: unknown, promote: boolean): void;
    addService4(serviceType: Type, serviceInstance: unknown): void;
    createComponent2(componentClass: Type, name: string): IComponent;
    createComponent2(componentClass: Type): IComponent;
    createTransaction(): DesignerTransaction;
    createTransaction(description: string): DesignerTransaction;
    destroyComponent(component: IComponent): void;
    endLoad(baseClassName: string, successful: boolean, errorCollection: ICollection): void;
    getDesigner(component: IComponent): IDesigner;
    getService(serviceType: Type): unknown;
    getType(typeName: string): Type;
    reload(): void;
    removeService2(serviceType: Type, promote: boolean): void;
    removeService2(serviceType: Type): void;
}


export type IDesignerLoaderHost2 = IDesignerLoaderHost2$instance;

export interface IDesignerLoaderService$instance {
    addLoadDependency(): void;
    dependentLoadComplete(successful: boolean, errorCollection: ICollection): void;
    reload(): boolean;
}


export type IDesignerLoaderService = IDesignerLoaderService$instance;

export interface IDesignerSerializationManager$instance extends IServiceProvider {
    readonly context: ContextStack;
    readonly properties: PropertyDescriptorCollection;
    addSerializationProvider(provider: IDesignerSerializationProvider): void;
    createInstance(type_: Type, arguments: ICollection, name: string, addToContainer: boolean): unknown;
    getInstance(name: string): unknown;
    getName(value: unknown): string;
    getSerializer(objectType: Type, serializerType: Type): unknown;
    getService(serviceType: Type): unknown;
    getType(typeName: string): Type;
    reportError(errorInformation: unknown): void;
    setName(instance: unknown, name: string): void;
}


export interface IDesignerSerializationManager$instance extends System_Internal.IServiceProvider$instance {}

export type IDesignerSerializationManager = IDesignerSerializationManager$instance;

export interface IDesignerSerializationProvider$instance {
    getSerializer(manager: IDesignerSerializationManager, currentSerializer: unknown, objectType: Type, serializerType: Type): unknown;
}


export type IDesignerSerializationProvider = IDesignerSerializationProvider$instance;

export interface IDesignerSerializationService$instance {
    deserialize(serializationData: unknown): ICollection;
    serialize(objects: ICollection): unknown;
}


export type IDesignerSerializationService = IDesignerSerializationService$instance;

export interface INameCreationService$instance {
    createName(container: IContainer, dataType: Type): string;
    isValidName(name: string): boolean;
    validateName(name: string): void;
}


export type INameCreationService = INameCreationService$instance;

export class MemberRelationship$instance {
    constructor(owner: unknown, member: MemberDescriptor);
    readonly isEmpty: boolean;
    readonly member: MemberDescriptor;
    readonly owner: unknown;
    equals(obj: unknown): boolean;
    equals(other: MemberRelationship): boolean;
    getHashCode(): int;
    static readonly empty: MemberRelationship;
}


export interface __MemberRelationship$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MemberRelationship>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MemberRelationship): boolean;
}

export type MemberRelationship = MemberRelationship$instance & __MemberRelationship$views;


export abstract class ComponentSerializationService$instance {
    abstract createStore(): SerializationStore;
    abstract deserialize(store: SerializationStore): ICollection;
    abstract deserialize(store: SerializationStore, container: IContainer): ICollection;
    deserializeTo(store: SerializationStore, container: IContainer, validateRecycledTypes: boolean, applyDefaults: boolean): void;
    deserializeTo(store: SerializationStore, container: IContainer): void;
    deserializeTo(store: SerializationStore, container: IContainer, validateRecycledTypes: boolean): void;
    abstract loadStore(stream: Stream): SerializationStore;
    abstract serialize(store: SerializationStore, value: unknown): void;
    abstract serializeAbsolute(store: SerializationStore, value: unknown): void;
    abstract serializeMember(store: SerializationStore, owningObject: unknown, member: MemberDescriptor): void;
    abstract serializeMemberAbsolute(store: SerializationStore, owningObject: unknown, member: MemberDescriptor): void;
}


export type ComponentSerializationService = ComponentSerializationService$instance;

export class ContextStack$instance {
    constructor();
    readonly current: unknown;
    append(context: unknown): void;
    getItem(level: int): unknown;
    getItem(type_: Type): unknown;
    pop(): unknown;
    push(context: unknown): void;
}


export type ContextStack = ContextStack$instance;

export class DefaultSerializationProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(providerType: Type);
    constructor(providerTypeName: string);
    readonly providerTypeName: string;
}


export type DefaultSerializationProviderAttribute = DefaultSerializationProviderAttribute$instance;

export abstract class DesignerLoader$instance {
    readonly loading: boolean;
    abstract beginLoad(host: IDesignerLoaderHost): void;
    abstract dispose(): void;
    flush(): void;
}


export type DesignerLoader = DesignerLoader$instance;

export class DesignerSerializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(serializerType: Type, baseSerializerType: Type);
    constructor(serializerTypeName: string, baseSerializerType: Type);
    constructor(serializerTypeName: string, baseSerializerTypeName: string);
    readonly serializerBaseTypeName: string;
    readonly serializerTypeName: string;
    readonly typeId: unknown;
}


export type DesignerSerializerAttribute = DesignerSerializerAttribute$instance;

export class InstanceDescriptor$instance {
    constructor(member: MemberInfo, arguments: ICollection);
    constructor(member: MemberInfo, arguments: ICollection, isComplete: boolean);
    readonly arguments: ICollection;
    readonly isComplete: boolean;
    readonly memberInfo: MemberInfo;
    invoke(): unknown;
}


export type InstanceDescriptor = InstanceDescriptor$instance;

export abstract class MemberRelationshipService$instance {
    getItem(source: MemberRelationship): MemberRelationship;
    getItem(sourceOwner: unknown, sourceMember: MemberDescriptor): MemberRelationship;
    setItem(source: MemberRelationship, value: MemberRelationship): void;
    setItem(sourceOwner: unknown, sourceMember: MemberDescriptor, value: MemberRelationship): void;
    abstract supportsRelationship(source: MemberRelationship, relationship: MemberRelationship): boolean;
}


export type MemberRelationshipService = MemberRelationshipService$instance;

export class ResolveNameEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(name: string);
    readonly name: string;
    value: unknown;
}


export type ResolveNameEventArgs = ResolveNameEventArgs$instance;

export class ResolveNameEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: ResolveNameEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: ResolveNameEventArgs): void;
}


export interface __ResolveNameEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ResolveNameEventHandler = ResolveNameEventHandler$instance & __ResolveNameEventHandler$views;


export class RootDesignerSerializerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(serializerType: Type, baseSerializerType: Type, reloadable: boolean);
    constructor(serializerTypeName: string, baseSerializerType: Type, reloadable: boolean);
    constructor(serializerTypeName: string, baseSerializerTypeName: string, reloadable: boolean);
    readonly reloadable: boolean;
    readonly serializerBaseTypeName: string;
    readonly serializerTypeName: string;
    readonly typeId: unknown;
}


export type RootDesignerSerializerAttribute = RootDesignerSerializerAttribute$instance;

export abstract class SerializationStore$instance {
    readonly errors: ICollection;
    abstract close(): void;
    abstract save(stream: Stream): void;
}


export interface __SerializationStore$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SerializationStore$instance extends System_Internal.IDisposable$instance {}

export type SerializationStore = SerializationStore$instance & __SerializationStore$views;


