// Generated by tsbindgen - Architecture
// Namespace: System.Drawing
// Assembly: System.ComponentModel.TypeConverter, System.Drawing.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection, IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, PropertyDescriptorCollection, TypeConverter, TypeConverter_StandardValuesCollection } from "../../System.ComponentModel/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Vector2, Vector4 } from "../../System.Numerics/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Enum, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum KnownColor {
    ActiveBorder = 1,
    ActiveCaption = 2,
    ActiveCaptionText = 3,
    AppWorkspace = 4,
    Control = 5,
    ControlDark = 6,
    ControlDarkDark = 7,
    ControlLight = 8,
    ControlLightLight = 9,
    ControlText = 10,
    Desktop = 11,
    GrayText = 12,
    Highlight = 13,
    HighlightText = 14,
    HotTrack = 15,
    InactiveBorder = 16,
    InactiveCaption = 17,
    InactiveCaptionText = 18,
    Info = 19,
    InfoText = 20,
    Menu = 21,
    MenuText = 22,
    ScrollBar = 23,
    Window = 24,
    WindowFrame = 25,
    WindowText = 26,
    Transparent = 27,
    AliceBlue = 28,
    AntiqueWhite = 29,
    Aqua = 30,
    Aquamarine = 31,
    Azure = 32,
    Beige = 33,
    Bisque = 34,
    Black = 35,
    BlanchedAlmond = 36,
    Blue = 37,
    BlueViolet = 38,
    Brown = 39,
    BurlyWood = 40,
    CadetBlue = 41,
    Chartreuse = 42,
    Chocolate = 43,
    Coral = 44,
    CornflowerBlue = 45,
    Cornsilk = 46,
    Crimson = 47,
    Cyan = 48,
    DarkBlue = 49,
    DarkCyan = 50,
    DarkGoldenrod = 51,
    DarkGray = 52,
    DarkGreen = 53,
    DarkKhaki = 54,
    DarkMagenta = 55,
    DarkOliveGreen = 56,
    DarkOrange = 57,
    DarkOrchid = 58,
    DarkRed = 59,
    DarkSalmon = 60,
    DarkSeaGreen = 61,
    DarkSlateBlue = 62,
    DarkSlateGray = 63,
    DarkTurquoise = 64,
    DarkViolet = 65,
    DeepPink = 66,
    DeepSkyBlue = 67,
    DimGray = 68,
    DodgerBlue = 69,
    Firebrick = 70,
    FloralWhite = 71,
    ForestGreen = 72,
    Fuchsia = 73,
    Gainsboro = 74,
    GhostWhite = 75,
    Gold = 76,
    Goldenrod = 77,
    Gray = 78,
    Green = 79,
    GreenYellow = 80,
    Honeydew = 81,
    HotPink = 82,
    IndianRed = 83,
    Indigo = 84,
    Ivory = 85,
    Khaki = 86,
    Lavender = 87,
    LavenderBlush = 88,
    LawnGreen = 89,
    LemonChiffon = 90,
    LightBlue = 91,
    LightCoral = 92,
    LightCyan = 93,
    LightGoldenrodYellow = 94,
    LightGray = 95,
    LightGreen = 96,
    LightPink = 97,
    LightSalmon = 98,
    LightSeaGreen = 99,
    LightSkyBlue = 100,
    LightSlateGray = 101,
    LightSteelBlue = 102,
    LightYellow = 103,
    Lime = 104,
    LimeGreen = 105,
    Linen = 106,
    Magenta = 107,
    Maroon = 108,
    MediumAquamarine = 109,
    MediumBlue = 110,
    MediumOrchid = 111,
    MediumPurple = 112,
    MediumSeaGreen = 113,
    MediumSlateBlue = 114,
    MediumSpringGreen = 115,
    MediumTurquoise = 116,
    MediumVioletRed = 117,
    MidnightBlue = 118,
    MintCream = 119,
    MistyRose = 120,
    Moccasin = 121,
    NavajoWhite = 122,
    Navy = 123,
    OldLace = 124,
    Olive = 125,
    OliveDrab = 126,
    Orange = 127,
    OrangeRed = 128,
    Orchid = 129,
    PaleGoldenrod = 130,
    PaleGreen = 131,
    PaleTurquoise = 132,
    PaleVioletRed = 133,
    PapayaWhip = 134,
    PeachPuff = 135,
    Peru = 136,
    Pink = 137,
    Plum = 138,
    PowderBlue = 139,
    Purple = 140,
    Red = 141,
    RosyBrown = 142,
    RoyalBlue = 143,
    SaddleBrown = 144,
    Salmon = 145,
    SandyBrown = 146,
    SeaGreen = 147,
    SeaShell = 148,
    Sienna = 149,
    Silver = 150,
    SkyBlue = 151,
    SlateBlue = 152,
    SlateGray = 153,
    Snow = 154,
    SpringGreen = 155,
    SteelBlue = 156,
    Tan = 157,
    Teal = 158,
    Thistle = 159,
    Tomato = 160,
    Turquoise = 161,
    Violet = 162,
    Wheat = 163,
    White = 164,
    WhiteSmoke = 165,
    Yellow = 166,
    YellowGreen = 167,
    ButtonFace = 168,
    ButtonHighlight = 169,
    ButtonShadow = 170,
    GradientActiveCaption = 171,
    GradientInactiveCaption = 172,
    MenuBar = 173,
    MenuHighlight = 174,
    RebeccaPurple = 175
}


export class Color$instance {
    readonly A: byte;
    readonly B: byte;
    readonly G: byte;
    readonly IsEmpty: boolean;
    readonly IsKnownColor: boolean;
    readonly IsNamedColor: boolean;
    readonly IsSystemColor: boolean;
    readonly Name: string;
    readonly R: byte;
    Equals(obj: unknown): boolean;
    Equals(other: Color): boolean;
    GetBrightness(): float;
    GetHashCode(): int;
    GetHue(): float;
    GetSaturation(): float;
    ToArgb(): int;
    ToKnownColor(): KnownColor;
    ToString(): string;
    static readonly Empty: Color;
    static readonly Transparent: Color;
    static readonly AliceBlue: Color;
    static readonly AntiqueWhite: Color;
    static readonly Aqua: Color;
    static readonly Aquamarine: Color;
    static readonly Azure: Color;
    static readonly Beige: Color;
    static readonly Bisque: Color;
    static readonly Black: Color;
    static readonly BlanchedAlmond: Color;
    static readonly Blue: Color;
    static readonly BlueViolet: Color;
    static readonly Brown: Color;
    static readonly BurlyWood: Color;
    static readonly CadetBlue: Color;
    static readonly Chartreuse: Color;
    static readonly Chocolate: Color;
    static readonly Coral: Color;
    static readonly CornflowerBlue: Color;
    static readonly Cornsilk: Color;
    static readonly Crimson: Color;
    static readonly Cyan: Color;
    static readonly DarkBlue: Color;
    static readonly DarkCyan: Color;
    static readonly DarkGoldenrod: Color;
    static readonly DarkGray: Color;
    static readonly DarkGreen: Color;
    static readonly DarkKhaki: Color;
    static readonly DarkMagenta: Color;
    static readonly DarkOliveGreen: Color;
    static readonly DarkOrange: Color;
    static readonly DarkOrchid: Color;
    static readonly DarkRed: Color;
    static readonly DarkSalmon: Color;
    static readonly DarkSeaGreen: Color;
    static readonly DarkSlateBlue: Color;
    static readonly DarkSlateGray: Color;
    static readonly DarkTurquoise: Color;
    static readonly DarkViolet: Color;
    static readonly DeepPink: Color;
    static readonly DeepSkyBlue: Color;
    static readonly DimGray: Color;
    static readonly DodgerBlue: Color;
    static readonly Firebrick: Color;
    static readonly FloralWhite: Color;
    static readonly ForestGreen: Color;
    static readonly Fuchsia: Color;
    static readonly Gainsboro: Color;
    static readonly GhostWhite: Color;
    static readonly Gold: Color;
    static readonly Goldenrod: Color;
    static readonly Gray: Color;
    static readonly Green: Color;
    static readonly GreenYellow: Color;
    static readonly Honeydew: Color;
    static readonly HotPink: Color;
    static readonly IndianRed: Color;
    static readonly Indigo: Color;
    static readonly Ivory: Color;
    static readonly Khaki: Color;
    static readonly Lavender: Color;
    static readonly LavenderBlush: Color;
    static readonly LawnGreen: Color;
    static readonly LemonChiffon: Color;
    static readonly LightBlue: Color;
    static readonly LightCoral: Color;
    static readonly LightCyan: Color;
    static readonly LightGoldenrodYellow: Color;
    static readonly LightGreen: Color;
    static readonly LightGray: Color;
    static readonly LightPink: Color;
    static readonly LightSalmon: Color;
    static readonly LightSeaGreen: Color;
    static readonly LightSkyBlue: Color;
    static readonly LightSlateGray: Color;
    static readonly LightSteelBlue: Color;
    static readonly LightYellow: Color;
    static readonly Lime: Color;
    static readonly LimeGreen: Color;
    static readonly Linen: Color;
    static readonly Magenta: Color;
    static readonly Maroon: Color;
    static readonly MediumAquamarine: Color;
    static readonly MediumBlue: Color;
    static readonly MediumOrchid: Color;
    static readonly MediumPurple: Color;
    static readonly MediumSeaGreen: Color;
    static readonly MediumSlateBlue: Color;
    static readonly MediumSpringGreen: Color;
    static readonly MediumTurquoise: Color;
    static readonly MediumVioletRed: Color;
    static readonly MidnightBlue: Color;
    static readonly MintCream: Color;
    static readonly MistyRose: Color;
    static readonly Moccasin: Color;
    static readonly NavajoWhite: Color;
    static readonly Navy: Color;
    static readonly OldLace: Color;
    static readonly Olive: Color;
    static readonly OliveDrab: Color;
    static readonly Orange: Color;
    static readonly OrangeRed: Color;
    static readonly Orchid: Color;
    static readonly PaleGoldenrod: Color;
    static readonly PaleGreen: Color;
    static readonly PaleTurquoise: Color;
    static readonly PaleVioletRed: Color;
    static readonly PapayaWhip: Color;
    static readonly PeachPuff: Color;
    static readonly Peru: Color;
    static readonly Pink: Color;
    static readonly Plum: Color;
    static readonly PowderBlue: Color;
    static readonly Purple: Color;
    static readonly RebeccaPurple: Color;
    static readonly Red: Color;
    static readonly RosyBrown: Color;
    static readonly RoyalBlue: Color;
    static readonly SaddleBrown: Color;
    static readonly Salmon: Color;
    static readonly SandyBrown: Color;
    static readonly SeaGreen: Color;
    static readonly SeaShell: Color;
    static readonly Sienna: Color;
    static readonly Silver: Color;
    static readonly SkyBlue: Color;
    static readonly SlateBlue: Color;
    static readonly SlateGray: Color;
    static readonly Snow: Color;
    static readonly SpringGreen: Color;
    static readonly SteelBlue: Color;
    static readonly Tan: Color;
    static readonly Teal: Color;
    static readonly Thistle: Color;
    static readonly Tomato: Color;
    static readonly Turquoise: Color;
    static readonly Violet: Color;
    static readonly Wheat: Color;
    static readonly White: Color;
    static readonly WhiteSmoke: Color;
    static readonly Yellow: Color;
    static readonly YellowGreen: Color;
    static FromArgb(alpha: int, baseColor: Color): Color;
    static FromArgb(alpha: int, red: int, green: int, blue: int): Color;
    static FromArgb(red: int, green: int, blue: int): Color;
    static FromArgb(argb: int): Color;
    static FromKnownColor(color: KnownColor): Color;
    static FromName(name: string): Color;
}


export interface __Color$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Color>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Color): boolean;
}

export type Color = Color$instance & __Color$views;


export class Point$instance {
    constructor(x: int, y: int);
    constructor(sz: Size);
    constructor(dw: int);
    readonly IsEmpty: boolean;
    X: int;
    Y: int;
    Equals(obj: unknown): boolean;
    Equals(other: Point): boolean;
    GetHashCode(): int;
    Offset(dx: int, dy: int): void;
    Offset(p: Point): void;
    ToString(): string;
    static readonly Empty: Point;
    static Add(pt: Point, sz: Size): Point;
    static Ceiling(value: PointF): Point;
    static Round(value: PointF): Point;
    static Subtract(pt: Point, sz: Size): Point;
    static Truncate(value: PointF): Point;
}


export interface __Point$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Point>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Point): boolean;
}

export type Point = Point$instance & __Point$views;


export class PointF$instance {
    constructor(x: float, y: float);
    constructor(vector: Vector2);
    readonly IsEmpty: boolean;
    X: float;
    Y: float;
    Equals(obj: unknown): boolean;
    Equals(other: PointF): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToVector2(): Vector2;
    static readonly Empty: PointF;
    static Add(pt: PointF, sz: Size): PointF;
    static Add(pt: PointF, sz: SizeF): PointF;
    static Subtract(pt: PointF, sz: Size): PointF;
    static Subtract(pt: PointF, sz: SizeF): PointF;
}


export interface __PointF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PointF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PointF): boolean;
}

export type PointF = PointF$instance & __PointF$views;


export class Rectangle$instance {
    constructor(x: int, y: int, width: int, height: int);
    constructor(location: Point, size: Size);
    readonly Bottom: int;
    Height: int;
    readonly IsEmpty: boolean;
    readonly Left: int;
    Location: Point;
    readonly Right: int;
    Size: Size;
    readonly Top: int;
    Width: int;
    X: int;
    Y: int;
    Contains(x: int, y: int): boolean;
    Contains(pt: Point): boolean;
    Contains(rect: Rectangle): boolean;
    Equals(obj: unknown): boolean;
    Equals(other: Rectangle): boolean;
    GetHashCode(): int;
    Inflate(width: int, height: int): void;
    Inflate(size: Size): void;
    Intersect(rect: Rectangle): void;
    IntersectsWith(rect: Rectangle): boolean;
    Offset(pos: Point): void;
    Offset(x: int, y: int): void;
    ToString(): string;
    static readonly Empty: Rectangle;
    static Ceiling(value: RectangleF): Rectangle;
    static FromLTRB(left: int, top: int, right: int, bottom: int): Rectangle;
    static Inflate(rect: Rectangle, x: int, y: int): Rectangle;
    static Intersect(a: Rectangle, b: Rectangle): Rectangle;
    static Round(value: RectangleF): Rectangle;
    static Truncate(value: RectangleF): Rectangle;
    static Union(a: Rectangle, b: Rectangle): Rectangle;
}


export interface __Rectangle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Rectangle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rectangle): boolean;
}

export type Rectangle = Rectangle$instance & __Rectangle$views;


export class RectangleF$instance {
    constructor(x: float, y: float, width: float, height: float);
    constructor(location: PointF, size: SizeF);
    constructor(vector: Vector4);
    readonly Bottom: float;
    Height: float;
    readonly IsEmpty: boolean;
    readonly Left: float;
    Location: PointF;
    readonly Right: float;
    Size: SizeF;
    readonly Top: float;
    Width: float;
    X: float;
    Y: float;
    Contains(x: float, y: float): boolean;
    Contains(pt: PointF): boolean;
    Contains(rect: RectangleF): boolean;
    Equals(obj: unknown): boolean;
    Equals(other: RectangleF): boolean;
    GetHashCode(): int;
    Inflate(x: float, y: float): void;
    Inflate(size: SizeF): void;
    Intersect(rect: RectangleF): void;
    IntersectsWith(rect: RectangleF): boolean;
    Offset(pos: PointF): void;
    Offset(x: float, y: float): void;
    ToString(): string;
    ToVector4(): Vector4;
    static readonly Empty: RectangleF;
    static FromLTRB(left: float, top: float, right: float, bottom: float): RectangleF;
    static Inflate(rect: RectangleF, x: float, y: float): RectangleF;
    static Intersect(a: RectangleF, b: RectangleF): RectangleF;
    static Union(a: RectangleF, b: RectangleF): RectangleF;
}


export interface __RectangleF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RectangleF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RectangleF): boolean;
}

export type RectangleF = RectangleF$instance & __RectangleF$views;


export class Size$instance {
    constructor(pt: Point);
    constructor(width: int, height: int);
    Height: int;
    readonly IsEmpty: boolean;
    Width: int;
    Equals(obj: unknown): boolean;
    Equals(other: Size): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly Empty: Size;
    static Add(sz1: Size, sz2: Size): Size;
    static Ceiling(value: SizeF): Size;
    static Round(value: SizeF): Size;
    static Subtract(sz1: Size, sz2: Size): Size;
    static Truncate(value: SizeF): Size;
}


export interface __Size$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Size>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Size): boolean;
}

export type Size = Size$instance & __Size$views;


export class SizeF$instance {
    constructor(size: SizeF);
    constructor(pt: PointF);
    constructor(vector: Vector2);
    constructor(width: float, height: float);
    Height: float;
    readonly IsEmpty: boolean;
    Width: float;
    Equals(obj: unknown): boolean;
    Equals(other: SizeF): boolean;
    GetHashCode(): int;
    ToPointF(): PointF;
    ToSize(): Size;
    ToString(): string;
    ToVector2(): Vector2;
    static readonly Empty: SizeF;
    static Add(sz1: SizeF, sz2: SizeF): SizeF;
    static Subtract(sz1: SizeF, sz2: SizeF): SizeF;
}


export interface __SizeF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SizeF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SizeF): boolean;
}

export type SizeF = SizeF$instance & __SizeF$views;


export class ColorConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export type ColorConverter = ColorConverter$instance;

export class PointConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type PointConverter = PointConverter$instance;

export class RectangleConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type RectangleConverter = RectangleConverter$instance;

export class SizeConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type SizeConverter = SizeConverter$instance;

export class SizeFConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export type SizeFConverter = SizeFConverter$instance;

export abstract class ColorTranslator$instance {
    static FromHtml(htmlColor: string): Color;
    static FromOle(oleColor: int): Color;
    static FromWin32(win32Color: int): Color;
    static ToHtml(c: Color): string;
    static ToOle(c: Color): int;
    static ToWin32(c: Color): int;
}


export type ColorTranslator = ColorTranslator$instance;

export abstract class SystemColors$instance {
    static readonly ActiveBorder: Color;
    static readonly ActiveCaption: Color;
    static readonly ActiveCaptionText: Color;
    static readonly AppWorkspace: Color;
    static readonly ButtonFace: Color;
    static readonly ButtonHighlight: Color;
    static readonly ButtonShadow: Color;
    static readonly Control: Color;
    static readonly ControlDark: Color;
    static readonly ControlDarkDark: Color;
    static readonly ControlLight: Color;
    static readonly ControlLightLight: Color;
    static readonly ControlText: Color;
    static readonly Desktop: Color;
    static readonly GradientActiveCaption: Color;
    static readonly GradientInactiveCaption: Color;
    static readonly GrayText: Color;
    static readonly Highlight: Color;
    static readonly HighlightText: Color;
    static readonly HotTrack: Color;
    static readonly InactiveBorder: Color;
    static readonly InactiveCaption: Color;
    static readonly InactiveCaptionText: Color;
    static readonly Info: Color;
    static readonly InfoText: Color;
    static readonly Menu: Color;
    static readonly MenuBar: Color;
    static readonly MenuHighlight: Color;
    static readonly MenuText: Color;
    static readonly ScrollBar: Color;
    static readonly Window: Color;
    static readonly WindowFrame: Color;
    static readonly WindowText: Color;
    static UseAlternativeColorSet: boolean;
}


export type SystemColors = SystemColors$instance;

