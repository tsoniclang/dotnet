// Generated by tsbindgen - Architecture
// Namespace: System.Drawing
// Assembly: System.ComponentModel.TypeConverter, System.Drawing.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection, IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, PropertyDescriptorCollection, TypeConverter, TypeConverter_StandardValuesCollection } from "../../System.ComponentModel/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Vector2, Vector4 } from "../../System.Numerics/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Enum, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum KnownColor {
    activeBorder = 1,
    activeCaption = 2,
    activeCaptionText = 3,
    appWorkspace = 4,
    control = 5,
    controlDark = 6,
    controlDarkDark = 7,
    controlLight = 8,
    controlLightLight = 9,
    controlText = 10,
    desktop = 11,
    grayText = 12,
    highlight = 13,
    highlightText = 14,
    hotTrack = 15,
    inactiveBorder = 16,
    inactiveCaption = 17,
    inactiveCaptionText = 18,
    info = 19,
    infoText = 20,
    menu = 21,
    menuText = 22,
    scrollBar = 23,
    window = 24,
    windowFrame = 25,
    windowText = 26,
    transparent = 27,
    aliceBlue = 28,
    antiqueWhite = 29,
    aqua = 30,
    aquamarine = 31,
    azure = 32,
    beige = 33,
    bisque = 34,
    black = 35,
    blanchedAlmond = 36,
    blue = 37,
    blueViolet = 38,
    brown = 39,
    burlyWood = 40,
    cadetBlue = 41,
    chartreuse = 42,
    chocolate = 43,
    coral = 44,
    cornflowerBlue = 45,
    cornsilk = 46,
    crimson = 47,
    cyan = 48,
    darkBlue = 49,
    darkCyan = 50,
    darkGoldenrod = 51,
    darkGray = 52,
    darkGreen = 53,
    darkKhaki = 54,
    darkMagenta = 55,
    darkOliveGreen = 56,
    darkOrange = 57,
    darkOrchid = 58,
    darkRed = 59,
    darkSalmon = 60,
    darkSeaGreen = 61,
    darkSlateBlue = 62,
    darkSlateGray = 63,
    darkTurquoise = 64,
    darkViolet = 65,
    deepPink = 66,
    deepSkyBlue = 67,
    dimGray = 68,
    dodgerBlue = 69,
    firebrick = 70,
    floralWhite = 71,
    forestGreen = 72,
    fuchsia = 73,
    gainsboro = 74,
    ghostWhite = 75,
    gold = 76,
    goldenrod = 77,
    gray = 78,
    green = 79,
    greenYellow = 80,
    honeydew = 81,
    hotPink = 82,
    indianRed = 83,
    indigo = 84,
    ivory = 85,
    khaki = 86,
    lavender = 87,
    lavenderBlush = 88,
    lawnGreen = 89,
    lemonChiffon = 90,
    lightBlue = 91,
    lightCoral = 92,
    lightCyan = 93,
    lightGoldenrodYellow = 94,
    lightGray = 95,
    lightGreen = 96,
    lightPink = 97,
    lightSalmon = 98,
    lightSeaGreen = 99,
    lightSkyBlue = 100,
    lightSlateGray = 101,
    lightSteelBlue = 102,
    lightYellow = 103,
    lime = 104,
    limeGreen = 105,
    linen = 106,
    magenta = 107,
    maroon = 108,
    mediumAquamarine = 109,
    mediumBlue = 110,
    mediumOrchid = 111,
    mediumPurple = 112,
    mediumSeaGreen = 113,
    mediumSlateBlue = 114,
    mediumSpringGreen = 115,
    mediumTurquoise = 116,
    mediumVioletRed = 117,
    midnightBlue = 118,
    mintCream = 119,
    mistyRose = 120,
    moccasin = 121,
    navajoWhite = 122,
    navy = 123,
    oldLace = 124,
    olive = 125,
    oliveDrab = 126,
    orange = 127,
    orangeRed = 128,
    orchid = 129,
    paleGoldenrod = 130,
    paleGreen = 131,
    paleTurquoise = 132,
    paleVioletRed = 133,
    papayaWhip = 134,
    peachPuff = 135,
    peru = 136,
    pink = 137,
    plum = 138,
    powderBlue = 139,
    purple = 140,
    red = 141,
    rosyBrown = 142,
    royalBlue = 143,
    saddleBrown = 144,
    salmon = 145,
    sandyBrown = 146,
    seaGreen = 147,
    seaShell = 148,
    sienna = 149,
    silver = 150,
    skyBlue = 151,
    slateBlue = 152,
    slateGray = 153,
    snow = 154,
    springGreen = 155,
    steelBlue = 156,
    tan = 157,
    teal = 158,
    thistle = 159,
    tomato = 160,
    turquoise = 161,
    violet = 162,
    wheat = 163,
    white = 164,
    whiteSmoke = 165,
    yellow = 166,
    yellowGreen = 167,
    buttonFace = 168,
    buttonHighlight = 169,
    buttonShadow = 170,
    gradientActiveCaption = 171,
    gradientInactiveCaption = 172,
    menuBar = 173,
    menuHighlight = 174,
    rebeccaPurple = 175
}


export class Color$instance {
    readonly A: byte;
    readonly B: byte;
    readonly G: byte;
    readonly isEmpty: boolean;
    readonly isKnownColor: boolean;
    readonly isNamedColor: boolean;
    readonly isSystemColor: boolean;
    readonly name: string;
    readonly R: byte;
    equals(obj: unknown): boolean;
    equals(other: Color): boolean;
    getBrightness(): float;
    getHashCode(): int;
    getHue(): float;
    getSaturation(): float;
    toArgb(): int;
    toKnownColor(): KnownColor;
    toString(): string;
    static readonly empty: Color;
    static readonly transparent: Color;
    static readonly aliceBlue: Color;
    static readonly antiqueWhite: Color;
    static readonly aqua: Color;
    static readonly aquamarine: Color;
    static readonly azure: Color;
    static readonly beige: Color;
    static readonly bisque: Color;
    static readonly black: Color;
    static readonly blanchedAlmond: Color;
    static readonly blue: Color;
    static readonly blueViolet: Color;
    static readonly brown: Color;
    static readonly burlyWood: Color;
    static readonly cadetBlue: Color;
    static readonly chartreuse: Color;
    static readonly chocolate: Color;
    static readonly coral: Color;
    static readonly cornflowerBlue: Color;
    static readonly cornsilk: Color;
    static readonly crimson: Color;
    static readonly cyan: Color;
    static readonly darkBlue: Color;
    static readonly darkCyan: Color;
    static readonly darkGoldenrod: Color;
    static readonly darkGray: Color;
    static readonly darkGreen: Color;
    static readonly darkKhaki: Color;
    static readonly darkMagenta: Color;
    static readonly darkOliveGreen: Color;
    static readonly darkOrange: Color;
    static readonly darkOrchid: Color;
    static readonly darkRed: Color;
    static readonly darkSalmon: Color;
    static readonly darkSeaGreen: Color;
    static readonly darkSlateBlue: Color;
    static readonly darkSlateGray: Color;
    static readonly darkTurquoise: Color;
    static readonly darkViolet: Color;
    static readonly deepPink: Color;
    static readonly deepSkyBlue: Color;
    static readonly dimGray: Color;
    static readonly dodgerBlue: Color;
    static readonly firebrick: Color;
    static readonly floralWhite: Color;
    static readonly forestGreen: Color;
    static readonly fuchsia: Color;
    static readonly gainsboro: Color;
    static readonly ghostWhite: Color;
    static readonly gold: Color;
    static readonly goldenrod: Color;
    static readonly gray: Color;
    static readonly green: Color;
    static readonly greenYellow: Color;
    static readonly honeydew: Color;
    static readonly hotPink: Color;
    static readonly indianRed: Color;
    static readonly indigo: Color;
    static readonly ivory: Color;
    static readonly khaki: Color;
    static readonly lavender: Color;
    static readonly lavenderBlush: Color;
    static readonly lawnGreen: Color;
    static readonly lemonChiffon: Color;
    static readonly lightBlue: Color;
    static readonly lightCoral: Color;
    static readonly lightCyan: Color;
    static readonly lightGoldenrodYellow: Color;
    static readonly lightGreen: Color;
    static readonly lightGray: Color;
    static readonly lightPink: Color;
    static readonly lightSalmon: Color;
    static readonly lightSeaGreen: Color;
    static readonly lightSkyBlue: Color;
    static readonly lightSlateGray: Color;
    static readonly lightSteelBlue: Color;
    static readonly lightYellow: Color;
    static readonly lime: Color;
    static readonly limeGreen: Color;
    static readonly linen: Color;
    static readonly magenta: Color;
    static readonly maroon: Color;
    static readonly mediumAquamarine: Color;
    static readonly mediumBlue: Color;
    static readonly mediumOrchid: Color;
    static readonly mediumPurple: Color;
    static readonly mediumSeaGreen: Color;
    static readonly mediumSlateBlue: Color;
    static readonly mediumSpringGreen: Color;
    static readonly mediumTurquoise: Color;
    static readonly mediumVioletRed: Color;
    static readonly midnightBlue: Color;
    static readonly mintCream: Color;
    static readonly mistyRose: Color;
    static readonly moccasin: Color;
    static readonly navajoWhite: Color;
    static readonly navy: Color;
    static readonly oldLace: Color;
    static readonly olive: Color;
    static readonly oliveDrab: Color;
    static readonly orange: Color;
    static readonly orangeRed: Color;
    static readonly orchid: Color;
    static readonly paleGoldenrod: Color;
    static readonly paleGreen: Color;
    static readonly paleTurquoise: Color;
    static readonly paleVioletRed: Color;
    static readonly papayaWhip: Color;
    static readonly peachPuff: Color;
    static readonly peru: Color;
    static readonly pink: Color;
    static readonly plum: Color;
    static readonly powderBlue: Color;
    static readonly purple: Color;
    static readonly rebeccaPurple: Color;
    static readonly red: Color;
    static readonly rosyBrown: Color;
    static readonly royalBlue: Color;
    static readonly saddleBrown: Color;
    static readonly salmon: Color;
    static readonly sandyBrown: Color;
    static readonly seaGreen: Color;
    static readonly seaShell: Color;
    static readonly sienna: Color;
    static readonly silver: Color;
    static readonly skyBlue: Color;
    static readonly slateBlue: Color;
    static readonly slateGray: Color;
    static readonly snow: Color;
    static readonly springGreen: Color;
    static readonly steelBlue: Color;
    static readonly tan: Color;
    static readonly teal: Color;
    static readonly thistle: Color;
    static readonly tomato: Color;
    static readonly turquoise: Color;
    static readonly violet: Color;
    static readonly wheat: Color;
    static readonly white: Color;
    static readonly whiteSmoke: Color;
    static readonly yellow: Color;
    static readonly yellowGreen: Color;
    static fromArgb(alpha: int, baseColor: Color): Color;
    static fromArgb(alpha: int, red: int, green: int, blue: int): Color;
    static fromArgb(red: int, green: int, blue: int): Color;
    static fromArgb(argb: int): Color;
    static fromKnownColor(color: KnownColor): Color;
    static fromName(name: string): Color;
}


export interface __Color$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Color>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Color): boolean;
}

export type Color = Color$instance & __Color$views;


export class Point$instance {
    constructor(x: int, y: int);
    constructor(sz: Size);
    constructor(dw: int);
    readonly isEmpty: boolean;
    X: int;
    Y: int;
    equals(obj: unknown): boolean;
    equals(other: Point): boolean;
    getHashCode(): int;
    offset(dx: int, dy: int): void;
    offset(p: Point): void;
    toString(): string;
    static readonly empty: Point;
    static add(pt: Point, sz: Size): Point;
    static ceiling(value: PointF): Point;
    static round(value: PointF): Point;
    static subtract(pt: Point, sz: Size): Point;
    static truncate(value: PointF): Point;
}


export interface __Point$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Point>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Point): boolean;
}

export type Point = Point$instance & __Point$views;


export class PointF$instance {
    constructor(x: float, y: float);
    constructor(vector: Vector2);
    readonly isEmpty: boolean;
    X: float;
    Y: float;
    equals(obj: unknown): boolean;
    equals(other: PointF): boolean;
    getHashCode(): int;
    toString(): string;
    toVector2(): Vector2;
    static readonly empty: PointF;
    static add(pt: PointF, sz: Size): PointF;
    static add(pt: PointF, sz: SizeF): PointF;
    static subtract(pt: PointF, sz: Size): PointF;
    static subtract(pt: PointF, sz: SizeF): PointF;
}


export interface __PointF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PointF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PointF): boolean;
}

export type PointF = PointF$instance & __PointF$views;


export class Rectangle$instance {
    constructor(x: int, y: int, width: int, height: int);
    constructor(location: Point, size: Size);
    readonly bottom: int;
    height: int;
    readonly isEmpty: boolean;
    readonly left: int;
    location: Point;
    readonly right: int;
    size: Size;
    readonly top: int;
    width: int;
    X: int;
    Y: int;
    contains(x: int, y: int): boolean;
    contains(pt: Point): boolean;
    contains(rect: Rectangle): boolean;
    equals(obj: unknown): boolean;
    equals(other: Rectangle): boolean;
    getHashCode(): int;
    inflate(width: int, height: int): void;
    inflate(size: Size): void;
    intersect(rect: Rectangle): void;
    intersectsWith(rect: Rectangle): boolean;
    offset(pos: Point): void;
    offset(x: int, y: int): void;
    toString(): string;
    static readonly empty: Rectangle;
    static ceiling(value: RectangleF): Rectangle;
    static fromLTRB(left: int, top: int, right: int, bottom: int): Rectangle;
    static inflate(rect: Rectangle, x: int, y: int): Rectangle;
    static intersect(a: Rectangle, b: Rectangle): Rectangle;
    static round(value: RectangleF): Rectangle;
    static truncate(value: RectangleF): Rectangle;
    static union(a: Rectangle, b: Rectangle): Rectangle;
}


export interface __Rectangle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Rectangle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rectangle): boolean;
}

export type Rectangle = Rectangle$instance & __Rectangle$views;


export class RectangleF$instance {
    constructor(x: float, y: float, width: float, height: float);
    constructor(location: PointF, size: SizeF);
    constructor(vector: Vector4);
    readonly bottom: float;
    height: float;
    readonly isEmpty: boolean;
    readonly left: float;
    location: PointF;
    readonly right: float;
    size: SizeF;
    readonly top: float;
    width: float;
    X: float;
    Y: float;
    contains(x: float, y: float): boolean;
    contains(pt: PointF): boolean;
    contains(rect: RectangleF): boolean;
    equals(obj: unknown): boolean;
    equals(other: RectangleF): boolean;
    getHashCode(): int;
    inflate(x: float, y: float): void;
    inflate(size: SizeF): void;
    intersect(rect: RectangleF): void;
    intersectsWith(rect: RectangleF): boolean;
    offset(pos: PointF): void;
    offset(x: float, y: float): void;
    toString(): string;
    toVector4(): Vector4;
    static readonly empty: RectangleF;
    static fromLTRB(left: float, top: float, right: float, bottom: float): RectangleF;
    static inflate(rect: RectangleF, x: float, y: float): RectangleF;
    static intersect(a: RectangleF, b: RectangleF): RectangleF;
    static union(a: RectangleF, b: RectangleF): RectangleF;
}


export interface __RectangleF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RectangleF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RectangleF): boolean;
}

export type RectangleF = RectangleF$instance & __RectangleF$views;


export class Size$instance {
    constructor(pt: Point);
    constructor(width: int, height: int);
    height: int;
    readonly isEmpty: boolean;
    width: int;
    equals(obj: unknown): boolean;
    equals(other: Size): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly empty: Size;
    static add(sz1: Size, sz2: Size): Size;
    static ceiling(value: SizeF): Size;
    static round(value: SizeF): Size;
    static subtract(sz1: Size, sz2: Size): Size;
    static truncate(value: SizeF): Size;
}


export interface __Size$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Size>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Size): boolean;
}

export type Size = Size$instance & __Size$views;


export class SizeF$instance {
    constructor(size: SizeF);
    constructor(pt: PointF);
    constructor(vector: Vector2);
    constructor(width: float, height: float);
    height: float;
    readonly isEmpty: boolean;
    width: float;
    equals(obj: unknown): boolean;
    equals(other: SizeF): boolean;
    getHashCode(): int;
    toPointF(): PointF;
    toSize(): Size;
    toString(): string;
    toVector2(): Vector2;
    static readonly empty: SizeF;
    static add(sz1: SizeF, sz2: SizeF): SizeF;
    static subtract(sz1: SizeF, sz2: SizeF): SizeF;
}


export interface __SizeF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SizeF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SizeF): boolean;
}

export type SizeF = SizeF$instance & __SizeF$views;


export class ColorConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export type ColorConverter = ColorConverter$instance;

export class PointConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type PointConverter = PointConverter$instance;

export class RectangleConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type RectangleConverter = RectangleConverter$instance;

export class SizeConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type SizeConverter = SizeConverter$instance;

export class SizeFConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    convertFrom(value: unknown): unknown;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    convertTo(value: unknown, destinationType: Type): unknown;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    createInstance(propertyValues: IDictionary): unknown;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: unknown): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type SizeFConverter = SizeFConverter$instance;

export abstract class ColorTranslator$instance {
    static fromHtml(htmlColor: string): Color;
    static fromOle(oleColor: int): Color;
    static fromWin32(win32Color: int): Color;
    static toHtml(c: Color): string;
    static toOle(c: Color): int;
    static toWin32(c: Color): int;
}


export type ColorTranslator = ColorTranslator$instance;

export abstract class SystemColors$instance {
    static readonly activeBorder: Color;
    static readonly activeCaption: Color;
    static readonly activeCaptionText: Color;
    static readonly appWorkspace: Color;
    static readonly buttonFace: Color;
    static readonly buttonHighlight: Color;
    static readonly buttonShadow: Color;
    static readonly control: Color;
    static readonly controlDark: Color;
    static readonly controlDarkDark: Color;
    static readonly controlLight: Color;
    static readonly controlLightLight: Color;
    static readonly controlText: Color;
    static readonly desktop: Color;
    static readonly gradientActiveCaption: Color;
    static readonly gradientInactiveCaption: Color;
    static readonly grayText: Color;
    static readonly highlight: Color;
    static readonly highlightText: Color;
    static readonly hotTrack: Color;
    static readonly inactiveBorder: Color;
    static readonly inactiveCaption: Color;
    static readonly inactiveCaptionText: Color;
    static readonly info: Color;
    static readonly infoText: Color;
    static readonly menu: Color;
    static readonly menuBar: Color;
    static readonly menuHighlight: Color;
    static readonly menuText: Color;
    static readonly scrollBar: Color;
    static readonly window: Color;
    static readonly windowFrame: Color;
    static readonly windowText: Color;
    static useAlternativeColorSet: boolean;
}


export type SystemColors = SystemColors$instance;

