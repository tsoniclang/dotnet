// Generated by tsbindgen - Architecture
// Namespace: System.Drawing
// Assembly: System.ComponentModel.TypeConverter, System.Drawing.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection, IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, PropertyDescriptorCollection, TypeConverter, TypeConverter_StandardValuesCollection } from "../../System.ComponentModel/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Vector2, Vector4 } from "../../System.Numerics/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Enum, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum KnownColor {
    activeBorder = 1,
    activeCaption = 2,
    activeCaptionText = 3,
    appWorkspace = 4,
    control = 5,
    controlDark = 6,
    controlDarkDark = 7,
    controlLight = 8,
    controlLightLight = 9,
    controlText = 10,
    desktop = 11,
    grayText = 12,
    highlight = 13,
    highlightText = 14,
    hotTrack = 15,
    inactiveBorder = 16,
    inactiveCaption = 17,
    inactiveCaptionText = 18,
    info = 19,
    infoText = 20,
    menu = 21,
    menuText = 22,
    scrollBar = 23,
    window = 24,
    windowFrame = 25,
    windowText = 26,
    transparent = 27,
    aliceBlue = 28,
    antiqueWhite = 29,
    aqua = 30,
    aquamarine = 31,
    azure = 32,
    beige = 33,
    bisque = 34,
    black = 35,
    blanchedAlmond = 36,
    blue = 37,
    blueViolet = 38,
    brown = 39,
    burlyWood = 40,
    cadetBlue = 41,
    chartreuse = 42,
    chocolate = 43,
    coral = 44,
    cornflowerBlue = 45,
    cornsilk = 46,
    crimson = 47,
    cyan = 48,
    darkBlue = 49,
    darkCyan = 50,
    darkGoldenrod = 51,
    darkGray = 52,
    darkGreen = 53,
    darkKhaki = 54,
    darkMagenta = 55,
    darkOliveGreen = 56,
    darkOrange = 57,
    darkOrchid = 58,
    darkRed = 59,
    darkSalmon = 60,
    darkSeaGreen = 61,
    darkSlateBlue = 62,
    darkSlateGray = 63,
    darkTurquoise = 64,
    darkViolet = 65,
    deepPink = 66,
    deepSkyBlue = 67,
    dimGray = 68,
    dodgerBlue = 69,
    firebrick = 70,
    floralWhite = 71,
    forestGreen = 72,
    fuchsia = 73,
    gainsboro = 74,
    ghostWhite = 75,
    gold = 76,
    goldenrod = 77,
    gray = 78,
    green = 79,
    greenYellow = 80,
    honeydew = 81,
    hotPink = 82,
    indianRed = 83,
    indigo = 84,
    ivory = 85,
    khaki = 86,
    lavender = 87,
    lavenderBlush = 88,
    lawnGreen = 89,
    lemonChiffon = 90,
    lightBlue = 91,
    lightCoral = 92,
    lightCyan = 93,
    lightGoldenrodYellow = 94,
    lightGray = 95,
    lightGreen = 96,
    lightPink = 97,
    lightSalmon = 98,
    lightSeaGreen = 99,
    lightSkyBlue = 100,
    lightSlateGray = 101,
    lightSteelBlue = 102,
    lightYellow = 103,
    lime = 104,
    limeGreen = 105,
    linen = 106,
    magenta = 107,
    maroon = 108,
    mediumAquamarine = 109,
    mediumBlue = 110,
    mediumOrchid = 111,
    mediumPurple = 112,
    mediumSeaGreen = 113,
    mediumSlateBlue = 114,
    mediumSpringGreen = 115,
    mediumTurquoise = 116,
    mediumVioletRed = 117,
    midnightBlue = 118,
    mintCream = 119,
    mistyRose = 120,
    moccasin = 121,
    navajoWhite = 122,
    navy = 123,
    oldLace = 124,
    olive = 125,
    oliveDrab = 126,
    orange = 127,
    orangeRed = 128,
    orchid = 129,
    paleGoldenrod = 130,
    paleGreen = 131,
    paleTurquoise = 132,
    paleVioletRed = 133,
    papayaWhip = 134,
    peachPuff = 135,
    peru = 136,
    pink = 137,
    plum = 138,
    powderBlue = 139,
    purple = 140,
    red = 141,
    rosyBrown = 142,
    royalBlue = 143,
    saddleBrown = 144,
    salmon = 145,
    sandyBrown = 146,
    seaGreen = 147,
    seaShell = 148,
    sienna = 149,
    silver = 150,
    skyBlue = 151,
    slateBlue = 152,
    slateGray = 153,
    snow = 154,
    springGreen = 155,
    steelBlue = 156,
    tan = 157,
    teal = 158,
    thistle = 159,
    tomato = 160,
    turquoise = 161,
    violet = 162,
    wheat = 163,
    white = 164,
    whiteSmoke = 165,
    yellow = 166,
    yellowGreen = 167,
    buttonFace = 168,
    buttonHighlight = 169,
    buttonShadow = 170,
    gradientActiveCaption = 171,
    gradientInactiveCaption = 172,
    menuBar = 173,
    menuHighlight = 174,
    rebeccaPurple = 175
}


export class Color$instance {
    readonly a: byte;
    readonly b: byte;
    readonly g: byte;
    readonly isEmpty: boolean;
    readonly isKnownColor: boolean;
    readonly isNamedColor: boolean;
    readonly isSystemColor: boolean;
    readonly name: string;
    readonly r: byte;
    equals(obj: any): boolean;
    equals(other: Color): boolean;
    getBrightness(): float;
    getHashCode(): int;
    getHue(): float;
    getSaturation(): float;
    toArgb(): int;
    toKnownColor(): KnownColor;
    toString(): string;
    static readonly empty: Color;
    static readonly Transparent: Color;
    static readonly AliceBlue: Color;
    static readonly AntiqueWhite: Color;
    static readonly Aqua: Color;
    static readonly Aquamarine: Color;
    static readonly Azure: Color;
    static readonly Beige: Color;
    static readonly Bisque: Color;
    static readonly Black: Color;
    static readonly BlanchedAlmond: Color;
    static readonly Blue: Color;
    static readonly BlueViolet: Color;
    static readonly Brown: Color;
    static readonly BurlyWood: Color;
    static readonly CadetBlue: Color;
    static readonly Chartreuse: Color;
    static readonly Chocolate: Color;
    static readonly Coral: Color;
    static readonly CornflowerBlue: Color;
    static readonly Cornsilk: Color;
    static readonly Crimson: Color;
    static readonly Cyan: Color;
    static readonly DarkBlue: Color;
    static readonly DarkCyan: Color;
    static readonly DarkGoldenrod: Color;
    static readonly DarkGray: Color;
    static readonly DarkGreen: Color;
    static readonly DarkKhaki: Color;
    static readonly DarkMagenta: Color;
    static readonly DarkOliveGreen: Color;
    static readonly DarkOrange: Color;
    static readonly DarkOrchid: Color;
    static readonly DarkRed: Color;
    static readonly DarkSalmon: Color;
    static readonly DarkSeaGreen: Color;
    static readonly DarkSlateBlue: Color;
    static readonly DarkSlateGray: Color;
    static readonly DarkTurquoise: Color;
    static readonly DarkViolet: Color;
    static readonly DeepPink: Color;
    static readonly DeepSkyBlue: Color;
    static readonly DimGray: Color;
    static readonly DodgerBlue: Color;
    static readonly Firebrick: Color;
    static readonly FloralWhite: Color;
    static readonly ForestGreen: Color;
    static readonly Fuchsia: Color;
    static readonly Gainsboro: Color;
    static readonly GhostWhite: Color;
    static readonly Gold: Color;
    static readonly Goldenrod: Color;
    static readonly Gray: Color;
    static readonly Green: Color;
    static readonly GreenYellow: Color;
    static readonly Honeydew: Color;
    static readonly HotPink: Color;
    static readonly IndianRed: Color;
    static readonly Indigo: Color;
    static readonly Ivory: Color;
    static readonly Khaki: Color;
    static readonly Lavender: Color;
    static readonly LavenderBlush: Color;
    static readonly LawnGreen: Color;
    static readonly LemonChiffon: Color;
    static readonly LightBlue: Color;
    static readonly LightCoral: Color;
    static readonly LightCyan: Color;
    static readonly LightGoldenrodYellow: Color;
    static readonly LightGreen: Color;
    static readonly LightGray: Color;
    static readonly LightPink: Color;
    static readonly LightSalmon: Color;
    static readonly LightSeaGreen: Color;
    static readonly LightSkyBlue: Color;
    static readonly LightSlateGray: Color;
    static readonly LightSteelBlue: Color;
    static readonly LightYellow: Color;
    static readonly Lime: Color;
    static readonly LimeGreen: Color;
    static readonly Linen: Color;
    static readonly Magenta: Color;
    static readonly Maroon: Color;
    static readonly MediumAquamarine: Color;
    static readonly MediumBlue: Color;
    static readonly MediumOrchid: Color;
    static readonly MediumPurple: Color;
    static readonly MediumSeaGreen: Color;
    static readonly MediumSlateBlue: Color;
    static readonly MediumSpringGreen: Color;
    static readonly MediumTurquoise: Color;
    static readonly MediumVioletRed: Color;
    static readonly MidnightBlue: Color;
    static readonly MintCream: Color;
    static readonly MistyRose: Color;
    static readonly Moccasin: Color;
    static readonly NavajoWhite: Color;
    static readonly Navy: Color;
    static readonly OldLace: Color;
    static readonly Olive: Color;
    static readonly OliveDrab: Color;
    static readonly Orange: Color;
    static readonly OrangeRed: Color;
    static readonly Orchid: Color;
    static readonly PaleGoldenrod: Color;
    static readonly PaleGreen: Color;
    static readonly PaleTurquoise: Color;
    static readonly PaleVioletRed: Color;
    static readonly PapayaWhip: Color;
    static readonly PeachPuff: Color;
    static readonly Peru: Color;
    static readonly Pink: Color;
    static readonly Plum: Color;
    static readonly PowderBlue: Color;
    static readonly Purple: Color;
    static readonly RebeccaPurple: Color;
    static readonly Red: Color;
    static readonly RosyBrown: Color;
    static readonly RoyalBlue: Color;
    static readonly SaddleBrown: Color;
    static readonly Salmon: Color;
    static readonly SandyBrown: Color;
    static readonly SeaGreen: Color;
    static readonly SeaShell: Color;
    static readonly Sienna: Color;
    static readonly Silver: Color;
    static readonly SkyBlue: Color;
    static readonly SlateBlue: Color;
    static readonly SlateGray: Color;
    static readonly Snow: Color;
    static readonly SpringGreen: Color;
    static readonly SteelBlue: Color;
    static readonly Tan: Color;
    static readonly Teal: Color;
    static readonly Thistle: Color;
    static readonly Tomato: Color;
    static readonly Turquoise: Color;
    static readonly Violet: Color;
    static readonly Wheat: Color;
    static readonly White: Color;
    static readonly WhiteSmoke: Color;
    static readonly Yellow: Color;
    static readonly YellowGreen: Color;
    static FromArgb(alpha: int, baseColor: Color): Color;
    static FromArgb(alpha: int, red: int, green: int, blue: int): Color;
    static FromArgb(red: int, green: int, blue: int): Color;
    static FromArgb(argb: int): Color;
    static FromKnownColor(color: KnownColor): Color;
    static FromName(name: string): Color;
}


export interface __Color$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<Color>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Color): boolean;
}

export type Color = Color$instance & __Color$views;


export class Point$instance {
    constructor(x: int, y: int);
    constructor(sz: Size);
    constructor(dw: int);
    readonly isEmpty: boolean;
    x: int;
    y: int;
    equals(obj: any): boolean;
    equals(other: Point): boolean;
    getHashCode(): int;
    offset(dx: int, dy: int): void;
    offset(p: Point): void;
    toString(): string;
    static readonly empty: Point;
    static Add(pt: Point, sz: Size): Point;
    static Ceiling(value: PointF): Point;
    static Round(value: PointF): Point;
    static Subtract(pt: Point, sz: Size): Point;
    static Truncate(value: PointF): Point;
}


export interface __Point$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<Point>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Point): boolean;
}

export type Point = Point$instance & __Point$views;


export class PointF$instance {
    constructor(x: float, y: float);
    constructor(vector: Vector2);
    readonly isEmpty: boolean;
    x: float;
    y: float;
    equals(obj: any): boolean;
    equals(other: PointF): boolean;
    getHashCode(): int;
    toString(): string;
    toVector2(): Vector2;
    static readonly empty: PointF;
    static Add(pt: PointF, sz: Size): PointF;
    static Add(pt: PointF, sz: SizeF): PointF;
    static Subtract(pt: PointF, sz: Size): PointF;
    static Subtract(pt: PointF, sz: SizeF): PointF;
}


export interface __PointF$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<PointF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PointF): boolean;
}

export type PointF = PointF$instance & __PointF$views;


export class Rectangle$instance {
    constructor(x: int, y: int, width: int, height: int);
    constructor(location: Point, size: Size);
    readonly bottom: int;
    height: int;
    readonly isEmpty: boolean;
    readonly left: int;
    location: Point;
    readonly right: int;
    size: Size;
    readonly top: int;
    width: int;
    x: int;
    y: int;
    contains(x: int, y: int): boolean;
    contains(pt: Point): boolean;
    contains(rect: Rectangle): boolean;
    equals(obj: any): boolean;
    equals(other: Rectangle): boolean;
    getHashCode(): int;
    inflate(width: int, height: int): void;
    inflate(size: Size): void;
    intersect(rect: Rectangle): void;
    intersectsWith(rect: Rectangle): boolean;
    offset(pos: Point): void;
    offset(x: int, y: int): void;
    toString(): string;
    static readonly empty: Rectangle;
    static Ceiling(value: RectangleF): Rectangle;
    static FromLTRB(left: int, top: int, right: int, bottom: int): Rectangle;
    static Inflate(rect: Rectangle, x: int, y: int): Rectangle;
    static Intersect(a: Rectangle, b: Rectangle): Rectangle;
    static Round(value: RectangleF): Rectangle;
    static Truncate(value: RectangleF): Rectangle;
    static Union(a: Rectangle, b: Rectangle): Rectangle;
}


export interface __Rectangle$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<Rectangle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rectangle): boolean;
}

export type Rectangle = Rectangle$instance & __Rectangle$views;


export class RectangleF$instance {
    constructor(x: float, y: float, width: float, height: float);
    constructor(location: PointF, size: SizeF);
    constructor(vector: Vector4);
    readonly bottom: float;
    height: float;
    readonly isEmpty: boolean;
    readonly left: float;
    location: PointF;
    readonly right: float;
    size: SizeF;
    readonly top: float;
    width: float;
    x: float;
    y: float;
    contains(x: float, y: float): boolean;
    contains(pt: PointF): boolean;
    contains(rect: RectangleF): boolean;
    equals(obj: any): boolean;
    equals(other: RectangleF): boolean;
    getHashCode(): int;
    inflate(x: float, y: float): void;
    inflate(size: SizeF): void;
    intersect(rect: RectangleF): void;
    intersectsWith(rect: RectangleF): boolean;
    offset(pos: PointF): void;
    offset(x: float, y: float): void;
    toString(): string;
    toVector4(): Vector4;
    static readonly empty: RectangleF;
    static FromLTRB(left: float, top: float, right: float, bottom: float): RectangleF;
    static Inflate(rect: RectangleF, x: float, y: float): RectangleF;
    static Intersect(a: RectangleF, b: RectangleF): RectangleF;
    static Union(a: RectangleF, b: RectangleF): RectangleF;
}


export interface __RectangleF$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<RectangleF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RectangleF): boolean;
}

export type RectangleF = RectangleF$instance & __RectangleF$views;


export class Size$instance {
    constructor(pt: Point);
    constructor(width: int, height: int);
    height: int;
    readonly isEmpty: boolean;
    width: int;
    equals(obj: any): boolean;
    equals(other: Size): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly empty: Size;
    static Add(sz1: Size, sz2: Size): Size;
    static Ceiling(value: SizeF): Size;
    static Round(value: SizeF): Size;
    static Subtract(sz1: Size, sz2: Size): Size;
    static Truncate(value: SizeF): Size;
}


export interface __Size$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<Size>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Size): boolean;
}

export type Size = Size$instance & __Size$views;


export class SizeF$instance {
    constructor(size: SizeF);
    constructor(pt: PointF);
    constructor(vector: Vector2);
    constructor(width: float, height: float);
    height: float;
    readonly isEmpty: boolean;
    width: float;
    equals(obj: any): boolean;
    equals(other: SizeF): boolean;
    getHashCode(): int;
    toPointF(): PointF;
    toSize(): Size;
    toString(): string;
    toVector2(): Vector2;
    static readonly empty: SizeF;
    static Add(sz1: SizeF, sz2: SizeF): SizeF;
    static Subtract(sz1: SizeF, sz2: SizeF): SizeF;
}


export interface __SizeF$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SizeF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SizeF): boolean;
}

export type SizeF = SizeF$instance & __SizeF$views;


export class ColorConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    convertFrom(value: any): any;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    convertTo(value: any, destinationType: Type): any;
    getStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    getStandardValues(): ICollection;
    getStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    getStandardValuesSupported(): boolean;
}


export type ColorConverter = ColorConverter$instance;

export class PointConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    convertFrom(value: any): any;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    convertTo(value: any, destinationType: Type): any;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): any;
    createInstance(propertyValues: IDictionary): any;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: any): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type PointConverter = PointConverter$instance;

export class RectangleConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    convertFrom(value: any): any;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    convertTo(value: any, destinationType: Type): any;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): any;
    createInstance(propertyValues: IDictionary): any;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: any): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type RectangleConverter = RectangleConverter$instance;

export class SizeConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    convertFrom(value: any): any;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    convertTo(value: any, destinationType: Type): any;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): any;
    createInstance(propertyValues: IDictionary): any;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: any): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type SizeConverter = SizeConverter$instance;

export class SizeFConverter$instance extends System_ComponentModel_Internal.TypeConverter$instance {
    constructor();
    canConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    canConvertFrom(sourceType: Type): boolean;
    canConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    canConvertTo(destinationType: Type): boolean;
    convertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: any): any;
    convertFrom(value: any): any;
    convertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: any, destinationType: Type): any;
    convertTo(value: any, destinationType: Type): any;
    createInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): any;
    createInstance(propertyValues: IDictionary): any;
    getCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    getCreateInstanceSupported(): boolean;
    getProperties(context: ITypeDescriptorContext, value: any, attributes: Attribute[]): PropertyDescriptorCollection;
    getProperties(value: any): PropertyDescriptorCollection;
    getProperties(context: ITypeDescriptorContext, value: any): PropertyDescriptorCollection;
    getPropertiesSupported(context: ITypeDescriptorContext): boolean;
    getPropertiesSupported(): boolean;
}


export type SizeFConverter = SizeFConverter$instance;

export abstract class ColorTranslator$instance {
    static FromHtml(htmlColor: string): Color;
    static FromOle(oleColor: int): Color;
    static FromWin32(win32Color: int): Color;
    static ToHtml(c: Color): string;
    static ToOle(c: Color): int;
    static ToWin32(c: Color): int;
}


export type ColorTranslator = ColorTranslator$instance;

export abstract class SystemColors$instance {
    static readonly ActiveBorder: Color;
    static readonly ActiveCaption: Color;
    static readonly ActiveCaptionText: Color;
    static readonly AppWorkspace: Color;
    static readonly ButtonFace: Color;
    static readonly ButtonHighlight: Color;
    static readonly ButtonShadow: Color;
    static readonly Control: Color;
    static readonly ControlDark: Color;
    static readonly ControlDarkDark: Color;
    static readonly ControlLight: Color;
    static readonly ControlLightLight: Color;
    static readonly ControlText: Color;
    static readonly Desktop: Color;
    static readonly GradientActiveCaption: Color;
    static readonly GradientInactiveCaption: Color;
    static readonly GrayText: Color;
    static readonly Highlight: Color;
    static readonly HighlightText: Color;
    static readonly HotTrack: Color;
    static readonly InactiveBorder: Color;
    static readonly InactiveCaption: Color;
    static readonly InactiveCaptionText: Color;
    static readonly Info: Color;
    static readonly InfoText: Color;
    static readonly Menu: Color;
    static readonly MenuBar: Color;
    static readonly MenuHighlight: Color;
    static readonly MenuText: Color;
    static readonly ScrollBar: Color;
    static readonly Window: Color;
    static readonly WindowFrame: Color;
    static readonly WindowText: Color;
    static UseAlternativeColorSet: boolean;
}


export type SystemColors = SystemColors$instance;

