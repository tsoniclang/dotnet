// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.ComTypes
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Enum, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ADVF {
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
}


export enum CALLCONV {
    CC_CDECL = 1,
    CC_MSCPASCAL = 2,
    CC_PASCAL = 2,
    CC_MACPASCAL = 3,
    CC_STDCALL = 4,
    CC_RESERVED = 5,
    CC_SYSCALL = 6,
    CC_MPWCDECL = 7,
    CC_MPWPASCAL = 8,
    CC_MAX = 9
}


export enum DATADIR {
    DATADIR_GET = 1,
    DATADIR_SET = 2
}


export enum DESCKIND {
    DESCKIND_NONE = 0,
    DESCKIND_FUNCDESC = 1,
    DESCKIND_VARDESC = 2,
    DESCKIND_TYPECOMP = 3,
    DESCKIND_IMPLICITAPPOBJ = 4,
    DESCKIND_MAX = 5
}


export enum DVASPECT {
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
}


export enum FUNCFLAGS {
    FUNCFLAG_FRESTRICTED = 1,
    FUNCFLAG_FSOURCE = 2,
    FUNCFLAG_FBINDABLE = 4,
    FUNCFLAG_FREQUESTEDIT = 8,
    FUNCFLAG_FDISPLAYBIND = 16,
    FUNCFLAG_FDEFAULTBIND = 32,
    FUNCFLAG_FHIDDEN = 64,
    FUNCFLAG_FUSESGETLASTERROR = 128,
    FUNCFLAG_FDEFAULTCOLLELEM = 256,
    FUNCFLAG_FUIDEFAULT = 512,
    FUNCFLAG_FNONBROWSABLE = 1024,
    FUNCFLAG_FREPLACEABLE = 2048,
    FUNCFLAG_FIMMEDIATEBIND = 4096
}


export enum FUNCKIND {
    FUNC_VIRTUAL = 0,
    FUNC_PUREVIRTUAL = 1,
    FUNC_NONVIRTUAL = 2,
    FUNC_STATIC = 3,
    FUNC_DISPATCH = 4
}


export enum IDLFLAG {
    IDLFLAG_NONE = 0,
    IDLFLAG_FIN = 1,
    IDLFLAG_FOUT = 2,
    IDLFLAG_FLCID = 4,
    IDLFLAG_FRETVAL = 8
}


export enum IMPLTYPEFLAGS {
    IMPLTYPEFLAG_FDEFAULT = 1,
    IMPLTYPEFLAG_FSOURCE = 2,
    IMPLTYPEFLAG_FRESTRICTED = 4,
    IMPLTYPEFLAG_FDEFAULTVTABLE = 8
}


export enum INVOKEKIND {
    INVOKE_FUNC = 1,
    INVOKE_PROPERTYGET = 2,
    INVOKE_PROPERTYPUT = 4,
    INVOKE_PROPERTYPUTREF = 8
}


export enum LIBFLAGS {
    LIBFLAG_FRESTRICTED = 1,
    LIBFLAG_FCONTROL = 2,
    LIBFLAG_FHIDDEN = 4,
    LIBFLAG_FHASDISKIMAGE = 8
}


export enum PARAMFLAG {
    PARAMFLAG_NONE = 0,
    PARAMFLAG_FIN = 1,
    PARAMFLAG_FOUT = 2,
    PARAMFLAG_FLCID = 4,
    PARAMFLAG_FRETVAL = 8,
    PARAMFLAG_FOPT = 16,
    PARAMFLAG_FHASDEFAULT = 32,
    PARAMFLAG_FHASCUSTDATA = 64
}


export enum SYSKIND {
    SYS_WIN16 = 0,
    SYS_WIN32 = 1,
    SYS_MAC = 2,
    SYS_WIN64 = 3
}


export enum TYMED {
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_ENHMF = 64,
    TYMED_NULL = 0
}


export enum TYPEFLAGS {
    TYPEFLAG_FAPPOBJECT = 1,
    TYPEFLAG_FCANCREATE = 2,
    TYPEFLAG_FLICENSED = 4,
    TYPEFLAG_FPREDECLID = 8,
    TYPEFLAG_FHIDDEN = 16,
    TYPEFLAG_FCONTROL = 32,
    TYPEFLAG_FDUAL = 64,
    TYPEFLAG_FNONEXTENSIBLE = 128,
    TYPEFLAG_FOLEAUTOMATION = 256,
    TYPEFLAG_FRESTRICTED = 512,
    TYPEFLAG_FAGGREGATABLE = 1024,
    TYPEFLAG_FREPLACEABLE = 2048,
    TYPEFLAG_FDISPATCHABLE = 4096,
    TYPEFLAG_FREVERSEBIND = 8192,
    TYPEFLAG_FPROXY = 16384
}


export enum TYPEKIND {
    TKIND_ENUM = 0,
    TKIND_RECORD = 1,
    TKIND_MODULE = 2,
    TKIND_INTERFACE = 3,
    TKIND_DISPATCH = 4,
    TKIND_COCLASS = 5,
    TKIND_ALIAS = 6,
    TKIND_UNION = 7,
    TKIND_MAX = 8
}


export enum VARFLAGS {
    VARFLAG_FREADONLY = 1,
    VARFLAG_FSOURCE = 2,
    VARFLAG_FBINDABLE = 4,
    VARFLAG_FREQUESTEDIT = 8,
    VARFLAG_FDISPLAYBIND = 16,
    VARFLAG_FDEFAULTBIND = 32,
    VARFLAG_FHIDDEN = 64,
    VARFLAG_FRESTRICTED = 128,
    VARFLAG_FDEFAULTCOLLELEM = 256,
    VARFLAG_FUIDEFAULT = 512,
    VARFLAG_FNONBROWSABLE = 1024,
    VARFLAG_FREPLACEABLE = 2048,
    VARFLAG_FIMMEDIATEBIND = 4096
}


export enum VARKIND {
    VAR_PERINSTANCE = 0,
    VAR_STATIC = 1,
    VAR_CONST = 2,
    VAR_DISPATCH = 3
}


export interface IAdviseSink$instance {
    OnDataChange(format: { value: TSByRef<FORMATETC> }, stgmedium: { value: TSByRef<STGMEDIUM> }): void;
    OnRename(moniker: IMoniker): void;
    OnSave(): void;
    OnViewChange(aspect: int, index: int): void;
}


export type IAdviseSink = IAdviseSink$instance;

export interface IBindCtx$instance {
    EnumObjectParam(ppenum: { value: TSByRef<IEnumString> }): void;
    GetObjectParam(pszKey: string, ppunk: { value: TSByRef<any> }): void;
    GetRunningObjectTable(pprot: { value: TSByRef<IRunningObjectTable> }): void;
    RegisterObjectBound(punk: any): void;
    RegisterObjectParam(pszKey: string, punk: any): void;
    ReleaseBoundObjects(): void;
    RevokeObjectParam(pszKey: string): int;
    SetBindOptions(pbindopts: { value: TSByRef<BIND_OPTS> }): void;
}


export type IBindCtx = IBindCtx$instance;

export interface IConnectionPoint$instance {
    Advise(pUnkSink: any, pdwCookie: { value: TSByRef<int> }): void;
    EnumConnections(ppEnum: { value: TSByRef<IEnumConnections> }): void;
    GetConnectionInterface(pIID: { value: TSByRef<Guid> }): void;
    GetConnectionPointContainer(ppCPC: { value: TSByRef<IConnectionPointContainer> }): void;
    Unadvise(dwCookie: int): void;
}


export type IConnectionPoint = IConnectionPoint$instance;

export interface IConnectionPointContainer$instance {
    EnumConnectionPoints(ppEnum: { value: TSByRef<IEnumConnectionPoints> }): void;
    FindConnectionPoint(riid: { value: TSByRef<Guid> }, ppCP: { value: TSByRef<IConnectionPoint> }): void;
}


export type IConnectionPointContainer = IConnectionPointContainer$instance;

export interface IDataObject$instance {
    DAdvise(pFormatetc: { value: TSByRef<FORMATETC> }, advf: ADVF, adviseSink: IAdviseSink, connection: { value: TSByRef<int> }): int;
    DUnadvise(connection: int): void;
    EnumDAdvise(enumAdvise: { value: TSByRef<IEnumSTATDATA> }): int;
    EnumFormatEtc(direction: DATADIR): IEnumFORMATETC;
    GetCanonicalFormatEtc(formatIn: { value: TSByRef<FORMATETC> }, formatOut: { value: TSByRef<FORMATETC> }): int;
    GetData(format: { value: TSByRef<FORMATETC> }, medium: { value: TSByRef<STGMEDIUM> }): void;
    QueryGetData(format: { value: TSByRef<FORMATETC> }): int;
    SetData(formatIn: { value: TSByRef<FORMATETC> }, medium: { value: TSByRef<STGMEDIUM> }, release: boolean): void;
}


export type IDataObject = IDataObject$instance;

export interface IEnumConnectionPoints$instance {
    Clone(ppenum: { value: TSByRef<IEnumConnectionPoints> }): void;
    Next(celt: int, rgelt: { value: IConnectionPoint[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumConnectionPoints = IEnumConnectionPoints$instance;

export interface IEnumConnections$instance {
    Clone(ppenum: { value: TSByRef<IEnumConnections> }): void;
    Next(celt: int, rgelt: { value: CONNECTDATA[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumConnections = IEnumConnections$instance;

export interface IEnumFORMATETC$instance {
    Clone(newEnum: { value: TSByRef<IEnumFORMATETC> }): void;
    Next(celt: int, rgelt: { value: FORMATETC[] }, pceltFetched: { value: int[] }): int;
    Reset(): int;
    Skip(celt: int): int;
}


export type IEnumFORMATETC = IEnumFORMATETC$instance;

export interface IEnumMoniker$instance {
    Clone(ppenum: { value: TSByRef<IEnumMoniker> }): void;
    Next(celt: int, rgelt: { value: IMoniker[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumMoniker = IEnumMoniker$instance;

export interface IEnumSTATDATA$instance {
    Clone(newEnum: { value: TSByRef<IEnumSTATDATA> }): void;
    Next(celt: int, rgelt: { value: STATDATA[] }, pceltFetched: { value: int[] }): int;
    Reset(): int;
    Skip(celt: int): int;
}


export type IEnumSTATDATA = IEnumSTATDATA$instance;

export interface IEnumString$instance {
    Clone(ppenum: { value: TSByRef<IEnumString> }): void;
    Next(celt: int, rgelt: { value: string[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumString = IEnumString$instance;

export interface IEnumVARIANT$instance {
    Clone(): IEnumVARIANT;
    Next(celt: int, rgVar: { value: any[] }, pceltFetched: nint): int;
    Reset(): int;
    Skip(celt: int): int;
}


export type IEnumVARIANT = IEnumVARIANT$instance;

export interface IMoniker$instance {
    BindToObject(pbc: IBindCtx, pmkToLeft: IMoniker, riidResult: { value: TSByRef<Guid> }, ppvResult: { value: TSByRef<any> }): void;
    CommonPrefixWith(pmkOther: IMoniker, ppmkPrefix: { value: TSByRef<IMoniker> }): void;
    ComposeWith(pmkRight: IMoniker, fOnlyIfNotGeneric: boolean, ppmkComposite: { value: TSByRef<IMoniker> }): void;
    Enum(fForward: boolean, ppenumMoniker: { value: TSByRef<IEnumMoniker> }): void;
    GetClassID(pClassID: { value: TSByRef<Guid> }): void;
    GetDisplayName(pbc: IBindCtx, pmkToLeft: IMoniker, ppszDisplayName: { value: TSByRef<string> }): void;
    GetSizeMax(pcbSize: { value: TSByRef<long> }): void;
    GetTimeOfLastChange(pbc: IBindCtx, pmkToLeft: IMoniker, pFileTime: { value: TSByRef<FILETIME> }): void;
    Hash(pdwHash: { value: TSByRef<int> }): void;
    Inverse(ppmk: { value: TSByRef<IMoniker> }): void;
    IsDirty(): int;
    IsEqual(pmkOtherMoniker: IMoniker): int;
    IsRunning(pbc: IBindCtx, pmkToLeft: IMoniker, pmkNewlyRunning: IMoniker): int;
    IsSystemMoniker(pdwMksys: { value: TSByRef<int> }): int;
    Load(pStm: IStream): void;
    ParseDisplayName(pbc: IBindCtx, pmkToLeft: IMoniker, pszDisplayName: string, pchEaten: { value: TSByRef<int> }, ppmkOut: { value: TSByRef<IMoniker> }): void;
    Reduce(pbc: IBindCtx, dwReduceHowFar: int, ppmkToLeft: { value: TSByRef<IMoniker> }, ppmkReduced: { value: TSByRef<IMoniker> }): void;
    Save(pStm: IStream, fClearDirty: boolean): void;
}


export type IMoniker = IMoniker$instance;

export interface IPersistFile$instance {
    GetClassID(pClassID: { value: TSByRef<Guid> }): void;
    GetCurFile(ppszFileName: { value: TSByRef<string> }): void;
    IsDirty(): int;
    Load(pszFileName: string, dwMode: int): void;
    Save(pszFileName: string, fRemember: boolean): void;
    SaveCompleted(pszFileName: string): void;
}


export type IPersistFile = IPersistFile$instance;

export interface IRunningObjectTable$instance {
    EnumRunning(ppenumMoniker: { value: TSByRef<IEnumMoniker> }): void;
    GetObject(pmkObjectName: IMoniker, ppunkObject: { value: TSByRef<any> }): int;
    GetTimeOfLastChange(pmkObjectName: IMoniker, pfiletime: { value: TSByRef<FILETIME> }): int;
    IsRunning(pmkObjectName: IMoniker): int;
    NoteChangeTime(dwRegister: int, pfiletime: { value: TSByRef<FILETIME> }): void;
    Register(grfFlags: int, punkObject: any, pmkObjectName: IMoniker): int;
    Revoke(dwRegister: int): void;
}


export type IRunningObjectTable = IRunningObjectTable$instance;

export interface IStream$instance {
    Clone(ppstm: { value: TSByRef<IStream> }): void;
    Commit(grfCommitFlags: int): void;
    CopyTo(pstm: IStream, cb: long, pcbRead: nint, pcbWritten: nint): void;
    LockRegion(libOffset: long, cb: long, dwLockType: int): void;
    Read(pv: { value: byte[] }, cb: int, pcbRead: nint): void;
    Revert(): void;
    Seek(dlibMove: long, dwOrigin: int, plibNewPosition: nint): void;
    SetSize(libNewSize: long): void;
    Stat(pstatstg: { value: TSByRef<STATSTG> }, grfStatFlag: int): void;
}


export type IStream = IStream$instance;

export interface ITypeComp$instance {
    Bind(szName: string, lHashVal: int, wFlags: short, ppTInfo: { value: TSByRef<ITypeInfo> }, pDescKind: { value: TSByRef<DESCKIND> }, pBindPtr: { value: TSByRef<BINDPTR> }): void;
    BindType(szName: string, lHashVal: int, ppTInfo: { value: TSByRef<ITypeInfo> }, ppTComp: { value: TSByRef<ITypeComp> }): void;
}


export type ITypeComp = ITypeComp$instance;

export interface ITypeInfo$instance {
    AddressOfMember(memid: int, invKind: INVOKEKIND, ppv: { value: TSByRef<nint> }): void;
    CreateInstance(pUnkOuter: any, riid: { value: TSByRef<Guid> }, ppvObj: { value: TSByRef<any> }): void;
    GetContainingTypeLib(ppTLB: { value: TSByRef<ITypeLib> }, pIndex: { value: TSByRef<int> }): void;
    GetDllEntry(memid: int, invKind: INVOKEKIND, pBstrDllName: nint, pBstrName: nint, pwOrdinal: nint): void;
    GetDocumentation(index: int, strName: { value: TSByRef<string> }, strDocString: { value: TSByRef<string> }, dwHelpContext: { value: TSByRef<int> }, strHelpFile: { value: TSByRef<string> }): void;
    GetFuncDesc(index: int, ppFuncDesc: { value: TSByRef<nint> }): void;
    GetIDsOfNames(rgszNames: string[], cNames: int, pMemId: { value: int[] }): void;
    GetImplTypeFlags(index: int, pImplTypeFlags: { value: TSByRef<IMPLTYPEFLAGS> }): void;
    GetMops(memid: int, pBstrMops: { value: TSByRef<string> }): void;
    GetNames(memid: int, rgBstrNames: { value: string[] }, cMaxNames: int, pcNames: { value: TSByRef<int> }): void;
    GetRefTypeInfo(hRef: int, ppTI: { value: TSByRef<ITypeInfo> }): void;
    GetRefTypeOfImplType(index: int, href: { value: TSByRef<int> }): void;
    GetTypeAttr(ppTypeAttr: { value: TSByRef<nint> }): void;
    GetTypeComp(ppTComp: { value: TSByRef<ITypeComp> }): void;
    Invoke(pvInstance: any, memid: int, wFlags: short, pDispParams: { value: TSByRef<DISPPARAMS> }, pVarResult: nint, pExcepInfo: nint, puArgErr: { value: TSByRef<int> }): void;
    ReleaseTypeAttr(pTypeAttr: nint): void;
}


export type ITypeInfo = ITypeInfo$instance;

export interface ITypeInfo2$instance {
    AddressOfMember(memid: int, invKind: INVOKEKIND, ppv: { value: TSByRef<nint> }): void;
    CreateInstance(pUnkOuter: any, riid: { value: TSByRef<Guid> }, ppvObj: { value: TSByRef<any> }): void;
    GetAllFuncCustData(index: int, pCustData: nint): void;
    GetAllParamCustData(indexFunc: int, indexParam: int, pCustData: nint): void;
    GetContainingTypeLib(ppTLB: { value: TSByRef<ITypeLib> }, pIndex: { value: TSByRef<int> }): void;
    GetCustData(guid: { value: TSByRef<Guid> }, pVarVal: { value: TSByRef<any> }): void;
    GetDllEntry(memid: int, invKind: INVOKEKIND, pBstrDllName: nint, pBstrName: nint, pwOrdinal: nint): void;
    GetDocumentation(index: int, strName: { value: TSByRef<string> }, strDocString: { value: TSByRef<string> }, dwHelpContext: { value: TSByRef<int> }, strHelpFile: { value: TSByRef<string> }): void;
    GetDocumentation2(memid: int, pbstrHelpString: { value: TSByRef<string> }, pdwHelpStringContext: { value: TSByRef<int> }, pbstrHelpStringDll: { value: TSByRef<string> }): void;
    GetFuncCustData(index: int, guid: { value: TSByRef<Guid> }, pVarVal: { value: TSByRef<any> }): void;
    GetFuncDesc(index: int, ppFuncDesc: { value: TSByRef<nint> }): void;
    GetFuncIndexOfMemId(memid: int, invKind: INVOKEKIND, pFuncIndex: { value: TSByRef<int> }): void;
    GetIDsOfNames(rgszNames: string[], cNames: int, pMemId: { value: int[] }): void;
    GetImplTypeFlags(index: int, pImplTypeFlags: { value: TSByRef<IMPLTYPEFLAGS> }): void;
    GetMops(memid: int, pBstrMops: { value: TSByRef<string> }): void;
    GetNames(memid: int, rgBstrNames: { value: string[] }, cMaxNames: int, pcNames: { value: TSByRef<int> }): void;
    GetParamCustData(indexFunc: int, indexParam: int, guid: { value: TSByRef<Guid> }, pVarVal: { value: TSByRef<any> }): void;
    GetRefTypeInfo(hRef: int, ppTI: { value: TSByRef<ITypeInfo> }): void;
    GetRefTypeOfImplType(index: int, href: { value: TSByRef<int> }): void;
    GetTypeAttr(ppTypeAttr: { value: TSByRef<nint> }): void;
    GetTypeComp(ppTComp: { value: TSByRef<ITypeComp> }): void;
    GetTypeFlags(pTypeFlags: { value: TSByRef<int> }): void;
    GetTypeKind(pTypeKind: { value: TSByRef<TYPEKIND> }): void;
    Invoke(pvInstance: any, memid: int, wFlags: short, pDispParams: { value: TSByRef<DISPPARAMS> }, pVarResult: nint, pExcepInfo: nint, puArgErr: { value: TSByRef<int> }): void;
    ReleaseTypeAttr(pTypeAttr: nint): void;
}


export type ITypeInfo2 = ITypeInfo2$instance;

export interface ITypeLib$instance {
    FindName(szNameBuf: string, lHashVal: int, ppTInfo: { value: ITypeInfo[] }, rgMemId: { value: int[] }, pcFound: { value: TSByRef<short> }): void;
    GetDocumentation(index: int, strName: { value: TSByRef<string> }, strDocString: { value: TSByRef<string> }, dwHelpContext: { value: TSByRef<int> }, strHelpFile: { value: TSByRef<string> }): void;
    GetLibAttr(ppTLibAttr: { value: TSByRef<nint> }): void;
    GetTypeComp(ppTComp: { value: TSByRef<ITypeComp> }): void;
    GetTypeInfo(index: int, ppTI: { value: TSByRef<ITypeInfo> }): void;
    GetTypeInfoCount(): int;
    GetTypeInfoOfGuid(guid: { value: TSByRef<Guid> }, ppTInfo: { value: TSByRef<ITypeInfo> }): void;
    GetTypeInfoType(index: int, pTKind: { value: TSByRef<TYPEKIND> }): void;
    IsName(szNameBuf: string, lHashVal: int): boolean;
    ReleaseTLibAttr(pTLibAttr: nint): void;
}


export type ITypeLib = ITypeLib$instance;

export interface ITypeLib2$instance {
    FindName(szNameBuf: string, lHashVal: int, ppTInfo: { value: ITypeInfo[] }, rgMemId: { value: int[] }, pcFound: { value: TSByRef<short> }): void;
    GetCustData(guid: { value: TSByRef<Guid> }, pVarVal: { value: TSByRef<any> }): void;
    GetDocumentation(index: int, strName: { value: TSByRef<string> }, strDocString: { value: TSByRef<string> }, dwHelpContext: { value: TSByRef<int> }, strHelpFile: { value: TSByRef<string> }): void;
    GetDocumentation2(index: int, pbstrHelpString: { value: TSByRef<string> }, pdwHelpStringContext: { value: TSByRef<int> }, pbstrHelpStringDll: { value: TSByRef<string> }): void;
    GetLibAttr(ppTLibAttr: { value: TSByRef<nint> }): void;
    GetLibStatistics(pcUniqueNames: nint, pcchUniqueNames: { value: TSByRef<int> }): void;
    GetTypeComp(ppTComp: { value: TSByRef<ITypeComp> }): void;
    GetTypeInfo(index: int, ppTI: { value: TSByRef<ITypeInfo> }): void;
    GetTypeInfoCount(): int;
    GetTypeInfoOfGuid(guid: { value: TSByRef<Guid> }, ppTInfo: { value: TSByRef<ITypeInfo> }): void;
    GetTypeInfoType(index: int, pTKind: { value: TSByRef<TYPEKIND> }): void;
    IsName(szNameBuf: string, lHashVal: int): boolean;
    ReleaseTLibAttr(pTLibAttr: nint): void;
}


export type ITypeLib2 = ITypeLib2$instance;

export class BIND_OPTS$instance {
    cbStruct: int;
    grfFlags: int;
    grfMode: int;
    dwTickCountDeadline: int;
}


export type BIND_OPTS = BIND_OPTS$instance;

export class BINDPTR$instance {
    lpfuncdesc: nint;
    lpvardesc: nint;
    lptcomp: nint;
}


export type BINDPTR = BINDPTR$instance;

export class CONNECTDATA$instance {
    pUnk: any;
    dwCookie: int;
}


export type CONNECTDATA = CONNECTDATA$instance;

export class DISPPARAMS$instance {
    rgvarg: nint;
    rgdispidNamedArgs: nint;
    cArgs: int;
    cNamedArgs: int;
}


export type DISPPARAMS = DISPPARAMS$instance;

export class ELEMDESC$instance {
    tdesc: TYPEDESC;
    desc: ELEMDESC_DESCUNION;
}


export type ELEMDESC = ELEMDESC$instance;

export class ELEMDESC_DESCUNION$instance {
    idldesc: IDLDESC;
    paramdesc: PARAMDESC;
}


export type ELEMDESC_DESCUNION = ELEMDESC_DESCUNION$instance;

export class EXCEPINFO$instance {
    wCode: short;
    wReserved: short;
    bstrSource: string;
    bstrDescription: string;
    bstrHelpFile: string;
    dwHelpContext: int;
    pvReserved: nint;
    pfnDeferredFillIn: nint;
    scode: int;
}


export type EXCEPINFO = EXCEPINFO$instance;

export class FILETIME$instance {
    dwLowDateTime: int;
    dwHighDateTime: int;
}


export type FILETIME = FILETIME$instance;

export class FORMATETC$instance {
    cfFormat: short;
    ptd: nint;
    dwAspect: DVASPECT;
    lindex: int;
    tymed: TYMED;
}


export type FORMATETC = FORMATETC$instance;

export class FUNCDESC$instance {
    memid: int;
    lprgscode: nint;
    lprgelemdescParam: nint;
    funckind: FUNCKIND;
    invkind: INVOKEKIND;
    callconv: CALLCONV;
    cParams: short;
    cParamsOpt: short;
    oVft: short;
    cScodes: short;
    elemdescFunc: ELEMDESC;
    wFuncFlags: short;
}


export type FUNCDESC = FUNCDESC$instance;

export class IDLDESC$instance {
    dwReserved: nint;
    wIDLFlags: IDLFLAG;
}


export type IDLDESC = IDLDESC$instance;

export class PARAMDESC$instance {
    lpVarValue: nint;
    wParamFlags: PARAMFLAG;
}


export type PARAMDESC = PARAMDESC$instance;

export class STATDATA$instance {
    formatetc: FORMATETC;
    advf: ADVF;
    advSink: IAdviseSink;
    connection: int;
}


export type STATDATA = STATDATA$instance;

export class STATSTG$instance {
    pwcsName: string;
    type_: int;
    cbSize: long;
    mtime: FILETIME;
    ctime: FILETIME;
    atime: FILETIME;
    grfMode: int;
    grfLocksSupported: int;
    clsid: Guid;
    grfStateBits: int;
    reserved: int;
}


export type STATSTG = STATSTG$instance;

export class STGMEDIUM$instance {
    tymed: TYMED;
    unionmember: nint;
    pUnkForRelease: any;
}


export type STGMEDIUM = STGMEDIUM$instance;

export class TYPEATTR$instance {
    guid: Guid;
    lcid: int;
    dwReserved: int;
    memidConstructor: int;
    memidDestructor: int;
    lpstrSchema: nint;
    cbSizeInstance: int;
    typekind: TYPEKIND;
    cFuncs: short;
    cVars: short;
    cImplTypes: short;
    cbSizeVft: short;
    cbAlignment: short;
    wTypeFlags: TYPEFLAGS;
    wMajorVerNum: short;
    wMinorVerNum: short;
    tdescAlias: TYPEDESC;
    idldescType: IDLDESC;
    static readonly MEMBER_ID_NIL: int;
}


export type TYPEATTR = TYPEATTR$instance;

export class TYPEDESC$instance {
    lpValue: nint;
    vt: short;
}


export type TYPEDESC = TYPEDESC$instance;

export class TYPELIBATTR$instance {
    guid: Guid;
    lcid: int;
    syskind: SYSKIND;
    wMajorVerNum: short;
    wMinorVerNum: short;
    wLibFlags: LIBFLAGS;
}


export type TYPELIBATTR = TYPELIBATTR$instance;

export class VARDESC$instance {
    memid: int;
    lpstrSchema: string;
    desc: VARDESC_DESCUNION;
    elemdescVar: ELEMDESC;
    wVarFlags: short;
    varkind: VARKIND;
}


export type VARDESC = VARDESC$instance;

export class VARDESC_DESCUNION$instance {
    oInst: int;
    lpvarValue: nint;
}


export type VARDESC_DESCUNION = VARDESC_DESCUNION$instance;

