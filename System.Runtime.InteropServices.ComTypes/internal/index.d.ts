// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.ComTypes
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Enum, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ADVF {
    advfNodata = 1,
    advfPrimefirst = 2,
    advfOnlyonce = 4,
    advfDataonstop = 64,
    advfcacheNohandler = 8,
    advfcacheForcebuiltin = 16,
    advfcacheOnsave = 32
}


export enum CALLCONV {
    ccCdecl = 1,
    ccMscpascal = 2,
    ccPascal = 2,
    ccMacpascal = 3,
    ccStdcall = 4,
    ccReserved = 5,
    ccSyscall = 6,
    ccMpwcdecl = 7,
    ccMpwpascal = 8,
    ccMax = 9
}


export enum DATADIR {
    datadirGet = 1,
    datadirSet = 2
}


export enum DESCKIND {
    desckindNone = 0,
    desckindFuncdesc = 1,
    desckindVardesc = 2,
    desckindTypecomp = 3,
    desckindImplicitappobj = 4,
    desckindMax = 5
}


export enum DVASPECT {
    dvaspectContent = 1,
    dvaspectThumbnail = 2,
    dvaspectIcon = 4,
    dvaspectDocprint = 8
}


export enum FUNCFLAGS {
    funcflagFrestricted = 1,
    funcflagFsource = 2,
    funcflagFbindable = 4,
    funcflagFrequestedit = 8,
    funcflagFdisplaybind = 16,
    funcflagFdefaultbind = 32,
    funcflagFhidden = 64,
    funcflagFusesgetlasterror = 128,
    funcflagFdefaultcollelem = 256,
    funcflagFuidefault = 512,
    funcflagFnonbrowsable = 1024,
    funcflagFreplaceable = 2048,
    funcflagFimmediatebind = 4096
}


export enum FUNCKIND {
    funcVirtual = 0,
    funcPurevirtual = 1,
    funcNonvirtual = 2,
    funcStatic = 3,
    funcDispatch = 4
}


export enum IDLFLAG {
    idlflagNone = 0,
    idlflagFin = 1,
    idlflagFout = 2,
    idlflagFlcid = 4,
    idlflagFretval = 8
}


export enum IMPLTYPEFLAGS {
    impltypeflagFdefault = 1,
    impltypeflagFsource = 2,
    impltypeflagFrestricted = 4,
    impltypeflagFdefaultvtable = 8
}


export enum INVOKEKIND {
    invokeFunc = 1,
    invokePropertyget = 2,
    invokePropertyput = 4,
    invokePropertyputref = 8
}


export enum LIBFLAGS {
    libflagFrestricted = 1,
    libflagFcontrol = 2,
    libflagFhidden = 4,
    libflagFhasdiskimage = 8
}


export enum PARAMFLAG {
    paramflagNone = 0,
    paramflagFin = 1,
    paramflagFout = 2,
    paramflagFlcid = 4,
    paramflagFretval = 8,
    paramflagFopt = 16,
    paramflagFhasdefault = 32,
    paramflagFhascustdata = 64
}


export enum SYSKIND {
    sysWin16 = 0,
    sysWin32 = 1,
    sysMac = 2,
    sysWin64 = 3
}


export enum TYMED {
    tymedHglobal = 1,
    tymedFile = 2,
    tymedIstream = 4,
    tymedIstorage = 8,
    tymedGdi = 16,
    tymedMfpict = 32,
    tymedEnhmf = 64,
    tymedNull = 0
}


export enum TYPEFLAGS {
    typeflagFappobject = 1,
    typeflagFcancreate = 2,
    typeflagFlicensed = 4,
    typeflagFpredeclid = 8,
    typeflagFhidden = 16,
    typeflagFcontrol = 32,
    typeflagFdual = 64,
    typeflagFnonextensible = 128,
    typeflagFoleautomation = 256,
    typeflagFrestricted = 512,
    typeflagFaggregatable = 1024,
    typeflagFreplaceable = 2048,
    typeflagFdispatchable = 4096,
    typeflagFreversebind = 8192,
    typeflagFproxy = 16384
}


export enum TYPEKIND {
    tkindEnum = 0,
    tkindRecord = 1,
    tkindModule = 2,
    tkindInterface = 3,
    tkindDispatch = 4,
    tkindCoclass = 5,
    tkindAlias = 6,
    tkindUnion = 7,
    tkindMax = 8
}


export enum VARFLAGS {
    varflagFreadonly = 1,
    varflagFsource = 2,
    varflagFbindable = 4,
    varflagFrequestedit = 8,
    varflagFdisplaybind = 16,
    varflagFdefaultbind = 32,
    varflagFhidden = 64,
    varflagFrestricted = 128,
    varflagFdefaultcollelem = 256,
    varflagFuidefault = 512,
    varflagFnonbrowsable = 1024,
    varflagFreplaceable = 2048,
    varflagFimmediatebind = 4096
}


export enum VARKIND {
    varPerinstance = 0,
    varStatic = 1,
    varConst = 2,
    varDispatch = 3
}


export interface IAdviseSink$instance {
    onDataChange(format: { value: ref<FORMATETC> }, stgmedium: { value: ref<STGMEDIUM> }): void;
    onRename(moniker: IMoniker): void;
    onSave(): void;
    onViewChange(aspect: int, index: int): void;
}


export type IAdviseSink = IAdviseSink$instance;

export interface IBindCtx$instance {
    enumObjectParam(ppenum: { value: ref<IEnumString> }): void;
    getObjectParam(pszKey: string, ppunk: { value: ref<unknown> }): void;
    getRunningObjectTable(pprot: { value: ref<IRunningObjectTable> }): void;
    registerObjectBound(punk: unknown): void;
    registerObjectParam(pszKey: string, punk: unknown): void;
    releaseBoundObjects(): void;
    revokeObjectParam(pszKey: string): int;
    setBindOptions(pbindopts: { value: ref<BIND_OPTS> }): void;
}


export type IBindCtx = IBindCtx$instance;

export interface IConnectionPoint$instance {
    advise(pUnkSink: unknown, pdwCookie: { value: ref<int> }): void;
    enumConnections(ppEnum: { value: ref<IEnumConnections> }): void;
    getConnectionInterface(pIID: { value: ref<Guid> }): void;
    getConnectionPointContainer(ppCPC: { value: ref<IConnectionPointContainer> }): void;
    unadvise(dwCookie: int): void;
}


export type IConnectionPoint = IConnectionPoint$instance;

export interface IConnectionPointContainer$instance {
    enumConnectionPoints(ppEnum: { value: ref<IEnumConnectionPoints> }): void;
    findConnectionPoint(riid: { value: ref<Guid> }, ppCP: { value: ref<IConnectionPoint> }): void;
}


export type IConnectionPointContainer = IConnectionPointContainer$instance;

export interface IDataObject$instance {
    dAdvise(pFormatetc: { value: ref<FORMATETC> }, advf: ADVF, adviseSink: IAdviseSink, connection: { value: ref<int> }): int;
    dUnadvise(connection: int): void;
    enumDAdvise(enumAdvise: { value: ref<IEnumSTATDATA> }): int;
    enumFormatEtc(direction: DATADIR): IEnumFORMATETC;
    getCanonicalFormatEtc(formatIn: { value: ref<FORMATETC> }, formatOut: { value: ref<FORMATETC> }): int;
    getData(format: { value: ref<FORMATETC> }, medium: { value: ref<STGMEDIUM> }): void;
    queryGetData(format: { value: ref<FORMATETC> }): int;
    setData(formatIn: { value: ref<FORMATETC> }, medium: { value: ref<STGMEDIUM> }, release: boolean): void;
}


export type IDataObject = IDataObject$instance;

export interface IEnumConnectionPoints$instance {
    clone(ppenum: { value: ref<IEnumConnectionPoints> }): void;
    next(celt: int, rgelt: { value: IConnectionPoint[] }, pceltFetched: nint): int;
    reset(): void;
    skip(celt: int): int;
}


export type IEnumConnectionPoints = IEnumConnectionPoints$instance;

export interface IEnumConnections$instance {
    clone(ppenum: { value: ref<IEnumConnections> }): void;
    next(celt: int, rgelt: { value: CONNECTDATA[] }, pceltFetched: nint): int;
    reset(): void;
    skip(celt: int): int;
}


export type IEnumConnections = IEnumConnections$instance;

export interface IEnumFORMATETC$instance {
    clone(newEnum: { value: ref<IEnumFORMATETC> }): void;
    next(celt: int, rgelt: { value: FORMATETC[] }, pceltFetched: { value: int[] }): int;
    reset(): int;
    skip(celt: int): int;
}


export type IEnumFORMATETC = IEnumFORMATETC$instance;

export interface IEnumMoniker$instance {
    clone(ppenum: { value: ref<IEnumMoniker> }): void;
    next(celt: int, rgelt: { value: IMoniker[] }, pceltFetched: nint): int;
    reset(): void;
    skip(celt: int): int;
}


export type IEnumMoniker = IEnumMoniker$instance;

export interface IEnumSTATDATA$instance {
    clone(newEnum: { value: ref<IEnumSTATDATA> }): void;
    next(celt: int, rgelt: { value: STATDATA[] }, pceltFetched: { value: int[] }): int;
    reset(): int;
    skip(celt: int): int;
}


export type IEnumSTATDATA = IEnumSTATDATA$instance;

export interface IEnumString$instance {
    clone(ppenum: { value: ref<IEnumString> }): void;
    next(celt: int, rgelt: { value: string[] }, pceltFetched: nint): int;
    reset(): void;
    skip(celt: int): int;
}


export type IEnumString = IEnumString$instance;

export interface IEnumVARIANT$instance {
    clone(): IEnumVARIANT;
    next(celt: int, rgVar: { value: unknown[] }, pceltFetched: nint): int;
    reset(): int;
    skip(celt: int): int;
}


export type IEnumVARIANT = IEnumVARIANT$instance;

export interface IMoniker$instance {
    bindToObject(pbc: IBindCtx, pmkToLeft: IMoniker, riidResult: { value: ref<Guid> }, ppvResult: { value: ref<unknown> }): void;
    commonPrefixWith(pmkOther: IMoniker, ppmkPrefix: { value: ref<IMoniker> }): void;
    composeWith(pmkRight: IMoniker, fOnlyIfNotGeneric: boolean, ppmkComposite: { value: ref<IMoniker> }): void;
    enum_(fForward: boolean, ppenumMoniker: { value: ref<IEnumMoniker> }): void;
    getClassID(pClassID: { value: ref<Guid> }): void;
    getDisplayName(pbc: IBindCtx, pmkToLeft: IMoniker, ppszDisplayName: { value: ref<string> }): void;
    getSizeMax(pcbSize: { value: ref<long> }): void;
    getTimeOfLastChange(pbc: IBindCtx, pmkToLeft: IMoniker, pFileTime: { value: ref<FILETIME> }): void;
    hash(pdwHash: { value: ref<int> }): void;
    inverse(ppmk: { value: ref<IMoniker> }): void;
    isDirty(): int;
    isEqual(pmkOtherMoniker: IMoniker): int;
    isRunning(pbc: IBindCtx, pmkToLeft: IMoniker, pmkNewlyRunning: IMoniker): int;
    isSystemMoniker(pdwMksys: { value: ref<int> }): int;
    load(pStm: IStream): void;
    parseDisplayName(pbc: IBindCtx, pmkToLeft: IMoniker, pszDisplayName: string, pchEaten: { value: ref<int> }, ppmkOut: { value: ref<IMoniker> }): void;
    reduce(pbc: IBindCtx, dwReduceHowFar: int, ppmkToLeft: { value: ref<IMoniker> }, ppmkReduced: { value: ref<IMoniker> }): void;
    save(pStm: IStream, fClearDirty: boolean): void;
}


export type IMoniker = IMoniker$instance;

export interface IPersistFile$instance {
    getClassID(pClassID: { value: ref<Guid> }): void;
    getCurFile(ppszFileName: { value: ref<string> }): void;
    isDirty(): int;
    load(pszFileName: string, dwMode: int): void;
    save(pszFileName: string, fRemember: boolean): void;
    saveCompleted(pszFileName: string): void;
}


export type IPersistFile = IPersistFile$instance;

export interface IRunningObjectTable$instance {
    enumRunning(ppenumMoniker: { value: ref<IEnumMoniker> }): void;
    getObject(pmkObjectName: IMoniker, ppunkObject: { value: ref<unknown> }): int;
    getTimeOfLastChange(pmkObjectName: IMoniker, pfiletime: { value: ref<FILETIME> }): int;
    isRunning(pmkObjectName: IMoniker): int;
    noteChangeTime(dwRegister: int, pfiletime: { value: ref<FILETIME> }): void;
    register(grfFlags: int, punkObject: unknown, pmkObjectName: IMoniker): int;
    revoke(dwRegister: int): void;
}


export type IRunningObjectTable = IRunningObjectTable$instance;

export interface IStream$instance {
    clone(ppstm: { value: ref<IStream> }): void;
    commit(grfCommitFlags: int): void;
    copyTo(pstm: IStream, cb: long, pcbRead: nint, pcbWritten: nint): void;
    lockRegion(libOffset: long, cb: long, dwLockType: int): void;
    read(pv: { value: byte[] }, cb: int, pcbRead: nint): void;
    revert(): void;
    seek(dlibMove: long, dwOrigin: int, plibNewPosition: nint): void;
    setSize(libNewSize: long): void;
    stat(pstatstg: { value: ref<STATSTG> }, grfStatFlag: int): void;
}


export type IStream = IStream$instance;

export interface ITypeComp$instance {
    bind(szName: string, lHashVal: int, wFlags: short, ppTInfo: { value: ref<ITypeInfo> }, pDescKind: { value: ref<DESCKIND> }, pBindPtr: { value: ref<BINDPTR> }): void;
    bindType(szName: string, lHashVal: int, ppTInfo: { value: ref<ITypeInfo> }, ppTComp: { value: ref<ITypeComp> }): void;
}


export type ITypeComp = ITypeComp$instance;

export interface ITypeInfo$instance {
    addressOfMember(memid: int, invKind: INVOKEKIND, ppv: { value: ref<nint> }): void;
    createInstance(pUnkOuter: unknown, riid: { value: ref<Guid> }, ppvObj: { value: ref<unknown> }): void;
    getContainingTypeLib(ppTLB: { value: ref<ITypeLib> }, pIndex: { value: ref<int> }): void;
    getDllEntry(memid: int, invKind: INVOKEKIND, pBstrDllName: nint, pBstrName: nint, pwOrdinal: nint): void;
    getDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    getFuncDesc(index: int, ppFuncDesc: { value: ref<nint> }): void;
    getIDsOfNames(rgszNames: string[], cNames: int, pMemId: { value: int[] }): void;
    getImplTypeFlags(index: int, pImplTypeFlags: { value: ref<IMPLTYPEFLAGS> }): void;
    getMops(memid: int, pBstrMops: { value: ref<string> }): void;
    getNames(memid: int, rgBstrNames: { value: string[] }, cMaxNames: int, pcNames: { value: ref<int> }): void;
    getRefTypeInfo(hRef: int, ppTI: { value: ref<ITypeInfo> }): void;
    getRefTypeOfImplType(index: int, href: { value: ref<int> }): void;
    getTypeAttr(ppTypeAttr: { value: ref<nint> }): void;
    getTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    invoke(pvInstance: unknown, memid: int, wFlags: short, pDispParams: { value: ref<DISPPARAMS> }, pVarResult: nint, pExcepInfo: nint, puArgErr: { value: ref<int> }): void;
    releaseTypeAttr(pTypeAttr: nint): void;
}


export type ITypeInfo = ITypeInfo$instance;

export interface ITypeInfo2$instance extends ITypeInfo {
    addressOfMember(memid: int, invKind: INVOKEKIND, ppv: { value: ref<nint> }): void;
    createInstance(pUnkOuter: unknown, riid: { value: ref<Guid> }, ppvObj: { value: ref<unknown> }): void;
    getAllFuncCustData(index: int, pCustData: nint): void;
    getAllParamCustData(indexFunc: int, indexParam: int, pCustData: nint): void;
    getContainingTypeLib(ppTLB: { value: ref<ITypeLib> }, pIndex: { value: ref<int> }): void;
    getCustData(guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    getDllEntry(memid: int, invKind: INVOKEKIND, pBstrDllName: nint, pBstrName: nint, pwOrdinal: nint): void;
    getDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    getDocumentation2(memid: int, pbstrHelpString: { value: ref<string> }, pdwHelpStringContext: { value: ref<int> }, pbstrHelpStringDll: { value: ref<string> }): void;
    getFuncCustData(index: int, guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    getFuncDesc(index: int, ppFuncDesc: { value: ref<nint> }): void;
    getFuncIndexOfMemId(memid: int, invKind: INVOKEKIND, pFuncIndex: { value: ref<int> }): void;
    getIDsOfNames(rgszNames: string[], cNames: int, pMemId: { value: int[] }): void;
    getImplTypeFlags(index: int, pImplTypeFlags: { value: ref<IMPLTYPEFLAGS> }): void;
    getMops(memid: int, pBstrMops: { value: ref<string> }): void;
    getNames(memid: int, rgBstrNames: { value: string[] }, cMaxNames: int, pcNames: { value: ref<int> }): void;
    getParamCustData(indexFunc: int, indexParam: int, guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    getRefTypeInfo(hRef: int, ppTI: { value: ref<ITypeInfo> }): void;
    getRefTypeOfImplType(index: int, href: { value: ref<int> }): void;
    getTypeAttr(ppTypeAttr: { value: ref<nint> }): void;
    getTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    getTypeFlags(pTypeFlags: { value: ref<int> }): void;
    getTypeKind(pTypeKind: { value: ref<TYPEKIND> }): void;
    invoke(pvInstance: unknown, memid: int, wFlags: short, pDispParams: { value: ref<DISPPARAMS> }, pVarResult: nint, pExcepInfo: nint, puArgErr: { value: ref<int> }): void;
    releaseTypeAttr(pTypeAttr: nint): void;
}


export interface ITypeInfo2$instance extends ITypeInfo$instance {}

export type ITypeInfo2 = ITypeInfo2$instance;

export interface ITypeLib$instance {
    findName(szNameBuf: string, lHashVal: int, ppTInfo: { value: ITypeInfo[] }, rgMemId: { value: int[] }, pcFound: { value: ref<short> }): void;
    getDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    getLibAttr(ppTLibAttr: { value: ref<nint> }): void;
    getTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    getTypeInfo(index: int, ppTI: { value: ref<ITypeInfo> }): void;
    getTypeInfoCount(): int;
    getTypeInfoOfGuid(guid: { value: ref<Guid> }, ppTInfo: { value: ref<ITypeInfo> }): void;
    getTypeInfoType(index: int, pTKind: { value: ref<TYPEKIND> }): void;
    isName(szNameBuf: string, lHashVal: int): boolean;
    releaseTLibAttr(pTLibAttr: nint): void;
}


export type ITypeLib = ITypeLib$instance;

export interface ITypeLib2$instance extends ITypeLib {
    findName(szNameBuf: string, lHashVal: int, ppTInfo: { value: ITypeInfo[] }, rgMemId: { value: int[] }, pcFound: { value: ref<short> }): void;
    getCustData(guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    getDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    getDocumentation2(index: int, pbstrHelpString: { value: ref<string> }, pdwHelpStringContext: { value: ref<int> }, pbstrHelpStringDll: { value: ref<string> }): void;
    getLibAttr(ppTLibAttr: { value: ref<nint> }): void;
    getLibStatistics(pcUniqueNames: nint, pcchUniqueNames: { value: ref<int> }): void;
    getTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    getTypeInfo(index: int, ppTI: { value: ref<ITypeInfo> }): void;
    getTypeInfoCount(): int;
    getTypeInfoOfGuid(guid: { value: ref<Guid> }, ppTInfo: { value: ref<ITypeInfo> }): void;
    getTypeInfoType(index: int, pTKind: { value: ref<TYPEKIND> }): void;
    isName(szNameBuf: string, lHashVal: int): boolean;
    releaseTLibAttr(pTLibAttr: nint): void;
}


export interface ITypeLib2$instance extends ITypeLib$instance {}

export type ITypeLib2 = ITypeLib2$instance;

export class BIND_OPTS$instance {
    cbStruct: int;
    grfFlags: int;
    grfMode: int;
    dwTickCountDeadline: int;
}


export type BIND_OPTS = BIND_OPTS$instance;

export class BINDPTR$instance {
    lpfuncdesc: nint;
    lpvardesc: nint;
    lptcomp: nint;
}


export type BINDPTR = BINDPTR$instance;

export class CONNECTDATA$instance {
    pUnk: unknown;
    dwCookie: int;
}


export type CONNECTDATA = CONNECTDATA$instance;

export class DISPPARAMS$instance {
    rgvarg: nint;
    rgdispidNamedArgs: nint;
    cArgs: int;
    cNamedArgs: int;
}


export type DISPPARAMS = DISPPARAMS$instance;

export class ELEMDESC$instance {
    tdesc: TYPEDESC;
    desc: ELEMDESC_DESCUNION;
}


export type ELEMDESC = ELEMDESC$instance;

export class ELEMDESC_DESCUNION$instance {
    idldesc: IDLDESC;
    paramdesc: PARAMDESC;
}


export type ELEMDESC_DESCUNION = ELEMDESC_DESCUNION$instance;

export class EXCEPINFO$instance {
    wCode: short;
    wReserved: short;
    bstrSource: string;
    bstrDescription: string;
    bstrHelpFile: string;
    dwHelpContext: int;
    pvReserved: nint;
    pfnDeferredFillIn: nint;
    scode: int;
}


export type EXCEPINFO = EXCEPINFO$instance;

export class FILETIME$instance {
    dwLowDateTime: int;
    dwHighDateTime: int;
}


export type FILETIME = FILETIME$instance;

export class FORMATETC$instance {
    cfFormat: short;
    ptd: nint;
    dwAspect: DVASPECT;
    lindex: int;
    tymed: TYMED;
}


export type FORMATETC = FORMATETC$instance;

export class FUNCDESC$instance {
    memid: int;
    lprgscode: nint;
    lprgelemdescParam: nint;
    funckind: FUNCKIND;
    invkind: INVOKEKIND;
    callconv: CALLCONV;
    cParams: short;
    cParamsOpt: short;
    oVft: short;
    cScodes: short;
    elemdescFunc: ELEMDESC;
    wFuncFlags: short;
}


export type FUNCDESC = FUNCDESC$instance;

export class IDLDESC$instance {
    dwReserved: nint;
    wIDLFlags: IDLFLAG;
}


export type IDLDESC = IDLDESC$instance;

export class PARAMDESC$instance {
    lpVarValue: nint;
    wParamFlags: PARAMFLAG;
}


export type PARAMDESC = PARAMDESC$instance;

export class STATDATA$instance {
    formatetc: FORMATETC;
    advf: ADVF;
    advSink: IAdviseSink;
    connection: int;
}


export type STATDATA = STATDATA$instance;

export class STATSTG$instance {
    pwcsName: string;
    type_: int;
    cbSize: long;
    mtime: FILETIME;
    ctime: FILETIME;
    atime: FILETIME;
    grfMode: int;
    grfLocksSupported: int;
    clsid: Guid;
    grfStateBits: int;
    reserved: int;
}


export type STATSTG = STATSTG$instance;

export class STGMEDIUM$instance {
    tymed: TYMED;
    unionmember: nint;
    pUnkForRelease: unknown;
}


export type STGMEDIUM = STGMEDIUM$instance;

export class TYPEATTR$instance {
    guid: Guid;
    lcid: int;
    dwReserved: int;
    memidConstructor: int;
    memidDestructor: int;
    lpstrSchema: nint;
    cbSizeInstance: int;
    typekind: TYPEKIND;
    cFuncs: short;
    cVars: short;
    cImplTypes: short;
    cbSizeVft: short;
    cbAlignment: short;
    wTypeFlags: TYPEFLAGS;
    wMajorVerNum: short;
    wMinorVerNum: short;
    tdescAlias: TYPEDESC;
    idldescType: IDLDESC;
    static readonly memberIdNil: int;
}


export type TYPEATTR = TYPEATTR$instance;

export class TYPEDESC$instance {
    lpValue: nint;
    vt: short;
}


export type TYPEDESC = TYPEDESC$instance;

export class TYPELIBATTR$instance {
    guid: Guid;
    lcid: int;
    syskind: SYSKIND;
    wMajorVerNum: short;
    wMinorVerNum: short;
    wLibFlags: LIBFLAGS;
}


export type TYPELIBATTR = TYPELIBATTR$instance;

export class VARDESC$instance {
    memid: int;
    lpstrSchema: string;
    desc: VARDESC_DESCUNION;
    elemdescVar: ELEMDESC;
    wVarFlags: short;
    varkind: VARKIND;
}


export type VARDESC = VARDESC$instance;

export class VARDESC_DESCUNION$instance {
    oInst: int;
    lpvarValue: nint;
}


export type VARDESC_DESCUNION = VARDESC_DESCUNION$instance;

