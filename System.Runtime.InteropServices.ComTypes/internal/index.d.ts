// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.ComTypes
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Enum, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ADVF {
    advf_nodata = 1,
    advf_primefirst = 2,
    advf_onlyonce = 4,
    advf_dataonstop = 64,
    advfcache_nohandler = 8,
    advfcache_forcebuiltin = 16,
    advfcache_onsave = 32
}


export enum CALLCONV {
    cc_cdecl = 1,
    cc_mscpascal = 2,
    cc_pascal = 2,
    cc_macpascal = 3,
    cc_stdcall = 4,
    cc_reserved = 5,
    cc_syscall = 6,
    cc_mpwcdecl = 7,
    cc_mpwpascal = 8,
    cc_max = 9
}


export enum DATADIR {
    datadir_get = 1,
    datadir_set = 2
}


export enum DESCKIND {
    desckind_none = 0,
    desckind_funcdesc = 1,
    desckind_vardesc = 2,
    desckind_typecomp = 3,
    desckind_implicitappobj = 4,
    desckind_max = 5
}


export enum DVASPECT {
    dvaspect_content = 1,
    dvaspect_thumbnail = 2,
    dvaspect_icon = 4,
    dvaspect_docprint = 8
}


export enum FUNCFLAGS {
    funcflag_frestricted = 1,
    funcflag_fsource = 2,
    funcflag_fbindable = 4,
    funcflag_frequestedit = 8,
    funcflag_fdisplaybind = 16,
    funcflag_fdefaultbind = 32,
    funcflag_fhidden = 64,
    funcflag_fusesgetlasterror = 128,
    funcflag_fdefaultcollelem = 256,
    funcflag_fuidefault = 512,
    funcflag_fnonbrowsable = 1024,
    funcflag_freplaceable = 2048,
    funcflag_fimmediatebind = 4096
}


export enum FUNCKIND {
    func_virtual = 0,
    func_purevirtual = 1,
    func_nonvirtual = 2,
    func_static = 3,
    func_dispatch = 4
}


export enum IDLFLAG {
    idlflag_none = 0,
    idlflag_fin = 1,
    idlflag_fout = 2,
    idlflag_flcid = 4,
    idlflag_fretval = 8
}


export enum IMPLTYPEFLAGS {
    impltypeflag_fdefault = 1,
    impltypeflag_fsource = 2,
    impltypeflag_frestricted = 4,
    impltypeflag_fdefaultvtable = 8
}


export enum INVOKEKIND {
    invoke_func = 1,
    invoke_propertyget = 2,
    invoke_propertyput = 4,
    invoke_propertyputref = 8
}


export enum LIBFLAGS {
    libflag_frestricted = 1,
    libflag_fcontrol = 2,
    libflag_fhidden = 4,
    libflag_fhasdiskimage = 8
}


export enum PARAMFLAG {
    paramflag_none = 0,
    paramflag_fin = 1,
    paramflag_fout = 2,
    paramflag_flcid = 4,
    paramflag_fretval = 8,
    paramflag_fopt = 16,
    paramflag_fhasdefault = 32,
    paramflag_fhascustdata = 64
}


export enum SYSKIND {
    sys_win16 = 0,
    sys_win32 = 1,
    sys_mac = 2,
    sys_win64 = 3
}


export enum TYMED {
    tymed_hglobal = 1,
    tymed_file = 2,
    tymed_istream = 4,
    tymed_istorage = 8,
    tymed_gdi = 16,
    tymed_mfpict = 32,
    tymed_enhmf = 64,
    tymed_null = 0
}


export enum TYPEFLAGS {
    typeflag_fappobject = 1,
    typeflag_fcancreate = 2,
    typeflag_flicensed = 4,
    typeflag_fpredeclid = 8,
    typeflag_fhidden = 16,
    typeflag_fcontrol = 32,
    typeflag_fdual = 64,
    typeflag_fnonextensible = 128,
    typeflag_foleautomation = 256,
    typeflag_frestricted = 512,
    typeflag_faggregatable = 1024,
    typeflag_freplaceable = 2048,
    typeflag_fdispatchable = 4096,
    typeflag_freversebind = 8192,
    typeflag_fproxy = 16384
}


export enum TYPEKIND {
    tkind_enum = 0,
    tkind_record = 1,
    tkind_module = 2,
    tkind_interface = 3,
    tkind_dispatch = 4,
    tkind_coclass = 5,
    tkind_alias = 6,
    tkind_union = 7,
    tkind_max = 8
}


export enum VARFLAGS {
    varflag_freadonly = 1,
    varflag_fsource = 2,
    varflag_fbindable = 4,
    varflag_frequestedit = 8,
    varflag_fdisplaybind = 16,
    varflag_fdefaultbind = 32,
    varflag_fhidden = 64,
    varflag_frestricted = 128,
    varflag_fdefaultcollelem = 256,
    varflag_fuidefault = 512,
    varflag_fnonbrowsable = 1024,
    varflag_freplaceable = 2048,
    varflag_fimmediatebind = 4096
}


export enum VARKIND {
    var_perinstance = 0,
    var_static = 1,
    var_const = 2,
    var_dispatch = 3
}


export interface IAdviseSink$instance {
    OnDataChange(format: { value: ref<FORMATETC> }, stgmedium: { value: ref<STGMEDIUM> }): void;
    OnRename(moniker: IMoniker): void;
    OnSave(): void;
    OnViewChange(aspect: int, index: int): void;
}


export type IAdviseSink = IAdviseSink$instance;

export interface IBindCtx$instance {
    EnumObjectParam(ppenum: { value: ref<IEnumString> }): void;
    GetObjectParam(pszKey: string, ppunk: { value: ref<unknown> }): void;
    GetRunningObjectTable(pprot: { value: ref<IRunningObjectTable> }): void;
    RegisterObjectBound(punk: unknown): void;
    RegisterObjectParam(pszKey: string, punk: unknown): void;
    ReleaseBoundObjects(): void;
    RevokeObjectParam(pszKey: string): int;
    SetBindOptions(pbindopts: { value: ref<BIND_OPTS> }): void;
}


export type IBindCtx = IBindCtx$instance;

export interface IConnectionPoint$instance {
    Advise(pUnkSink: unknown, pdwCookie: { value: ref<int> }): void;
    EnumConnections(ppEnum: { value: ref<IEnumConnections> }): void;
    GetConnectionInterface(pIID: { value: ref<Guid> }): void;
    GetConnectionPointContainer(ppCPC: { value: ref<IConnectionPointContainer> }): void;
    Unadvise(dwCookie: int): void;
}


export type IConnectionPoint = IConnectionPoint$instance;

export interface IConnectionPointContainer$instance {
    EnumConnectionPoints(ppEnum: { value: ref<IEnumConnectionPoints> }): void;
    FindConnectionPoint(riid: { value: ref<Guid> }, ppCP: { value: ref<IConnectionPoint> }): void;
}


export type IConnectionPointContainer = IConnectionPointContainer$instance;

export interface IDataObject$instance {
    DAdvise(pFormatetc: { value: ref<FORMATETC> }, advf: ADVF, adviseSink: IAdviseSink, connection: { value: ref<int> }): int;
    DUnadvise(connection: int): void;
    EnumDAdvise(enumAdvise: { value: ref<IEnumSTATDATA> }): int;
    EnumFormatEtc(direction: DATADIR): IEnumFORMATETC;
    GetCanonicalFormatEtc(formatIn: { value: ref<FORMATETC> }, formatOut: { value: ref<FORMATETC> }): int;
    GetData(format: { value: ref<FORMATETC> }, medium: { value: ref<STGMEDIUM> }): void;
    QueryGetData(format: { value: ref<FORMATETC> }): int;
    SetData(formatIn: { value: ref<FORMATETC> }, medium: { value: ref<STGMEDIUM> }, release: boolean): void;
}


export type IDataObject = IDataObject$instance;

export interface IEnumConnectionPoints$instance {
    Clone(ppenum: { value: ref<IEnumConnectionPoints> }): void;
    Next(celt: int, rgelt: { value: IConnectionPoint[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumConnectionPoints = IEnumConnectionPoints$instance;

export interface IEnumConnections$instance {
    Clone(ppenum: { value: ref<IEnumConnections> }): void;
    Next(celt: int, rgelt: { value: CONNECTDATA[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumConnections = IEnumConnections$instance;

export interface IEnumFORMATETC$instance {
    Clone(newEnum: { value: ref<IEnumFORMATETC> }): void;
    Next(celt: int, rgelt: { value: FORMATETC[] }, pceltFetched: { value: int[] }): int;
    Reset(): int;
    Skip(celt: int): int;
}


export type IEnumFORMATETC = IEnumFORMATETC$instance;

export interface IEnumMoniker$instance {
    Clone(ppenum: { value: ref<IEnumMoniker> }): void;
    Next(celt: int, rgelt: { value: IMoniker[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumMoniker = IEnumMoniker$instance;

export interface IEnumSTATDATA$instance {
    Clone(newEnum: { value: ref<IEnumSTATDATA> }): void;
    Next(celt: int, rgelt: { value: STATDATA[] }, pceltFetched: { value: int[] }): int;
    Reset(): int;
    Skip(celt: int): int;
}


export type IEnumSTATDATA = IEnumSTATDATA$instance;

export interface IEnumString$instance {
    Clone(ppenum: { value: ref<IEnumString> }): void;
    Next(celt: int, rgelt: { value: string[] }, pceltFetched: nint): int;
    Reset(): void;
    Skip(celt: int): int;
}


export type IEnumString = IEnumString$instance;

export interface IEnumVARIANT$instance {
    Clone(): IEnumVARIANT;
    Next(celt: int, rgVar: { value: unknown[] }, pceltFetched: nint): int;
    Reset(): int;
    Skip(celt: int): int;
}


export type IEnumVARIANT = IEnumVARIANT$instance;

export interface IMoniker$instance {
    BindToObject(pbc: IBindCtx, pmkToLeft: IMoniker, riidResult: { value: ref<Guid> }, ppvResult: { value: ref<unknown> }): void;
    CommonPrefixWith(pmkOther: IMoniker, ppmkPrefix: { value: ref<IMoniker> }): void;
    ComposeWith(pmkRight: IMoniker, fOnlyIfNotGeneric: boolean, ppmkComposite: { value: ref<IMoniker> }): void;
    Enum(fForward: boolean, ppenumMoniker: { value: ref<IEnumMoniker> }): void;
    GetClassID(pClassID: { value: ref<Guid> }): void;
    GetDisplayName(pbc: IBindCtx, pmkToLeft: IMoniker, ppszDisplayName: { value: ref<string> }): void;
    GetSizeMax(pcbSize: { value: ref<long> }): void;
    GetTimeOfLastChange(pbc: IBindCtx, pmkToLeft: IMoniker, pFileTime: { value: ref<FILETIME> }): void;
    Hash(pdwHash: { value: ref<int> }): void;
    Inverse(ppmk: { value: ref<IMoniker> }): void;
    IsDirty(): int;
    IsEqual(pmkOtherMoniker: IMoniker): int;
    IsRunning(pbc: IBindCtx, pmkToLeft: IMoniker, pmkNewlyRunning: IMoniker): int;
    IsSystemMoniker(pdwMksys: { value: ref<int> }): int;
    Load(pStm: IStream): void;
    ParseDisplayName(pbc: IBindCtx, pmkToLeft: IMoniker, pszDisplayName: string, pchEaten: { value: ref<int> }, ppmkOut: { value: ref<IMoniker> }): void;
    Reduce(pbc: IBindCtx, dwReduceHowFar: int, ppmkToLeft: { value: ref<IMoniker> }, ppmkReduced: { value: ref<IMoniker> }): void;
    Save(pStm: IStream, fClearDirty: boolean): void;
}


export type IMoniker = IMoniker$instance;

export interface IPersistFile$instance {
    GetClassID(pClassID: { value: ref<Guid> }): void;
    GetCurFile(ppszFileName: { value: ref<string> }): void;
    IsDirty(): int;
    Load(pszFileName: string, dwMode: int): void;
    Save(pszFileName: string, fRemember: boolean): void;
    SaveCompleted(pszFileName: string): void;
}


export type IPersistFile = IPersistFile$instance;

export interface IRunningObjectTable$instance {
    EnumRunning(ppenumMoniker: { value: ref<IEnumMoniker> }): void;
    GetObject(pmkObjectName: IMoniker, ppunkObject: { value: ref<unknown> }): int;
    GetTimeOfLastChange(pmkObjectName: IMoniker, pfiletime: { value: ref<FILETIME> }): int;
    IsRunning(pmkObjectName: IMoniker): int;
    NoteChangeTime(dwRegister: int, pfiletime: { value: ref<FILETIME> }): void;
    Register(grfFlags: int, punkObject: unknown, pmkObjectName: IMoniker): int;
    Revoke(dwRegister: int): void;
}


export type IRunningObjectTable = IRunningObjectTable$instance;

export interface IStream$instance {
    Clone(ppstm: { value: ref<IStream> }): void;
    Commit(grfCommitFlags: int): void;
    CopyTo(pstm: IStream, cb: long, pcbRead: nint, pcbWritten: nint): void;
    LockRegion(libOffset: long, cb: long, dwLockType: int): void;
    Read(pv: { value: byte[] }, cb: int, pcbRead: nint): void;
    Revert(): void;
    Seek(dlibMove: long, dwOrigin: int, plibNewPosition: nint): void;
    SetSize(libNewSize: long): void;
    Stat(pstatstg: { value: ref<STATSTG> }, grfStatFlag: int): void;
}


export type IStream = IStream$instance;

export interface ITypeComp$instance {
    Bind(szName: string, lHashVal: int, wFlags: short, ppTInfo: { value: ref<ITypeInfo> }, pDescKind: { value: ref<DESCKIND> }, pBindPtr: { value: ref<BINDPTR> }): void;
    BindType(szName: string, lHashVal: int, ppTInfo: { value: ref<ITypeInfo> }, ppTComp: { value: ref<ITypeComp> }): void;
}


export type ITypeComp = ITypeComp$instance;

export interface ITypeInfo$instance {
    AddressOfMember(memid: int, invKind: INVOKEKIND, ppv: { value: ref<nint> }): void;
    CreateInstance(pUnkOuter: unknown, riid: { value: ref<Guid> }, ppvObj: { value: ref<unknown> }): void;
    GetContainingTypeLib(ppTLB: { value: ref<ITypeLib> }, pIndex: { value: ref<int> }): void;
    GetDllEntry(memid: int, invKind: INVOKEKIND, pBstrDllName: nint, pBstrName: nint, pwOrdinal: nint): void;
    GetDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    GetFuncDesc(index: int, ppFuncDesc: { value: ref<nint> }): void;
    GetIDsOfNames(rgszNames: string[], cNames: int, pMemId: { value: int[] }): void;
    GetImplTypeFlags(index: int, pImplTypeFlags: { value: ref<IMPLTYPEFLAGS> }): void;
    GetMops(memid: int, pBstrMops: { value: ref<string> }): void;
    GetNames(memid: int, rgBstrNames: { value: string[] }, cMaxNames: int, pcNames: { value: ref<int> }): void;
    GetRefTypeInfo(hRef: int, ppTI: { value: ref<ITypeInfo> }): void;
    GetRefTypeOfImplType(index: int, href: { value: ref<int> }): void;
    GetTypeAttr(ppTypeAttr: { value: ref<nint> }): void;
    GetTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    Invoke(pvInstance: unknown, memid: int, wFlags: short, pDispParams: { value: ref<DISPPARAMS> }, pVarResult: nint, pExcepInfo: nint, puArgErr: { value: ref<int> }): void;
    ReleaseTypeAttr(pTypeAttr: nint): void;
}


export type ITypeInfo = ITypeInfo$instance;

export interface ITypeInfo2$instance {
    AddressOfMember(memid: int, invKind: INVOKEKIND, ppv: { value: ref<nint> }): void;
    CreateInstance(pUnkOuter: unknown, riid: { value: ref<Guid> }, ppvObj: { value: ref<unknown> }): void;
    GetAllFuncCustData(index: int, pCustData: nint): void;
    GetAllParamCustData(indexFunc: int, indexParam: int, pCustData: nint): void;
    GetContainingTypeLib(ppTLB: { value: ref<ITypeLib> }, pIndex: { value: ref<int> }): void;
    GetCustData(guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    GetDllEntry(memid: int, invKind: INVOKEKIND, pBstrDllName: nint, pBstrName: nint, pwOrdinal: nint): void;
    GetDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    GetDocumentation2(memid: int, pbstrHelpString: { value: ref<string> }, pdwHelpStringContext: { value: ref<int> }, pbstrHelpStringDll: { value: ref<string> }): void;
    GetFuncCustData(index: int, guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    GetFuncDesc(index: int, ppFuncDesc: { value: ref<nint> }): void;
    GetFuncIndexOfMemId(memid: int, invKind: INVOKEKIND, pFuncIndex: { value: ref<int> }): void;
    GetIDsOfNames(rgszNames: string[], cNames: int, pMemId: { value: int[] }): void;
    GetImplTypeFlags(index: int, pImplTypeFlags: { value: ref<IMPLTYPEFLAGS> }): void;
    GetMops(memid: int, pBstrMops: { value: ref<string> }): void;
    GetNames(memid: int, rgBstrNames: { value: string[] }, cMaxNames: int, pcNames: { value: ref<int> }): void;
    GetParamCustData(indexFunc: int, indexParam: int, guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    GetRefTypeInfo(hRef: int, ppTI: { value: ref<ITypeInfo> }): void;
    GetRefTypeOfImplType(index: int, href: { value: ref<int> }): void;
    GetTypeAttr(ppTypeAttr: { value: ref<nint> }): void;
    GetTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    GetTypeFlags(pTypeFlags: { value: ref<int> }): void;
    GetTypeKind(pTypeKind: { value: ref<TYPEKIND> }): void;
    Invoke(pvInstance: unknown, memid: int, wFlags: short, pDispParams: { value: ref<DISPPARAMS> }, pVarResult: nint, pExcepInfo: nint, puArgErr: { value: ref<int> }): void;
    ReleaseTypeAttr(pTypeAttr: nint): void;
}


export type ITypeInfo2 = ITypeInfo2$instance;

export interface ITypeLib$instance {
    FindName(szNameBuf: string, lHashVal: int, ppTInfo: { value: ITypeInfo[] }, rgMemId: { value: int[] }, pcFound: { value: ref<short> }): void;
    GetDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    GetLibAttr(ppTLibAttr: { value: ref<nint> }): void;
    GetTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    GetTypeInfo(index: int, ppTI: { value: ref<ITypeInfo> }): void;
    GetTypeInfoCount(): int;
    GetTypeInfoOfGuid(guid: { value: ref<Guid> }, ppTInfo: { value: ref<ITypeInfo> }): void;
    GetTypeInfoType(index: int, pTKind: { value: ref<TYPEKIND> }): void;
    IsName(szNameBuf: string, lHashVal: int): boolean;
    ReleaseTLibAttr(pTLibAttr: nint): void;
}


export type ITypeLib = ITypeLib$instance;

export interface ITypeLib2$instance {
    FindName(szNameBuf: string, lHashVal: int, ppTInfo: { value: ITypeInfo[] }, rgMemId: { value: int[] }, pcFound: { value: ref<short> }): void;
    GetCustData(guid: { value: ref<Guid> }, pVarVal: { value: ref<unknown> }): void;
    GetDocumentation(index: int, strName: { value: ref<string> }, strDocString: { value: ref<string> }, dwHelpContext: { value: ref<int> }, strHelpFile: { value: ref<string> }): void;
    GetDocumentation2(index: int, pbstrHelpString: { value: ref<string> }, pdwHelpStringContext: { value: ref<int> }, pbstrHelpStringDll: { value: ref<string> }): void;
    GetLibAttr(ppTLibAttr: { value: ref<nint> }): void;
    GetLibStatistics(pcUniqueNames: nint, pcchUniqueNames: { value: ref<int> }): void;
    GetTypeComp(ppTComp: { value: ref<ITypeComp> }): void;
    GetTypeInfo(index: int, ppTI: { value: ref<ITypeInfo> }): void;
    GetTypeInfoCount(): int;
    GetTypeInfoOfGuid(guid: { value: ref<Guid> }, ppTInfo: { value: ref<ITypeInfo> }): void;
    GetTypeInfoType(index: int, pTKind: { value: ref<TYPEKIND> }): void;
    IsName(szNameBuf: string, lHashVal: int): boolean;
    ReleaseTLibAttr(pTLibAttr: nint): void;
}


export type ITypeLib2 = ITypeLib2$instance;

export class BIND_OPTS$instance {
    cbStruct: int;
    grfFlags: int;
    grfMode: int;
    dwTickCountDeadline: int;
}


export type BIND_OPTS = BIND_OPTS$instance;

export class BINDPTR$instance {
    lpfuncdesc: nint;
    lpvardesc: nint;
    lptcomp: nint;
}


export type BINDPTR = BINDPTR$instance;

export class CONNECTDATA$instance {
    pUnk: unknown;
    dwCookie: int;
}


export type CONNECTDATA = CONNECTDATA$instance;

export class DISPPARAMS$instance {
    rgvarg: nint;
    rgdispidNamedArgs: nint;
    cArgs: int;
    cNamedArgs: int;
}


export type DISPPARAMS = DISPPARAMS$instance;

export class ELEMDESC$instance {
    tdesc: TYPEDESC;
    desc: ELEMDESC_DESCUNION;
}


export type ELEMDESC = ELEMDESC$instance;

export class ELEMDESC_DESCUNION$instance {
    idldesc: IDLDESC;
    paramdesc: PARAMDESC;
}


export type ELEMDESC_DESCUNION = ELEMDESC_DESCUNION$instance;

export class EXCEPINFO$instance {
    wCode: short;
    wReserved: short;
    bstrSource: string;
    bstrDescription: string;
    bstrHelpFile: string;
    dwHelpContext: int;
    pvReserved: nint;
    pfnDeferredFillIn: nint;
    scode: int;
}


export type EXCEPINFO = EXCEPINFO$instance;

export class FILETIME$instance {
    dwLowDateTime: int;
    dwHighDateTime: int;
}


export type FILETIME = FILETIME$instance;

export class FORMATETC$instance {
    cfFormat: short;
    ptd: nint;
    dwAspect: DVASPECT;
    lindex: int;
    tymed: TYMED;
}


export type FORMATETC = FORMATETC$instance;

export class FUNCDESC$instance {
    memid: int;
    lprgscode: nint;
    lprgelemdescParam: nint;
    funckind: FUNCKIND;
    invkind: INVOKEKIND;
    callconv: CALLCONV;
    cParams: short;
    cParamsOpt: short;
    oVft: short;
    cScodes: short;
    elemdescFunc: ELEMDESC;
    wFuncFlags: short;
}


export type FUNCDESC = FUNCDESC$instance;

export class IDLDESC$instance {
    dwReserved: nint;
    wIDLFlags: IDLFLAG;
}


export type IDLDESC = IDLDESC$instance;

export class PARAMDESC$instance {
    lpVarValue: nint;
    wParamFlags: PARAMFLAG;
}


export type PARAMDESC = PARAMDESC$instance;

export class STATDATA$instance {
    formatetc: FORMATETC;
    advf: ADVF;
    advSink: IAdviseSink;
    connection: int;
}


export type STATDATA = STATDATA$instance;

export class STATSTG$instance {
    pwcsName: string;
    type_: int;
    cbSize: long;
    mtime: FILETIME;
    ctime: FILETIME;
    atime: FILETIME;
    grfMode: int;
    grfLocksSupported: int;
    clsid: Guid;
    grfStateBits: int;
    reserved: int;
}


export type STATSTG = STATSTG$instance;

export class STGMEDIUM$instance {
    tymed: TYMED;
    unionmember: nint;
    pUnkForRelease: unknown;
}


export type STGMEDIUM = STGMEDIUM$instance;

export class TYPEATTR$instance {
    guid: Guid;
    lcid: int;
    dwReserved: int;
    memidConstructor: int;
    memidDestructor: int;
    lpstrSchema: nint;
    cbSizeInstance: int;
    typekind: TYPEKIND;
    cFuncs: short;
    cVars: short;
    cImplTypes: short;
    cbSizeVft: short;
    cbAlignment: short;
    wTypeFlags: TYPEFLAGS;
    wMajorVerNum: short;
    wMinorVerNum: short;
    tdescAlias: TYPEDESC;
    idldescType: IDLDESC;
    static readonly MEMBER_ID_NIL: int;
}


export type TYPEATTR = TYPEATTR$instance;

export class TYPEDESC$instance {
    lpValue: nint;
    vt: short;
}


export type TYPEDESC = TYPEDESC$instance;

export class TYPELIBATTR$instance {
    guid: Guid;
    lcid: int;
    syskind: SYSKIND;
    wMajorVerNum: short;
    wMinorVerNum: short;
    wLibFlags: LIBFLAGS;
}


export type TYPELIBATTR = TYPELIBATTR$instance;

export class VARDESC$instance {
    memid: int;
    lpstrSchema: string;
    desc: VARDESC_DESCUNION;
    elemdescVar: ELEMDESC;
    wVarFlags: short;
    varkind: VARKIND;
}


export type VARDESC = VARDESC$instance;

export class VARDESC_DESCUNION$instance {
    oInst: int;
    lpvarValue: nint;
}


export type VARDESC_DESCUNION = VARDESC_DESCUNION$instance;

