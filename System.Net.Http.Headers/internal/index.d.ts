// Generated by tsbindgen - Architecture
// Namespace: System.Net.Http.Headers
// Assembly: System.Net.Http

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Double, ICloneable, IDisposable, Int32, Int64, Nullable_1, Object as ClrObject, String as ClrString, TimeSpan, Type, Uri, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export class HeaderStringValues$instance {
    readonly Count: int;
    GetEnumerator(): HeaderStringValues_Enumerator;
    ToString(): string;
}


export interface __HeaderStringValues$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<CLROf<string>>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CLROf<string>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HeaderStringValues = HeaderStringValues$instance & __HeaderStringValues$views;


export class HeaderStringValues_Enumerator$instance {
    readonly Current: string;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __HeaderStringValues_Enumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<CLROf<string>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type HeaderStringValues_Enumerator = HeaderStringValues_Enumerator$instance & __HeaderStringValues_Enumerator$views;


export class HttpHeadersNonValidated$instance {
    readonly Count: int;
    readonly Item: HeaderStringValues;
    Contains(headerName: string): boolean;
    GetEnumerator(): HttpHeadersNonValidated_Enumerator;
    TryGetValues(headerName: string, values: { value: TSByRef<HeaderStringValues> }): boolean;
}


export interface __HttpHeadersNonValidated$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, HeaderStringValues>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<CLROf<string>, HeaderStringValues>>;
    readonly As_IReadOnlyDictionary_2: System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<CLROf<string>, HeaderStringValues>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeadersNonValidated = HttpHeadersNonValidated$instance & __HttpHeadersNonValidated$views;


export class HttpHeadersNonValidated_Enumerator$instance {
    readonly Current: KeyValuePair_2<CLROf<string>, HeaderStringValues>;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __HttpHeadersNonValidated_Enumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, HeaderStringValues>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type HttpHeadersNonValidated_Enumerator = HttpHeadersNonValidated_Enumerator$instance & __HttpHeadersNonValidated_Enumerator$views;


export class AuthenticationHeaderValue$instance {
    constructor(scheme: string);
    constructor(scheme: string, parameter: string);
    readonly Parameter: string;
    readonly Scheme: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): AuthenticationHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<AuthenticationHeaderValue> }): boolean;
}


export interface __AuthenticationHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type AuthenticationHeaderValue = AuthenticationHeaderValue$instance & __AuthenticationHeaderValue$views;


export class CacheControlHeaderValue$instance {
    constructor();
    readonly Extensions: ICollection_1<NameValueHeaderValue>;
    MaxAge: Nullable_1<TimeSpan>;
    MaxStale: boolean;
    MaxStaleLimit: Nullable_1<TimeSpan>;
    MinFresh: Nullable_1<TimeSpan>;
    MustRevalidate: boolean;
    NoCache: boolean;
    readonly NoCacheHeaders: ICollection_1<CLROf<string>>;
    NoStore: boolean;
    NoTransform: boolean;
    OnlyIfCached: boolean;
    Private: boolean;
    readonly PrivateHeaders: ICollection_1<CLROf<string>>;
    ProxyRevalidate: boolean;
    Public: boolean;
    SharedMaxAge: Nullable_1<TimeSpan>;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): CacheControlHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<CacheControlHeaderValue> }): boolean;
}


export interface __CacheControlHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type CacheControlHeaderValue = CacheControlHeaderValue$instance & __CacheControlHeaderValue$views;


export class ContentDispositionHeaderValue$instance {
    constructor(dispositionType: string);
    CreationDate: Nullable_1<DateTimeOffset>;
    DispositionType: string;
    FileName: string;
    FileNameStar: string;
    ModificationDate: Nullable_1<DateTimeOffset>;
    Name: string;
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    ReadDate: Nullable_1<DateTimeOffset>;
    Size: Nullable_1<CLROf<long>>;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): ContentDispositionHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<ContentDispositionHeaderValue> }): boolean;
}


export interface __ContentDispositionHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ContentDispositionHeaderValue = ContentDispositionHeaderValue$instance & __ContentDispositionHeaderValue$views;


export class ContentRangeHeaderValue$instance {
    constructor(from_: long, to: long, length: long);
    constructor(length: long);
    constructor(from_: long, to: long);
    readonly From: Nullable_1<CLROf<long>>;
    readonly HasLength: boolean;
    readonly HasRange: boolean;
    readonly Length: Nullable_1<CLROf<long>>;
    readonly To: Nullable_1<CLROf<long>>;
    Unit: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): ContentRangeHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<ContentRangeHeaderValue> }): boolean;
}


export interface __ContentRangeHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ContentRangeHeaderValue = ContentRangeHeaderValue$instance & __ContentRangeHeaderValue$views;


export class EntityTagHeaderValue$instance {
    constructor(tag: string);
    constructor(tag: string, isWeak: boolean);
    readonly IsWeak: boolean;
    readonly Tag: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly Any: EntityTagHeaderValue;
    static Parse(input: string): EntityTagHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<EntityTagHeaderValue> }): boolean;
}


export interface __EntityTagHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type EntityTagHeaderValue = EntityTagHeaderValue$instance & __EntityTagHeaderValue$views;


export class HttpContentHeaders$instance extends HttpHeaders$instance {
    readonly Allow: ICollection_1<CLROf<string>>;
    ContentDisposition: ContentDispositionHeaderValue;
    readonly ContentEncoding: ICollection_1<CLROf<string>>;
    readonly ContentLanguage: ICollection_1<CLROf<string>>;
    ContentLength: Nullable_1<CLROf<long>>;
    ContentLocation: Uri;
    ContentMD5: byte[];
    ContentRange: ContentRangeHeaderValue;
    ContentType: MediaTypeHeaderValue;
    Expires: Nullable_1<DateTimeOffset>;
    LastModified: Nullable_1<DateTimeOffset>;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    GetEnumerator(): IEnumerator;
}


export interface __HttpContentHeaders$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HttpContentHeaders = HttpContentHeaders$instance & __HttpContentHeaders$views;


export abstract class HttpHeaders$instance {
    readonly NonValidated: HttpHeadersNonValidated;
    Add(name: string, value: string): void;
    Add(name: string, values: IEnumerable_1<CLROf<string>>): void;
    Clear(): void;
    Contains(name: string): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    GetValues(name: string): IEnumerable_1<CLROf<string>>;
    Remove(name: string): boolean;
    ToString(): string;
    TryAddWithoutValidation(name: string, value: string): boolean;
    TryAddWithoutValidation(name: string, values: IEnumerable_1<CLROf<string>>): boolean;
    TryGetValues(name: string, values: { value: TSByRef<IEnumerable_1<CLROf<string>>> }): boolean;
}


export interface __HttpHeaders$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeaders = HttpHeaders$instance & __HttpHeaders$views;


export class HttpHeaderValueCollection_1$instance<T> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    ParseAdd(input: string): void;
    Remove(item: T): boolean;
    ToString(): string;
    TryParseAdd(input: string): boolean;
}


export interface __HttpHeaderValueCollection_1$views<T> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeaderValueCollection_1<T> = HttpHeaderValueCollection_1$instance<T> & __HttpHeaderValueCollection_1$views<T>;


export class HttpRequestHeaders$instance extends HttpHeaders$instance {
    readonly Accept: HttpHeaderValueCollection_1<MediaTypeWithQualityHeaderValue>;
    readonly AcceptCharset: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    readonly AcceptEncoding: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    readonly AcceptLanguage: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    Authorization: AuthenticationHeaderValue;
    CacheControl: CacheControlHeaderValue;
    readonly Connection: HttpHeaderValueCollection_1<CLROf<string>>;
    ConnectionClose: Nullable_1<CLROf<boolean>>;
    Date: Nullable_1<DateTimeOffset>;
    readonly Expect: HttpHeaderValueCollection_1<NameValueWithParametersHeaderValue>;
    ExpectContinue: Nullable_1<CLROf<boolean>>;
    From: string;
    Host: string;
    readonly IfMatch: HttpHeaderValueCollection_1<EntityTagHeaderValue>;
    IfModifiedSince: Nullable_1<DateTimeOffset>;
    readonly IfNoneMatch: HttpHeaderValueCollection_1<EntityTagHeaderValue>;
    IfRange: RangeConditionHeaderValue;
    IfUnmodifiedSince: Nullable_1<DateTimeOffset>;
    MaxForwards: Nullable_1<CLROf<int>>;
    readonly Pragma: HttpHeaderValueCollection_1<NameValueHeaderValue>;
    Protocol: string;
    ProxyAuthorization: AuthenticationHeaderValue;
    Range: RangeHeaderValue;
    Referrer: Uri;
    readonly TE: HttpHeaderValueCollection_1<TransferCodingWithQualityHeaderValue>;
    readonly Trailer: HttpHeaderValueCollection_1<CLROf<string>>;
    readonly TransferEncoding: HttpHeaderValueCollection_1<TransferCodingHeaderValue>;
    TransferEncodingChunked: Nullable_1<CLROf<boolean>>;
    readonly Upgrade: HttpHeaderValueCollection_1<ProductHeaderValue>;
    readonly UserAgent: HttpHeaderValueCollection_1<ProductInfoHeaderValue>;
    readonly Via: HttpHeaderValueCollection_1<ViaHeaderValue>;
    readonly Warning: HttpHeaderValueCollection_1<WarningHeaderValue>;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    GetEnumerator(): IEnumerator;
}


export interface __HttpRequestHeaders$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HttpRequestHeaders = HttpRequestHeaders$instance & __HttpRequestHeaders$views;


export class HttpResponseHeaders$instance extends HttpHeaders$instance {
    readonly AcceptRanges: HttpHeaderValueCollection_1<CLROf<string>>;
    Age: Nullable_1<TimeSpan>;
    CacheControl: CacheControlHeaderValue;
    readonly Connection: HttpHeaderValueCollection_1<CLROf<string>>;
    ConnectionClose: Nullable_1<CLROf<boolean>>;
    Date: Nullable_1<DateTimeOffset>;
    ETag: EntityTagHeaderValue;
    Location: Uri;
    readonly Pragma: HttpHeaderValueCollection_1<NameValueHeaderValue>;
    readonly ProxyAuthenticate: HttpHeaderValueCollection_1<AuthenticationHeaderValue>;
    RetryAfter: RetryConditionHeaderValue;
    readonly Server: HttpHeaderValueCollection_1<ProductInfoHeaderValue>;
    readonly Trailer: HttpHeaderValueCollection_1<CLROf<string>>;
    readonly TransferEncoding: HttpHeaderValueCollection_1<TransferCodingHeaderValue>;
    TransferEncodingChunked: Nullable_1<CLROf<boolean>>;
    readonly Upgrade: HttpHeaderValueCollection_1<ProductHeaderValue>;
    readonly Vary: HttpHeaderValueCollection_1<CLROf<string>>;
    readonly Via: HttpHeaderValueCollection_1<ViaHeaderValue>;
    readonly Warning: HttpHeaderValueCollection_1<WarningHeaderValue>;
    readonly WwwAuthenticate: HttpHeaderValueCollection_1<AuthenticationHeaderValue>;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    GetEnumerator(): IEnumerator;
}


export interface __HttpResponseHeaders$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, IEnumerable_1<CLROf<string>>>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HttpResponseHeaders = HttpResponseHeaders$instance & __HttpResponseHeaders$views;


export class MediaTypeHeaderValue$instance {
    constructor(mediaType: string);
    constructor(mediaType: string, charSet: string);
    CharSet: string;
    MediaType: string;
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): MediaTypeHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<MediaTypeHeaderValue> }): boolean;
}


export interface __MediaTypeHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type MediaTypeHeaderValue = MediaTypeHeaderValue$instance & __MediaTypeHeaderValue$views;


export class MediaTypeWithQualityHeaderValue$instance extends MediaTypeHeaderValue$instance {
    constructor(mediaType: string);
    constructor(mediaType: string, quality: double);
    Quality: Nullable_1<CLROf<double>>;
    Clone(): any;
}


export interface __MediaTypeWithQualityHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type MediaTypeWithQualityHeaderValue = MediaTypeWithQualityHeaderValue$instance & __MediaTypeWithQualityHeaderValue$views;


export class NameValueHeaderValue$instance {
    constructor(name: string);
    constructor(name: string, value: string);
    readonly Name: string;
    Value: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): NameValueHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<NameValueHeaderValue> }): boolean;
}


export interface __NameValueHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type NameValueHeaderValue = NameValueHeaderValue$instance & __NameValueHeaderValue$views;


export class NameValueWithParametersHeaderValue$instance extends NameValueHeaderValue$instance {
    constructor(name: string);
    constructor(name: string, value: string);
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    Clone(): any;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export interface __NameValueWithParametersHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type NameValueWithParametersHeaderValue = NameValueWithParametersHeaderValue$instance & __NameValueWithParametersHeaderValue$views;


export class ProductHeaderValue$instance {
    constructor(name: string);
    constructor(name: string, version: string);
    readonly Name: string;
    readonly Version: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): ProductHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<ProductHeaderValue> }): boolean;
}


export interface __ProductHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ProductHeaderValue = ProductHeaderValue$instance & __ProductHeaderValue$views;


export class ProductInfoHeaderValue$instance {
    constructor(productName: string, productVersion: string);
    constructor(product: ProductHeaderValue);
    constructor(comment: string);
    readonly Comment: string;
    readonly Product: ProductHeaderValue;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): ProductInfoHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<ProductInfoHeaderValue> }): boolean;
}


export interface __ProductInfoHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ProductInfoHeaderValue = ProductInfoHeaderValue$instance & __ProductInfoHeaderValue$views;


export class RangeConditionHeaderValue$instance {
    constructor(date: DateTimeOffset);
    constructor(entityTag: EntityTagHeaderValue);
    constructor(entityTag: string);
    readonly Date: Nullable_1<DateTimeOffset>;
    readonly EntityTag: EntityTagHeaderValue;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): RangeConditionHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<RangeConditionHeaderValue> }): boolean;
}


export interface __RangeConditionHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type RangeConditionHeaderValue = RangeConditionHeaderValue$instance & __RangeConditionHeaderValue$views;


export class RangeHeaderValue$instance {
    constructor();
    constructor(from_: Nullable_1<CLROf<long>>, to: Nullable_1<CLROf<long>>);
    readonly Ranges: ICollection_1<RangeItemHeaderValue>;
    Unit: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): RangeHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<RangeHeaderValue> }): boolean;
}


export interface __RangeHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type RangeHeaderValue = RangeHeaderValue$instance & __RangeHeaderValue$views;


export class RangeItemHeaderValue$instance {
    constructor(from_: Nullable_1<CLROf<long>>, to: Nullable_1<CLROf<long>>);
    readonly From: Nullable_1<CLROf<long>>;
    readonly To: Nullable_1<CLROf<long>>;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export interface __RangeItemHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type RangeItemHeaderValue = RangeItemHeaderValue$instance & __RangeItemHeaderValue$views;


export class RetryConditionHeaderValue$instance {
    constructor(date: DateTimeOffset);
    constructor(delta: TimeSpan);
    readonly Date: Nullable_1<DateTimeOffset>;
    readonly Delta: Nullable_1<TimeSpan>;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): RetryConditionHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<RetryConditionHeaderValue> }): boolean;
}


export interface __RetryConditionHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type RetryConditionHeaderValue = RetryConditionHeaderValue$instance & __RetryConditionHeaderValue$views;


export class StringWithQualityHeaderValue$instance {
    constructor(value: string);
    constructor(value: string, quality: double);
    readonly Quality: Nullable_1<CLROf<double>>;
    readonly Value: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): StringWithQualityHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<StringWithQualityHeaderValue> }): boolean;
}


export interface __StringWithQualityHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type StringWithQualityHeaderValue = StringWithQualityHeaderValue$instance & __StringWithQualityHeaderValue$views;


export class TransferCodingHeaderValue$instance {
    constructor(value: string);
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    readonly Value: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): TransferCodingHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<TransferCodingHeaderValue> }): boolean;
}


export interface __TransferCodingHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type TransferCodingHeaderValue = TransferCodingHeaderValue$instance & __TransferCodingHeaderValue$views;


export class TransferCodingWithQualityHeaderValue$instance extends TransferCodingHeaderValue$instance {
    constructor(value: string);
    constructor(value: string, quality: double);
    Quality: Nullable_1<CLROf<double>>;
    Clone(): any;
}


export interface __TransferCodingWithQualityHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type TransferCodingWithQualityHeaderValue = TransferCodingWithQualityHeaderValue$instance & __TransferCodingWithQualityHeaderValue$views;


export class ViaHeaderValue$instance {
    constructor(protocolVersion: string, receivedBy: string);
    constructor(protocolVersion: string, receivedBy: string, protocolName: string);
    constructor(protocolVersion: string, receivedBy: string, protocolName: string, comment: string);
    readonly Comment: string;
    readonly ProtocolName: string;
    readonly ProtocolVersion: string;
    readonly ReceivedBy: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): ViaHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<ViaHeaderValue> }): boolean;
}


export interface __ViaHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type ViaHeaderValue = ViaHeaderValue$instance & __ViaHeaderValue$views;


export class WarningHeaderValue$instance {
    constructor(code: int, agent: string, text: string);
    constructor(code: int, agent: string, text: string, date: DateTimeOffset);
    readonly Agent: string;
    readonly Code: int;
    readonly Date: Nullable_1<DateTimeOffset>;
    readonly Text: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Parse(input: string): WarningHeaderValue;
    static TryParse(input: string, parsedValue: { value: TSByRef<WarningHeaderValue> }): boolean;
}


export interface __WarningHeaderValue$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
}

export type WarningHeaderValue = WarningHeaderValue$instance & __WarningHeaderValue$views;


