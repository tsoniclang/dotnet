// Generated by tsbindgen - Architecture
// Namespace: System.Buffers
// Assembly: System.Memory, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import type { GCHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SequencePosition, Span_1, String as ClrString, StringComparison, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum OperationStatus {
    done = 0,
    destinationTooSmall = 1,
    needMoreData = 2,
    invalidData = 3
}


export interface IBufferWriter_1$instance<T> {
    Advance(count: int): void;
    GetMemory(sizeHint?: int): Memory_1<T>;
    GetSpan(sizeHint?: int): Span_1<T>;
}


export type IBufferWriter_1<T> = IBufferWriter_1$instance<T>;

export interface IMemoryOwner_1$instance<T> {
    readonly Memory: Memory_1<T>;
    Dispose(): void;
}


export type IMemoryOwner_1<T> = IMemoryOwner_1$instance<T>;

export interface IPinnable$instance {
    Pin(elementIndex: int): MemoryHandle;
    Unpin(): void;
}


export type IPinnable = IPinnable$instance;

export class MemoryHandle$instance {
    constructor(pointer: ptr<void>, handle: GCHandle, pinnable: IPinnable);
    readonly pointer: ptr<void>;
    dispose(): void;
}


export interface __MemoryHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MemoryHandle = MemoryHandle$instance & __MemoryHandle$views;


export class ReadOnlySequence_1$instance<T> {
    constructor(startSegment: ReadOnlySequenceSegment_1<T>, startIndex: int, endSegment: ReadOnlySequenceSegment_1<T>, endIndex: int);
    constructor(array: T[]);
    constructor(array: T[], start: int, length: int);
    constructor(memory: ReadOnlyMemory_1<T>);
    readonly end: SequencePosition;
    readonly first: ReadOnlyMemory_1<T>;
    readonly firstSpan: ReadOnlySpan_1<T>;
    readonly isEmpty: boolean;
    readonly isSingleSegment: boolean;
    readonly length: long;
    readonly start: SequencePosition;
    getEnumerator(): ReadOnlySequence_1_Enumerator<T>;
    getOffset(position: SequencePosition): long;
    getPosition(offset: long): SequencePosition;
    getPosition(offset: long, origin: SequencePosition): SequencePosition;
    slice(start: long, length: long): ReadOnlySequence_1<T>;
    slice(start: long, end: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: SequencePosition, length: long): ReadOnlySequence_1<T>;
    slice(start: int, length: int): ReadOnlySequence_1<T>;
    slice(start: int, end: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: SequencePosition, length: int): ReadOnlySequence_1<T>;
    slice(start: SequencePosition, end: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: SequencePosition): ReadOnlySequence_1<T>;
    slice(start: long): ReadOnlySequence_1<T>;
    toString(): string;
    tryGet(position: { value: ref<SequencePosition> }, memory: { value: ref<ReadOnlyMemory_1<T>> }, advance?: boolean): boolean;
    static readonly empty: unknown;
}


export type ReadOnlySequence_1<T> = ReadOnlySequence_1$instance<T>;

export class ReadOnlySequence_1_Enumerator$instance<T> {
    constructor(sequence: ref<ReadOnlySequence_1<T>>);
    readonly current: ReadOnlyMemory_1<T>;
    moveNext(): boolean;
}


export type ReadOnlySequence_1_Enumerator<T> = ReadOnlySequence_1_Enumerator$instance<T>;

export class SequenceReader_1$instance<T extends IEquatable_1<T>> {
    constructor(sequence: ReadOnlySequence_1<T>);
    readonly consumed: long;
    readonly currentSpan: ReadOnlySpan_1<T>;
    readonly currentSpanIndex: int;
    readonly end: boolean;
    readonly length: long;
    readonly position: SequencePosition;
    readonly remaining: long;
    readonly sequence: ReadOnlySequence_1<T>;
    readonly unreadSequence: ReadOnlySequence_1<T>;
    readonly unreadSpan: ReadOnlySpan_1<T>;
    advance(count: long): void;
    advancePast(value: T): long;
    advancePastAny(values: ReadOnlySpan_1<T>): long;
    advancePastAny(value0: T, value1: T, value2: T, value3: T): long;
    advancePastAny(value0: T, value1: T, value2: T): long;
    advancePastAny(value0: T, value1: T): long;
    advanceToEnd(): void;
    isNext(next: T, advancePast?: boolean): boolean;
    isNext(next: ReadOnlySpan_1<T>, advancePast?: boolean): boolean;
    rewind(count: long): void;
    tryAdvanceTo(delimiter: T, advancePastDelimiter?: boolean): boolean;
    tryAdvanceToAny(delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryCopyTo(destination: Span_1<T>): boolean;
    tryPeek(value: { value: ref<T> }): boolean;
    tryPeek(offset: long, value: { value: ref<T> }): boolean;
    tryRead(value: { value: ref<T> }): boolean;
    tryReadExact(count: int, sequence: { value: ref<ReadOnlySequence_1<T>> }): boolean;
    tryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    tryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryReadToAny(span: { value: ref<ReadOnlySpan_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    tryReadToAny(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
}


export type SequenceReader_1<T extends IEquatable_1<T>> = SequenceReader_1$instance<T>;

export class StandardFormat$instance {
    constructor(symbol_: string, precision: byte);
    readonly hasPrecision: boolean;
    readonly isDefault: boolean;
    readonly precision: byte;
    readonly symbol_: string;
    equals(obj: any): boolean;
    equals(other: StandardFormat): boolean;
    getHashCode(): int;
    toString(): string;
    static readonly NoPrecision: byte;
    static readonly MaxPrecision: byte;
    static Parse(format: ReadOnlySpan_1<CLROf<string>>): StandardFormat;
    static Parse(format: string): StandardFormat;
    static TryParse(format: ReadOnlySpan_1<CLROf<string>>, result: { value: ref<StandardFormat> }): boolean;
}


export interface __StandardFormat$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<StandardFormat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: StandardFormat): boolean;
}

export type StandardFormat = StandardFormat$instance & __StandardFormat$views;


export class ArrayBufferWriter_1$instance<T> {
    constructor();
    constructor(initialCapacity: int);
    readonly capacity: int;
    readonly freeCapacity: int;
    readonly writtenCount: int;
    readonly writtenMemory: ReadOnlyMemory_1<T>;
    readonly writtenSpan: ReadOnlySpan_1<T>;
    advance(count: int): void;
    clear(): void;
    getMemory(sizeHint?: int): Memory_1<T>;
    getSpan(sizeHint?: int): Span_1<T>;
    resetWrittenCount(): void;
}


export interface __ArrayBufferWriter_1$views<T> {
    readonly As_IBufferWriter_1: IBufferWriter_1$instance<T>;
}

export type ArrayBufferWriter_1<T> = ArrayBufferWriter_1$instance<T> & __ArrayBufferWriter_1$views<T>;


export abstract class ArrayPool_1$instance<T> {
    abstract rent(minimumLength: int): T[];
    abstract return_(array: T[], clearArray?: boolean): void;
    static readonly Shared: unknown;
    static Create<T>(): ArrayPool_1<T>;
    static Create<T>(maxArrayLength: int, maxArraysPerBucket: int): ArrayPool_1<T>;
}


export type ArrayPool_1<T> = ArrayPool_1$instance<T>;

export abstract class MemoryManager_1$instance<T> {
    readonly memory: Memory_1<T>;
    abstract getSpan(): Span_1<T>;
    abstract pin(elementIndex?: int): MemoryHandle;
    abstract unpin(): void;
}


export interface __MemoryManager_1$views<T> {
    readonly As_IMemoryOwner_1: IMemoryOwner_1$instance<T>;
    readonly As_IPinnable: IPinnable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MemoryManager_1<T> = MemoryManager_1$instance<T> & __MemoryManager_1$views<T>;


export abstract class MemoryPool_1$instance<T> {
    readonly maxBufferSize: int;
    dispose(): void;
    abstract rent(minBufferSize?: int): IMemoryOwner_1<T>;
    static readonly Shared: unknown;
}


export interface __MemoryPool_1$views<T> {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MemoryPool_1<T> = MemoryPool_1$instance<T> & __MemoryPool_1$views<T>;


export abstract class ReadOnlySequenceSegment_1$instance<T> {
    readonly memory: ReadOnlyMemory_1<T>;
    readonly next: ReadOnlySequenceSegment_1<T>;
    readonly runningIndex: long;
}


export type ReadOnlySequenceSegment_1<T> = ReadOnlySequenceSegment_1$instance<T>;

export class ReadOnlySpanAction_2$instance<T, TArg> extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(span: ReadOnlySpan_1<T>, arg: TArg, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(span: ReadOnlySpan_1<T>, arg: TArg): void;
}


export interface __ReadOnlySpanAction_2$views<T, TArg> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReadOnlySpanAction_2<T, TArg> = ReadOnlySpanAction_2$instance<T, TArg> & __ReadOnlySpanAction_2$views<T, TArg>;


export class SearchValues_1$instance<T extends IEquatable_1<T>> {
    contains(value: T): boolean;
}


export type SearchValues_1<T extends IEquatable_1<T>> = SearchValues_1$instance<T>;

export class SpanAction_2$instance<T, TArg> extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(span: Span_1<T>, arg: TArg, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(span: Span_1<T>, arg: TArg): void;
}


export interface __SpanAction_2$views<T, TArg> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SpanAction_2<T, TArg> = SpanAction_2$instance<T, TArg> & __SpanAction_2$views<T, TArg>;


export abstract class BuffersExtensions$instance {
    static CopyTo<T>(source: { value: ref<ReadOnlySequence_1<T>> }, destination: Span_1<T>): void;
    static PositionOf<T extends IEquatable_1<T>>(source: { value: ref<ReadOnlySequence_1<T>> }, value: T): Nullable_1<SequencePosition>;
    static ToArray<T>(sequence: { value: ref<ReadOnlySequence_1<T>> }): T[];
    static Write<T>(writer: IBufferWriter_1<T>, value: ReadOnlySpan_1<T>): void;
}


export type BuffersExtensions = BuffersExtensions$instance;

export abstract class SearchValues$instance {
    static Create(values: ReadOnlySpan_1<CLROf<byte>>): SearchValues_1<CLROf<byte>>;
    static Create(values: ReadOnlySpan_1<CLROf<string>>): SearchValues_1<CLROf<string>>;
    static Create(values: ReadOnlySpan_1<CLROf<string>>, comparisonType: StringComparison): SearchValues_1<CLROf<string>>;
}


export type SearchValues = SearchValues$instance;

export abstract class SequenceReaderExtensions$instance {
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
}


export type SequenceReaderExtensions = SequenceReaderExtensions$instance;

