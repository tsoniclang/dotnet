// Generated by tsbindgen - Architecture
// Namespace: System.Buffers
// Assembly: System.Memory, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import type { GCHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SequencePosition, Span_1, String as ClrString, StringComparison, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum OperationStatus {
    Done = 0,
    DestinationTooSmall = 1,
    NeedMoreData = 2,
    InvalidData = 3
}


export interface IBufferWriter_1$instance<T> {
    Advance(count: int): void;
    GetMemory(sizeHint?: int): Memory_1<T>;
    GetSpan(sizeHint?: int): Span_1<T>;
}


export type IBufferWriter_1<T> = IBufferWriter_1$instance<T>;

export interface IMemoryOwner_1$instance<T> {
    readonly Memory: Memory_1<T>;
    Dispose(): void;
}


export type IMemoryOwner_1<T> = IMemoryOwner_1$instance<T>;

export interface IPinnable$instance {
    Pin(elementIndex: int): MemoryHandle;
    Unpin(): void;
}


export type IPinnable = IPinnable$instance;

export class MemoryHandle$instance {
    constructor(pointer: ptr<void>, handle: GCHandle, pinnable: IPinnable);
    readonly Pointer: ptr<void>;
    Dispose(): void;
}


export interface __MemoryHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MemoryHandle = MemoryHandle$instance & __MemoryHandle$views;


export class ReadOnlySequence_1$instance<T> {
    constructor(startSegment: ReadOnlySequenceSegment_1<T>, startIndex: int, endSegment: ReadOnlySequenceSegment_1<T>, endIndex: int);
    constructor(array: T[]);
    constructor(array: T[], start: int, length: int);
    constructor(memory: ReadOnlyMemory_1<T>);
    readonly End: SequencePosition;
    readonly First: ReadOnlyMemory_1<T>;
    readonly FirstSpan: ReadOnlySpan_1<T>;
    readonly IsEmpty: boolean;
    readonly IsSingleSegment: boolean;
    readonly Length: long;
    readonly Start: SequencePosition;
    GetEnumerator(): ReadOnlySequence_1_Enumerator<T>;
    GetOffset(position: SequencePosition): long;
    GetPosition(offset: long): SequencePosition;
    GetPosition(offset: long, origin: SequencePosition): SequencePosition;
    Slice(start: long, length: long): ReadOnlySequence_1<T>;
    Slice(start: long, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, length: long): ReadOnlySequence_1<T>;
    Slice(start: int, length: int): ReadOnlySequence_1<T>;
    Slice(start: int, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, length: int): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: long): ReadOnlySequence_1<T>;
    ToString(): string;
    TryGet(position: { value: ref<SequencePosition> }, memory: { value: ref<ReadOnlyMemory_1<T>> }, advance?: boolean): boolean;
    static readonly Empty: unknown;
}


export type ReadOnlySequence_1<T> = ReadOnlySequence_1$instance<T>;

export class ReadOnlySequence_1_Enumerator$instance<T> {
    constructor(sequence: ref<ReadOnlySequence_1<T>>);
    readonly Current: ReadOnlyMemory_1<T>;
    MoveNext(): boolean;
}


export type ReadOnlySequence_1_Enumerator<T> = ReadOnlySequence_1_Enumerator$instance<T>;

export class SequenceReader_1$instance<T extends IEquatable_1<T>> {
    constructor(sequence: ReadOnlySequence_1<T>);
    readonly Consumed: long;
    readonly CurrentSpan: ReadOnlySpan_1<T>;
    readonly CurrentSpanIndex: int;
    readonly End: boolean;
    readonly Length: long;
    readonly Position: SequencePosition;
    readonly Remaining: long;
    readonly Sequence: ReadOnlySequence_1<T>;
    readonly UnreadSequence: ReadOnlySequence_1<T>;
    readonly UnreadSpan: ReadOnlySpan_1<T>;
    Advance(count: long): void;
    AdvancePast(value: T): long;
    AdvancePastAny(values: ReadOnlySpan_1<T>): long;
    AdvancePastAny(value0: T, value1: T, value2: T, value3: T): long;
    AdvancePastAny(value0: T, value1: T, value2: T): long;
    AdvancePastAny(value0: T, value1: T): long;
    AdvanceToEnd(): void;
    IsNext(next: T, advancePast?: boolean): boolean;
    IsNext(next: ReadOnlySpan_1<T>, advancePast?: boolean): boolean;
    Rewind(count: long): void;
    TryAdvanceTo(delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryAdvanceToAny(delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryCopyTo(destination: Span_1<T>): boolean;
    TryPeek(value: { value: ref<T> }): boolean;
    TryPeek(offset: long, value: { value: ref<T> }): boolean;
    TryRead(value: { value: ref<T> }): boolean;
    TryReadExact(count: int, sequence: { value: ref<ReadOnlySequence_1<T>> }): boolean;
    TryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadToAny(span: { value: ref<ReadOnlySpan_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadToAny(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
}


export type SequenceReader_1<T extends IEquatable_1<T>> = SequenceReader_1$instance<T>;

export class StandardFormat$instance {
    constructor(symbol_: string, precision: byte);
    readonly HasPrecision: boolean;
    readonly IsDefault: boolean;
    readonly Precision: byte;
    readonly Symbol: string;
    Equals(obj: any): boolean;
    Equals(other: StandardFormat): boolean;
    GetHashCode(): int;
    ToString(): string;
    static readonly NoPrecision: byte;
    static readonly MaxPrecision: byte;
    static Parse(format: ReadOnlySpan_1<CLROf<string>>): StandardFormat;
    static Parse(format: string): StandardFormat;
    static TryParse(format: ReadOnlySpan_1<CLROf<string>>, result: { value: ref<StandardFormat> }): boolean;
}


export interface __StandardFormat$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<StandardFormat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: StandardFormat): boolean;
}

export type StandardFormat = StandardFormat$instance & __StandardFormat$views;


export class ArrayBufferWriter_1$instance<T> {
    constructor();
    constructor(initialCapacity: int);
    readonly Capacity: int;
    readonly FreeCapacity: int;
    readonly WrittenCount: int;
    readonly WrittenMemory: ReadOnlyMemory_1<T>;
    readonly WrittenSpan: ReadOnlySpan_1<T>;
    Advance(count: int): void;
    Clear(): void;
    GetMemory(sizeHint?: int): Memory_1<T>;
    GetSpan(sizeHint?: int): Span_1<T>;
    ResetWrittenCount(): void;
}


export interface __ArrayBufferWriter_1$views<T> {
    readonly As_IBufferWriter_1: IBufferWriter_1$instance<T>;
}

export type ArrayBufferWriter_1<T> = ArrayBufferWriter_1$instance<T> & __ArrayBufferWriter_1$views<T>;


export abstract class ArrayPool_1$instance<T> {
    abstract Rent(minimumLength: int): T[];
    abstract Return(array: T[], clearArray?: boolean): void;
    static readonly Shared: unknown;
    static Create<T>(): ArrayPool_1<T>;
    static Create<T>(maxArrayLength: int, maxArraysPerBucket: int): ArrayPool_1<T>;
}


export type ArrayPool_1<T> = ArrayPool_1$instance<T>;

export abstract class MemoryManager_1$instance<T> {
    readonly Memory: Memory_1<T>;
    abstract GetSpan(): Span_1<T>;
    abstract Pin(elementIndex?: int): MemoryHandle;
    abstract Unpin(): void;
}


export interface __MemoryManager_1$views<T> {
    readonly As_IMemoryOwner_1: IMemoryOwner_1$instance<T>;
    readonly As_IPinnable: IPinnable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MemoryManager_1<T> = MemoryManager_1$instance<T> & __MemoryManager_1$views<T>;


export abstract class MemoryPool_1$instance<T> {
    readonly MaxBufferSize: int;
    Dispose(): void;
    abstract Rent(minBufferSize?: int): IMemoryOwner_1<T>;
    static readonly Shared: unknown;
}


export interface __MemoryPool_1$views<T> {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MemoryPool_1<T> = MemoryPool_1$instance<T> & __MemoryPool_1$views<T>;


export abstract class ReadOnlySequenceSegment_1$instance<T> {
    readonly Memory: ReadOnlyMemory_1<T>;
    readonly Next: ReadOnlySequenceSegment_1<T>;
    readonly RunningIndex: long;
}


export type ReadOnlySequenceSegment_1<T> = ReadOnlySequenceSegment_1$instance<T>;

export class ReadOnlySpanAction_2$instance<T, TArg> extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(span: ReadOnlySpan_1<T>, arg: TArg, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(span: ReadOnlySpan_1<T>, arg: TArg): void;
}


export interface __ReadOnlySpanAction_2$views<T, TArg> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReadOnlySpanAction_2<T, TArg> = ReadOnlySpanAction_2$instance<T, TArg> & __ReadOnlySpanAction_2$views<T, TArg>;


export class SearchValues_1$instance<T extends IEquatable_1<T>> {
    Contains(value: T): boolean;
}


export type SearchValues_1<T extends IEquatable_1<T>> = SearchValues_1$instance<T>;

export class SpanAction_2$instance<T, TArg> extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(span: Span_1<T>, arg: TArg, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(span: Span_1<T>, arg: TArg): void;
}


export interface __SpanAction_2$views<T, TArg> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SpanAction_2<T, TArg> = SpanAction_2$instance<T, TArg> & __SpanAction_2$views<T, TArg>;


export abstract class BuffersExtensions$instance {
    static CopyTo<T>(source: { value: ref<ReadOnlySequence_1<T>> }, destination: Span_1<T>): void;
    static PositionOf<T extends IEquatable_1<T>>(source: { value: ref<ReadOnlySequence_1<T>> }, value: T): Nullable_1<SequencePosition>;
    static ToArray<T>(sequence: { value: ref<ReadOnlySequence_1<T>> }): T[];
    static Write<T>(writer: IBufferWriter_1<T>, value: ReadOnlySpan_1<T>): void;
}


export type BuffersExtensions = BuffersExtensions$instance;

export abstract class SearchValues$instance {
    static Create(values: ReadOnlySpan_1<CLROf<byte>>): SearchValues_1<CLROf<byte>>;
    static Create(values: ReadOnlySpan_1<CLROf<string>>): SearchValues_1<CLROf<string>>;
    static Create(values: ReadOnlySpan_1<CLROf<string>>, comparisonType: StringComparison): SearchValues_1<CLROf<string>>;
}


export type SearchValues = SearchValues$instance;

export abstract class SequenceReaderExtensions$instance {
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
}


export type SequenceReaderExtensions = SequenceReaderExtensions$instance;

