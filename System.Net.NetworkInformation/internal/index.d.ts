// Generated by tsbindgen - Architecture
// Namespace: System.Net.NetworkInformation
// Assembly: System.Net.NetworkInformation, System.Net.Ping, System.Net.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, Component, IComponent, IContainer, ISite, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import * as System_Net_Internal from "../../System.Net/internal/index.js";
import type { IPAddress, IPEndPoint } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DuplicateAddressDetectionState {
    invalid = 0,
    tentative = 1,
    duplicate = 2,
    deprecated = 3,
    preferred = 4
}


export enum IPStatus {
    success = 0,
    destinationNetworkUnreachable = 11002,
    destinationHostUnreachable = 11003,
    destinationProtocolUnreachable = 11004,
    destinationPortUnreachable = 11005,
    destinationProhibited = 11004,
    noResources = 11006,
    badOption = 11007,
    hardwareError = 11008,
    packetTooBig = 11009,
    timedOut = 11010,
    badRoute = 11012,
    ttlExpired = 11013,
    ttlReassemblyTimeExceeded = 11014,
    parameterProblem = 11015,
    sourceQuench = 11016,
    badDestination = 11018,
    destinationUnreachable = 11040,
    timeExceeded = 11041,
    badHeader = 11042,
    unrecognizedNextHeader = 11043,
    icmpError = 11044,
    destinationScopeMismatch = 11045,
    unknown_ = -1
}


export enum NetBiosNodeType {
    unknown_ = 0,
    broadcast = 1,
    peer2Peer = 2,
    mixed = 4,
    hybrid = 8
}


export enum NetworkInterfaceComponent {
    iPv4 = 0,
    iPv6 = 1
}


export enum NetworkInterfaceType {
    unknown_ = 1,
    ethernet = 6,
    tokenRing = 9,
    fddi = 15,
    basicIsdn = 20,
    primaryIsdn = 21,
    ppp = 23,
    loopback = 24,
    ethernet3Megabit = 26,
    slip = 28,
    atm = 37,
    genericModem = 48,
    fastEthernetT = 62,
    isdn = 63,
    fastEthernetFx = 69,
    wireless80211 = 71,
    asymmetricDsl = 94,
    rateAdaptDsl = 95,
    symmetricDsl = 96,
    veryHighSpeedDsl = 97,
    ipOverAtm = 114,
    gigabitEthernet = 117,
    tunnel = 131,
    multiRateSymmetricDsl = 143,
    highPerformanceSerialBus = 144,
    wman = 237,
    wwanpp = 243,
    wwanpp2 = 244
}


export enum OperationalStatus {
    up = 1,
    down = 2,
    testing = 3,
    unknown_ = 4,
    dormant = 5,
    notPresent = 6,
    lowerLayerDown = 7
}


export enum PrefixOrigin {
    other = 0,
    manual = 1,
    wellKnown = 2,
    dhcp = 3,
    routerAdvertisement = 4
}


export enum ScopeLevel {
    none = 0,
    interface_ = 1,
    link = 2,
    subnet = 3,
    admin = 4,
    site = 5,
    organization = 8,
    global = 14
}


export enum SuffixOrigin {
    other = 0,
    manual = 1,
    wellKnown = 2,
    originDhcp = 3,
    linkLayerAddress = 4,
    random = 5
}


export enum TcpState {
    unknown_ = 0,
    closed = 1,
    listen = 2,
    synSent = 3,
    synReceived = 4,
    established = 5,
    finWait1 = 6,
    finWait2 = 7,
    closeWait = 8,
    closing = 9,
    lastAck = 10,
    timeWait = 11,
    deleteTcb = 12
}


export abstract class GatewayIPAddressInformation$instance {
    readonly address: IPAddress;
}


export type GatewayIPAddressInformation = GatewayIPAddressInformation$instance;

export class GatewayIPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: GatewayIPAddressInformation;
    add(address: GatewayIPAddressInformation): void;
    clear(): void;
    contains(address: GatewayIPAddressInformation): boolean;
    copyTo(array: GatewayIPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<GatewayIPAddressInformation>;
    remove(address: GatewayIPAddressInformation): boolean;
}


export interface __GatewayIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<GatewayIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<GatewayIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type GatewayIPAddressInformationCollection = GatewayIPAddressInformationCollection$instance & __GatewayIPAddressInformationCollection$views;


export abstract class IcmpV4Statistics$instance {
    readonly addressMaskRepliesReceived: long;
    readonly addressMaskRepliesSent: long;
    readonly addressMaskRequestsReceived: long;
    readonly addressMaskRequestsSent: long;
    readonly destinationUnreachableMessagesReceived: long;
    readonly destinationUnreachableMessagesSent: long;
    readonly echoRepliesReceived: long;
    readonly echoRepliesSent: long;
    readonly echoRequestsReceived: long;
    readonly echoRequestsSent: long;
    readonly errorsReceived: long;
    readonly errorsSent: long;
    readonly messagesReceived: long;
    readonly messagesSent: long;
    readonly parameterProblemsReceived: long;
    readonly parameterProblemsSent: long;
    readonly redirectsReceived: long;
    readonly redirectsSent: long;
    readonly sourceQuenchesReceived: long;
    readonly sourceQuenchesSent: long;
    readonly timeExceededMessagesReceived: long;
    readonly timeExceededMessagesSent: long;
    readonly timestampRepliesReceived: long;
    readonly timestampRepliesSent: long;
    readonly timestampRequestsReceived: long;
    readonly timestampRequestsSent: long;
}


export type IcmpV4Statistics = IcmpV4Statistics$instance;

export abstract class IcmpV6Statistics$instance {
    readonly destinationUnreachableMessagesReceived: long;
    readonly destinationUnreachableMessagesSent: long;
    readonly echoRepliesReceived: long;
    readonly echoRepliesSent: long;
    readonly echoRequestsReceived: long;
    readonly echoRequestsSent: long;
    readonly errorsReceived: long;
    readonly errorsSent: long;
    readonly membershipQueriesReceived: long;
    readonly membershipQueriesSent: long;
    readonly membershipReductionsReceived: long;
    readonly membershipReductionsSent: long;
    readonly membershipReportsReceived: long;
    readonly membershipReportsSent: long;
    readonly messagesReceived: long;
    readonly messagesSent: long;
    readonly neighborAdvertisementsReceived: long;
    readonly neighborAdvertisementsSent: long;
    readonly neighborSolicitsReceived: long;
    readonly neighborSolicitsSent: long;
    readonly packetTooBigMessagesReceived: long;
    readonly packetTooBigMessagesSent: long;
    readonly parameterProblemsReceived: long;
    readonly parameterProblemsSent: long;
    readonly redirectsReceived: long;
    readonly redirectsSent: long;
    readonly routerAdvertisementsReceived: long;
    readonly routerAdvertisementsSent: long;
    readonly routerSolicitsReceived: long;
    readonly routerSolicitsSent: long;
    readonly timeExceededMessagesReceived: long;
    readonly timeExceededMessagesSent: long;
}


export type IcmpV6Statistics = IcmpV6Statistics$instance;

export class IPAddressCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: IPAddress;
    add(address: IPAddress): void;
    clear(): void;
    contains(address: IPAddress): boolean;
    copyTo(array: IPAddress[], offset: int): void;
    getEnumerator(): IEnumerator_1<IPAddress>;
    remove(address: IPAddress): boolean;
}


export interface __IPAddressCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<IPAddress>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddress>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressCollection = IPAddressCollection$instance & __IPAddressCollection$views;


export abstract class IPAddressInformation$instance {
    readonly address: IPAddress;
    readonly isDnsEligible: boolean;
    readonly isTransient: boolean;
}


export type IPAddressInformation = IPAddressInformation$instance;

export class IPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: IPAddressInformation;
    add(address: IPAddressInformation): void;
    clear(): void;
    contains(address: IPAddressInformation): boolean;
    copyTo(array: IPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<IPAddressInformation>;
    remove(address: IPAddressInformation): boolean;
}


export interface __IPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<IPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressInformationCollection = IPAddressInformationCollection$instance & __IPAddressInformationCollection$views;


export abstract class IPGlobalProperties$instance {
    readonly dhcpScopeName: string;
    readonly domainName: string;
    readonly hostName: string;
    readonly isWinsProxy: boolean;
    readonly nodeType: NetBiosNodeType;
    beginGetUnicastAddresses(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetUnicastAddresses(asyncResult: IAsyncResult): UnicastIPAddressInformationCollection;
    abstract getActiveTcpConnections(): TcpConnectionInformation[];
    abstract getActiveTcpListeners(): IPEndPoint[];
    abstract getActiveUdpListeners(): IPEndPoint[];
    abstract getIcmpV4Statistics(): IcmpV4Statistics;
    abstract getIcmpV6Statistics(): IcmpV6Statistics;
    abstract getIPv4GlobalStatistics(): IPGlobalStatistics;
    abstract getIPv6GlobalStatistics(): IPGlobalStatistics;
    abstract getTcpIPv4Statistics(): TcpStatistics;
    abstract getTcpIPv6Statistics(): TcpStatistics;
    abstract getUdpIPv4Statistics(): UdpStatistics;
    abstract getUdpIPv6Statistics(): UdpStatistics;
    getUnicastAddresses(): UnicastIPAddressInformationCollection;
    getUnicastAddressesAsync(): Task_1<UnicastIPAddressInformationCollection>;
    static getIPGlobalProperties(): IPGlobalProperties;
}


export type IPGlobalProperties = IPGlobalProperties$instance;

export abstract class IPGlobalStatistics$instance {
    readonly defaultTtl: int;
    readonly forwardingEnabled: boolean;
    readonly numberOfInterfaces: int;
    readonly numberOfIPAddresses: int;
    readonly numberOfRoutes: int;
    readonly outputPacketRequests: long;
    readonly outputPacketRoutingDiscards: long;
    readonly outputPacketsDiscarded: long;
    readonly outputPacketsWithNoRoute: long;
    readonly packetFragmentFailures: long;
    readonly packetReassembliesRequired: long;
    readonly packetReassemblyFailures: long;
    readonly packetReassemblyTimeout: long;
    readonly packetsFragmented: long;
    readonly packetsReassembled: long;
    readonly receivedPackets: long;
    readonly receivedPacketsDelivered: long;
    readonly receivedPacketsDiscarded: long;
    readonly receivedPacketsForwarded: long;
    readonly receivedPacketsWithAddressErrors: long;
    readonly receivedPacketsWithHeadersErrors: long;
    readonly receivedPacketsWithUnknownProtocol: long;
}


export type IPGlobalStatistics = IPGlobalStatistics$instance;

export abstract class IPInterfaceProperties$instance {
    readonly anycastAddresses: IPAddressInformationCollection;
    readonly dhcpServerAddresses: IPAddressCollection;
    readonly dnsAddresses: IPAddressCollection;
    readonly dnsSuffix: string;
    readonly gatewayAddresses: GatewayIPAddressInformationCollection;
    readonly isDnsEnabled: boolean;
    readonly isDynamicDnsEnabled: boolean;
    readonly multicastAddresses: MulticastIPAddressInformationCollection;
    readonly unicastAddresses: UnicastIPAddressInformationCollection;
    readonly winsServersAddresses: IPAddressCollection;
    abstract getIPv4Properties(): IPv4InterfaceProperties;
    abstract getIPv6Properties(): IPv6InterfaceProperties;
}


export type IPInterfaceProperties = IPInterfaceProperties$instance;

export abstract class IPInterfaceStatistics$instance {
    readonly bytesReceived: long;
    readonly bytesSent: long;
    readonly incomingPacketsDiscarded: long;
    readonly incomingPacketsWithErrors: long;
    readonly incomingUnknownProtocolPackets: long;
    readonly nonUnicastPacketsReceived: long;
    readonly nonUnicastPacketsSent: long;
    readonly outgoingPacketsDiscarded: long;
    readonly outgoingPacketsWithErrors: long;
    readonly outputQueueLength: long;
    readonly unicastPacketsReceived: long;
    readonly unicastPacketsSent: long;
}


export type IPInterfaceStatistics = IPInterfaceStatistics$instance;

export abstract class IPv4InterfaceProperties$instance {
    readonly index: int;
    readonly isAutomaticPrivateAddressingActive: boolean;
    readonly isAutomaticPrivateAddressingEnabled: boolean;
    readonly isDhcpEnabled: boolean;
    readonly isForwardingEnabled: boolean;
    readonly mtu: int;
    readonly usesWins: boolean;
}


export type IPv4InterfaceProperties = IPv4InterfaceProperties$instance;

export abstract class IPv4InterfaceStatistics$instance {
    readonly bytesReceived: long;
    readonly bytesSent: long;
    readonly incomingPacketsDiscarded: long;
    readonly incomingPacketsWithErrors: long;
    readonly incomingUnknownProtocolPackets: long;
    readonly nonUnicastPacketsReceived: long;
    readonly nonUnicastPacketsSent: long;
    readonly outgoingPacketsDiscarded: long;
    readonly outgoingPacketsWithErrors: long;
    readonly outputQueueLength: long;
    readonly unicastPacketsReceived: long;
    readonly unicastPacketsSent: long;
}


export type IPv4InterfaceStatistics = IPv4InterfaceStatistics$instance;

export abstract class IPv6InterfaceProperties$instance {
    readonly index: int;
    readonly mtu: int;
    getScopeId(scopeLevel: ScopeLevel): long;
}


export type IPv6InterfaceProperties = IPv6InterfaceProperties$instance;

export abstract class MulticastIPAddressInformation$instance extends IPAddressInformation$instance {
    readonly addressPreferredLifetime: long;
    readonly addressValidLifetime: long;
    readonly dhcpLeaseLifetime: long;
    readonly duplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly prefixOrigin: PrefixOrigin;
    readonly suffixOrigin: SuffixOrigin;
}


export type MulticastIPAddressInformation = MulticastIPAddressInformation$instance;

export class MulticastIPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: MulticastIPAddressInformation;
    add(address: MulticastIPAddressInformation): void;
    clear(): void;
    contains(address: MulticastIPAddressInformation): boolean;
    copyTo(array: MulticastIPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<MulticastIPAddressInformation>;
    remove(address: MulticastIPAddressInformation): boolean;
}


export interface __MulticastIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<MulticastIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MulticastIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type MulticastIPAddressInformationCollection = MulticastIPAddressInformationCollection$instance & __MulticastIPAddressInformationCollection$views;


export class NetworkAddressChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: EventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: EventArgs): void;
}


export interface __NetworkAddressChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkAddressChangedEventHandler = NetworkAddressChangedEventHandler$instance & __NetworkAddressChangedEventHandler$views;


export class NetworkAvailabilityChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: NetworkAvailabilityEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: NetworkAvailabilityEventArgs): void;
}


export interface __NetworkAvailabilityChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkAvailabilityChangedEventHandler = NetworkAvailabilityChangedEventHandler$instance & __NetworkAvailabilityChangedEventHandler$views;


export class NetworkAvailabilityEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly isAvailable: boolean;
}


export type NetworkAvailabilityEventArgs = NetworkAvailabilityEventArgs$instance;

export class NetworkChange$instance {
    constructor();
    static registerNetworkChange(nc: NetworkChange): void;
}


export type NetworkChange = NetworkChange$instance;

export class NetworkInformationException$instance extends System_ComponentModel_Internal.Win32Exception$instance {
    constructor();
    constructor(errorCode: int);
    readonly errorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NetworkInformationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkInformationException = NetworkInformationException$instance & __NetworkInformationException$views;


export abstract class NetworkInterface$instance {
    readonly description: string;
    readonly id: string;
    readonly isReceiveOnly: boolean;
    readonly name: string;
    readonly networkInterfaceType: NetworkInterfaceType;
    readonly operationalStatus: OperationalStatus;
    readonly speed: long;
    readonly supportsMulticast: boolean;
    getIPProperties(): IPInterfaceProperties;
    getIPStatistics(): IPInterfaceStatistics;
    getIPv4Statistics(): IPv4InterfaceStatistics;
    getPhysicalAddress(): PhysicalAddress;
    supports(networkInterfaceComponent: NetworkInterfaceComponent): boolean;
    static readonly iPv6LoopbackInterfaceIndex: int;
    static readonly loopbackInterfaceIndex: int;
    static getAllNetworkInterfaces(): NetworkInterface[];
    static getIsNetworkAvailable(): boolean;
}


export type NetworkInterface = NetworkInterface$instance;

export class PhysicalAddress$instance {
    constructor(address: byte[]);
    equals(comparand: unknown): boolean;
    getAddressBytes(): byte[];
    getHashCode(): int;
    toString(): string;
    static readonly none: PhysicalAddress;
    static parse2(address: ReadOnlySpan_1<CLROf<char>>): PhysicalAddress;
    static parse2(address: string): PhysicalAddress;
    static tryParse2(address: ReadOnlySpan_1<CLROf<char>>, value: { value: ref<PhysicalAddress> }): boolean;
    static tryParse2(address: string, value: { value: ref<PhysicalAddress> }): boolean;
}


export type PhysicalAddress = PhysicalAddress$instance;

export class Ping$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    dispose(): void;
    send(hostNameOrAddress: string): PingReply;
    send(hostNameOrAddress: string, timeout: int): PingReply;
    send(address: IPAddress): PingReply;
    send(address: IPAddress, timeout: int): PingReply;
    send(hostNameOrAddress: string, timeout: int, buffer: byte[]): PingReply;
    send(address: IPAddress, timeout: int, buffer: byte[]): PingReply;
    send(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions): PingReply;
    send(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions): PingReply;
    send(address: IPAddress, timeout: TimeSpan, buffer?: byte[], options?: PingOptions): PingReply;
    send(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[], options?: PingOptions): PingReply;
    sendAsync(hostNameOrAddress: string, userToken: unknown): void;
    sendAsync(hostNameOrAddress: string, timeout: int, userToken: unknown): void;
    sendAsync(address: IPAddress, userToken: unknown): void;
    sendAsync(address: IPAddress, timeout: int, userToken: unknown): void;
    sendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], userToken: unknown): void;
    sendAsync(address: IPAddress, timeout: int, buffer: byte[], userToken: unknown): void;
    sendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions, userToken: unknown): void;
    sendAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions, userToken: unknown): void;
    sendAsyncCancel(): void;
    sendPingAsync(address: IPAddress): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: int): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: int): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: int, buffer: byte[]): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[]): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions): Task_1<PingReply>;
    sendPingAsync(address: IPAddress, timeout: TimeSpan, buffer?: byte[], options?: PingOptions, cancellationToken?: CancellationToken): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions): Task_1<PingReply>;
    sendPingAsync(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[], options?: PingOptions, cancellationToken?: CancellationToken): Task_1<PingReply>;
}


export interface __Ping$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Ping$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type Ping = Ping$instance & __Ping$views;


export class PingCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly reply: PingReply;
}


export type PingCompletedEventArgs = PingCompletedEventArgs$instance;

export class PingCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: PingCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: PingCompletedEventArgs): void;
}


export interface __PingCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PingCompletedEventHandler = PingCompletedEventHandler$instance & __PingCompletedEventHandler$views;


export class PingException$instance extends System_Internal.InvalidOperationException$instance {
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __PingException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PingException = PingException$instance & __PingException$views;


export class PingOptions$instance {
    constructor();
    constructor(ttl: int, dontFragment: boolean);
    dontFragment: boolean;
    ttl: int;
}


export type PingOptions = PingOptions$instance;

export class PingReply$instance {
    readonly address: IPAddress;
    readonly buffer: byte[];
    readonly options: PingOptions;
    readonly roundtripTime: long;
    readonly status: IPStatus;
}


export type PingReply = PingReply$instance;

export abstract class TcpConnectionInformation$instance {
    readonly localEndPoint: IPEndPoint;
    readonly remoteEndPoint: IPEndPoint;
    readonly state: TcpState;
}


export type TcpConnectionInformation = TcpConnectionInformation$instance;

export abstract class TcpStatistics$instance {
    readonly connectionsAccepted: long;
    readonly connectionsInitiated: long;
    readonly cumulativeConnections: long;
    readonly currentConnections: long;
    readonly errorsReceived: long;
    readonly failedConnectionAttempts: long;
    readonly maximumConnections: long;
    readonly maximumTransmissionTimeout: long;
    readonly minimumTransmissionTimeout: long;
    readonly resetConnections: long;
    readonly resetsSent: long;
    readonly segmentsReceived: long;
    readonly segmentsResent: long;
    readonly segmentsSent: long;
}


export type TcpStatistics = TcpStatistics$instance;

export abstract class UdpStatistics$instance {
    readonly datagramsReceived: long;
    readonly datagramsSent: long;
    readonly incomingDatagramsDiscarded: long;
    readonly incomingDatagramsWithErrors: long;
    readonly udpListeners: int;
}


export type UdpStatistics = UdpStatistics$instance;

export abstract class UnicastIPAddressInformation$instance extends IPAddressInformation$instance {
    readonly addressPreferredLifetime: long;
    readonly addressValidLifetime: long;
    readonly dhcpLeaseLifetime: long;
    readonly duplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly iPv4Mask: IPAddress;
    readonly prefixLength: int;
    readonly prefixOrigin: PrefixOrigin;
    readonly suffixOrigin: SuffixOrigin;
}


export type UnicastIPAddressInformation = UnicastIPAddressInformation$instance;

export class UnicastIPAddressInformationCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly item: UnicastIPAddressInformation;
    add(address: UnicastIPAddressInformation): void;
    clear(): void;
    contains(address: UnicastIPAddressInformation): boolean;
    copyTo(array: UnicastIPAddressInformation[], offset: int): void;
    getEnumerator(): IEnumerator_1<UnicastIPAddressInformation>;
    remove(address: UnicastIPAddressInformation): boolean;
}


export interface __UnicastIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<UnicastIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<UnicastIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type UnicastIPAddressInformationCollection = UnicastIPAddressInformationCollection$instance & __UnicastIPAddressInformationCollection$views;


