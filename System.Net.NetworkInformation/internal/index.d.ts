// Generated by tsbindgen - Architecture
// Namespace: System.Net.NetworkInformation
// Assembly: System.Net.Primitives, System.Net.Ping, System.Net.NetworkInformation

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, Component, IComponent, IContainer, ISite, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import * as System_Net_Internal from "../../System.Net/internal/index.js";
import type { IPAddress, IPEndPoint } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DuplicateAddressDetectionState {
    Invalid = 0,
    Tentative = 1,
    Duplicate = 2,
    Deprecated = 3,
    Preferred = 4
}


export enum IPStatus {
    Success = 0,
    DestinationNetworkUnreachable = 11002,
    DestinationHostUnreachable = 11003,
    DestinationProtocolUnreachable = 11004,
    DestinationPortUnreachable = 11005,
    DestinationProhibited = 11004,
    NoResources = 11006,
    BadOption = 11007,
    HardwareError = 11008,
    PacketTooBig = 11009,
    TimedOut = 11010,
    BadRoute = 11012,
    TtlExpired = 11013,
    TtlReassemblyTimeExceeded = 11014,
    ParameterProblem = 11015,
    SourceQuench = 11016,
    BadDestination = 11018,
    DestinationUnreachable = 11040,
    TimeExceeded = 11041,
    BadHeader = 11042,
    UnrecognizedNextHeader = 11043,
    IcmpError = 11044,
    DestinationScopeMismatch = 11045,
    Unknown = -1
}


export enum NetBiosNodeType {
    Unknown = 0,
    Broadcast = 1,
    Peer2Peer = 2,
    Mixed = 4,
    Hybrid = 8
}


export enum NetworkInterfaceComponent {
    IPv4 = 0,
    IPv6 = 1
}


export enum NetworkInterfaceType {
    Unknown = 1,
    Ethernet = 6,
    TokenRing = 9,
    Fddi = 15,
    BasicIsdn = 20,
    PrimaryIsdn = 21,
    Ppp = 23,
    Loopback = 24,
    Ethernet3Megabit = 26,
    Slip = 28,
    Atm = 37,
    GenericModem = 48,
    FastEthernetT = 62,
    Isdn = 63,
    FastEthernetFx = 69,
    Wireless80211 = 71,
    AsymmetricDsl = 94,
    RateAdaptDsl = 95,
    SymmetricDsl = 96,
    VeryHighSpeedDsl = 97,
    IPOverAtm = 114,
    GigabitEthernet = 117,
    Tunnel = 131,
    MultiRateSymmetricDsl = 143,
    HighPerformanceSerialBus = 144,
    Wman = 237,
    Wwanpp = 243,
    Wwanpp2 = 244
}


export enum OperationalStatus {
    Up = 1,
    Down = 2,
    Testing = 3,
    Unknown = 4,
    Dormant = 5,
    NotPresent = 6,
    LowerLayerDown = 7
}


export enum PrefixOrigin {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    Dhcp = 3,
    RouterAdvertisement = 4
}


export enum ScopeLevel {
    None = 0,
    Interface = 1,
    Link = 2,
    Subnet = 3,
    Admin = 4,
    Site = 5,
    Organization = 8,
    Global = 14
}


export enum SuffixOrigin {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    OriginDhcp = 3,
    LinkLayerAddress = 4,
    Random = 5
}


export enum TcpState {
    Unknown = 0,
    Closed = 1,
    Listen = 2,
    SynSent = 3,
    SynReceived = 4,
    Established = 5,
    FinWait1 = 6,
    FinWait2 = 7,
    CloseWait = 8,
    Closing = 9,
    LastAck = 10,
    TimeWait = 11,
    DeleteTcb = 12
}


export abstract class GatewayIPAddressInformation$instance {
    readonly Address: IPAddress;
}


export type GatewayIPAddressInformation = GatewayIPAddressInformation$instance;

export class GatewayIPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: GatewayIPAddressInformation;
    Add(address: GatewayIPAddressInformation): void;
    Clear(): void;
    Contains(address: GatewayIPAddressInformation): boolean;
    CopyTo(array: GatewayIPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<GatewayIPAddressInformation>;
    Remove(address: GatewayIPAddressInformation): boolean;
}


export interface __GatewayIPAddressInformationCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<GatewayIPAddressInformation>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<GatewayIPAddressInformation>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type GatewayIPAddressInformationCollection = GatewayIPAddressInformationCollection$instance & __GatewayIPAddressInformationCollection$views;


export abstract class IcmpV4Statistics$instance {
    readonly AddressMaskRepliesReceived: long;
    readonly AddressMaskRepliesSent: long;
    readonly AddressMaskRequestsReceived: long;
    readonly AddressMaskRequestsSent: long;
    readonly DestinationUnreachableMessagesReceived: long;
    readonly DestinationUnreachableMessagesSent: long;
    readonly EchoRepliesReceived: long;
    readonly EchoRepliesSent: long;
    readonly EchoRequestsReceived: long;
    readonly EchoRequestsSent: long;
    readonly ErrorsReceived: long;
    readonly ErrorsSent: long;
    readonly MessagesReceived: long;
    readonly MessagesSent: long;
    readonly ParameterProblemsReceived: long;
    readonly ParameterProblemsSent: long;
    readonly RedirectsReceived: long;
    readonly RedirectsSent: long;
    readonly SourceQuenchesReceived: long;
    readonly SourceQuenchesSent: long;
    readonly TimeExceededMessagesReceived: long;
    readonly TimeExceededMessagesSent: long;
    readonly TimestampRepliesReceived: long;
    readonly TimestampRepliesSent: long;
    readonly TimestampRequestsReceived: long;
    readonly TimestampRequestsSent: long;
}


export type IcmpV4Statistics = IcmpV4Statistics$instance;

export abstract class IcmpV6Statistics$instance {
    readonly DestinationUnreachableMessagesReceived: long;
    readonly DestinationUnreachableMessagesSent: long;
    readonly EchoRepliesReceived: long;
    readonly EchoRepliesSent: long;
    readonly EchoRequestsReceived: long;
    readonly EchoRequestsSent: long;
    readonly ErrorsReceived: long;
    readonly ErrorsSent: long;
    readonly MembershipQueriesReceived: long;
    readonly MembershipQueriesSent: long;
    readonly MembershipReductionsReceived: long;
    readonly MembershipReductionsSent: long;
    readonly MembershipReportsReceived: long;
    readonly MembershipReportsSent: long;
    readonly MessagesReceived: long;
    readonly MessagesSent: long;
    readonly NeighborAdvertisementsReceived: long;
    readonly NeighborAdvertisementsSent: long;
    readonly NeighborSolicitsReceived: long;
    readonly NeighborSolicitsSent: long;
    readonly PacketTooBigMessagesReceived: long;
    readonly PacketTooBigMessagesSent: long;
    readonly ParameterProblemsReceived: long;
    readonly ParameterProblemsSent: long;
    readonly RedirectsReceived: long;
    readonly RedirectsSent: long;
    readonly RouterAdvertisementsReceived: long;
    readonly RouterAdvertisementsSent: long;
    readonly RouterSolicitsReceived: long;
    readonly RouterSolicitsSent: long;
    readonly TimeExceededMessagesReceived: long;
    readonly TimeExceededMessagesSent: long;
}


export type IcmpV6Statistics = IcmpV6Statistics$instance;

export class IPAddressCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: IPAddress;
    Add(address: IPAddress): void;
    Clear(): void;
    Contains(address: IPAddress): boolean;
    CopyTo(array: IPAddress[], offset: int): void;
    GetEnumerator(): IEnumerator_1<IPAddress>;
    Remove(address: IPAddress): boolean;
}


export interface __IPAddressCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<IPAddress>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddress>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressCollection = IPAddressCollection$instance & __IPAddressCollection$views;


export abstract class IPAddressInformation$instance {
    readonly Address: IPAddress;
    readonly IsDnsEligible: boolean;
    readonly IsTransient: boolean;
}


export type IPAddressInformation = IPAddressInformation$instance;

export class IPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: IPAddressInformation;
    Add(address: IPAddressInformation): void;
    Clear(): void;
    Contains(address: IPAddressInformation): boolean;
    CopyTo(array: IPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<IPAddressInformation>;
    Remove(address: IPAddressInformation): boolean;
}


export interface __IPAddressInformationCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<IPAddressInformation>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddressInformation>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressInformationCollection = IPAddressInformationCollection$instance & __IPAddressInformationCollection$views;


export abstract class IPGlobalProperties$instance {
    readonly DhcpScopeName: string;
    readonly DomainName: string;
    readonly HostName: string;
    readonly IsWinsProxy: boolean;
    readonly NodeType: NetBiosNodeType;
    BeginGetUnicastAddresses(callback: AsyncCallback, state: any): IAsyncResult;
    EndGetUnicastAddresses(asyncResult: IAsyncResult): UnicastIPAddressInformationCollection;
    abstract GetActiveTcpConnections(): TcpConnectionInformation[];
    abstract GetActiveTcpListeners(): IPEndPoint[];
    abstract GetActiveUdpListeners(): IPEndPoint[];
    abstract GetIcmpV4Statistics(): IcmpV4Statistics;
    abstract GetIcmpV6Statistics(): IcmpV6Statistics;
    abstract GetIPv4GlobalStatistics(): IPGlobalStatistics;
    abstract GetIPv6GlobalStatistics(): IPGlobalStatistics;
    abstract GetTcpIPv4Statistics(): TcpStatistics;
    abstract GetTcpIPv6Statistics(): TcpStatistics;
    abstract GetUdpIPv4Statistics(): UdpStatistics;
    abstract GetUdpIPv6Statistics(): UdpStatistics;
    GetUnicastAddresses(): UnicastIPAddressInformationCollection;
    GetUnicastAddressesAsync(): Task_1<UnicastIPAddressInformationCollection>;
    static GetIPGlobalProperties(): IPGlobalProperties;
}


export type IPGlobalProperties = IPGlobalProperties$instance;

export abstract class IPGlobalStatistics$instance {
    readonly DefaultTtl: int;
    readonly ForwardingEnabled: boolean;
    readonly NumberOfInterfaces: int;
    readonly NumberOfIPAddresses: int;
    readonly NumberOfRoutes: int;
    readonly OutputPacketRequests: long;
    readonly OutputPacketRoutingDiscards: long;
    readonly OutputPacketsDiscarded: long;
    readonly OutputPacketsWithNoRoute: long;
    readonly PacketFragmentFailures: long;
    readonly PacketReassembliesRequired: long;
    readonly PacketReassemblyFailures: long;
    readonly PacketReassemblyTimeout: long;
    readonly PacketsFragmented: long;
    readonly PacketsReassembled: long;
    readonly ReceivedPackets: long;
    readonly ReceivedPacketsDelivered: long;
    readonly ReceivedPacketsDiscarded: long;
    readonly ReceivedPacketsForwarded: long;
    readonly ReceivedPacketsWithAddressErrors: long;
    readonly ReceivedPacketsWithHeadersErrors: long;
    readonly ReceivedPacketsWithUnknownProtocol: long;
}


export type IPGlobalStatistics = IPGlobalStatistics$instance;

export abstract class IPInterfaceProperties$instance {
    readonly AnycastAddresses: IPAddressInformationCollection;
    readonly DhcpServerAddresses: IPAddressCollection;
    readonly DnsAddresses: IPAddressCollection;
    readonly DnsSuffix: string;
    readonly GatewayAddresses: GatewayIPAddressInformationCollection;
    readonly IsDnsEnabled: boolean;
    readonly IsDynamicDnsEnabled: boolean;
    readonly MulticastAddresses: MulticastIPAddressInformationCollection;
    readonly UnicastAddresses: UnicastIPAddressInformationCollection;
    readonly WinsServersAddresses: IPAddressCollection;
    abstract GetIPv4Properties(): IPv4InterfaceProperties;
    abstract GetIPv6Properties(): IPv6InterfaceProperties;
}


export type IPInterfaceProperties = IPInterfaceProperties$instance;

export abstract class IPInterfaceStatistics$instance {
    readonly BytesReceived: long;
    readonly BytesSent: long;
    readonly IncomingPacketsDiscarded: long;
    readonly IncomingPacketsWithErrors: long;
    readonly IncomingUnknownProtocolPackets: long;
    readonly NonUnicastPacketsReceived: long;
    readonly NonUnicastPacketsSent: long;
    readonly OutgoingPacketsDiscarded: long;
    readonly OutgoingPacketsWithErrors: long;
    readonly OutputQueueLength: long;
    readonly UnicastPacketsReceived: long;
    readonly UnicastPacketsSent: long;
}


export type IPInterfaceStatistics = IPInterfaceStatistics$instance;

export abstract class IPv4InterfaceProperties$instance {
    readonly Index: int;
    readonly IsAutomaticPrivateAddressingActive: boolean;
    readonly IsAutomaticPrivateAddressingEnabled: boolean;
    readonly IsDhcpEnabled: boolean;
    readonly IsForwardingEnabled: boolean;
    readonly Mtu: int;
    readonly UsesWins: boolean;
}


export type IPv4InterfaceProperties = IPv4InterfaceProperties$instance;

export abstract class IPv4InterfaceStatistics$instance {
    readonly BytesReceived: long;
    readonly BytesSent: long;
    readonly IncomingPacketsDiscarded: long;
    readonly IncomingPacketsWithErrors: long;
    readonly IncomingUnknownProtocolPackets: long;
    readonly NonUnicastPacketsReceived: long;
    readonly NonUnicastPacketsSent: long;
    readonly OutgoingPacketsDiscarded: long;
    readonly OutgoingPacketsWithErrors: long;
    readonly OutputQueueLength: long;
    readonly UnicastPacketsReceived: long;
    readonly UnicastPacketsSent: long;
}


export type IPv4InterfaceStatistics = IPv4InterfaceStatistics$instance;

export abstract class IPv6InterfaceProperties$instance {
    readonly Index: int;
    readonly Mtu: int;
    GetScopeId(scopeLevel: ScopeLevel): long;
}


export type IPv6InterfaceProperties = IPv6InterfaceProperties$instance;

export abstract class MulticastIPAddressInformation$instance extends IPAddressInformation$instance {
    readonly AddressPreferredLifetime: long;
    readonly AddressValidLifetime: long;
    readonly DhcpLeaseLifetime: long;
    readonly DuplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly PrefixOrigin: PrefixOrigin;
    readonly SuffixOrigin: SuffixOrigin;
}


export type MulticastIPAddressInformation = MulticastIPAddressInformation$instance;

export class MulticastIPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: MulticastIPAddressInformation;
    Add(address: MulticastIPAddressInformation): void;
    Clear(): void;
    Contains(address: MulticastIPAddressInformation): boolean;
    CopyTo(array: MulticastIPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<MulticastIPAddressInformation>;
    Remove(address: MulticastIPAddressInformation): boolean;
}


export interface __MulticastIPAddressInformationCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<MulticastIPAddressInformation>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<MulticastIPAddressInformation>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type MulticastIPAddressInformationCollection = MulticastIPAddressInformationCollection$instance & __MulticastIPAddressInformationCollection$views;


export class NetworkAddressChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: EventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: EventArgs): void;
}


export interface __NetworkAddressChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkAddressChangedEventHandler = NetworkAddressChangedEventHandler$instance & __NetworkAddressChangedEventHandler$views;


export class NetworkAvailabilityChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: NetworkAvailabilityEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: NetworkAvailabilityEventArgs): void;
}


export interface __NetworkAvailabilityChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkAvailabilityChangedEventHandler = NetworkAvailabilityChangedEventHandler$instance & __NetworkAvailabilityChangedEventHandler$views;


export class NetworkAvailabilityEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly IsAvailable: boolean;
}


export type NetworkAvailabilityEventArgs = NetworkAvailabilityEventArgs$instance;

export class NetworkChange$instance {
    constructor();
    static RegisterNetworkChange(nc: NetworkChange): void;
}


export type NetworkChange = NetworkChange$instance;

export class NetworkInformationException$instance extends System_ComponentModel_Internal.Win32Exception$instance {
    constructor();
    constructor(errorCode: int);
    readonly ErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __NetworkInformationException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkInformationException = NetworkInformationException$instance & __NetworkInformationException$views;


export abstract class NetworkInterface$instance {
    readonly Description: string;
    readonly Id: string;
    readonly IsReceiveOnly: boolean;
    readonly Name: string;
    readonly NetworkInterfaceType: NetworkInterfaceType;
    readonly OperationalStatus: OperationalStatus;
    readonly Speed: long;
    readonly SupportsMulticast: boolean;
    GetIPProperties(): IPInterfaceProperties;
    GetIPStatistics(): IPInterfaceStatistics;
    GetIPv4Statistics(): IPv4InterfaceStatistics;
    GetPhysicalAddress(): PhysicalAddress;
    Supports(networkInterfaceComponent: NetworkInterfaceComponent): boolean;
    static readonly IPv6LoopbackInterfaceIndex: int;
    static readonly LoopbackInterfaceIndex: int;
    static GetAllNetworkInterfaces(): NetworkInterface[];
    static GetIsNetworkAvailable(): boolean;
}


export type NetworkInterface = NetworkInterface$instance;

export class PhysicalAddress$instance {
    constructor(address: byte[]);
    Equals(comparand: any): boolean;
    GetAddressBytes(): byte[];
    GetHashCode(): int;
    ToString(): string;
    static readonly None: PhysicalAddress;
    static Parse(address: ReadOnlySpan_1<CLROf<string>>): PhysicalAddress;
    static Parse(address: string): PhysicalAddress;
    static TryParse(address: ReadOnlySpan_1<CLROf<string>>, value: { value: TSByRef<PhysicalAddress> }): boolean;
    static TryParse(address: string, value: { value: TSByRef<PhysicalAddress> }): boolean;
}


export type PhysicalAddress = PhysicalAddress$instance;

export class Ping$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    Dispose(): void;
    Send(hostNameOrAddress: string): PingReply;
    Send(hostNameOrAddress: string, timeout: int): PingReply;
    Send(address: IPAddress): PingReply;
    Send(address: IPAddress, timeout: int): PingReply;
    Send(hostNameOrAddress: string, timeout: int, buffer: byte[]): PingReply;
    Send(address: IPAddress, timeout: int, buffer: byte[]): PingReply;
    Send(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions): PingReply;
    Send(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions): PingReply;
    Send(address: IPAddress, timeout: TimeSpan, buffer?: byte[], options?: PingOptions): PingReply;
    Send(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[], options?: PingOptions): PingReply;
    SendAsync(hostNameOrAddress: string, userToken: any): void;
    SendAsync(hostNameOrAddress: string, timeout: int, userToken: any): void;
    SendAsync(address: IPAddress, userToken: any): void;
    SendAsync(address: IPAddress, timeout: int, userToken: any): void;
    SendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], userToken: any): void;
    SendAsync(address: IPAddress, timeout: int, buffer: byte[], userToken: any): void;
    SendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions, userToken: any): void;
    SendAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions, userToken: any): void;
    SendAsyncCancel(): void;
    SendPingAsync(address: IPAddress): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: int): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: int): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: int, buffer: byte[]): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[]): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: TimeSpan, buffer?: byte[], options?: PingOptions, cancellationToken?: CancellationToken): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[], options?: PingOptions, cancellationToken?: CancellationToken): Task_1<PingReply>;
}


export interface __Ping$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Ping = Ping$instance & __Ping$views;


export class PingCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Reply: PingReply;
}


export type PingCompletedEventArgs = PingCompletedEventArgs$instance;

export class PingCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: PingCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: PingCompletedEventArgs): void;
}


export interface __PingCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PingCompletedEventHandler = PingCompletedEventHandler$instance & __PingCompletedEventHandler$views;


export class PingException$instance extends System_Internal.InvalidOperationException$instance {
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __PingException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PingException = PingException$instance & __PingException$views;


export class PingOptions$instance {
    constructor();
    constructor(ttl: int, dontFragment: boolean);
    DontFragment: boolean;
    Ttl: int;
}


export type PingOptions = PingOptions$instance;

export class PingReply$instance {
    readonly Address: IPAddress;
    readonly Buffer: byte[];
    readonly Options: PingOptions;
    readonly RoundtripTime: long;
    readonly Status: IPStatus;
}


export type PingReply = PingReply$instance;

export abstract class TcpConnectionInformation$instance {
    readonly LocalEndPoint: IPEndPoint;
    readonly RemoteEndPoint: IPEndPoint;
    readonly State: TcpState;
}


export type TcpConnectionInformation = TcpConnectionInformation$instance;

export abstract class TcpStatistics$instance {
    readonly ConnectionsAccepted: long;
    readonly ConnectionsInitiated: long;
    readonly CumulativeConnections: long;
    readonly CurrentConnections: long;
    readonly ErrorsReceived: long;
    readonly FailedConnectionAttempts: long;
    readonly MaximumConnections: long;
    readonly MaximumTransmissionTimeout: long;
    readonly MinimumTransmissionTimeout: long;
    readonly ResetConnections: long;
    readonly ResetsSent: long;
    readonly SegmentsReceived: long;
    readonly SegmentsResent: long;
    readonly SegmentsSent: long;
}


export type TcpStatistics = TcpStatistics$instance;

export abstract class UdpStatistics$instance {
    readonly DatagramsReceived: long;
    readonly DatagramsSent: long;
    readonly IncomingDatagramsDiscarded: long;
    readonly IncomingDatagramsWithErrors: long;
    readonly UdpListeners: int;
}


export type UdpStatistics = UdpStatistics$instance;

export abstract class UnicastIPAddressInformation$instance extends IPAddressInformation$instance {
    readonly AddressPreferredLifetime: long;
    readonly AddressValidLifetime: long;
    readonly DhcpLeaseLifetime: long;
    readonly DuplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly IPv4Mask: IPAddress;
    readonly PrefixLength: int;
    readonly PrefixOrigin: PrefixOrigin;
    readonly SuffixOrigin: SuffixOrigin;
}


export type UnicastIPAddressInformation = UnicastIPAddressInformation$instance;

export class UnicastIPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: UnicastIPAddressInformation;
    Add(address: UnicastIPAddressInformation): void;
    Clear(): void;
    Contains(address: UnicastIPAddressInformation): boolean;
    CopyTo(array: UnicastIPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<UnicastIPAddressInformation>;
    Remove(address: UnicastIPAddressInformation): boolean;
}


export interface __UnicastIPAddressInformationCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<UnicastIPAddressInformation>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<UnicastIPAddressInformation>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type UnicastIPAddressInformationCollection = UnicastIPAddressInformationCollection$instance & __UnicastIPAddressInformationCollection$views;


