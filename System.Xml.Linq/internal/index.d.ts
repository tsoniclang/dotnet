// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Linq
// Assembly: System.Private.Xml.Linq

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEnumerable_1, IEqualityComparer_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IComparer, IEqualityComparer } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { XmlSchema } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { IXmlLineInfo, XmlNodeType, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Enum, EventArgs, EventHandler_1, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum LoadOptions {
    None = 0,
    PreserveWhitespace = 1,
    SetBaseUri = 2,
    SetLineInfo = 4
}


export enum ReaderOptions {
    None = 0,
    OmitDuplicateNamespaces = 1
}


export enum SaveOptions {
    None = 0,
    DisableFormatting = 1,
    OmitDuplicateNamespaces = 2
}


export enum XObjectChange {
    Add = 0,
    Remove = 1,
    Name = 2,
    Value = 3
}


export class XAttribute$instance extends XObject$instance {
    constructor(name: XName, value: any);
    constructor(other: XAttribute);
    readonly IsNamespaceDeclaration: boolean;
    readonly Name: XName;
    readonly NextAttribute: XAttribute;
    readonly NodeType: XmlNodeType;
    readonly PreviousAttribute: XAttribute;
    Value: string;
    HasLineInfo(): boolean;
    Remove(): void;
    SetValue(value: any): void;
    ToString(): string;
    static readonly EmptySequence: IEnumerable_1<XAttribute>;
}


export interface __XAttribute$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XAttribute = XAttribute$instance & __XAttribute$views;


export class XCData$instance extends XText$instance {
    constructor(value: string);
    constructor(other: XCData);
    readonly NodeType: XmlNodeType;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export interface __XCData$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XCData = XCData$instance & __XCData$views;


export class XComment$instance extends XNode$instance {
    constructor(value: string);
    constructor(other: XComment);
    readonly NodeType: XmlNodeType;
    Value: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export interface __XComment$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XComment = XComment$instance & __XComment$views;


export abstract class XContainer$instance extends XNode$instance {
    readonly FirstNode: XNode;
    readonly LastNode: XNode;
    Add(content: any): void;
    Add(content: any[]): void;
    AddFirst(content: any): void;
    AddFirst(content: any[]): void;
    CreateWriter(): XmlWriter;
    DescendantNodes(): IEnumerable_1<XNode>;
    Descendants(): IEnumerable_1<XElement>;
    Descendants(name: XName): IEnumerable_1<XElement>;
    Element(name: XName): XElement;
    Elements(): IEnumerable_1<XElement>;
    Elements(name: XName): IEnumerable_1<XElement>;
    HasLineInfo(): boolean;
    Nodes(): IEnumerable_1<XNode>;
    RemoveNodes(): void;
    ReplaceNodes(content: any): void;
    ReplaceNodes(content: any[]): void;
}


export interface __XContainer$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XContainer = XContainer$instance & __XContainer$views;


export class XDeclaration$instance {
    constructor(version: string, encoding: string, standalone: string);
    constructor(other: XDeclaration);
    Encoding: string;
    Standalone: string;
    Version: string;
    ToString(): string;
}


export type XDeclaration = XDeclaration$instance;

export class XDocument$instance extends XContainer$instance {
    constructor();
    constructor(content: any[]);
    constructor(declaration: XDeclaration, content: any[]);
    constructor(other: XDocument);
    Declaration: XDeclaration;
    readonly DocumentType: XDocumentType;
    readonly NodeType: XmlNodeType;
    readonly Root: XElement;
    HasLineInfo(): boolean;
    Save(stream: Stream): void;
    Save(stream: Stream, options: SaveOptions): void;
    Save(textWriter: TextWriter): void;
    Save(textWriter: TextWriter, options: SaveOptions): void;
    Save(writer: XmlWriter): void;
    Save(fileName: string): void;
    Save(fileName: string, options: SaveOptions): void;
    SaveAsync(stream: Stream, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(textWriter: TextWriter, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    static Load(stream: Stream, options: LoadOptions): XDocument;
    static Load(stream: Stream): XDocument;
    static Load(textReader: TextReader, options: LoadOptions): XDocument;
    static Load(textReader: TextReader): XDocument;
    static Load(uri: string, options: LoadOptions): XDocument;
    static Load(uri: string): XDocument;
    static Load(reader: XmlReader, options: LoadOptions): XDocument;
    static Load(reader: XmlReader): XDocument;
    static LoadAsync(stream: Stream, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    static LoadAsync(textReader: TextReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    static LoadAsync(reader: XmlReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    static Parse(text: string, options: LoadOptions): XDocument;
    static Parse(text: string): XDocument;
}


export interface __XDocument$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XDocument = XDocument$instance & __XDocument$views;


export class XDocumentType$instance extends XNode$instance {
    constructor(name: string, publicId: string, systemId: string, internalSubset: string);
    constructor(other: XDocumentType);
    InternalSubset: string;
    Name: string;
    readonly NodeType: XmlNodeType;
    PublicId: string;
    SystemId: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export interface __XDocumentType$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XDocumentType = XDocumentType$instance & __XDocumentType$views;


export class XElement$instance extends XContainer$instance {
    constructor(name: XName);
    constructor(name: XName, content: any);
    constructor(name: XName, content: any[]);
    constructor(other: XElement);
    constructor(other: XStreamingElement);
    readonly FirstAttribute: XAttribute;
    readonly HasAttributes: boolean;
    readonly HasElements: boolean;
    readonly IsEmpty: boolean;
    readonly LastAttribute: XAttribute;
    Name: XName;
    readonly NodeType: XmlNodeType;
    Value: string;
    AncestorsAndSelf(): IEnumerable_1<XElement>;
    AncestorsAndSelf(name: XName): IEnumerable_1<XElement>;
    Attribute(name: XName): XAttribute;
    Attributes(): IEnumerable_1<XAttribute>;
    Attributes(name: XName): IEnumerable_1<XAttribute>;
    DescendantNodesAndSelf(): IEnumerable_1<XNode>;
    DescendantsAndSelf(): IEnumerable_1<XElement>;
    DescendantsAndSelf(name: XName): IEnumerable_1<XElement>;
    GetDefaultNamespace(): XNamespace;
    GetNamespaceOfPrefix(prefix: string): XNamespace;
    GetPrefixOfNamespace(ns: XNamespace): string;
    HasLineInfo(): boolean;
    RemoveAll(): void;
    RemoveAttributes(): void;
    ReplaceAll(content: any): void;
    ReplaceAll(content: any[]): void;
    ReplaceAttributes(content: any): void;
    ReplaceAttributes(content: any[]): void;
    Save(fileName: string): void;
    Save(fileName: string, options: SaveOptions): void;
    Save(stream: Stream): void;
    Save(stream: Stream, options: SaveOptions): void;
    Save(textWriter: TextWriter): void;
    Save(textWriter: TextWriter, options: SaveOptions): void;
    Save(writer: XmlWriter): void;
    SaveAsync(stream: Stream, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(textWriter: TextWriter, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    SetAttributeValue(name: XName, value: any): void;
    SetElementValue(name: XName, value: any): void;
    SetValue(value: any): void;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    static readonly EmptySequence: IEnumerable_1<XElement>;
    static Load(stream: Stream, options: LoadOptions): XElement;
    static Load(stream: Stream): XElement;
    static Load(textReader: TextReader, options: LoadOptions): XElement;
    static Load(textReader: TextReader): XElement;
    static Load(uri: string, options: LoadOptions): XElement;
    static Load(uri: string): XElement;
    static Load(reader: XmlReader, options: LoadOptions): XElement;
    static Load(reader: XmlReader): XElement;
    static LoadAsync(stream: Stream, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    static LoadAsync(textReader: TextReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    static LoadAsync(reader: XmlReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    static Parse(text: string, options: LoadOptions): XElement;
    static Parse(text: string): XElement;
}


export interface __XElement$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
    readonly As_IXmlSerializable: System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export type XElement = XElement$instance & __XElement$views;


export class XName$instance {
    readonly LocalName: string;
    readonly Namespace: XNamespace;
    readonly NamespaceName: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Get(localName: string, namespaceName: string): XName;
    static Get(expandedName: string): XName;
}


export interface __XName$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<XName>;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: XName): boolean;
}

export type XName = XName$instance & __XName$views;


export class XNamespace$instance {
    readonly NamespaceName: string;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    GetName(localName: string): XName;
    ToString(): string;
    static readonly None: XNamespace;
    static readonly Xml: XNamespace;
    static readonly Xmlns: XNamespace;
    static Get(namespaceName: string): XNamespace;
}


export type XNamespace = XNamespace$instance;

export abstract class XNode$instance extends XObject$instance {
    readonly NextNode: XNode;
    readonly PreviousNode: XNode;
    AddAfterSelf(content: any): void;
    AddAfterSelf(content: any[]): void;
    AddBeforeSelf(content: any): void;
    AddBeforeSelf(content: any[]): void;
    Ancestors(): IEnumerable_1<XElement>;
    Ancestors(name: XName): IEnumerable_1<XElement>;
    CreateReader(): XmlReader;
    CreateReader(readerOptions: ReaderOptions): XmlReader;
    ElementsAfterSelf(): IEnumerable_1<XElement>;
    ElementsAfterSelf(name: XName): IEnumerable_1<XElement>;
    ElementsBeforeSelf(): IEnumerable_1<XElement>;
    ElementsBeforeSelf(name: XName): IEnumerable_1<XElement>;
    HasLineInfo(): boolean;
    IsAfter(node: XNode): boolean;
    IsBefore(node: XNode): boolean;
    NodesAfterSelf(): IEnumerable_1<XNode>;
    NodesBeforeSelf(): IEnumerable_1<XNode>;
    Remove(): void;
    ReplaceWith(content: any): void;
    ReplaceWith(content: any[]): void;
    ToString(): string;
    ToString(options: SaveOptions): string;
    abstract WriteTo(writer: XmlWriter): void;
    abstract WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    static readonly DocumentOrderComparer: XNodeDocumentOrderComparer;
    static readonly EqualityComparer: XNodeEqualityComparer;
    static CompareDocumentOrder(n1: XNode, n2: XNode): int;
    static DeepEquals(n1: XNode, n2: XNode): boolean;
    static ReadFrom(reader: XmlReader): XNode;
    static ReadFromAsync(reader: XmlReader, cancellationToken: CancellationToken): Task_1<XNode>;
}


export interface __XNode$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XNode = XNode$instance & __XNode$views;


export class XNodeDocumentOrderComparer$instance {
    constructor();
    Compare(x: XNode, y: XNode): int;
}


export interface __XNodeDocumentOrderComparer$views {
    readonly As_IComparer_1_of_String: System_Collections_Generic_Internal.IComparer_1$instance<XNode>;
    readonly As_IComparer: System_Collections_Internal.IComparer$instance;
}

export type XNodeDocumentOrderComparer = XNodeDocumentOrderComparer$instance & __XNodeDocumentOrderComparer$views;


export class XNodeEqualityComparer$instance {
    constructor();
    Equals(x: XNode, y: XNode): boolean;
    GetHashCode(obj: XNode): int;
}


export interface __XNodeEqualityComparer$views {
    readonly As_IEqualityComparer_1_of_String: System_Collections_Generic_Internal.IEqualityComparer_1$instance<XNode>;
    readonly As_IEqualityComparer: System_Collections_Internal.IEqualityComparer$instance;
}

export type XNodeEqualityComparer = XNodeEqualityComparer$instance & __XNodeEqualityComparer$views;


export abstract class XObject$instance {
    readonly BaseUri: string;
    readonly Document: XDocument;
    readonly NodeType: XmlNodeType;
    readonly Parent: XElement;
    AddAnnotation(annotation: any): void;
    Annotation(type_: Type): any;
    Annotation<T>(): T;
    Annotations(type_: Type): IEnumerable_1<any>;
    Annotations<T>(): IEnumerable_1<T>;
    RemoveAnnotations(type_: Type): void;
    RemoveAnnotations<T>(): void;
}


export interface __XObject$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XObject = XObject$instance & __XObject$views;


export class XObjectChangeEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(objectChange: XObjectChange);
    readonly ObjectChange: XObjectChange;
    static readonly Add: XObjectChangeEventArgs;
    static readonly Remove: XObjectChangeEventArgs;
    static readonly Name: XObjectChangeEventArgs;
    static readonly Value: XObjectChangeEventArgs;
}


export type XObjectChangeEventArgs = XObjectChangeEventArgs$instance;

export class XProcessingInstruction$instance extends XNode$instance {
    constructor(target: string, data: string);
    constructor(other: XProcessingInstruction);
    Data: string;
    readonly NodeType: XmlNodeType;
    Target: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export interface __XProcessingInstruction$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XProcessingInstruction = XProcessingInstruction$instance & __XProcessingInstruction$views;


export class XStreamingElement$instance {
    constructor(name: XName);
    constructor(name: XName, content: any);
    constructor(name: XName, content: any[]);
    Name: XName;
    Add(content: any): void;
    Add(content: any[]): void;
    Save(stream: Stream): void;
    Save(stream: Stream, options: SaveOptions): void;
    Save(textWriter: TextWriter): void;
    Save(textWriter: TextWriter, options: SaveOptions): void;
    Save(writer: XmlWriter): void;
    Save(fileName: string): void;
    Save(fileName: string, options: SaveOptions): void;
    ToString(): string;
    ToString(options: SaveOptions): string;
    WriteTo(writer: XmlWriter): void;
}


export type XStreamingElement = XStreamingElement$instance;

export class XText$instance extends XNode$instance {
    constructor(value: string);
    constructor(other: XText);
    readonly NodeType: XmlNodeType;
    Value: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export interface __XText$views {
    readonly As_IXmlLineInfo: System_Xml_Internal.IXmlLineInfo$instance;
}

export type XText = XText$instance & __XText$views;


export abstract class Extensions$instance {
    static Ancestors<T extends XNode>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static Ancestors<T extends XNode>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static AncestorsAndSelf(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XElement>;
    static AncestorsAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XElement>;
    static Attributes(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XAttribute>;
    static Attributes(source: IEnumerable_1<XElement>): IEnumerable_1<XAttribute>;
    static DescendantNodes<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XNode>;
    static DescendantNodesAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XNode>;
    static Descendants<T extends XContainer>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static Descendants<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static DescendantsAndSelf(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XElement>;
    static DescendantsAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XElement>;
    static Elements<T extends XContainer>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static Elements<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static InDocumentOrder<T extends XNode>(source: IEnumerable_1<T>): IEnumerable_1<T>;
    static Nodes<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XNode>;
    static Remove<T extends XNode>(source: IEnumerable_1<T>): void;
    static Remove(source: IEnumerable_1<XAttribute>): void;
}


export type Extensions = Extensions$instance;

