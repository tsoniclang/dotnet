// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Schema
// Assembly: System.Private.Xml, System.Private.Xml.Linq

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, CollectionBase, ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { XAttribute, XDocument, XElement } from "../../System.Xml.Linq/internal/index.js";
import type { XmlSerializerNamespaces } from "../../System.Xml.Serialization/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { XPathItem } from "../../System.Xml.XPath/internal/index.js";
import type { IXmlLineInfo, IXmlNamespaceResolver, XmlAttribute, XmlNamespaceManager, XmlNameTable, XmlNode, XmlQualifiedName, XmlReader, XmlResolver, XmlTokenizedType, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Uri, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum XmlSchemaContentProcessing {
    None = 0,
    Skip = 1,
    Lax = 2,
    Strict = 3
}


export enum XmlSchemaContentType {
    TextOnly = 0,
    Empty = 1,
    ElementOnly = 2,
    Mixed = 3
}


export enum XmlSchemaDatatypeVariety {
    Atomic = 0,
    List = 1,
    Union = 2
}


export enum XmlSchemaDerivationMethod {
    Empty = 0,
    Substitution = 1,
    Extension = 2,
    Restriction = 4,
    List = 8,
    Union = 16,
    All = 255,
    None = 256
}


export enum XmlSchemaForm {
    None = 0,
    Qualified = 1,
    Unqualified = 2
}


export enum XmlSchemaInference_InferenceOption {
    Restricted = 0,
    Relaxed = 1
}


export enum XmlSchemaUse {
    None = 0,
    Optional = 1,
    Prohibited = 2,
    Required = 3
}


export enum XmlSchemaValidationFlags {
    None = 0,
    ProcessInlineSchema = 1,
    ProcessSchemaLocation = 2,
    ReportValidationWarnings = 4,
    ProcessIdentityConstraints = 8,
    AllowXmlAttributes = 16
}


export enum XmlSchemaValidity {
    NotKnown = 0,
    Valid = 1,
    Invalid = 2
}


export enum XmlSeverityType {
    Error = 0,
    Warning = 1
}


export enum XmlTypeCode {
    None = 0,
    Item = 1,
    Node = 2,
    Document = 3,
    Element = 4,
    Attribute = 5,
    Namespace = 6,
    ProcessingInstruction = 7,
    Comment = 8,
    Text = 9,
    AnyAtomicType = 10,
    UntypedAtomic = 11,
    String = 12,
    Boolean = 13,
    Decimal = 14,
    Float = 15,
    Double = 16,
    Duration = 17,
    DateTime = 18,
    Time = 19,
    Date = 20,
    GYearMonth = 21,
    GYear = 22,
    GMonthDay = 23,
    GDay = 24,
    GMonth = 25,
    HexBinary = 26,
    Base64Binary = 27,
    AnyUri = 28,
    QName = 29,
    Notation = 30,
    NormalizedString = 31,
    Token = 32,
    Language = 33,
    NmToken = 34,
    Name = 35,
    NCName = 36,
    Id = 37,
    Idref = 38,
    Entity = 39,
    Integer = 40,
    NonPositiveInteger = 41,
    NegativeInteger = 42,
    Long = 43,
    Int = 44,
    Short = 45,
    Byte = 46,
    NonNegativeInteger = 47,
    UnsignedLong = 48,
    UnsignedInt = 49,
    UnsignedShort = 50,
    UnsignedByte = 51,
    PositiveInteger = 52,
    YearMonthDuration = 53,
    DayTimeDuration = 54
}


export interface IXmlSchemaInfo$instance {
    readonly Validity: XmlSchemaValidity;
    readonly IsDefault: boolean;
    readonly IsNil: boolean;
    readonly MemberType: XmlSchemaSimpleType;
    readonly SchemaType: XmlSchemaType;
    readonly SchemaElement: XmlSchemaElement;
    readonly SchemaAttribute: XmlSchemaAttribute;
}


export type IXmlSchemaInfo = IXmlSchemaInfo$instance;

export class ValidationEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly Exception: XmlSchemaException;
    readonly Message: string;
    readonly Severity: XmlSeverityType;
}


export type ValidationEventArgs = ValidationEventArgs$instance;

export class ValidationEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(sender: unknown, e: ValidationEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: unknown, e: ValidationEventArgs): void;
}


export interface __ValidationEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ValidationEventHandler = ValidationEventHandler$instance & __ValidationEventHandler$views;


export class XmlAtomicValue$instance extends System_Xml_XPath_Internal.XPathItem$instance {
    readonly IsNode: boolean;
    readonly TypedValue: unknown;
    readonly Value: string;
    readonly ValueAsBoolean: boolean;
    readonly ValueAsDateTime: DateTime;
    readonly ValueAsDouble: double;
    readonly ValueAsInt: int;
    readonly ValueAsLong: long;
    readonly ValueType: Type;
    readonly XmlType: XmlSchemaType;
    Clone(): XmlAtomicValue;
    ToString(): string;
    ValueAs(type_: Type, nsResolver: IXmlNamespaceResolver): unknown;
    ValueAs(returnType: Type): unknown;
}


export interface __XmlAtomicValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type XmlAtomicValue = XmlAtomicValue$instance & __XmlAtomicValue$views;


export class XmlSchema$instance extends XmlSchemaObject$instance {
    constructor();
    AttributeFormDefault: XmlSchemaForm;
    readonly AttributeGroups: XmlSchemaObjectTable;
    readonly Attributes: XmlSchemaObjectTable;
    BlockDefault: XmlSchemaDerivationMethod;
    ElementFormDefault: XmlSchemaForm;
    readonly Elements: XmlSchemaObjectTable;
    FinalDefault: XmlSchemaDerivationMethod;
    readonly Groups: XmlSchemaObjectTable;
    Id: string;
    readonly Includes: XmlSchemaObjectCollection;
    readonly IsCompiled: boolean;
    readonly Items: XmlSchemaObjectCollection;
    readonly Notations: XmlSchemaObjectTable;
    readonly SchemaTypes: XmlSchemaObjectTable;
    TargetNamespace: string;
    UnhandledAttributes: XmlAttribute[];
    Version: string;
    Compile(validationEventHandler: ValidationEventHandler): void;
    Compile(validationEventHandler: ValidationEventHandler, resolver: XmlResolver): void;
    Write(stream: Stream): void;
    Write(stream: Stream, namespaceManager: XmlNamespaceManager): void;
    Write(writer: TextWriter): void;
    Write(writer: TextWriter, namespaceManager: XmlNamespaceManager): void;
    Write(writer: XmlWriter): void;
    Write(writer: XmlWriter, namespaceManager: XmlNamespaceManager): void;
    static readonly Namespace: string;
    static readonly InstanceNamespace: string;
    static Read(stream: Stream, validationEventHandler: ValidationEventHandler): XmlSchema;
    static Read(reader: TextReader, validationEventHandler: ValidationEventHandler): XmlSchema;
    static Read(reader: XmlReader, validationEventHandler: ValidationEventHandler): XmlSchema;
}


export type XmlSchema = XmlSchema$instance;

export class XmlSchemaAll$instance extends XmlSchemaGroupBase$instance {
    constructor();
    readonly Items: XmlSchemaObjectCollection;
}


export type XmlSchemaAll = XmlSchemaAll$instance;

export class XmlSchemaAnnotated$instance extends XmlSchemaObject$instance {
    constructor();
    Annotation: XmlSchemaAnnotation;
    Id: string;
    UnhandledAttributes: XmlAttribute[];
}


export type XmlSchemaAnnotated = XmlSchemaAnnotated$instance;

export class XmlSchemaAnnotation$instance extends XmlSchemaObject$instance {
    constructor();
    Id: string;
    readonly Items: XmlSchemaObjectCollection;
    UnhandledAttributes: XmlAttribute[];
}


export type XmlSchemaAnnotation = XmlSchemaAnnotation$instance;

export class XmlSchemaAny$instance extends XmlSchemaParticle$instance {
    constructor();
    Namespace: string;
    ProcessContents: XmlSchemaContentProcessing;
}


export type XmlSchemaAny = XmlSchemaAny$instance;

export class XmlSchemaAnyAttribute$instance extends XmlSchemaAnnotated$instance {
    constructor();
    Namespace: string;
    ProcessContents: XmlSchemaContentProcessing;
}


export type XmlSchemaAnyAttribute = XmlSchemaAnyAttribute$instance;

export class XmlSchemaAppInfo$instance extends XmlSchemaObject$instance {
    constructor();
    Markup: XmlNode[];
    Source: string;
}


export type XmlSchemaAppInfo = XmlSchemaAppInfo$instance;

export class XmlSchemaAttribute$instance extends XmlSchemaAnnotated$instance {
    constructor();
    readonly AttributeSchemaType: XmlSchemaSimpleType;
    readonly AttributeType: unknown;
    DefaultValue: string;
    FixedValue: string;
    Form: XmlSchemaForm;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    RefName: XmlQualifiedName;
    SchemaType: XmlSchemaSimpleType;
    SchemaTypeName: XmlQualifiedName;
    Use: XmlSchemaUse;
}


export type XmlSchemaAttribute = XmlSchemaAttribute$instance;

export class XmlSchemaAttributeGroup$instance extends XmlSchemaAnnotated$instance {
    constructor();
    AnyAttribute: XmlSchemaAnyAttribute;
    readonly Attributes: XmlSchemaObjectCollection;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    readonly RedefinedAttributeGroup: XmlSchemaAttributeGroup;
}


export type XmlSchemaAttributeGroup = XmlSchemaAttributeGroup$instance;

export class XmlSchemaAttributeGroupRef$instance extends XmlSchemaAnnotated$instance {
    constructor();
    RefName: XmlQualifiedName;
}


export type XmlSchemaAttributeGroupRef = XmlSchemaAttributeGroupRef$instance;

export class XmlSchemaChoice$instance extends XmlSchemaGroupBase$instance {
    constructor();
    readonly Items: XmlSchemaObjectCollection;
}


export type XmlSchemaChoice = XmlSchemaChoice$instance;

export class XmlSchemaCollection$instance {
    constructor();
    constructor(nametable: XmlNameTable);
    readonly Count: int;
    readonly Item: XmlSchema;
    readonly NameTable: XmlNameTable;
    Add(ns: string, uri: string): XmlSchema;
    Add(ns: string, reader: XmlReader): XmlSchema;
    Add(ns: string, reader: XmlReader, resolver: XmlResolver): XmlSchema;
    Add(schema: XmlSchema): XmlSchema;
    Add(schema: XmlSchema, resolver: XmlResolver): XmlSchema;
    Add(schema: XmlSchemaCollection): void;
    Contains(schema: XmlSchema): boolean;
    Contains(ns: string): boolean;
    CopyTo(array: XmlSchema[], index: int): void;
    GetEnumerator(): XmlSchemaCollectionEnumerator;
}


export interface __XmlSchemaCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type XmlSchemaCollection = XmlSchemaCollection$instance & __XmlSchemaCollection$views;


export class XmlSchemaCollectionEnumerator$instance {
    readonly Current: unknown | XmlSchema;
    MoveNext(): boolean;
}


export interface __XmlSchemaCollectionEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaCollectionEnumerator = XmlSchemaCollectionEnumerator$instance & __XmlSchemaCollectionEnumerator$views;


export class XmlSchemaCompilationSettings$instance {
    constructor();
    EnableUpaCheck: boolean;
}


export type XmlSchemaCompilationSettings = XmlSchemaCompilationSettings$instance;

export class XmlSchemaComplexContent$instance extends XmlSchemaContentModel$instance {
    constructor();
    Content: XmlSchemaContent;
    IsMixed: boolean;
}


export type XmlSchemaComplexContent = XmlSchemaComplexContent$instance;

export class XmlSchemaComplexContentExtension$instance extends XmlSchemaContent$instance {
    constructor();
    AnyAttribute: XmlSchemaAnyAttribute;
    readonly Attributes: XmlSchemaObjectCollection;
    BaseTypeName: XmlQualifiedName;
    Particle: XmlSchemaParticle;
}


export type XmlSchemaComplexContentExtension = XmlSchemaComplexContentExtension$instance;

export class XmlSchemaComplexContentRestriction$instance extends XmlSchemaContent$instance {
    constructor();
    AnyAttribute: XmlSchemaAnyAttribute;
    readonly Attributes: XmlSchemaObjectCollection;
    BaseTypeName: XmlQualifiedName;
    Particle: XmlSchemaParticle;
}


export type XmlSchemaComplexContentRestriction = XmlSchemaComplexContentRestriction$instance;

export class XmlSchemaComplexType$instance extends XmlSchemaType$instance {
    constructor();
    AnyAttribute: XmlSchemaAnyAttribute;
    readonly Attributes: XmlSchemaObjectCollection;
    readonly AttributeUses: XmlSchemaObjectTable;
    readonly AttributeWildcard: XmlSchemaAnyAttribute;
    Block: XmlSchemaDerivationMethod;
    readonly BlockResolved: XmlSchemaDerivationMethod;
    ContentModel: XmlSchemaContentModel;
    readonly ContentType: XmlSchemaContentType;
    readonly ContentTypeParticle: XmlSchemaParticle;
    IsAbstract: boolean;
    IsMixed: boolean;
    Particle: XmlSchemaParticle;
}


export type XmlSchemaComplexType = XmlSchemaComplexType$instance;

export abstract class XmlSchemaContent$instance extends XmlSchemaAnnotated$instance {
}


export type XmlSchemaContent = XmlSchemaContent$instance;

export abstract class XmlSchemaContentModel$instance extends XmlSchemaAnnotated$instance {
    Content: XmlSchemaContent;
}


export type XmlSchemaContentModel = XmlSchemaContentModel$instance;

export abstract class XmlSchemaDatatype$instance {
    readonly TokenizedType: XmlTokenizedType;
    readonly TypeCode: XmlTypeCode;
    readonly ValueType: Type;
    readonly Variety: XmlSchemaDatatypeVariety;
    ChangeType(value: unknown, targetType: Type): unknown;
    ChangeType(value: unknown, targetType: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    IsDerivedFrom(datatype: XmlSchemaDatatype): boolean;
    abstract ParseValue(s: string, nameTable: XmlNameTable, nsmgr: IXmlNamespaceResolver): unknown;
}


export type XmlSchemaDatatype = XmlSchemaDatatype$instance;

export class XmlSchemaDocumentation$instance extends XmlSchemaObject$instance {
    constructor();
    Language: string;
    Markup: XmlNode[];
    Source: string;
}


export type XmlSchemaDocumentation = XmlSchemaDocumentation$instance;

export class XmlSchemaElement$instance extends XmlSchemaParticle$instance {
    constructor();
    Block: XmlSchemaDerivationMethod;
    readonly BlockResolved: XmlSchemaDerivationMethod;
    readonly Constraints: XmlSchemaObjectCollection;
    DefaultValue: string;
    readonly ElementSchemaType: XmlSchemaType;
    readonly ElementType: unknown;
    Final: XmlSchemaDerivationMethod;
    readonly FinalResolved: XmlSchemaDerivationMethod;
    FixedValue: string;
    Form: XmlSchemaForm;
    IsAbstract: boolean;
    IsNillable: boolean;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    RefName: XmlQualifiedName;
    SchemaType: XmlSchemaType;
    SchemaTypeName: XmlQualifiedName;
    SubstitutionGroup: XmlQualifiedName;
}


export type XmlSchemaElement = XmlSchemaElement$instance;

export class XmlSchemaEnumerationFacet$instance extends XmlSchemaFacet$instance {
    constructor();
}


export type XmlSchemaEnumerationFacet = XmlSchemaEnumerationFacet$instance;

export class XmlSchemaException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerException: Exception, lineNumber: int, linePosition: int);
    readonly LineNumber: int;
    readonly LinePosition: int;
    readonly Message: string;
    readonly SourceSchemaObject: XmlSchemaObject;
    readonly SourceUri: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XmlSchemaException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaException = XmlSchemaException$instance & __XmlSchemaException$views;


export abstract class XmlSchemaExternal$instance extends XmlSchemaObject$instance {
    Id: string;
    Schema: XmlSchema;
    SchemaLocation: string;
    UnhandledAttributes: XmlAttribute[];
}


export type XmlSchemaExternal = XmlSchemaExternal$instance;

export abstract class XmlSchemaFacet$instance extends XmlSchemaAnnotated$instance {
    IsFixed: boolean;
    Value: string;
}


export type XmlSchemaFacet = XmlSchemaFacet$instance;

export class XmlSchemaFractionDigitsFacet$instance extends XmlSchemaNumericFacet$instance {
    constructor();
}


export type XmlSchemaFractionDigitsFacet = XmlSchemaFractionDigitsFacet$instance;

export class XmlSchemaGroup$instance extends XmlSchemaAnnotated$instance {
    constructor();
    Name: string;
    Particle: XmlSchemaGroupBase;
    readonly QualifiedName: XmlQualifiedName;
}


export type XmlSchemaGroup = XmlSchemaGroup$instance;

export abstract class XmlSchemaGroupBase$instance extends XmlSchemaParticle$instance {
    readonly Items: XmlSchemaObjectCollection;
}


export type XmlSchemaGroupBase = XmlSchemaGroupBase$instance;

export class XmlSchemaGroupRef$instance extends XmlSchemaParticle$instance {
    constructor();
    readonly Particle: XmlSchemaGroupBase;
    RefName: XmlQualifiedName;
}


export type XmlSchemaGroupRef = XmlSchemaGroupRef$instance;

export class XmlSchemaIdentityConstraint$instance extends XmlSchemaAnnotated$instance {
    constructor();
    readonly Fields: XmlSchemaObjectCollection;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    Selector: XmlSchemaXPath;
}


export type XmlSchemaIdentityConstraint = XmlSchemaIdentityConstraint$instance;

export class XmlSchemaImport$instance extends XmlSchemaExternal$instance {
    constructor();
    Annotation: XmlSchemaAnnotation;
    Namespace: string;
}


export type XmlSchemaImport = XmlSchemaImport$instance;

export class XmlSchemaInclude$instance extends XmlSchemaExternal$instance {
    constructor();
    Annotation: XmlSchemaAnnotation;
}


export type XmlSchemaInclude = XmlSchemaInclude$instance;

export class XmlSchemaInference$instance {
    constructor();
    Occurrence: XmlSchemaInference_InferenceOption;
    TypeInference: XmlSchemaInference_InferenceOption;
    InferSchema(instanceDocument: XmlReader): XmlSchemaSet;
    InferSchema(instanceDocument: XmlReader, schemas: XmlSchemaSet): XmlSchemaSet;
}


export type XmlSchemaInference = XmlSchemaInference$instance;

export class XmlSchemaInferenceException$instance extends XmlSchemaException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerException: Exception, lineNumber: int, linePosition: int);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XmlSchemaInferenceException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaInferenceException = XmlSchemaInferenceException$instance & __XmlSchemaInferenceException$views;


export class XmlSchemaInfo$instance {
    constructor();
    ContentType: XmlSchemaContentType;
    IsDefault: boolean;
    IsNil: boolean;
    MemberType: XmlSchemaSimpleType;
    SchemaAttribute: XmlSchemaAttribute;
    SchemaElement: XmlSchemaElement;
    SchemaType: XmlSchemaType;
    Validity: XmlSchemaValidity;
}


export interface __XmlSchemaInfo$views {
    As_IXmlSchemaInfo(): IXmlSchemaInfo$instance;
}

export type XmlSchemaInfo = XmlSchemaInfo$instance & __XmlSchemaInfo$views;


export class XmlSchemaKey$instance extends XmlSchemaIdentityConstraint$instance {
    constructor();
}


export type XmlSchemaKey = XmlSchemaKey$instance;

export class XmlSchemaKeyref$instance extends XmlSchemaIdentityConstraint$instance {
    constructor();
    Refer: XmlQualifiedName;
}


export type XmlSchemaKeyref = XmlSchemaKeyref$instance;

export class XmlSchemaLengthFacet$instance extends XmlSchemaNumericFacet$instance {
    constructor();
}


export type XmlSchemaLengthFacet = XmlSchemaLengthFacet$instance;

export class XmlSchemaMaxExclusiveFacet$instance extends XmlSchemaFacet$instance {
    constructor();
}


export type XmlSchemaMaxExclusiveFacet = XmlSchemaMaxExclusiveFacet$instance;

export class XmlSchemaMaxInclusiveFacet$instance extends XmlSchemaFacet$instance {
    constructor();
}


export type XmlSchemaMaxInclusiveFacet = XmlSchemaMaxInclusiveFacet$instance;

export class XmlSchemaMaxLengthFacet$instance extends XmlSchemaNumericFacet$instance {
    constructor();
}


export type XmlSchemaMaxLengthFacet = XmlSchemaMaxLengthFacet$instance;

export class XmlSchemaMinExclusiveFacet$instance extends XmlSchemaFacet$instance {
    constructor();
}


export type XmlSchemaMinExclusiveFacet = XmlSchemaMinExclusiveFacet$instance;

export class XmlSchemaMinInclusiveFacet$instance extends XmlSchemaFacet$instance {
    constructor();
}


export type XmlSchemaMinInclusiveFacet = XmlSchemaMinInclusiveFacet$instance;

export class XmlSchemaMinLengthFacet$instance extends XmlSchemaNumericFacet$instance {
    constructor();
}


export type XmlSchemaMinLengthFacet = XmlSchemaMinLengthFacet$instance;

export class XmlSchemaNotation$instance extends XmlSchemaAnnotated$instance {
    constructor();
    Name: string;
    Public: string;
    System: string;
}


export type XmlSchemaNotation = XmlSchemaNotation$instance;

export abstract class XmlSchemaNumericFacet$instance extends XmlSchemaFacet$instance {
}


export type XmlSchemaNumericFacet = XmlSchemaNumericFacet$instance;

export abstract class XmlSchemaObject$instance {
    LineNumber: int;
    LinePosition: int;
    Namespaces: XmlSerializerNamespaces;
    Parent: XmlSchemaObject;
    SourceUri: string;
}


export type XmlSchemaObject = XmlSchemaObject$instance;

export class XmlSchemaObjectCollection$instance extends System_Collections_Internal.CollectionBase$instance {
    constructor();
    constructor(parent: XmlSchemaObject);
    Item: XmlSchemaObject;
    Add(value: unknown): int;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(item: XmlSchemaObject): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export interface __XmlSchemaObjectCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlSchemaObjectCollection = XmlSchemaObjectCollection$instance & __XmlSchemaObjectCollection$views;


export class XmlSchemaObjectEnumerator$instance {
    readonly Current: unknown | XmlSchemaObject;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __XmlSchemaObjectEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaObjectEnumerator = XmlSchemaObjectEnumerator$instance & __XmlSchemaObjectEnumerator$views;


export class XmlSchemaObjectTable$instance {
    readonly Count: int;
    readonly Item: XmlSchemaObject;
    readonly Names: ICollection;
    readonly Values: ICollection;
    Contains(name: XmlQualifiedName): boolean;
    GetEnumerator(): IDictionaryEnumerator;
}


export type XmlSchemaObjectTable = XmlSchemaObjectTable$instance;

export abstract class XmlSchemaParticle$instance extends XmlSchemaAnnotated$instance {
    MaxOccurs: decimal;
    MaxOccursString: string;
    MinOccurs: decimal;
    MinOccursString: string;
}


export type XmlSchemaParticle = XmlSchemaParticle$instance;

export class XmlSchemaPatternFacet$instance extends XmlSchemaFacet$instance {
    constructor();
}


export type XmlSchemaPatternFacet = XmlSchemaPatternFacet$instance;

export class XmlSchemaRedefine$instance extends XmlSchemaExternal$instance {
    constructor();
    readonly AttributeGroups: XmlSchemaObjectTable;
    readonly Groups: XmlSchemaObjectTable;
    readonly Items: XmlSchemaObjectCollection;
    readonly SchemaTypes: XmlSchemaObjectTable;
}


export type XmlSchemaRedefine = XmlSchemaRedefine$instance;

export class XmlSchemaSequence$instance extends XmlSchemaGroupBase$instance {
    constructor();
    readonly Items: XmlSchemaObjectCollection;
}


export type XmlSchemaSequence = XmlSchemaSequence$instance;

export class XmlSchemaSet$instance {
    constructor();
    constructor(nameTable: XmlNameTable);
    CompilationSettings: XmlSchemaCompilationSettings;
    readonly Count: int;
    readonly GlobalAttributes: XmlSchemaObjectTable;
    readonly GlobalElements: XmlSchemaObjectTable;
    readonly GlobalTypes: XmlSchemaObjectTable;
    readonly IsCompiled: boolean;
    readonly NameTable: XmlNameTable;
    XmlResolver: XmlResolver;
    Add(targetNamespace: string, schemaUri: string): XmlSchema;
    Add(targetNamespace: string, schemaDocument: XmlReader): XmlSchema;
    Add(schemas: XmlSchemaSet): void;
    Add(schema: XmlSchema): XmlSchema;
    Compile(): void;
    Contains(targetNamespace: string): boolean;
    Contains(schema: XmlSchema): boolean;
    CopyTo(schemas: XmlSchema[], index: int): void;
    Remove(schema: XmlSchema): XmlSchema;
    RemoveRecursive(schemaToRemove: XmlSchema): boolean;
    Reprocess(schema: XmlSchema): XmlSchema;
    Schemas(): ICollection;
    Schemas(targetNamespace: string): ICollection;
}


export type XmlSchemaSet = XmlSchemaSet$instance;

export class XmlSchemaSimpleContent$instance extends XmlSchemaContentModel$instance {
    constructor();
    Content: XmlSchemaContent;
}


export type XmlSchemaSimpleContent = XmlSchemaSimpleContent$instance;

export class XmlSchemaSimpleContentExtension$instance extends XmlSchemaContent$instance {
    constructor();
    AnyAttribute: XmlSchemaAnyAttribute;
    readonly Attributes: XmlSchemaObjectCollection;
    BaseTypeName: XmlQualifiedName;
}


export type XmlSchemaSimpleContentExtension = XmlSchemaSimpleContentExtension$instance;

export class XmlSchemaSimpleContentRestriction$instance extends XmlSchemaContent$instance {
    constructor();
    AnyAttribute: XmlSchemaAnyAttribute;
    readonly Attributes: XmlSchemaObjectCollection;
    BaseType: XmlSchemaSimpleType;
    BaseTypeName: XmlQualifiedName;
    readonly Facets: XmlSchemaObjectCollection;
}


export type XmlSchemaSimpleContentRestriction = XmlSchemaSimpleContentRestriction$instance;

export class XmlSchemaSimpleType$instance extends XmlSchemaType$instance {
    constructor();
    Content: XmlSchemaSimpleTypeContent;
}


export type XmlSchemaSimpleType = XmlSchemaSimpleType$instance;

export abstract class XmlSchemaSimpleTypeContent$instance extends XmlSchemaAnnotated$instance {
}


export type XmlSchemaSimpleTypeContent = XmlSchemaSimpleTypeContent$instance;

export class XmlSchemaSimpleTypeList$instance extends XmlSchemaSimpleTypeContent$instance {
    constructor();
    BaseItemType: XmlSchemaSimpleType;
    ItemType: XmlSchemaSimpleType;
    ItemTypeName: XmlQualifiedName;
}


export type XmlSchemaSimpleTypeList = XmlSchemaSimpleTypeList$instance;

export class XmlSchemaSimpleTypeRestriction$instance extends XmlSchemaSimpleTypeContent$instance {
    constructor();
    BaseType: XmlSchemaSimpleType;
    BaseTypeName: XmlQualifiedName;
    readonly Facets: XmlSchemaObjectCollection;
}


export type XmlSchemaSimpleTypeRestriction = XmlSchemaSimpleTypeRestriction$instance;

export class XmlSchemaSimpleTypeUnion$instance extends XmlSchemaSimpleTypeContent$instance {
    constructor();
    readonly BaseMemberTypes: XmlSchemaSimpleType[];
    readonly BaseTypes: XmlSchemaObjectCollection;
    MemberTypes: XmlQualifiedName[];
}


export type XmlSchemaSimpleTypeUnion = XmlSchemaSimpleTypeUnion$instance;

export class XmlSchemaTotalDigitsFacet$instance extends XmlSchemaNumericFacet$instance {
    constructor();
}


export type XmlSchemaTotalDigitsFacet = XmlSchemaTotalDigitsFacet$instance;

export class XmlSchemaType$instance extends XmlSchemaAnnotated$instance {
    constructor();
    readonly BaseSchemaType: unknown;
    readonly BaseXmlSchemaType: XmlSchemaType;
    readonly Datatype: XmlSchemaDatatype;
    readonly DerivedBy: XmlSchemaDerivationMethod;
    Final: XmlSchemaDerivationMethod;
    readonly FinalResolved: XmlSchemaDerivationMethod;
    IsMixed: boolean;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    readonly TypeCode: XmlTypeCode;
    static GetBuiltInComplexType(typeCode: XmlTypeCode): XmlSchemaComplexType;
    static GetBuiltInComplexType(qualifiedName: XmlQualifiedName): XmlSchemaComplexType;
    static GetBuiltInSimpleType(typeCode: XmlTypeCode): XmlSchemaSimpleType;
    static GetBuiltInSimpleType(qualifiedName: XmlQualifiedName): XmlSchemaSimpleType;
    static IsDerivedFrom(derivedType: XmlSchemaType, baseType: XmlSchemaType, except: XmlSchemaDerivationMethod): boolean;
}


export type XmlSchemaType = XmlSchemaType$instance;

export class XmlSchemaUnique$instance extends XmlSchemaIdentityConstraint$instance {
    constructor();
}


export type XmlSchemaUnique = XmlSchemaUnique$instance;

export class XmlSchemaValidationException$instance extends XmlSchemaException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, innerException: Exception, lineNumber: int, linePosition: int);
    readonly SourceObject: unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XmlSchemaValidationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaValidationException = XmlSchemaValidationException$instance & __XmlSchemaValidationException$views;


export class XmlSchemaValidator$instance {
    constructor(nameTable: XmlNameTable, schemas: XmlSchemaSet, namespaceResolver: IXmlNamespaceResolver, validationFlags: XmlSchemaValidationFlags);
    LineInfoProvider: IXmlLineInfo;
    SourceUri: Uri;
    ValidationEventSender: unknown;
    XmlResolver: XmlResolver;
    AddSchema(schema: XmlSchema): void;
    EndValidation(): void;
    GetExpectedAttributes(): XmlSchemaAttribute[];
    GetExpectedParticles(): XmlSchemaParticle[];
    GetUnspecifiedDefaultAttributes(defaultAttributes: ArrayList): void;
    Initialize(): void;
    Initialize(partialValidationType: XmlSchemaObject): void;
    SkipToEndElement(schemaInfo: XmlSchemaInfo): void;
    ValidateAttribute(localName: string, namespaceUri: string, attributeValue: string, schemaInfo: XmlSchemaInfo): unknown;
    ValidateAttribute(localName: string, namespaceUri: string, attributeValue: XmlValueGetter, schemaInfo: XmlSchemaInfo): unknown;
    ValidateElement(localName: string, namespaceUri: string, schemaInfo: XmlSchemaInfo): void;
    ValidateElement(localName: string, namespaceUri: string, schemaInfo: XmlSchemaInfo, xsiType: string, xsiNil: string, xsiSchemaLocation: string, xsiNoNamespaceSchemaLocation: string): void;
    ValidateEndElement(schemaInfo: XmlSchemaInfo): unknown;
    ValidateEndElement(schemaInfo: XmlSchemaInfo, typedValue: unknown): unknown;
    ValidateEndOfAttributes(schemaInfo: XmlSchemaInfo): void;
    ValidateText(elementValue: string): void;
    ValidateText(elementValue: XmlValueGetter): void;
    ValidateWhitespace(elementValue: string): void;
    ValidateWhitespace(elementValue: XmlValueGetter): void;
}


export type XmlSchemaValidator = XmlSchemaValidator$instance;

export class XmlSchemaWhiteSpaceFacet$instance extends XmlSchemaFacet$instance {
    constructor();
}


export type XmlSchemaWhiteSpaceFacet = XmlSchemaWhiteSpaceFacet$instance;

export class XmlSchemaXPath$instance extends XmlSchemaAnnotated$instance {
    constructor();
    XPath: string;
}


export type XmlSchemaXPath = XmlSchemaXPath$instance;

export class XmlValueGetter$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(): unknown;
}


export interface __XmlValueGetter$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlValueGetter = XmlValueGetter$instance & __XmlValueGetter$views;


export abstract class Extensions$instance {
    static GetSchemaInfo(source: XAttribute): IXmlSchemaInfo;
    static GetSchemaInfo(source: XElement): IXmlSchemaInfo;
    static Validate(source: XAttribute, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static Validate(source: XAttribute, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
    static Validate(source: XDocument, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static Validate(source: XDocument, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
    static Validate(source: XElement, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static Validate(source: XElement, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
}


export type Extensions = Extensions$instance;

