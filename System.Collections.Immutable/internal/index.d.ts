// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Immutable
// Assembly: System.Collections.Immutable

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IComparer_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1, IReadOnlySet_1, ISet_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IEqualityComparer, IList, IStructuralComparable, IStructuralEquatable } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, Boolean as ClrBoolean, Comparison_1, Func_2, Func_3, IDisposable, IEquatable_1, Int32, Object as ClrObject, Predicate_1, Range, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IImmutableDictionary_2$instance<TKey, TValue> {
    readonly Item: TValue;
    readonly Keys: IEnumerable_1<TKey>;
    readonly Values: IEnumerable_1<TValue>;
    readonly Count: int;
    Add(key: TKey, value: TValue): IImmutableDictionary_2<TKey, TValue>;
    AddRange(pairs: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): IImmutableDictionary_2<TKey, TValue>;
    Clear(): IImmutableDictionary_2<TKey, TValue>;
    Contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    Remove(key: TKey): IImmutableDictionary_2<TKey, TValue>;
    TryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    TryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export type IImmutableDictionary_2<TKey, TValue> = IImmutableDictionary_2$instance<TKey, TValue>;

export interface IImmutableList_1$instance<T> {
    readonly Item: T;
    readonly Count: int;
    Add(value: T): IImmutableList_1<T>;
    AddRange(items: IEnumerable_1<T>): IImmutableList_1<T>;
    Clear(): IImmutableList_1<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    Insert(index: int, element: T): IImmutableList_1<T>;
    InsertRange(index: int, items: IEnumerable_1<T>): IImmutableList_1<T>;
    Remove(value: T, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
    RemoveAll(match: Predicate_1<T>): IImmutableList_1<T>;
    RemoveAt(index: int): IImmutableList_1<T>;
    RemoveRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
    RemoveRange(index: int, count: int): IImmutableList_1<T>;
    Replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
}


export type IImmutableList_1<T> = IImmutableList_1$instance<T>;

export interface IImmutableQueue_1$instance<T> {
    readonly IsEmpty: boolean;
    Clear(): IImmutableQueue_1<T>;
    Enqueue(value: T): IImmutableQueue_1<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    Peek(): T;
}


export type IImmutableQueue_1<T> = IImmutableQueue_1$instance<T>;

export interface IImmutableSet_1$instance<T> {
    readonly Count: int;
    Add(value: T): IImmutableSet_1<T>;
    Clear(): IImmutableSet_1<T>;
    Contains(value: T): boolean;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    Intersect(other: IEnumerable_1<T>): IImmutableSet_1<T>;
    SetEquals(other: IEnumerable_1<T>): boolean;
    TryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
}


export type IImmutableSet_1<T> = IImmutableSet_1$instance<T>;

export interface IImmutableStack_1$instance<T> {
    readonly IsEmpty: boolean;
    Clear(): IImmutableStack_1<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    Peek(): T;
    Push(value: T): IImmutableStack_1<T>;
}


export type IImmutableStack_1<T> = IImmutableStack_1$instance<T>;

export class ImmutableArray_1$instance<T> {
    readonly isDefault: boolean;
    readonly isDefaultOrEmpty: boolean;
    readonly isEmpty: boolean;
    readonly item: T;
    readonly length: int;
    add(item: T): ImmutableArray_1<T>;
    addRange(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    addRange(items: T[], length: int): ImmutableArray_1<T>;
    addRange<TDerived extends T>(items: TDerived[]): ImmutableArray_1<T>;
    addRange(items: ImmutableArray_1<T>, length: int): ImmutableArray_1<T>;
    addRange<TDerived extends T>(items: ImmutableArray_1<TDerived>): ImmutableArray_1<T>;
    addRange(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    addRange(items: T[]): ImmutableArray_1<T>;
    as_<TOther>(): ImmutableArray_1<TOther>;
    asMemory(): ReadOnlyMemory_1<T>;
    asSpan(): ReadOnlySpan_1<T>;
    asSpan(start: int, length: int): ReadOnlySpan_1<T>;
    asSpan(range: Range): ReadOnlySpan_1<T>;
    castArray<TOther>(): ImmutableArray_1<TOther>;
    clear(): ImmutableArray_1<T>;
    contains(item: T): boolean;
    contains(item: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    copyTo(destination: Span_1<T>): void;
    copyTo(destination: T[]): void;
    copyTo(destination: T[], destinationIndex: int): void;
    copyTo(sourceIndex: int, destination: T[], destinationIndex: int, length: int): void;
    equals(obj: any): boolean;
    equals(other: ImmutableArray_1<T>): boolean;
    getEnumerator(): ImmutableArray_1_Enumerator<T>;
    getHashCode(): int;
    indexOf(item: T): int;
    indexOf(item: T, startIndex: int, equalityComparer: IEqualityComparer_1<T>): int;
    indexOf(item: T, startIndex: int): int;
    indexOf(item: T, startIndex: int, count: int): int;
    indexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    insert(index: int, item: T): ImmutableArray_1<T>;
    insertRange(index: int, items: IEnumerable_1<T>): ImmutableArray_1<T>;
    insertRange(index: int, items: ImmutableArray_1<T>): ImmutableArray_1<T>;
    insertRange(index: int, items: T[]): ImmutableArray_1<T>;
    insertRange(index: int, items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, startIndex: int): int;
    lastIndexOf(item: T, startIndex: int, count: int): int;
    lastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    ofType<TResult>(): IEnumerable_1<TResult>;
    remove(item: T): ImmutableArray_1<T>;
    remove(item: T, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeAll(match: Predicate_1<T>): ImmutableArray_1<T>;
    removeAt(index: int): ImmutableArray_1<T>;
    removeRange(index: int, length: int): ImmutableArray_1<T>;
    removeRange(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeRange(items: ImmutableArray_1<T>): ImmutableArray_1<T>;
    removeRange(items: ImmutableArray_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeRange(items: ReadOnlySpan_1<T>, equalityComparer?: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    removeRange(items: T[], equalityComparer?: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    replace(oldValue: T, newValue: T): ImmutableArray_1<T>;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    setItem(index: int, item: T): ImmutableArray_1<T>;
    slice(start: int, length: int): ImmutableArray_1<T>;
    sort(): ImmutableArray_1<T>;
    sort(comparison: Comparison_1<T>): ImmutableArray_1<T>;
    sort(comparer: IComparer_1<T>): ImmutableArray_1<T>;
    sort(index: int, count: int, comparer: IComparer_1<T>): ImmutableArray_1<T>;
    toBuilder(): ImmutableArray_1_Builder<T>;
    static readonly empty: unknown;
    static CastUp<T, TDerived extends T>(items: ImmutableArray_1<TDerived>): ImmutableArray_1<T>;
}


export interface __ImmutableArray_1$views<T> {
    readonly As_IImmutableList_1: IImmutableList_1$instance<T>;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
    readonly As_IStructuralComparable: System_Collections_Internal.IStructuralComparable$instance;
    readonly As_IStructuralEquatable: System_Collections_Internal.IStructuralEquatable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ImmutableArray_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ImmutableArray_1<T>): boolean;
}

export type ImmutableArray_1<T> = ImmutableArray_1$instance<T> & __ImmutableArray_1$views<T>;


export class ImmutableArray_1_Enumerator$instance<T> {
    readonly current: T;
    moveNext(): boolean;
}


export type ImmutableArray_1_Enumerator<T> = ImmutableArray_1_Enumerator$instance<T>;

export class ImmutableDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export interface __ImmutableDictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableDictionary_2_Enumerator<TKey, TValue> = ImmutableDictionary_2_Enumerator$instance<TKey, TValue> & __ImmutableDictionary_2_Enumerator$views<TKey, TValue>;


export class ImmutableHashSet_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export interface __ImmutableHashSet_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableHashSet_1_Enumerator<T> = ImmutableHashSet_1_Enumerator$instance<T> & __ImmutableHashSet_1_Enumerator$views<T>;


export class ImmutableList_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export interface __ImmutableList_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableList_1_Enumerator<T> = ImmutableList_1_Enumerator$instance<T> & __ImmutableList_1_Enumerator$views<T>;


export class ImmutableQueue_1_Enumerator$instance<T> {
    readonly current: T;
    moveNext(): boolean;
}


export type ImmutableQueue_1_Enumerator<T> = ImmutableQueue_1_Enumerator$instance<T>;

export class ImmutableSortedDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly current: KeyValuePair_2<TKey, TValue>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export interface __ImmutableSortedDictionary_2_Enumerator$views<TKey, TValue> {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableSortedDictionary_2_Enumerator<TKey, TValue> = ImmutableSortedDictionary_2_Enumerator$instance<TKey, TValue> & __ImmutableSortedDictionary_2_Enumerator$views<TKey, TValue>;


export class ImmutableSortedSet_1_Enumerator$instance<T> {
    readonly current: T;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export interface __ImmutableSortedSet_1_Enumerator$views<T> {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableSortedSet_1_Enumerator<T> = ImmutableSortedSet_1_Enumerator$instance<T> & __ImmutableSortedSet_1_Enumerator$views<T>;


export class ImmutableStack_1_Enumerator$instance<T> {
    readonly current: T;
    moveNext(): boolean;
}


export type ImmutableStack_1_Enumerator<T> = ImmutableStack_1_Enumerator$instance<T>;

export class ImmutableArray_1_Builder$instance<T> {
    capacity: int;
    count: int;
    item: T;
    add(item: T): void;
    addRange(items: IEnumerable_1<T>): void;
    addRange(items: T[]): void;
    addRange<TDerived extends T>(items: TDerived[]): void;
    addRange(items: T[], length: int): void;
    addRange(items: ImmutableArray_1<T>): void;
    addRange(items: ImmutableArray_1<T>, length: int): void;
    addRange(items: ReadOnlySpan_1<T>): void;
    addRange(items: ImmutableArray_1_Builder<T>): void;
    clear(): void;
    contains(item: T): boolean;
    copyTo(array: T[], index: int): void;
    copyTo(destination: T[]): void;
    copyTo(sourceIndex: int, destination: T[], destinationIndex: int, length: int): void;
    copyTo(destination: Span_1<T>): void;
    drainToImmutable(): ImmutableArray_1<T>;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(item: T): int;
    indexOf(item: T, startIndex: int): int;
    indexOf(item: T, startIndex: int, count: int): int;
    indexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    indexOf(item: T, startIndex: int, equalityComparer: IEqualityComparer_1<T>): int;
    insert(index: int, item: T): void;
    insertRange(index: int, items: IEnumerable_1<T>): void;
    insertRange(index: int, items: ImmutableArray_1<T>): void;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, startIndex: int): int;
    lastIndexOf(item: T, startIndex: int, count: int): int;
    lastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    moveToImmutable(): ImmutableArray_1<T>;
    remove(element: T): boolean;
    remove(element: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    removeAll(match: Predicate_1<T>): void;
    removeAt(index: int): void;
    removeRange(index: int, length: int): void;
    removeRange(items: IEnumerable_1<T>): void;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): void;
    replace(oldValue: T, newValue: T): void;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): void;
    reverse(): void;
    sort(): void;
    sort(comparison: Comparison_1<T>): void;
    sort(comparer: IComparer_1<T>): void;
    sort(index: int, count: int, comparer: IComparer_1<T>): void;
    toArray(): T[];
    toImmutable(): ImmutableArray_1<T>;
}


export interface __ImmutableArray_1_Builder$views<T> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableArray_1_Builder<T> = ImmutableArray_1_Builder$instance<T> & __ImmutableArray_1_Builder$views<T>;


export class ImmutableDictionary_2$instance<TKey, TValue> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: TValue;
    readonly keyComparer: IEqualityComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    readonly valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): ImmutableDictionary_2<TKey, TValue>;
    addRange(pairs: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    clear(): ImmutableDictionary_2<TKey, TValue>;
    contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableDictionary_2_Enumerator<TKey, TValue>;
    remove(key: TKey): ImmutableDictionary_2<TKey, TValue>;
    removeRange(keys: IEnumerable_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    setItem(key: TKey, value: TValue): ImmutableDictionary_2<TKey, TValue>;
    setItems(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    toBuilder(): ImmutableDictionary_2_Builder<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    withComparers(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    withComparers(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static readonly empty: unknown;
}


export interface __ImmutableDictionary_2$views<TKey, TValue> {
    readonly As_IImmutableDictionary_2: IImmutableDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableDictionary_2<TKey, TValue> = ImmutableDictionary_2$instance<TKey, TValue> & __ImmutableDictionary_2$views<TKey, TValue>;


export class ImmutableDictionary_2_Builder$instance<TKey, TValue> {
    readonly count: int;
    item: TValue;
    keyComparer: IEqualityComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): void;
    add(item: KeyValuePair_2<TKey, TValue>): void;
    addRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): void;
    clear(): void;
    contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableDictionary_2_Enumerator<TKey, TValue>;
    getValueOrDefault(key: TKey): TValue;
    getValueOrDefault(key: TKey, defaultValue: TValue): TValue;
    remove(key: TKey): boolean;
    remove(item: KeyValuePair_2<TKey, TValue>): boolean;
    removeRange(keys: IEnumerable_1<TKey>): void;
    toImmutable(): ImmutableDictionary_2<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export interface __ImmutableDictionary_2_Builder$views<TKey, TValue> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableDictionary_2_Builder<TKey, TValue> = ImmutableDictionary_2_Builder$instance<TKey, TValue> & __ImmutableDictionary_2_Builder$views<TKey, TValue>;


export class ImmutableHashSet_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly keyComparer: IEqualityComparer_1<T>;
    add(item: T): ImmutableHashSet_1<T>;
    clear(): ImmutableHashSet_1<T>;
    contains(item: T): boolean;
    except(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    getEnumerator(): ImmutableHashSet_1_Enumerator<T>;
    intersect(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): ImmutableHashSet_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExcept(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    toBuilder(): ImmutableHashSet_1_Builder<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    union(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    withComparer(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1<T>;
    static readonly empty: unknown;
}


export interface __ImmutableHashSet_1$views<T> {
    readonly As_IImmutableSet_1: IImmutableSet_1$instance<T>;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: System_Collections_Generic_Internal.ISet_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableHashSet_1<T> = ImmutableHashSet_1$instance<T> & __ImmutableHashSet_1$views<T>;


export class ImmutableHashSet_1_Builder$instance<T> {
    readonly count: int;
    keyComparer: IEqualityComparer_1<T>;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    exceptWith(other: IEnumerable_1<T>): void;
    getEnumerator(): ImmutableHashSet_1_Enumerator<T>;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    toImmutable(): ImmutableHashSet_1<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
}


export interface __ImmutableHashSet_1_Builder$views<T> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ISet_1: System_Collections_Generic_Internal.ISet_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableHashSet_1_Builder<T> = ImmutableHashSet_1_Builder$instance<T> & __ImmutableHashSet_1_Builder$views<T>;


export class ImmutableList_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: T;
    add(value: T): ImmutableList_1<T>;
    addRange(items: IEnumerable_1<T>): ImmutableList_1<T>;
    binarySearch(item: T): int;
    binarySearch(item: T, comparer: IComparer_1<T>): int;
    binarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    clear(): ImmutableList_1<T>;
    contains(value: T): boolean;
    convertAll<TOutput>(converter: Func_2<T, TOutput>): ImmutableList_1<TOutput>;
    copyTo(array: T[]): void;
    copyTo(array: T[], arrayIndex: int): void;
    copyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    exists(match: Predicate_1<T>): boolean;
    find(match: Predicate_1<T>): T;
    findAll(match: Predicate_1<T>): ImmutableList_1<T>;
    findIndex(match: Predicate_1<T>): int;
    findIndex(startIndex: int, match: Predicate_1<T>): int;
    findIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    findLast(match: Predicate_1<T>): T;
    findLastIndex(match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    forEach(action: Action_1<T>): void;
    getEnumerator(): ImmutableList_1_Enumerator<T>;
    getRange(index: int, count: int): ImmutableList_1<T>;
    indexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    indexOf(value: T): int;
    insert(index: int, item: T): ImmutableList_1<T>;
    insertRange(index: int, items: IEnumerable_1<T>): ImmutableList_1<T>;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    remove(value: T): ImmutableList_1<T>;
    remove(value: T, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    removeAll(match: Predicate_1<T>): ImmutableList_1<T>;
    removeAt(index: int): ImmutableList_1<T>;
    removeRange(index: int, count: int): ImmutableList_1<T>;
    removeRange(items: IEnumerable_1<T>): ImmutableList_1<T>;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    replace(oldValue: T, newValue: T): ImmutableList_1<T>;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    reverse(): ImmutableList_1<T>;
    reverse(index: int, count: int): ImmutableList_1<T>;
    setItem(index: int, value: T): ImmutableList_1<T>;
    sort(): ImmutableList_1<T>;
    sort(comparison: Comparison_1<T>): ImmutableList_1<T>;
    sort(comparer: IComparer_1<T>): ImmutableList_1<T>;
    sort(index: int, count: int, comparer: IComparer_1<T>): ImmutableList_1<T>;
    toBuilder(): ImmutableList_1_Builder<T>;
    trueForAll(match: Predicate_1<T>): boolean;
    static readonly empty: unknown;
}


export interface __ImmutableList_1$views<T> {
    readonly As_IImmutableList_1: IImmutableList_1$instance<T>;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type ImmutableList_1<T> = ImmutableList_1$instance<T> & __ImmutableList_1$views<T>;


export class ImmutableList_1_Builder$instance<T> {
    readonly count: int;
    item: T;
    add(item: T): void;
    addRange(items: IEnumerable_1<T>): void;
    binarySearch(item: T): int;
    binarySearch(item: T, comparer: IComparer_1<T>): int;
    binarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    clear(): void;
    contains(item: T): boolean;
    convertAll<TOutput>(converter: Func_2<T, TOutput>): ImmutableList_1<TOutput>;
    copyTo(array: T[]): void;
    copyTo(array: T[], arrayIndex: int): void;
    copyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    exists(match: Predicate_1<T>): boolean;
    find(match: Predicate_1<T>): T;
    findAll(match: Predicate_1<T>): ImmutableList_1<T>;
    findIndex(match: Predicate_1<T>): int;
    findIndex(startIndex: int, match: Predicate_1<T>): int;
    findIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    findLast(match: Predicate_1<T>): T;
    findLastIndex(match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, match: Predicate_1<T>): int;
    findLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    forEach(action: Action_1<T>): void;
    getEnumerator(): ImmutableList_1_Enumerator<T>;
    getRange(index: int, count: int): ImmutableList_1<T>;
    indexOf(item: T): int;
    indexOf(item: T, index: int): int;
    indexOf(item: T, index: int, count: int): int;
    indexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    insert(index: int, item: T): void;
    insertRange(index: int, items: IEnumerable_1<T>): void;
    itemRef(index: int): ref<T>;
    lastIndexOf(item: T): int;
    lastIndexOf(item: T, startIndex: int): int;
    lastIndexOf(item: T, startIndex: int, count: int): int;
    lastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    remove(item: T): boolean;
    remove(item: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    removeAll(match: Predicate_1<T>): int;
    removeAt(index: int): void;
    removeRange(index: int, count: int): void;
    removeRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): void;
    removeRange(items: IEnumerable_1<T>): void;
    replace(oldValue: T, newValue: T): void;
    replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): void;
    reverse(): void;
    reverse(index: int, count: int): void;
    sort(): void;
    sort(comparison: Comparison_1<T>): void;
    sort(comparer: IComparer_1<T>): void;
    sort(index: int, count: int, comparer: IComparer_1<T>): void;
    toImmutable(): ImmutableList_1<T>;
    trueForAll(match: Predicate_1<T>): boolean;
}


export interface __ImmutableList_1_Builder$views<T> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type ImmutableList_1_Builder<T> = ImmutableList_1_Builder$instance<T> & __ImmutableList_1_Builder$views<T>;


export class ImmutableQueue_1$instance<T> {
    readonly isEmpty: boolean;
    clear(): ImmutableQueue_1<T>;
    dequeue(): ImmutableQueue_1<T>;
    dequeue(value: { value: ref<T> }): ImmutableQueue_1<T>;
    enqueue(value: T): ImmutableQueue_1<T>;
    getEnumerator(): ImmutableQueue_1_Enumerator<T>;
    peek(): T;
    peekRef(): ref<T>;
    static readonly Empty: unknown;
}


export interface __ImmutableQueue_1$views<T> {
    readonly As_IImmutableQueue_1: IImmutableQueue_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableQueue_1<T> = ImmutableQueue_1$instance<T> & __ImmutableQueue_1$views<T>;


export class ImmutableSortedDictionary_2$instance<TKey, TValue> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: TValue;
    readonly keyComparer: IComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    readonly valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): ImmutableSortedDictionary_2<TKey, TValue>;
    addRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    clear(): ImmutableSortedDictionary_2<TKey, TValue>;
    contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableSortedDictionary_2_Enumerator<TKey, TValue>;
    remove(value: TKey): ImmutableSortedDictionary_2<TKey, TValue>;
    removeRange(keys: IEnumerable_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    setItem(key: TKey, value: TValue): ImmutableSortedDictionary_2<TKey, TValue>;
    setItems(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    toBuilder(): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    valueRef(key: TKey): ref<TValue>;
    withComparers(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    withComparers(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static readonly empty: unknown;
}


export interface __ImmutableSortedDictionary_2$views<TKey, TValue> {
    readonly As_IImmutableDictionary_2: IImmutableDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedDictionary_2<TKey, TValue> = ImmutableSortedDictionary_2$instance<TKey, TValue> & __ImmutableSortedDictionary_2$views<TKey, TValue>;


export class ImmutableSortedDictionary_2_Builder$instance<TKey, TValue> {
    readonly count: int;
    item: TValue;
    keyComparer: IComparer_1<TKey>;
    readonly keys: IEnumerable_1<TKey>;
    valueComparer: IEqualityComparer_1<TValue>;
    readonly values: IEnumerable_1<TValue>;
    add(key: TKey, value: TValue): void;
    add(item: KeyValuePair_2<TKey, TValue>): void;
    addRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): void;
    clear(): void;
    contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    getEnumerator(): ImmutableSortedDictionary_2_Enumerator<TKey, TValue>;
    getValueOrDefault(key: TKey): TValue;
    getValueOrDefault(key: TKey, defaultValue: TValue): TValue;
    remove(key: TKey): boolean;
    remove(item: KeyValuePair_2<TKey, TValue>): boolean;
    removeRange(keys: IEnumerable_1<TKey>): void;
    toImmutable(): ImmutableSortedDictionary_2<TKey, TValue>;
    tryGetKey(equalKey: TKey, actualKey: { value: ref<TKey> }): boolean;
    tryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
    valueRef(key: TKey): ref<TValue>;
}


export interface __ImmutableSortedDictionary_2_Builder$views<TKey, TValue> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyCollection_1_of_KeyValuePair_2: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    readonly As_IReadOnlyDictionary_2: System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IDictionary: System_Collections_Internal.IDictionary$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedDictionary_2_Builder<TKey, TValue> = ImmutableSortedDictionary_2_Builder$instance<TKey, TValue> & __ImmutableSortedDictionary_2_Builder$views<TKey, TValue>;


export class ImmutableSortedSet_1$instance<T> {
    readonly count: int;
    readonly isEmpty: boolean;
    readonly item: T;
    readonly keyComparer: IComparer_1<T>;
    readonly max: T;
    readonly min: T;
    add(value: T): ImmutableSortedSet_1<T>;
    clear(): ImmutableSortedSet_1<T>;
    contains(value: T): boolean;
    except(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    getEnumerator(): ImmutableSortedSet_1_Enumerator<T>;
    indexOf(item: T): int;
    intersect(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    itemRef(index: int): ref<T>;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(value: T): ImmutableSortedSet_1<T>;
    reverse(): IEnumerable_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExcept(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    toBuilder(): ImmutableSortedSet_1_Builder<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    union(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    withComparer(comparer: IComparer_1<T>): ImmutableSortedSet_1<T>;
    static readonly empty: unknown;
}


export interface __ImmutableSortedSet_1$views<T> {
    readonly As_IImmutableSet_1: IImmutableSet_1$instance<T>;
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_IReadOnlySet_1: System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    readonly As_ISet_1: System_Collections_Generic_Internal.ISet_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type ImmutableSortedSet_1<T> = ImmutableSortedSet_1$instance<T> & __ImmutableSortedSet_1$views<T>;


export class ImmutableSortedSet_1_Builder$instance<T> {
    readonly count: int;
    readonly item: T;
    keyComparer: IComparer_1<T>;
    readonly max: T;
    readonly min: T;
    add(item: T): boolean;
    clear(): void;
    contains(item: T): boolean;
    exceptWith(other: IEnumerable_1<T>): void;
    getEnumerator(): ImmutableSortedSet_1_Enumerator<T>;
    indexOf(item: T): int;
    intersectWith(other: IEnumerable_1<T>): void;
    isProperSubsetOf(other: IEnumerable_1<T>): boolean;
    isProperSupersetOf(other: IEnumerable_1<T>): boolean;
    isSubsetOf(other: IEnumerable_1<T>): boolean;
    isSupersetOf(other: IEnumerable_1<T>): boolean;
    itemRef(index: int): ref<T>;
    overlaps(other: IEnumerable_1<T>): boolean;
    remove(item: T): boolean;
    reverse(): IEnumerable_1<T>;
    setEquals(other: IEnumerable_1<T>): boolean;
    symmetricExceptWith(other: IEnumerable_1<T>): void;
    toImmutable(): ImmutableSortedSet_1<T>;
    tryGetValue(equalValue: T, actualValue: { value: ref<T> }): boolean;
    unionWith(other: IEnumerable_1<T>): void;
}


export interface __ImmutableSortedSet_1_Builder$views<T> {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    readonly As_ISet_1: System_Collections_Generic_Internal.ISet_1$instance<T>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedSet_1_Builder<T> = ImmutableSortedSet_1_Builder$instance<T> & __ImmutableSortedSet_1_Builder$views<T>;


export class ImmutableStack_1$instance<T> {
    readonly isEmpty: boolean;
    clear(): ImmutableStack_1<T>;
    getEnumerator(): ImmutableStack_1_Enumerator<T>;
    peek(): T;
    peekRef(): ref<T>;
    pop(): ImmutableStack_1<T>;
    pop(value: { value: ref<T> }): ImmutableStack_1<T>;
    push(value: T): ImmutableStack_1<T>;
    static readonly Empty: unknown;
}


export interface __ImmutableStack_1$views<T> {
    readonly As_IImmutableStack_1: IImmutableStack_1$instance<T>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableStack_1<T> = ImmutableStack_1$instance<T> & __ImmutableStack_1$views<T>;


export abstract class ImmutableArray$instance {
    static BinarySearch<T>(array: ImmutableArray_1<T>, index: int, length: int, value: T, comparer: IComparer_1<T>): int;
    static BinarySearch<T>(array: ImmutableArray_1<T>, index: int, length: int, value: T): int;
    static BinarySearch<T>(array: ImmutableArray_1<T>, value: T, comparer: IComparer_1<T>): int;
    static BinarySearch<T>(array: ImmutableArray_1<T>, value: T): int;
    static Create<T>(): ImmutableArray_1<T>;
    static Create<T>(items: ImmutableArray_1<T>, start: int, length: int): ImmutableArray_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    static Create<T>(items: Span_1<T>): ImmutableArray_1<T>;
    static Create<T>(item1: T, item2: T, item3: T, item4: T): ImmutableArray_1<T>;
    static Create<T>(item1: T, item2: T, item3: T): ImmutableArray_1<T>;
    static Create<T>(item1: T, item2: T): ImmutableArray_1<T>;
    static Create<T>(item: T): ImmutableArray_1<T>;
    static Create<T>(items: T[], start: int, length: int): ImmutableArray_1<T>;
    static Create<T>(items: T[]): ImmutableArray_1<T>;
    static CreateBuilder<T>(): ImmutableArray_1_Builder<T>;
    static CreateBuilder<T>(initialCapacity: int): ImmutableArray_1_Builder<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    static CreateRange<TSource, TResult>(items: ImmutableArray_1<TSource>, selector: Func_2<TSource, TResult>): ImmutableArray_1<TResult>;
    static CreateRange<TSource, TArg, TResult>(items: ImmutableArray_1<TSource>, selector: Func_3<TSource, TArg, TResult>, arg: TArg): ImmutableArray_1<TResult>;
    static CreateRange<TSource, TResult>(items: ImmutableArray_1<TSource>, start: int, length: int, selector: Func_2<TSource, TResult>): ImmutableArray_1<TResult>;
    static CreateRange<TSource, TArg, TResult>(items: ImmutableArray_1<TSource>, start: int, length: int, selector: Func_3<TSource, TArg, TResult>, arg: TArg): ImmutableArray_1<TResult>;
    static ToImmutableArray<TSource>(builder: ImmutableArray_1_Builder<TSource>): ImmutableArray_1<TSource>;
    static ToImmutableArray<TSource>(items: IEnumerable_1<TSource>): ImmutableArray_1<TSource>;
    static ToImmutableArray<T>(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    static ToImmutableArray<T>(items: Span_1<T>): ImmutableArray_1<T>;
}


export type ImmutableArray = ImmutableArray$instance;

export abstract class ImmutableDictionary$instance {
    static Contains<TKey, TValue>(map: IImmutableDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
    static Create<TKey, TValue>(): ImmutableDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(): ImmutableDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2_Builder<TKey, TValue>;
    static CreateRange<TKey, TValue>(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRangeWithOverwrite<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, items: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRangeWithOverwrite<TKey, TValue>(items: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static GetValueOrDefault<TKey, TValue>(dictionary: IImmutableDictionary_2<TKey, TValue>, key: TKey, defaultValue: TValue): TValue;
    static GetValueOrDefault<TKey, TValue>(dictionary: IImmutableDictionary_2<TKey, TValue>, key: TKey): TValue;
    static ToImmutableDictionary<TKey, TValue>(builder: ImmutableDictionary_2_Builder<TKey, TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TSource>;
    static ToImmutableDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): ImmutableDictionary_2<TKey, TSource>;
    static ToImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
}


export type ImmutableDictionary = ImmutableDictionary$instance;

export abstract class ImmutableHashSet$instance {
    static Create<T>(): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>, items: ReadOnlySpan_1<T>): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>, item: T): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>, items: T[]): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableHashSet_1<T>;
    static Create<T>(item: T): ImmutableHashSet_1<T>;
    static Create<T>(items: T[]): ImmutableHashSet_1<T>;
    static CreateBuilder<T>(): ImmutableHashSet_1_Builder<T>;
    static CreateBuilder<T>(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1_Builder<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    static CreateRange<T>(equalityComparer: IEqualityComparer_1<T>, items: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    static ToImmutableHashSet<TSource>(builder: ImmutableHashSet_1_Builder<TSource>): ImmutableHashSet_1<TSource>;
    static ToImmutableHashSet<TSource>(source: IEnumerable_1<TSource>, equalityComparer: IEqualityComparer_1<TSource>): ImmutableHashSet_1<TSource>;
    static ToImmutableHashSet<TSource>(source: IEnumerable_1<TSource>): ImmutableHashSet_1<TSource>;
}


export type ImmutableHashSet = ImmutableHashSet$instance;

export abstract class ImmutableInterlocked$instance {
    static AddOrUpdate<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, addValueFactory: Func_2<TKey, TValue>, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    static AddOrUpdate<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, addValue: TValue, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    static Enqueue<T>(location: { value: ref<ImmutableQueue_1<T>> }, value: T): void;
    static GetOrAdd<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    static GetOrAdd<TKey, TValue, TArg>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    static GetOrAdd<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, value: TValue): TValue;
    static InterlockedCompareExchange<T>(location: { value: ref<ImmutableArray_1<T>> }, value: ImmutableArray_1<T>, comparand: ImmutableArray_1<T>): ImmutableArray_1<T>;
    static InterlockedExchange<T>(location: { value: ref<ImmutableArray_1<T>> }, value: ImmutableArray_1<T>): ImmutableArray_1<T>;
    static InterlockedInitialize<T>(location: { value: ref<ImmutableArray_1<T>> }, value: ImmutableArray_1<T>): boolean;
    static Push<T>(location: { value: ref<ImmutableStack_1<T>> }, value: T): void;
    static TryAdd<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, value: TValue): boolean;
    static TryDequeue<T>(location: { value: ref<ImmutableQueue_1<T>> }, value: { value: ref<T> }): boolean;
    static TryPop<T>(location: { value: ref<ImmutableStack_1<T>> }, value: { value: ref<T> }): boolean;
    static TryRemove<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, value: { value: ref<TValue> }): boolean;
    static TryUpdate<TKey, TValue>(location: { value: ref<ImmutableDictionary_2<TKey, TValue>> }, key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
    static Update<T>(location: { value: ref<ImmutableArray_1<T>> }, transformer: Func_2<ImmutableArray_1<T>, ImmutableArray_1<T>>): boolean;
    static Update<T, TArg>(location: { value: ref<ImmutableArray_1<T>> }, transformer: Func_3<ImmutableArray_1<T>, TArg, ImmutableArray_1<T>>, transformerArgument: TArg): boolean;
    static Update<T>(location: { value: ref<T> }, transformer: Func_2<T, T>): boolean;
    static Update<T, TArg>(location: { value: ref<T> }, transformer: Func_3<T, TArg, T>, transformerArgument: TArg): boolean;
}


export type ImmutableInterlocked = ImmutableInterlocked$instance;

export abstract class ImmutableList$instance {
    static Create<T>(): ImmutableList_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableList_1<T>;
    static Create<T>(item: T): ImmutableList_1<T>;
    static Create<T>(items: T[]): ImmutableList_1<T>;
    static CreateBuilder<T>(): ImmutableList_1_Builder<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableList_1<T>;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T, equalityComparer: IEqualityComparer_1<T>): int;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int, count: int): int;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int): int;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T, equalityComparer: IEqualityComparer_1<T>): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int, count: int): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T): int;
    static Remove<T>(list: IImmutableList_1<T>, value: T): IImmutableList_1<T>;
    static RemoveRange<T>(list: IImmutableList_1<T>, items: IEnumerable_1<T>): IImmutableList_1<T>;
    static Replace<T>(list: IImmutableList_1<T>, oldValue: T, newValue: T): IImmutableList_1<T>;
    static ToImmutableList<TSource>(builder: ImmutableList_1_Builder<TSource>): ImmutableList_1<TSource>;
    static ToImmutableList<TSource>(source: IEnumerable_1<TSource>): ImmutableList_1<TSource>;
}


export type ImmutableList = ImmutableList$instance;

export abstract class ImmutableQueue$instance {
    static Create<T>(): ImmutableQueue_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableQueue_1<T>;
    static Create<T>(item: T): ImmutableQueue_1<T>;
    static Create<T>(items: T[]): ImmutableQueue_1<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableQueue_1<T>;
    static Dequeue<T>(queue: IImmutableQueue_1<T>, value: { value: ref<T> }): IImmutableQueue_1<T>;
}


export type ImmutableQueue = ImmutableQueue$instance;

export abstract class ImmutableSortedDictionary$instance {
    static Create<TKey, TValue>(): ImmutableSortedDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IComparer_1<TKey>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(builder: ImmutableSortedDictionary_2_Builder<TKey, TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
}


export type ImmutableSortedDictionary = ImmutableSortedDictionary$instance;

export abstract class ImmutableSortedSet$instance {
    static Create<T>(): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>, items: ReadOnlySpan_1<T>): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>, item: T): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>, items: T[]): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>): ImmutableSortedSet_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableSortedSet_1<T>;
    static Create<T>(item: T): ImmutableSortedSet_1<T>;
    static Create<T>(items: T[]): ImmutableSortedSet_1<T>;
    static CreateBuilder<T>(): ImmutableSortedSet_1_Builder<T>;
    static CreateBuilder<T>(comparer: IComparer_1<T>): ImmutableSortedSet_1_Builder<T>;
    static CreateRange<T>(comparer: IComparer_1<T>, items: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    static ToImmutableSortedSet<TSource>(builder: ImmutableSortedSet_1_Builder<TSource>): ImmutableSortedSet_1<TSource>;
    static ToImmutableSortedSet<TSource>(source: IEnumerable_1<TSource>, comparer: IComparer_1<TSource>): ImmutableSortedSet_1<TSource>;
    static ToImmutableSortedSet<TSource>(source: IEnumerable_1<TSource>): ImmutableSortedSet_1<TSource>;
}


export type ImmutableSortedSet = ImmutableSortedSet$instance;

export abstract class ImmutableStack$instance {
    static Create<T>(): ImmutableStack_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableStack_1<T>;
    static Create<T>(item: T): ImmutableStack_1<T>;
    static Create<T>(items: T[]): ImmutableStack_1<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableStack_1<T>;
    static Pop<T>(stack: IImmutableStack_1<T>, value: { value: ref<T> }): IImmutableStack_1<T>;
}


export type ImmutableStack = ImmutableStack$instance;

