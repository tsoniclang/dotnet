// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Xsl.Runtime
// Assembly: System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IComparer_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { Task, ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { XmlAtomicValue, XmlTypeCode } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { XPathItem, XPathNavigator, XPathNodeType } from "../../System.Xml.XPath/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { WriteState, XmlNameTable, XmlQualifiedName, XmlReader, XmlSpace, XmlWriter, XmlWriterSettings } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Enum, IAsyncDisposable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum IteratorResult {
    noMoreNodes = 0,
    needInputNode = 1,
    haveCurrentNode = 2
}


export enum SetIteratorResult {
    noMoreNodes = 0,
    initRightIterator = 1,
    needLeftNode = 2,
    needRightNode = 3,
    haveCurrentNode = 4
}


export class AncestorDocOrderIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(): boolean;
}


export type AncestorDocOrderIterator = AncestorDocOrderIterator$instance;

export class AncestorIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(): boolean;
}


export type AncestorIterator = AncestorIterator$instance;

export class AttributeContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export type AttributeContentIterator = AttributeContentIterator$instance;

export class AttributeIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export type AttributeIterator = AttributeIterator$instance;

export class ContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export type ContentIterator = ContentIterator$instance;

export class ContentMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export type ContentMergeIterator = ContentMergeIterator$instance;

export class DecimalAggregator$instance {
    readonly averageResult: decimal;
    readonly isEmpty: boolean;
    readonly maximumResult: decimal;
    readonly minimumResult: decimal;
    readonly sumResult: decimal;
    average(value: decimal): void;
    create(): void;
    maximum(value: decimal): void;
    minimum(value: decimal): void;
    sum(value: decimal): void;
}


export type DecimalAggregator = DecimalAggregator$instance;

export class DescendantIterator$instance {
    readonly current: XPathNavigator;
    create(input: XPathNavigator, filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(): boolean;
}


export type DescendantIterator = DescendantIterator$instance;

export class DescendantMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter, orSelf: boolean): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export type DescendantMergeIterator = DescendantMergeIterator$instance;

export class DifferenceIterator$instance {
    readonly current: XPathNavigator;
    create(runtime: XmlQueryRuntime): void;
    moveNext(nestedNavigator: XPathNavigator): SetIteratorResult;
}


export type DifferenceIterator = DifferenceIterator$instance;

export class DodSequenceMerge$instance {
    addSequence(sequence: IList_1<XPathNavigator>): void;
    create(runtime: XmlQueryRuntime): void;
    mergeSequences(): IList_1<XPathNavigator>;
}


export type DodSequenceMerge = DodSequenceMerge$instance;

export class DoubleAggregator$instance {
    readonly averageResult: double;
    readonly isEmpty: boolean;
    readonly maximumResult: double;
    readonly minimumResult: double;
    readonly sumResult: double;
    average(value: double): void;
    create(): void;
    maximum(value: double): void;
    minimum(value: double): void;
    sum(value: double): void;
}


export type DoubleAggregator = DoubleAggregator$instance;

export class ElementContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, localName: string, ns: string): void;
    moveNext(): boolean;
}


export type ElementContentIterator = ElementContentIterator$instance;

export class FollowingSiblingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type FollowingSiblingIterator = FollowingSiblingIterator$instance;

export class FollowingSiblingMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(navigator: XPathNavigator): IteratorResult;
}


export type FollowingSiblingMergeIterator = FollowingSiblingMergeIterator$instance;

export class IdIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, value: string): void;
    moveNext(): boolean;
}


export type IdIterator = IdIterator$instance;

export class Int32Aggregator$instance {
    readonly averageResult: int;
    readonly isEmpty: boolean;
    readonly maximumResult: int;
    readonly minimumResult: int;
    readonly sumResult: int;
    average(value: int): void;
    create(): void;
    maximum(value: int): void;
    minimum(value: int): void;
    sum(value: int): void;
}


export type Int32Aggregator = Int32Aggregator$instance;

export class Int64Aggregator$instance {
    readonly averageResult: long;
    readonly isEmpty: boolean;
    readonly maximumResult: long;
    readonly minimumResult: long;
    readonly sumResult: long;
    average(value: long): void;
    create(): void;
    maximum(value: long): void;
    minimum(value: long): void;
    sum(value: long): void;
}


export type Int64Aggregator = Int64Aggregator$instance;

export class IntersectIterator$instance {
    readonly current: XPathNavigator;
    create(runtime: XmlQueryRuntime): void;
    moveNext(nestedNavigator: XPathNavigator): SetIteratorResult;
}


export type IntersectIterator = IntersectIterator$instance;

export class NamespaceIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator): void;
    moveNext(): boolean;
}


export type NamespaceIterator = NamespaceIterator$instance;

export class NodeKindContentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, nodeType: XPathNodeType): void;
    moveNext(): boolean;
}


export type NodeKindContentIterator = NodeKindContentIterator$instance;

export class NodeRangeIterator$instance {
    readonly current: XPathNavigator;
    create(start: XPathNavigator, filter: XmlNavigatorFilter, end: XPathNavigator): void;
    moveNext(): boolean;
}


export type NodeRangeIterator = NodeRangeIterator$instance;

export class ParentIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type ParentIterator = ParentIterator$instance;

export class PrecedingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type PrecedingIterator = PrecedingIterator$instance;

export class PrecedingSiblingDocOrderIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type PrecedingSiblingDocOrderIterator = PrecedingSiblingDocOrderIterator$instance;

export class PrecedingSiblingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type PrecedingSiblingIterator = PrecedingSiblingIterator$instance;

export class StringConcat$instance {
    delimiter: string;
    clear(): void;
    concat(value: string): void;
    getResult(): string;
}


export type StringConcat = StringConcat$instance;

export class UnionIterator$instance {
    readonly current: XPathNavigator;
    create(runtime: XmlQueryRuntime): void;
    moveNext(nestedNavigator: XPathNavigator): SetIteratorResult;
}


export type UnionIterator = UnionIterator$instance;

export class XmlSortKeyAccumulator$instance {
    readonly keys: ClrArray;
    addDateTimeSortKey(collation: XmlCollation, value: DateTime): void;
    addDecimalSortKey(collation: XmlCollation, value: decimal): void;
    addDoubleSortKey(collation: XmlCollation, value: double): void;
    addEmptySortKey(collation: XmlCollation): void;
    addIntegerSortKey(collation: XmlCollation, value: long): void;
    addIntSortKey(collation: XmlCollation, value: int): void;
    addStringSortKey(collation: XmlCollation, value: string): void;
    create(): void;
    finishSortKeys(): void;
}


export type XmlSortKeyAccumulator = XmlSortKeyAccumulator$instance;

export class XPathFollowingIterator$instance {
    readonly current: XPathNavigator;
    create(input: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type XPathFollowingIterator = XPathFollowingIterator$instance;

export class XPathFollowingMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export type XPathFollowingMergeIterator = XPathFollowingMergeIterator$instance;

export class XPathPrecedingDocOrderIterator$instance {
    readonly current: XPathNavigator;
    create(input: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type XPathPrecedingDocOrderIterator = XPathPrecedingDocOrderIterator$instance;

export class XPathPrecedingIterator$instance {
    readonly current: XPathNavigator;
    create(context: XPathNavigator, filter: XmlNavigatorFilter): void;
    moveNext(): boolean;
}


export type XPathPrecedingIterator = XPathPrecedingIterator$instance;

export class XPathPrecedingMergeIterator$instance {
    readonly current: XPathNavigator;
    create(filter: XmlNavigatorFilter): void;
    moveNext(input: XPathNavigator): IteratorResult;
}


export type XPathPrecedingMergeIterator = XPathPrecedingMergeIterator$instance;

export class XmlCollation$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type XmlCollation = XmlCollation$instance;

export class XmlILIndex$instance {
    add(key: string, navigator: XPathNavigator): void;
    lookup(key: string): XmlQueryNodeSequence;
}


export type XmlILIndex = XmlILIndex$instance;

export abstract class XmlNavigatorFilter$instance {
    abstract isFiltered(navigator: XPathNavigator): boolean;
    abstract moveToContent(navigator: XPathNavigator): boolean;
    abstract moveToFollowing(navigator: XPathNavigator, navigatorEnd: XPathNavigator): boolean;
    abstract moveToFollowingSibling(navigator: XPathNavigator): boolean;
    abstract moveToNextContent(navigator: XPathNavigator): boolean;
    abstract moveToPreviousSibling(navigator: XPathNavigator): boolean;
}


export type XmlNavigatorFilter = XmlNavigatorFilter$instance;

export class XmlQueryContext$instance {
    readonly defaultDataSource: XPathNavigator;
    readonly defaultNameTable: XmlNameTable;
    readonly queryNameTable: XmlNameTable;
    getDataSource(uriRelative: string, uriBase: string): XPathNavigator;
    getLateBoundObject(namespaceUri: string): unknown;
    getParameter(localName: string, namespaceUri: string): unknown;
    invokeXsltLateBoundFunction(name: string, namespaceUri: string, args: IList_1<XPathItem>[]): IList_1<XPathItem>;
    lateBoundFunctionExists(name: string, namespaceUri: string): boolean;
    onXsltMessageEncountered(message: string): void;
}


export type XmlQueryContext = XmlQueryContext$instance;

export class XmlQueryItemSequence$instance extends XmlQuerySequence_1$instance<XPathItem> {
    constructor();
    constructor(capacity: int);
    constructor(item: XPathItem);
    add(value: XPathItem): void;
    add(value: unknown): int;
    addClone(item: XPathItem): void;
    clear(): void;
    contains(value: XPathItem): boolean;
    contains(value: unknown): boolean;
    copyTo(array: XPathItem[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator_1<XPathItem>;
    getEnumerator(): IEnumerator;
    indexOf(value: XPathItem): int;
    insert(index: int, item: XPathItem): void;
    insert(index: int, value: unknown): void;
    remove(item: XPathItem): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export interface __XmlQueryItemSequence$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<XPathItem>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<XPathItem>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<XPathItem>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlQueryItemSequence = XmlQueryItemSequence$instance & __XmlQueryItemSequence$views;


export class XmlQueryNodeSequence$instance extends XmlQuerySequence_1$instance<XPathNavigator> {
    constructor();
    constructor(capacity: int);
    constructor(list: IList_1<XPathNavigator>);
    constructor(array: XPathNavigator[], size: int);
    constructor(navigator: XPathNavigator);
    isDocOrderDistinct: boolean;
    add(value: XPathNavigator): void;
    add(value: unknown): int;
    addClone(navigator: XPathNavigator): void;
    clear(): void;
    contains(value: XPathNavigator): boolean;
    contains(value: unknown): boolean;
    copyTo(array: XPathNavigator[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    docOrderDistinct(comparer: IComparer_1<XPathNavigator>): XmlQueryNodeSequence;
    getEnumerator(): IEnumerator_1<XPathNavigator>;
    getEnumerator(): IEnumerator;
    indexOf(value: XPathNavigator): int;
    insert(index: int, item: XPathNavigator): void;
    insert(index: int, value: unknown): void;
    remove(item: XPathNavigator): boolean;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export interface __XmlQueryNodeSequence$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<XPathNavigator>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<XPathNavigator>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<XPathNavigator>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlQueryNodeSequence = XmlQueryNodeSequence$instance & __XmlQueryNodeSequence$views;


export class XmlQueryOutput$instance extends System_Xml_Internal.XmlWriter$instance {
    readonly writeState: WriteState;
    readonly xmlLang: string;
    readonly xmlSpace: XmlSpace;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    endCopy(navigator: XPathNavigator): void;
    endTree(): void;
    flush(): void;
    lookupPrefix(ns: string): string;
    startCopy(navigator: XPathNavigator): boolean;
    startElementContentUnchecked(): void;
    startTree(rootType: XPathNodeType): void;
    writeBase64(buffer: byte[], index: int, count: int): void;
    writeCData(text: string): void;
    writeCharEntity(ch: char): void;
    writeChars(buffer: char[], index: int, count: int): void;
    writeComment(text: string): void;
    writeCommentString(text: string): void;
    writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
    writeEndAttribute(): void;
    writeEndAttributeUnchecked(): void;
    writeEndComment(): void;
    writeEndDocument(): void;
    writeEndElement(): void;
    writeEndElementUnchecked(prefix: string, localName: string, ns: string): void;
    writeEndElementUnchecked(localName: string): void;
    writeEndNamespace(): void;
    writeEndProcessingInstruction(): void;
    writeEndRoot(): void;
    writeEntityRef(name: string): void;
    writeFullEndElement(): void;
    writeItem(item: XPathItem): void;
    writeNamespaceDeclaration(prefix: string, ns: string): void;
    writeNamespaceDeclarationUnchecked(prefix: string, ns: string): void;
    writeNamespaceString(text: string): void;
    writeProcessingInstruction(target: string, text: string): void;
    writeProcessingInstructionString(text: string): void;
    writeRaw(buffer: char[], index: int, count: int): void;
    writeRaw(data: string): void;
    writeRawUnchecked(text: string): void;
    writeStartAttribute(prefix: string, localName: string, ns: string): void;
    writeStartAttribute(localName: string, ns: string): void;
    writeStartAttribute(localName: string): void;
    writeStartAttributeComputed(tagName: string, prefixMappingsIndex: int): void;
    writeStartAttributeComputed(tagName: string, ns: string): void;
    writeStartAttributeComputed(navigator: XPathNavigator): void;
    writeStartAttributeComputed(name: XmlQualifiedName): void;
    writeStartAttributeLocalName(localName: string): void;
    writeStartAttributeUnchecked(prefix: string, localName: string, ns: string): void;
    writeStartAttributeUnchecked(localName: string): void;
    writeStartComment(): void;
    writeStartDocument(): void;
    writeStartDocument(standalone: boolean): void;
    writeStartElement(prefix: string, localName: string, ns: string): void;
    writeStartElement(localName: string, ns: string): void;
    writeStartElement(localName: string): void;
    writeStartElementComputed(tagName: string, prefixMappingsIndex: int): void;
    writeStartElementComputed(tagName: string, ns: string): void;
    writeStartElementComputed(navigator: XPathNavigator): void;
    writeStartElementComputed(name: XmlQualifiedName): void;
    writeStartElementLocalName(localName: string): void;
    writeStartElementUnchecked(prefix: string, localName: string, ns: string): void;
    writeStartElementUnchecked(localName: string): void;
    writeStartNamespace(prefix: string): void;
    writeStartProcessingInstruction(target: string): void;
    writeStartRoot(): void;
    writeString(text: string): void;
    writeStringUnchecked(text: string): void;
    writeSurrogateCharEntity(lowChar: char, highChar: char): void;
    writeWhitespace(ws: string): void;
    xsltCopyOf(navigator: XPathNavigator): void;
}


export interface __XmlQueryOutput$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlQueryOutput = XmlQueryOutput$instance & __XmlQueryOutput$views;


export class XmlQueryRuntime$instance {
    readonly externalContext: XmlQueryContext;
    readonly nameTable: XmlNameTable;
    readonly output: XmlQueryOutput;
    readonly xsltFunctions: XsltLibrary;
    addNewIndex(context: XPathNavigator, indexId: int, index: XmlILIndex): void;
    changeTypeXsltArgument(indexType: int, value: unknown, destinationType: Type): unknown;
    changeTypeXsltResult(indexType: int, value: unknown): unknown;
    comparePosition(navigatorThis: XPathNavigator, navigatorThat: XPathNavigator): int;
    createCollation(collation: string): XmlCollation;
    debugGetGlobalNames(): string[];
    debugGetGlobalValue(name: string): IList;
    debugGetXsltValue(seq: IList): unknown;
    debugSetGlobalValue(name: string, value: unknown): void;
    docOrderDistinct(seq: IList_1<XPathNavigator>): IList_1<XPathNavigator>;
    earlyBoundFunctionExists(name: string, namespaceUri: string): boolean;
    endRtfConstruction(output: { value: ref<XmlQueryOutput> }): XPathNavigator;
    endSequenceConstruction(output: { value: ref<XmlQueryOutput> }): IList_1<XPathItem>;
    findIndex(context: XPathNavigator, indexId: int, index: { value: ref<XmlILIndex> }): boolean;
    generateId(navigator: XPathNavigator): string;
    getAtomizedName(index: int): string;
    getCollation(index: int): XmlCollation;
    getEarlyBoundObject(index: int): unknown;
    getGlobalValue(index: int): unknown;
    getNameFilter(index: int): XmlNavigatorFilter;
    getTypeFilter(nodeType: XPathNodeType): XmlNavigatorFilter;
    isGlobalComputed(index: int): boolean;
    isQNameEqual(n1: XPathNavigator, n2: XPathNavigator): boolean;
    isQNameEqual(navigator: XPathNavigator, indexLocalName: int, indexNamespaceUri: int): boolean;
    matchesXmlType(seq: IList_1<XPathItem>, indexType: int): boolean;
    matchesXmlType(item: XPathItem, indexType: int): boolean;
    matchesXmlType(seq: IList_1<XPathItem>, code: XmlTypeCode): boolean;
    matchesXmlType(item: XPathItem, code: XmlTypeCode): boolean;
    parseTagName(tagName: string, indexPrefixMappings: int): XmlQualifiedName;
    parseTagName(tagName: string, ns: string): XmlQualifiedName;
    sendMessage(message: string): void;
    setGlobalValue(index: int, value: unknown): void;
    startRtfConstruction(baseUri: string, output: { value: ref<XmlQueryOutput> }): void;
    startSequenceConstruction(output: { value: ref<XmlQueryOutput> }): void;
    textRtfConstruction(text: string, baseUri: string): XPathNavigator;
    throwException(text: string): void;
    static OnCurrentNodeChanged(currentNode: XPathNavigator): int;
}


export type XmlQueryRuntime = XmlQueryRuntime$instance;

export class XmlQuerySequence_1$instance<T> {
    constructor();
    constructor(capacity: int);
    constructor(array: T[], size: int);
    constructor(value: T);
    readonly count: int;
    item: T;
    add(value: T): void;
    clear(): void;
    contains(value: T): boolean;
    copyTo(array: T[], index: int): void;
    getEnumerator(): IEnumerator_1<T>;
    indexOf(value: T): int;
    sortByKeys(keys: ClrArray): void;
    static readonly empty: unknown;
    static CreateOrReuse<T>(seq: XmlQuerySequence_1<T>, item: T): XmlQuerySequence_1<T>;
    static CreateOrReuse<T>(seq: XmlQuerySequence_1<T>): XmlQuerySequence_1<T>;
}


export interface __XmlQuerySequence_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlQuerySequence_1<T> = XmlQuerySequence_1$instance<T> & __XmlQuerySequence_1$views<T>;


export class XsltLibrary$instance {
    checkScriptNamespace(nsUri: string): int;
    elementAvailable(name: XmlQualifiedName): boolean;
    equalityOperator(opCode: double, left: IList_1<XPathItem>, right: IList_1<XPathItem>): boolean;
    formatMessage(res: string, args: IList_1<CLROf<string>>): string;
    formatNumberDynamic(value: double, formatPicture: string, decimalFormatName: XmlQualifiedName, errorMessageName: string): string;
    formatNumberStatic(value: double, decimalFormatterIndex: double): string;
    functionAvailable(name: XmlQualifiedName): boolean;
    isSameNodeSort(nav1: XPathNavigator, nav2: XPathNavigator): boolean;
    langToLcid(lang: string, forwardCompatibility: boolean): int;
    numberFormat(value: IList_1<XPathItem>, formatString: string, lang: double, letterValue: string, groupingSeparator: string, groupingSize: double): string;
    registerDecimalFormat(name: XmlQualifiedName, infinitySymbol: string, nanSymbol: string, characters: string): int;
    registerDecimalFormatter(formatPicture: string, infinitySymbol: string, nanSymbol: string, characters: string): double;
    relationalOperator(opCode: double, left: IList_1<XPathItem>, right: IList_1<XPathItem>): boolean;
}


export type XsltLibrary = XsltLibrary$instance;

export abstract class XmlILStorageConverter$instance {
    static BooleanToAtomicValue(value: boolean, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static BytesToAtomicValue(value: byte[], index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static DateTimeToAtomicValue(value: DateTime, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static DecimalToAtomicValue(value: decimal, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static DoubleToAtomicValue(value: double, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static Int32ToAtomicValue(value: int, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static Int64ToAtomicValue(value: long, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static ItemsToNavigators(listItems: IList_1<XPathItem>): IList_1<XPathNavigator>;
    static NavigatorsToItems(listNavigators: IList_1<XPathNavigator>): IList_1<XPathItem>;
    static SingleToAtomicValue(value: float, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static StringToAtomicValue(value: string, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static TimeSpanToAtomicValue(value: TimeSpan, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
    static XmlQualifiedNameToAtomicValue(value: XmlQualifiedName, index: int, runtime: XmlQueryRuntime): XmlAtomicValue;
}


export type XmlILStorageConverter = XmlILStorageConverter$instance;

export abstract class XsltConvert$instance {
    static EnsureNodeSet(listItems: IList_1<XPathItem>): IList_1<XPathNavigator>;
    static ToBoolean(listItems: IList_1<XPathItem>): boolean;
    static ToBoolean(item: XPathItem): boolean;
    static ToDateTime(value: string): DateTime;
    static ToDecimal(value: double): decimal;
    static ToDouble(listItems: IList_1<XPathItem>): double;
    static ToDouble(value: decimal): double;
    static ToDouble(value: int): double;
    static ToDouble(value: long): double;
    static ToDouble(value: string): double;
    static ToDouble(item: XPathItem): double;
    static ToInt(value: double): int;
    static ToLong(value: double): long;
    static ToNode(listItems: IList_1<XPathItem>): XPathNavigator;
    static ToNode(item: XPathItem): XPathNavigator;
    static ToNodeSet(listItems: IList_1<XPathItem>): IList_1<XPathNavigator>;
    static ToNodeSet(item: XPathItem): IList_1<XPathNavigator>;
    static ToString(listItems: IList_1<XPathItem>): string;
    static ToString(value: DateTime): string;
    static ToString(value: double): string;
    static ToString(item: XPathItem): string;
}


export type XsltConvert = XsltConvert$instance;

export abstract class XsltFunctions$instance {
    static BaseUri(navigator: XPathNavigator): string;
    static Contains(s1: string, s2: string): boolean;
    static EXslObjectType(value: IList_1<XPathItem>): string;
    static Lang(value: string, context: XPathNavigator): boolean;
    static MSFormatDateTime(dateTime: string, format: string, lang: string, isDate: boolean): string;
    static MSLocalName(name: string): string;
    static MSNamespaceUri(name: string, currentNode: XPathNavigator): string;
    static MSNumber(value: IList_1<XPathItem>): double;
    static MSStringCompare(s1: string, s2: string, lang: string, options: string): double;
    static MSUtc(dateTime: string): string;
    static NormalizeSpace(value: string): string;
    static OuterXml(navigator: XPathNavigator): string;
    static Round(value: double): double;
    static StartsWith(s1: string, s2: string): boolean;
    static Substring(value: string, startIndex: double, length: double): string;
    static Substring(value: string, startIndex: double): string;
    static SubstringAfter(s1: string, s2: string): string;
    static SubstringBefore(s1: string, s2: string): string;
    static SystemProperty(name: XmlQualifiedName): XPathItem;
    static Translate(arg: string, mapString: string, transString: string): string;
}


export type XsltFunctions = XsltFunctions$instance;

