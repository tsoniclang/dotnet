// Generated by tsbindgen - Architecture
// Namespace: System.Linq.Expressions
// Assembly: System.Linq.Expressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { ConstructorInfo, FieldInfo, MemberInfo, MethodInfo, PropertyInfo } from "../../System.Reflection/internal/index.js";
import type { CallSiteBinder, DebugInfoGenerator } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Delegate, Enum, Func_2, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ExpressionType {
    Add = 0,
    AddChecked = 1,
    And = 2,
    AndAlso = 3,
    ArrayLength = 4,
    ArrayIndex = 5,
    Call = 6,
    Coalesce = 7,
    Conditional = 8,
    Constant = 9,
    Convert = 10,
    ConvertChecked = 11,
    Divide = 12,
    Equal = 13,
    ExclusiveOr = 14,
    GreaterThan = 15,
    GreaterThanOrEqual = 16,
    Invoke = 17,
    Lambda = 18,
    LeftShift = 19,
    LessThan = 20,
    LessThanOrEqual = 21,
    ListInit = 22,
    MemberAccess = 23,
    MemberInit = 24,
    Modulo = 25,
    Multiply = 26,
    MultiplyChecked = 27,
    Negate = 28,
    UnaryPlus = 29,
    NegateChecked = 30,
    New = 31,
    NewArrayInit = 32,
    NewArrayBounds = 33,
    Not = 34,
    NotEqual = 35,
    Or = 36,
    OrElse = 37,
    Parameter = 38,
    Power = 39,
    Quote = 40,
    RightShift = 41,
    Subtract = 42,
    SubtractChecked = 43,
    TypeAs = 44,
    TypeIs = 45,
    Assign = 46,
    Block = 47,
    DebugInfo = 48,
    Decrement = 49,
    Dynamic = 50,
    Default = 51,
    Extension = 52,
    Goto = 53,
    Increment = 54,
    Index = 55,
    Label = 56,
    RuntimeVariables = 57,
    Loop = 58,
    Switch = 59,
    Throw = 60,
    Try = 61,
    Unbox = 62,
    AddAssign = 63,
    AndAssign = 64,
    DivideAssign = 65,
    ExclusiveOrAssign = 66,
    LeftShiftAssign = 67,
    ModuloAssign = 68,
    MultiplyAssign = 69,
    OrAssign = 70,
    PowerAssign = 71,
    RightShiftAssign = 72,
    SubtractAssign = 73,
    AddAssignChecked = 74,
    MultiplyAssignChecked = 75,
    SubtractAssignChecked = 76,
    PreIncrementAssign = 77,
    PreDecrementAssign = 78,
    PostIncrementAssign = 79,
    PostDecrementAssign = 80,
    TypeEqual = 81,
    OnesComplement = 82,
    IsTrue = 83,
    IsFalse = 84
}


export enum GotoExpressionKind {
    Goto = 0,
    Return = 1,
    Break = 2,
    Continue = 3
}


export enum MemberBindingType {
    Assignment = 0,
    MemberBinding = 1,
    ListBinding = 2
}


export interface IArgumentProvider$instance {
    readonly ArgumentCount: int;
    GetArgument(index: int): Expression;
}


export type IArgumentProvider = IArgumentProvider$instance;

export interface IDynamicExpression$instance {
    readonly DelegateType: Type;
    readonly ArgumentCount: int;
    CreateCallSite(): any;
    GetArgument(index: int): Expression;
    Rewrite(args: Expression[]): Expression;
}


export type IDynamicExpression = IDynamicExpression$instance;

export class BinaryExpression$instance extends Expression$instance {
    readonly CanReduce: boolean;
    readonly Conversion: LambdaExpression;
    readonly IsLifted: boolean;
    readonly IsLiftedToNull: boolean;
    readonly Left: Expression;
    readonly Method: MethodInfo;
    readonly Right: Expression;
    Reduce(): Expression;
    Update(left: Expression, conversion: LambdaExpression, right: Expression): BinaryExpression;
}


export type BinaryExpression = BinaryExpression$instance;

export class BlockExpression$instance extends Expression$instance {
    readonly Expressions: ReadOnlyCollection_1<Expression>;
    readonly NodeType: ExpressionType;
    readonly Result: Expression;
    readonly Type: Type;
    readonly Variables: ReadOnlyCollection_1<ParameterExpression>;
    Update(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
}


export type BlockExpression = BlockExpression$instance;

export class CatchBlock$instance {
    readonly Body: Expression;
    readonly Filter: Expression;
    readonly Test: Type;
    readonly Variable: ParameterExpression;
    ToString(): string;
    Update(variable: ParameterExpression, filter: Expression, body: Expression): CatchBlock;
}


export type CatchBlock = CatchBlock$instance;

export class ConditionalExpression$instance extends Expression$instance {
    readonly IfFalse: Expression;
    readonly IfTrue: Expression;
    readonly NodeType: ExpressionType;
    readonly Test: Expression;
    readonly Type: Type;
    Update(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
}


export type ConditionalExpression = ConditionalExpression$instance;

export class ConstantExpression$instance extends Expression$instance {
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    readonly Value: any;
}


export type ConstantExpression = ConstantExpression$instance;

export class DebugInfoExpression$instance extends Expression$instance {
    readonly Document: SymbolDocumentInfo;
    readonly EndColumn: int;
    readonly EndLine: int;
    readonly IsClear: boolean;
    readonly NodeType: ExpressionType;
    readonly StartColumn: int;
    readonly StartLine: int;
    readonly Type: Type;
}


export type DebugInfoExpression = DebugInfoExpression$instance;

export class DefaultExpression$instance extends Expression$instance {
    readonly NodeType: ExpressionType;
    readonly Type: Type;
}


export type DefaultExpression = DefaultExpression$instance;

export class DynamicExpression$instance extends Expression$instance {
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Binder: CallSiteBinder;
    readonly CanReduce: boolean;
    readonly DelegateType: Type;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    Update(arguments: IEnumerable_1<Expression>): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
}


export interface __DynamicExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
    readonly As_IDynamicExpression: IDynamicExpression$instance;
}

export type DynamicExpression = DynamicExpression$instance & __DynamicExpression$views;


export class DynamicExpressionVisitor$instance extends ExpressionVisitor$instance {
    constructor();
}


export type DynamicExpressionVisitor = DynamicExpressionVisitor$instance;

export class ElementInit$instance {
    readonly AddMethod: MethodInfo;
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    GetArgument(index: int): Expression;
    ToString(): string;
    Update(arguments: IEnumerable_1<Expression>): ElementInit;
}


export interface __ElementInit$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type ElementInit = ElementInit$instance & __ElementInit$views;


export abstract class Expression$instance {
    readonly CanReduce: boolean;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    ReduceAndCheck(): Expression;
    ReduceExtensions(): Expression;
    ToString(): string;
    static Add(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Add(left: Expression, right: Expression): BinaryExpression;
    static AddAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static AddAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AddAssign(left: Expression, right: Expression): BinaryExpression;
    static AddAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static AddAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AddAssignChecked(left: Expression, right: Expression): BinaryExpression;
    static AddChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AddChecked(left: Expression, right: Expression): BinaryExpression;
    static And(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static And(left: Expression, right: Expression): BinaryExpression;
    static AndAlso(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AndAlso(left: Expression, right: Expression): BinaryExpression;
    static AndAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static AndAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AndAssign(left: Expression, right: Expression): BinaryExpression;
    static ArrayAccess(array: Expression, indexes: IEnumerable_1<Expression>): IndexExpression;
    static ArrayAccess(array: Expression, indexes: Expression[]): IndexExpression;
    static ArrayIndex(array: Expression, indexes: IEnumerable_1<Expression>): MethodCallExpression;
    static ArrayIndex(array: Expression, index: Expression): BinaryExpression;
    static ArrayIndex(array: Expression, indexes: Expression[]): MethodCallExpression;
    static ArrayLength(array: Expression): UnaryExpression;
    static Assign(left: Expression, right: Expression): BinaryExpression;
    static Bind(member: MemberInfo, expression: Expression): MemberAssignment;
    static Bind(propertyAccessor: MethodInfo, expression: Expression): MemberAssignment;
    static Block(expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    static Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): BlockExpression;
    static Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): BlockExpression;
    static Block(arg0: Expression, arg1: Expression, arg2: Expression): BlockExpression;
    static Block(arg0: Expression, arg1: Expression): BlockExpression;
    static Block(expressions: Expression[]): BlockExpression;
    static Block(type_: Type, expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    static Block(type_: Type, expressions: Expression[]): BlockExpression;
    static Break(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static Break(target: LabelTarget, value: Expression): GotoExpression;
    static Break(target: LabelTarget, type_: Type): GotoExpression;
    static Break(target: LabelTarget): GotoExpression;
    static Call(instance: Expression, method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo): MethodCallExpression;
    static Call(instance: Expression, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    static Call(method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    static Call(type_: Type, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    static Catch(variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    static Catch(variable: ParameterExpression, body: Expression): CatchBlock;
    static Catch(type_: Type, body: Expression, filter: Expression): CatchBlock;
    static Catch(type_: Type, body: Expression): CatchBlock;
    static ClearDebugInfo(document: SymbolDocumentInfo): DebugInfoExpression;
    static Coalesce(left: Expression, right: Expression, conversion: LambdaExpression): BinaryExpression;
    static Coalesce(left: Expression, right: Expression): BinaryExpression;
    static Condition(test: Expression, ifTrue: Expression, ifFalse: Expression, type_: Type): ConditionalExpression;
    static Condition(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    static Constant(value: any, type_: Type): ConstantExpression;
    static Constant(value: any): ConstantExpression;
    static Continue(target: LabelTarget, type_: Type): GotoExpression;
    static Continue(target: LabelTarget): GotoExpression;
    static Convert(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static Convert(expression: Expression, type_: Type): UnaryExpression;
    static ConvertChecked(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static ConvertChecked(expression: Expression, type_: Type): UnaryExpression;
    static DebugInfo(document: SymbolDocumentInfo, startLine: int, startColumn: int, endLine: int, endColumn: int): DebugInfoExpression;
    static Decrement(expression: Expression, method: MethodInfo): UnaryExpression;
    static Decrement(expression: Expression): UnaryExpression;
    static Default(type_: Type): DefaultExpression;
    static Divide(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Divide(left: Expression, right: Expression): BinaryExpression;
    static DivideAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static DivideAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static DivideAssign(left: Expression, right: Expression): BinaryExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    static ElementInit(addMethod: MethodInfo, arguments: IEnumerable_1<Expression>): ElementInit;
    static ElementInit(addMethod: MethodInfo, arguments: Expression[]): ElementInit;
    static Empty(): DefaultExpression;
    static Equal(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static Equal(left: Expression, right: Expression): BinaryExpression;
    static ExclusiveOr(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static ExclusiveOr(left: Expression, right: Expression): BinaryExpression;
    static ExclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static ExclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static ExclusiveOrAssign(left: Expression, right: Expression): BinaryExpression;
    static Field(expression: Expression, field: FieldInfo): MemberExpression;
    static Field(expression: Expression, fieldName: string): MemberExpression;
    static Field(expression: Expression, type_: Type, fieldName: string): MemberExpression;
    static GetActionType(typeArgs: Type[]): Type;
    static GetDelegateType(typeArgs: Type[]): Type;
    static GetFuncType(typeArgs: Type[]): Type;
    static Goto(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static Goto(target: LabelTarget, value: Expression): GotoExpression;
    static Goto(target: LabelTarget, type_: Type): GotoExpression;
    static Goto(target: LabelTarget): GotoExpression;
    static GreaterThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static GreaterThan(left: Expression, right: Expression): BinaryExpression;
    static GreaterThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static GreaterThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    static IfThen(test: Expression, ifTrue: Expression): ConditionalExpression;
    static IfThenElse(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    static Increment(expression: Expression, method: MethodInfo): UnaryExpression;
    static Increment(expression: Expression): UnaryExpression;
    static Invoke(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
    static Invoke(expression: Expression, arguments: Expression[]): InvocationExpression;
    static IsFalse(expression: Expression, method: MethodInfo): UnaryExpression;
    static IsFalse(expression: Expression): UnaryExpression;
    static IsTrue(expression: Expression, method: MethodInfo): UnaryExpression;
    static IsTrue(expression: Expression): UnaryExpression;
    static Label(): LabelTarget;
    static Label(target: LabelTarget, defaultValue: Expression): LabelExpression;
    static Label(target: LabelTarget): LabelExpression;
    static Label(name: string): LabelTarget;
    static Label(type_: Type, name: string): LabelTarget;
    static Label(type_: Type): LabelTarget;
    static Lambda<TDelegate>(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    static Lambda(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    static Lambda(body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static LeftShift(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static LeftShift(left: Expression, right: Expression): BinaryExpression;
    static LeftShiftAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static LeftShiftAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static LeftShiftAssign(left: Expression, right: Expression): BinaryExpression;
    static LessThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static LessThan(left: Expression, right: Expression): BinaryExpression;
    static LessThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static LessThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    static ListBind(member: MemberInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    static ListBind(member: MemberInfo, initializers: ElementInit[]): MemberListBinding;
    static ListBind(propertyAccessor: MethodInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    static ListBind(propertyAccessor: MethodInfo, initializers: ElementInit[]): MemberListBinding;
    static ListInit(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
    static ListInit(newExpression: NewExpression, initializers: IEnumerable_1<Expression>): ListInitExpression;
    static ListInit(newExpression: NewExpression, initializers: ElementInit[]): ListInitExpression;
    static ListInit(newExpression: NewExpression, initializers: Expression[]): ListInitExpression;
    static ListInit(newExpression: NewExpression, addMethod: MethodInfo, initializers: IEnumerable_1<Expression>): ListInitExpression;
    static ListInit(newExpression: NewExpression, addMethod: MethodInfo, initializers: Expression[]): ListInitExpression;
    static Loop(body: Expression, break_: LabelTarget, continue_: LabelTarget): LoopExpression;
    static Loop(body: Expression, break_: LabelTarget): LoopExpression;
    static Loop(body: Expression): LoopExpression;
    static MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression): BinaryExpression;
    static MakeCatchBlock(type_: Type, variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
    static MakeGoto(kind: GotoExpressionKind, target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static MakeIndex(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    static MakeMemberAccess(expression: Expression, member: MemberInfo): MemberExpression;
    static MakeTry(type_: Type, body: Expression, finally_: Expression, fault: Expression, handlers: IEnumerable_1<CatchBlock>): TryExpression;
    static MakeUnary(unaryType: ExpressionType, operand: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static MakeUnary(unaryType: ExpressionType, operand: Expression, type_: Type): UnaryExpression;
    static MemberBind(member: MemberInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    static MemberBind(member: MemberInfo, bindings: MemberBinding[]): MemberMemberBinding;
    static MemberBind(propertyAccessor: MethodInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    static MemberBind(propertyAccessor: MethodInfo, bindings: MemberBinding[]): MemberMemberBinding;
    static MemberInit(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
    static MemberInit(newExpression: NewExpression, bindings: MemberBinding[]): MemberInitExpression;
    static Modulo(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Modulo(left: Expression, right: Expression): BinaryExpression;
    static ModuloAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static ModuloAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static ModuloAssign(left: Expression, right: Expression): BinaryExpression;
    static Multiply(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Multiply(left: Expression, right: Expression): BinaryExpression;
    static MultiplyAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static MultiplyAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static MultiplyAssign(left: Expression, right: Expression): BinaryExpression;
    static MultiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static MultiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static MultiplyAssignChecked(left: Expression, right: Expression): BinaryExpression;
    static MultiplyChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static MultiplyChecked(left: Expression, right: Expression): BinaryExpression;
    static Negate(expression: Expression, method: MethodInfo): UnaryExpression;
    static Negate(expression: Expression): UnaryExpression;
    static NegateChecked(expression: Expression, method: MethodInfo): UnaryExpression;
    static NegateChecked(expression: Expression): UnaryExpression;
    static New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: IEnumerable_1<MemberInfo>): NewExpression;
    static New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: MemberInfo[]): NewExpression;
    static New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>): NewExpression;
    static New(constructor_: ConstructorInfo, arguments: Expression[]): NewExpression;
    static New(constructor_: ConstructorInfo): NewExpression;
    static New(type_: Type): NewExpression;
    static NewArrayBounds(type_: Type, bounds: IEnumerable_1<Expression>): NewArrayExpression;
    static NewArrayBounds(type_: Type, bounds: Expression[]): NewArrayExpression;
    static NewArrayInit(type_: Type, initializers: IEnumerable_1<Expression>): NewArrayExpression;
    static NewArrayInit(type_: Type, initializers: Expression[]): NewArrayExpression;
    static Not(expression: Expression, method: MethodInfo): UnaryExpression;
    static Not(expression: Expression): UnaryExpression;
    static NotEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static NotEqual(left: Expression, right: Expression): BinaryExpression;
    static OnesComplement(expression: Expression, method: MethodInfo): UnaryExpression;
    static OnesComplement(expression: Expression): UnaryExpression;
    static Or(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Or(left: Expression, right: Expression): BinaryExpression;
    static OrAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static OrAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static OrAssign(left: Expression, right: Expression): BinaryExpression;
    static OrElse(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static OrElse(left: Expression, right: Expression): BinaryExpression;
    static Parameter(type_: Type, name: string): ParameterExpression;
    static Parameter(type_: Type): ParameterExpression;
    static PostDecrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PostDecrementAssign(expression: Expression): UnaryExpression;
    static PostIncrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PostIncrementAssign(expression: Expression): UnaryExpression;
    static Power(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Power(left: Expression, right: Expression): BinaryExpression;
    static PowerAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static PowerAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static PowerAssign(left: Expression, right: Expression): BinaryExpression;
    static PreDecrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PreDecrementAssign(expression: Expression): UnaryExpression;
    static PreIncrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PreIncrementAssign(expression: Expression): UnaryExpression;
    static Property(expression: Expression, propertyAccessor: MethodInfo): MemberExpression;
    static Property(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    static Property(instance: Expression, indexer: PropertyInfo, arguments: Expression[]): IndexExpression;
    static Property(expression: Expression, property: PropertyInfo): MemberExpression;
    static Property(instance: Expression, propertyName: string, arguments: Expression[]): IndexExpression;
    static Property(expression: Expression, propertyName: string): MemberExpression;
    static Property(expression: Expression, type_: Type, propertyName: string): MemberExpression;
    static PropertyOrField(expression: Expression, propertyOrFieldName: string): MemberExpression;
    static Quote(expression: Expression): UnaryExpression;
    static ReferenceEqual(left: Expression, right: Expression): BinaryExpression;
    static ReferenceNotEqual(left: Expression, right: Expression): BinaryExpression;
    static Rethrow(): UnaryExpression;
    static Rethrow(type_: Type): UnaryExpression;
    static Return(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static Return(target: LabelTarget, value: Expression): GotoExpression;
    static Return(target: LabelTarget, type_: Type): GotoExpression;
    static Return(target: LabelTarget): GotoExpression;
    static RightShift(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static RightShift(left: Expression, right: Expression): BinaryExpression;
    static RightShiftAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static RightShiftAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static RightShiftAssign(left: Expression, right: Expression): BinaryExpression;
    static RuntimeVariables(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
    static RuntimeVariables(variables: ParameterExpression[]): RuntimeVariablesExpression;
    static Subtract(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Subtract(left: Expression, right: Expression): BinaryExpression;
    static SubtractAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static SubtractAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static SubtractAssign(left: Expression, right: Expression): BinaryExpression;
    static SubtractAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static SubtractAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static SubtractAssignChecked(left: Expression, right: Expression): BinaryExpression;
    static SubtractChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static SubtractChecked(left: Expression, right: Expression): BinaryExpression;
    static Switch(switchValue: Expression, defaultBody: Expression, cases: SwitchCase[]): SwitchExpression;
    static Switch(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    static Switch(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    static Switch(switchValue: Expression, cases: SwitchCase[]): SwitchExpression;
    static Switch(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    static Switch(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    static SwitchCase(body: Expression, testValues: IEnumerable_1<Expression>): SwitchCase;
    static SwitchCase(body: Expression, testValues: Expression[]): SwitchCase;
    static SymbolDocument(fileName: string, language: Guid, languageVendor: Guid, documentType: Guid): SymbolDocumentInfo;
    static SymbolDocument(fileName: string, language: Guid, languageVendor: Guid): SymbolDocumentInfo;
    static SymbolDocument(fileName: string, language: Guid): SymbolDocumentInfo;
    static SymbolDocument(fileName: string): SymbolDocumentInfo;
    static Throw(value: Expression, type_: Type): UnaryExpression;
    static Throw(value: Expression): UnaryExpression;
    static TryCatch(body: Expression, handlers: CatchBlock[]): TryExpression;
    static TryCatchFinally(body: Expression, finally_: Expression, handlers: CatchBlock[]): TryExpression;
    static TryFault(body: Expression, fault: Expression): TryExpression;
    static TryFinally(body: Expression, finally_: Expression): TryExpression;
    static TryGetActionType(typeArgs: Type[], actionType: { value: TSByRef<Type> }): boolean;
    static TryGetFuncType(typeArgs: Type[], funcType: { value: TSByRef<Type> }): boolean;
    static TypeAs(expression: Expression, type_: Type): UnaryExpression;
    static TypeEqual(expression: Expression, type_: Type): TypeBinaryExpression;
    static TypeIs(expression: Expression, type_: Type): TypeBinaryExpression;
    static UnaryPlus(expression: Expression, method: MethodInfo): UnaryExpression;
    static UnaryPlus(expression: Expression): UnaryExpression;
    static Unbox(expression: Expression, type_: Type): UnaryExpression;
    static Variable(type_: Type, name: string): ParameterExpression;
    static Variable(type_: Type): ParameterExpression;
}


export type Expression = Expression$instance;

export class Expression_1$instance<TDelegate> extends LambdaExpression$instance {
    Compile(): TDelegate;
    Compile(preferInterpretation: boolean): TDelegate;
    Compile(debugInfoGenerator: DebugInfoGenerator): TDelegate;
    Compile(): Function;
    Compile(preferInterpretation: boolean): Function;
    Compile(debugInfoGenerator: DebugInfoGenerator): Function;
    Update(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
}


export type Expression_1<TDelegate> = Expression_1$instance<TDelegate>;

export abstract class ExpressionVisitor$instance {
    Visit(node: Expression): Expression;
    Visit(nodes: ReadOnlyCollection_1<Expression>): ReadOnlyCollection_1<Expression>;
    VisitAndConvert<T extends Expression>(node: T, callerName: string): T;
    VisitAndConvert<T extends Expression>(nodes: ReadOnlyCollection_1<T>, callerName: string): ReadOnlyCollection_1<T>;
    static Visit<T>(nodes: ReadOnlyCollection_1<T>, elementVisitor: Func_2<T, T>): ReadOnlyCollection_1<T>;
}


export type ExpressionVisitor = ExpressionVisitor$instance;

export class GotoExpression$instance extends Expression$instance {
    readonly Kind: GotoExpressionKind;
    readonly NodeType: ExpressionType;
    readonly Target: LabelTarget;
    readonly Type: Type;
    readonly Value: Expression;
    Update(target: LabelTarget, value: Expression): GotoExpression;
}


export type GotoExpression = GotoExpression$instance;

export class IndexExpression$instance extends Expression$instance {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Indexer: PropertyInfo;
    readonly NodeType: ExpressionType;
    readonly Object: Expression;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(object_: Expression, arguments: IEnumerable_1<Expression>): IndexExpression;
}


export interface __IndexExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type IndexExpression = IndexExpression$instance & __IndexExpression$views;


export class InvocationExpression$instance extends Expression$instance {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Expression: Expression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
}


export interface __InvocationExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type InvocationExpression = InvocationExpression$instance & __InvocationExpression$views;


export class LabelExpression$instance extends Expression$instance {
    readonly DefaultValue: Expression;
    readonly NodeType: ExpressionType;
    readonly Target: LabelTarget;
    readonly Type: Type;
    Update(target: LabelTarget, defaultValue: Expression): LabelExpression;
}


export type LabelExpression = LabelExpression$instance;

export class LabelTarget$instance {
    readonly Name: string;
    readonly Type: Type;
    ToString(): string;
}


export type LabelTarget = LabelTarget$instance;

export abstract class LambdaExpression$instance extends Expression$instance {
    readonly Body: Expression;
    readonly Name: string;
    readonly NodeType: ExpressionType;
    readonly Parameters: ReadOnlyCollection_1<ParameterExpression>;
    readonly ReturnType: Type;
    readonly TailCall: boolean;
    readonly Type: Type;
    Compile(): Function;
    Compile(preferInterpretation: boolean): Function;
    Compile(debugInfoGenerator: DebugInfoGenerator): Function;
    static readonly CanCompileToIL: boolean;
    static readonly CanInterpret: boolean;
}


export type LambdaExpression = LambdaExpression$instance;

export class ListInitExpression$instance extends Expression$instance {
    readonly CanReduce: boolean;
    readonly Initializers: ReadOnlyCollection_1<ElementInit>;
    readonly NewExpression: NewExpression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    Update(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
}


export type ListInitExpression = ListInitExpression$instance;

export class LoopExpression$instance extends Expression$instance {
    readonly Body: Expression;
    readonly BreakLabel: LabelTarget;
    readonly ContinueLabel: LabelTarget;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Update(breakLabel: LabelTarget, continueLabel: LabelTarget, body: Expression): LoopExpression;
}


export type LoopExpression = LoopExpression$instance;

export class MemberAssignment$instance extends MemberBinding$instance {
    readonly Expression: Expression;
    Update(expression: Expression): MemberAssignment;
}


export type MemberAssignment = MemberAssignment$instance;

export abstract class MemberBinding$instance {
    readonly BindingType: MemberBindingType;
    readonly Member: MemberInfo;
    ToString(): string;
}


export type MemberBinding = MemberBinding$instance;

export class MemberExpression$instance extends Expression$instance {
    readonly Expression: Expression;
    readonly Member: MemberInfo;
    readonly NodeType: ExpressionType;
    Update(expression: Expression): MemberExpression;
}


export type MemberExpression = MemberExpression$instance;

export class MemberInitExpression$instance extends Expression$instance {
    readonly Bindings: ReadOnlyCollection_1<MemberBinding>;
    readonly CanReduce: boolean;
    readonly NewExpression: NewExpression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    Update(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
}


export type MemberInitExpression = MemberInitExpression$instance;

export class MemberListBinding$instance extends MemberBinding$instance {
    readonly Initializers: ReadOnlyCollection_1<ElementInit>;
    Update(initializers: IEnumerable_1<ElementInit>): MemberListBinding;
}


export type MemberListBinding = MemberListBinding$instance;

export class MemberMemberBinding$instance extends MemberBinding$instance {
    readonly Bindings: ReadOnlyCollection_1<MemberBinding>;
    Update(bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
}


export type MemberMemberBinding = MemberMemberBinding$instance;

export class MethodCallExpression$instance extends Expression$instance {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Method: MethodInfo;
    readonly NodeType: ExpressionType;
    readonly Object: Expression;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(object_: Expression, arguments: IEnumerable_1<Expression>): MethodCallExpression;
}


export interface __MethodCallExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type MethodCallExpression = MethodCallExpression$instance & __MethodCallExpression$views;


export class NewArrayExpression$instance extends Expression$instance {
    readonly Expressions: ReadOnlyCollection_1<Expression>;
    readonly Type: Type;
    Update(expressions: IEnumerable_1<Expression>): NewArrayExpression;
}


export type NewArrayExpression = NewArrayExpression$instance;

export class NewExpression$instance extends Expression$instance {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Constructor: ConstructorInfo;
    readonly Members: ReadOnlyCollection_1<MemberInfo>;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(arguments: IEnumerable_1<Expression>): NewExpression;
}


export interface __NewExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type NewExpression = NewExpression$instance & __NewExpression$views;


export class ParameterExpression$instance extends Expression$instance {
    readonly IsByRef: boolean;
    readonly Name: string;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
}


export type ParameterExpression = ParameterExpression$instance;

export class RuntimeVariablesExpression$instance extends Expression$instance {
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    readonly Variables: ReadOnlyCollection_1<ParameterExpression>;
    Update(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
}


export type RuntimeVariablesExpression = RuntimeVariablesExpression$instance;

export class SwitchCase$instance {
    readonly Body: Expression;
    readonly TestValues: ReadOnlyCollection_1<Expression>;
    ToString(): string;
    Update(testValues: IEnumerable_1<Expression>, body: Expression): SwitchCase;
}


export type SwitchCase = SwitchCase$instance;

export class SwitchExpression$instance extends Expression$instance {
    readonly Cases: ReadOnlyCollection_1<SwitchCase>;
    readonly Comparison: MethodInfo;
    readonly DefaultBody: Expression;
    readonly NodeType: ExpressionType;
    readonly SwitchValue: Expression;
    readonly Type: Type;
    Update(switchValue: Expression, cases: IEnumerable_1<SwitchCase>, defaultBody: Expression): SwitchExpression;
}


export type SwitchExpression = SwitchExpression$instance;

export class SymbolDocumentInfo$instance {
    readonly DocumentType: Guid;
    readonly FileName: string;
    readonly Language: Guid;
    readonly LanguageVendor: Guid;
}


export type SymbolDocumentInfo = SymbolDocumentInfo$instance;

export class TryExpression$instance extends Expression$instance {
    readonly Body: Expression;
    readonly Fault: Expression;
    readonly Finally: Expression;
    readonly Handlers: ReadOnlyCollection_1<CatchBlock>;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Update(body: Expression, handlers: IEnumerable_1<CatchBlock>, finally_: Expression, fault: Expression): TryExpression;
}


export type TryExpression = TryExpression$instance;

export class TypeBinaryExpression$instance extends Expression$instance {
    readonly Expression: Expression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    readonly TypeOperand: Type;
    Update(expression: Expression): TypeBinaryExpression;
}


export type TypeBinaryExpression = TypeBinaryExpression$instance;

export class UnaryExpression$instance extends Expression$instance {
    readonly CanReduce: boolean;
    readonly IsLifted: boolean;
    readonly IsLiftedToNull: boolean;
    readonly Method: MethodInfo;
    readonly NodeType: ExpressionType;
    readonly Operand: Expression;
    readonly Type: Type;
    Reduce(): Expression;
    Update(operand: Expression): UnaryExpression;
}


export type UnaryExpression = UnaryExpression$instance;

