// Generated by tsbindgen - Architecture
// Namespace: System.Linq.Expressions
// Assembly: System.Linq.Expressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { ConstructorInfo, FieldInfo, MemberInfo, MethodInfo, PropertyInfo } from "../../System.Reflection/internal/index.js";
import type { CallSiteBinder, DebugInfoGenerator } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Delegate, Enum, Func_2, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ExpressionType {
    add = 0,
    addChecked = 1,
    and = 2,
    andAlso = 3,
    arrayLength = 4,
    arrayIndex = 5,
    call = 6,
    coalesce = 7,
    conditional = 8,
    constant = 9,
    convert = 10,
    convertChecked = 11,
    divide = 12,
    equal = 13,
    exclusiveOr = 14,
    greaterThan = 15,
    greaterThanOrEqual = 16,
    invoke = 17,
    lambda = 18,
    leftShift = 19,
    lessThan = 20,
    lessThanOrEqual = 21,
    listInit = 22,
    memberAccess = 23,
    memberInit = 24,
    modulo = 25,
    multiply = 26,
    multiplyChecked = 27,
    negate = 28,
    unaryPlus = 29,
    negateChecked = 30,
    new_ = 31,
    newArrayInit = 32,
    newArrayBounds = 33,
    not = 34,
    notEqual = 35,
    or = 36,
    orElse = 37,
    parameter = 38,
    power = 39,
    quote = 40,
    rightShift = 41,
    subtract = 42,
    subtractChecked = 43,
    typeAs = 44,
    typeIs = 45,
    assign = 46,
    block = 47,
    debugInfo = 48,
    decrement = 49,
    dynamic = 50,
    default_ = 51,
    extension = 52,
    goto = 53,
    increment = 54,
    index = 55,
    label = 56,
    runtimeVariables = 57,
    loop = 58,
    switch_ = 59,
    throw_ = 60,
    try_ = 61,
    unbox = 62,
    addAssign = 63,
    andAssign = 64,
    divideAssign = 65,
    exclusiveOrAssign = 66,
    leftShiftAssign = 67,
    moduloAssign = 68,
    multiplyAssign = 69,
    orAssign = 70,
    powerAssign = 71,
    rightShiftAssign = 72,
    subtractAssign = 73,
    addAssignChecked = 74,
    multiplyAssignChecked = 75,
    subtractAssignChecked = 76,
    preIncrementAssign = 77,
    preDecrementAssign = 78,
    postIncrementAssign = 79,
    postDecrementAssign = 80,
    typeEqual = 81,
    onesComplement = 82,
    isTrue = 83,
    isFalse = 84
}


export enum GotoExpressionKind {
    goto = 0,
    return_ = 1,
    break_ = 2,
    continue_ = 3
}


export enum MemberBindingType {
    assignment = 0,
    memberBinding = 1,
    listBinding = 2
}


export interface IArgumentProvider$instance {
    readonly argumentCount: int;
    getArgument(index: int): Expression;
}


export type IArgumentProvider = IArgumentProvider$instance;

export interface IDynamicExpression$instance extends IArgumentProvider {
    readonly delegateType: Type;
    readonly argumentCount: int;
    createCallSite(): unknown;
    getArgument(index: int): Expression;
    rewrite(args: Expression[]): Expression;
}


export interface IDynamicExpression$instance extends IArgumentProvider$instance {}

export type IDynamicExpression = IDynamicExpression$instance;

export class BinaryExpression$instance extends Expression$instance {
    readonly canReduce: boolean;
    readonly conversion: LambdaExpression;
    readonly isLifted: boolean;
    readonly isLiftedToNull: boolean;
    readonly left: Expression;
    readonly method: MethodInfo;
    readonly right: Expression;
    reduce(): Expression;
    update(left: Expression, conversion: LambdaExpression, right: Expression): BinaryExpression;
}


export type BinaryExpression = BinaryExpression$instance;

export class BlockExpression$instance extends Expression$instance {
    readonly expressions: ReadOnlyCollection_1<Expression>;
    readonly nodeType: ExpressionType;
    readonly result: Expression;
    readonly type_: Type;
    readonly variables: ReadOnlyCollection_1<ParameterExpression>;
    update(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
}


export type BlockExpression = BlockExpression$instance;

export class CatchBlock$instance {
    readonly body: Expression;
    readonly filter: Expression;
    readonly test: Type;
    readonly variable: ParameterExpression;
    toString(): string;
    update(variable: ParameterExpression, filter: Expression, body: Expression): CatchBlock;
}


export type CatchBlock = CatchBlock$instance;

export class ConditionalExpression$instance extends Expression$instance {
    readonly ifFalse: Expression;
    readonly ifTrue: Expression;
    readonly nodeType: ExpressionType;
    readonly test: Expression;
    readonly type_: Type;
    update(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
}


export type ConditionalExpression = ConditionalExpression$instance;

export class ConstantExpression$instance extends Expression$instance {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly value: unknown;
}


export type ConstantExpression = ConstantExpression$instance;

export class DebugInfoExpression$instance extends Expression$instance {
    readonly document: SymbolDocumentInfo;
    readonly endColumn: int;
    readonly endLine: int;
    readonly isClear: boolean;
    readonly nodeType: ExpressionType;
    readonly startColumn: int;
    readonly startLine: int;
    readonly type_: Type;
}


export type DebugInfoExpression = DebugInfoExpression$instance;

export class DefaultExpression$instance extends Expression$instance {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
}


export type DefaultExpression = DefaultExpression$instance;

export class DynamicExpression$instance extends Expression$instance {
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly binder: CallSiteBinder;
    readonly canReduce: boolean;
    readonly delegateType: Type;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(arguments: IEnumerable_1<Expression>): DynamicExpression;
    static dynamic2(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static dynamic2(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static dynamic2(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static dynamic2(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    static dynamic2(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    static dynamic2(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
}


export interface __DynamicExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
    As_IDynamicExpression(): IDynamicExpression$instance;
}

export interface DynamicExpression$instance extends IDynamicExpression$instance {}

export type DynamicExpression = DynamicExpression$instance & __DynamicExpression$views;


export class DynamicExpressionVisitor$instance extends ExpressionVisitor$instance {
    constructor();
}


export type DynamicExpressionVisitor = DynamicExpressionVisitor$instance;

export class ElementInit$instance {
    readonly addMethod: MethodInfo;
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    getArgument(index: int): Expression;
    toString(): string;
    update(arguments: IEnumerable_1<Expression>): ElementInit;
}


export interface __ElementInit$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface ElementInit$instance extends IArgumentProvider$instance {}

export type ElementInit = ElementInit$instance & __ElementInit$views;


export abstract class Expression$instance {
    readonly canReduce: boolean;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    reduceAndCheck(): Expression;
    reduceExtensions(): Expression;
    toString(): string;
    static add2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static add2(left: Expression, right: Expression): BinaryExpression;
    static addAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static addAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static addAssign3(left: Expression, right: Expression): BinaryExpression;
    static addAssignChecked3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static addAssignChecked3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static addAssignChecked3(left: Expression, right: Expression): BinaryExpression;
    static addChecked2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static addChecked2(left: Expression, right: Expression): BinaryExpression;
    static and2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static and2(left: Expression, right: Expression): BinaryExpression;
    static andAlso2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static andAlso2(left: Expression, right: Expression): BinaryExpression;
    static andAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static andAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static andAssign3(left: Expression, right: Expression): BinaryExpression;
    static arrayAccess2(array: Expression, indexes: IEnumerable_1<Expression>): IndexExpression;
    static arrayAccess2(array: Expression, indexes: Expression[]): IndexExpression;
    static arrayIndex3(array: Expression, indexes: IEnumerable_1<Expression>): MethodCallExpression;
    static arrayIndex3(array: Expression, index: Expression): BinaryExpression;
    static arrayIndex3(array: Expression, indexes: Expression[]): MethodCallExpression;
    static arrayLength(array: Expression): UnaryExpression;
    static assign(left: Expression, right: Expression): BinaryExpression;
    static bind(member: MemberInfo, expression: Expression): MemberAssignment;
    static bind(propertyAccessor: MethodInfo, expression: Expression): MemberAssignment;
    static block6(expressions: IEnumerable_1<Expression>): BlockExpression;
    static block6(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    static block6(variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    static block6(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): BlockExpression;
    static block6(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): BlockExpression;
    static block6(arg0: Expression, arg1: Expression, arg2: Expression): BlockExpression;
    static block6(arg0: Expression, arg1: Expression): BlockExpression;
    static block6(expressions: Expression[]): BlockExpression;
    static block6(type_: Type, expressions: IEnumerable_1<Expression>): BlockExpression;
    static block6(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    static block6(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    static block6(type_: Type, expressions: Expression[]): BlockExpression;
    static break_4(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static break_4(target: LabelTarget, value: Expression): GotoExpression;
    static break_4(target: LabelTarget, type_: Type): GotoExpression;
    static break_4(target: LabelTarget): GotoExpression;
    static call14(instance: Expression, method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    static call14(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    static call14(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    static call14(instance: Expression, method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    static call14(instance: Expression, method: MethodInfo): MethodCallExpression;
    static call14(instance: Expression, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    static call14(method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    static call14(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): MethodCallExpression;
    static call14(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): MethodCallExpression;
    static call14(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    static call14(method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    static call14(method: MethodInfo, arg0: Expression): MethodCallExpression;
    static call14(method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    static call14(type_: Type, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    static catch_4(variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    static catch_4(variable: ParameterExpression, body: Expression): CatchBlock;
    static catch_4(type_: Type, body: Expression, filter: Expression): CatchBlock;
    static catch_4(type_: Type, body: Expression): CatchBlock;
    static clearDebugInfo(document: SymbolDocumentInfo): DebugInfoExpression;
    static coalesce2(left: Expression, right: Expression, conversion: LambdaExpression): BinaryExpression;
    static coalesce2(left: Expression, right: Expression): BinaryExpression;
    static condition2(test: Expression, ifTrue: Expression, ifFalse: Expression, type_: Type): ConditionalExpression;
    static condition2(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    static constant2(value: unknown, type_: Type): ConstantExpression;
    static constant2(value: unknown): ConstantExpression;
    static continue_2(target: LabelTarget, type_: Type): GotoExpression;
    static continue_2(target: LabelTarget): GotoExpression;
    static convert2(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static convert2(expression: Expression, type_: Type): UnaryExpression;
    static convertChecked2(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static convertChecked2(expression: Expression, type_: Type): UnaryExpression;
    static debugInfo(document: SymbolDocumentInfo, startLine: int, startColumn: int, endLine: int, endColumn: int): DebugInfoExpression;
    static decrement2(expression: Expression, method: MethodInfo): UnaryExpression;
    static decrement2(expression: Expression): UnaryExpression;
    static default_(type_: Type): DefaultExpression;
    static divide2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static divide2(left: Expression, right: Expression): BinaryExpression;
    static divideAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static divideAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static divideAssign3(left: Expression, right: Expression): BinaryExpression;
    static dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    static dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    static dynamic(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    static elementInit2(addMethod: MethodInfo, arguments: IEnumerable_1<Expression>): ElementInit;
    static elementInit2(addMethod: MethodInfo, arguments: Expression[]): ElementInit;
    static empty(): DefaultExpression;
    static equal2(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static equal2(left: Expression, right: Expression): BinaryExpression;
    static exclusiveOr2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static exclusiveOr2(left: Expression, right: Expression): BinaryExpression;
    static exclusiveOrAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static exclusiveOrAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static exclusiveOrAssign3(left: Expression, right: Expression): BinaryExpression;
    static field(expression: Expression, field: FieldInfo): MemberExpression;
    static field(expression: Expression, fieldName: string): MemberExpression;
    static field(expression: Expression, type_: Type, fieldName: string): MemberExpression;
    static getActionType(typeArgs: Type[]): Type;
    static getDelegateType(typeArgs: Type[]): Type;
    static getFuncType(typeArgs: Type[]): Type;
    static goto4(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static goto4(target: LabelTarget, value: Expression): GotoExpression;
    static goto4(target: LabelTarget, type_: Type): GotoExpression;
    static goto4(target: LabelTarget): GotoExpression;
    static greaterThan2(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static greaterThan2(left: Expression, right: Expression): BinaryExpression;
    static greaterThanOrEqual2(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static greaterThanOrEqual2(left: Expression, right: Expression): BinaryExpression;
    static ifThen(test: Expression, ifTrue: Expression): ConditionalExpression;
    static ifThenElse(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    static increment2(expression: Expression, method: MethodInfo): UnaryExpression;
    static increment2(expression: Expression): UnaryExpression;
    static invoke2(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
    static invoke2(expression: Expression, arguments: Expression[]): InvocationExpression;
    static isFalse2(expression: Expression, method: MethodInfo): UnaryExpression;
    static isFalse2(expression: Expression): UnaryExpression;
    static isTrue2(expression: Expression, method: MethodInfo): UnaryExpression;
    static isTrue2(expression: Expression): UnaryExpression;
    static label3(): LabelTarget;
    static label3(target: LabelTarget, defaultValue: Expression): LabelExpression;
    static label3(target: LabelTarget): LabelExpression;
    static label3(name: string): LabelTarget;
    static label3(type_: Type, name: string): LabelTarget;
    static label3(type_: Type): LabelTarget;
    static lambda4<TDelegate>(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static lambda4(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static lambda4<TDelegate>(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    static lambda4(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    static lambda4<TDelegate>(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static lambda4(body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static lambda4<TDelegate>(body: Expression, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    static lambda4(body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    static lambda4<TDelegate>(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static lambda4(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static lambda4<TDelegate>(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static lambda4(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static lambda4(delegateType: Type, body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static lambda4(delegateType: Type, body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    static lambda4(delegateType: Type, body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static lambda4(delegateType: Type, body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    static lambda4(delegateType: Type, body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static lambda4(delegateType: Type, body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static leftShift2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static leftShift2(left: Expression, right: Expression): BinaryExpression;
    static leftShiftAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static leftShiftAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static leftShiftAssign3(left: Expression, right: Expression): BinaryExpression;
    static lessThan2(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static lessThan2(left: Expression, right: Expression): BinaryExpression;
    static lessThanOrEqual2(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static lessThanOrEqual2(left: Expression, right: Expression): BinaryExpression;
    static listBind2(member: MemberInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    static listBind2(member: MemberInfo, initializers: ElementInit[]): MemberListBinding;
    static listBind2(propertyAccessor: MethodInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    static listBind2(propertyAccessor: MethodInfo, initializers: ElementInit[]): MemberListBinding;
    static listInit6(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
    static listInit6(newExpression: NewExpression, initializers: IEnumerable_1<Expression>): ListInitExpression;
    static listInit6(newExpression: NewExpression, initializers: ElementInit[]): ListInitExpression;
    static listInit6(newExpression: NewExpression, initializers: Expression[]): ListInitExpression;
    static listInit6(newExpression: NewExpression, addMethod: MethodInfo, initializers: IEnumerable_1<Expression>): ListInitExpression;
    static listInit6(newExpression: NewExpression, addMethod: MethodInfo, initializers: Expression[]): ListInitExpression;
    static loop3(body: Expression, break_: LabelTarget, continue_: LabelTarget): LoopExpression;
    static loop3(body: Expression, break_: LabelTarget): LoopExpression;
    static loop3(body: Expression): LoopExpression;
    static makeBinary3(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static makeBinary3(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static makeBinary3(binaryType: ExpressionType, left: Expression, right: Expression): BinaryExpression;
    static makeCatchBlock(type_: Type, variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    static makeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
    static makeGoto(kind: GotoExpressionKind, target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static makeIndex(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    static makeMemberAccess(expression: Expression, member: MemberInfo): MemberExpression;
    static makeTry(type_: Type, body: Expression, finally_: Expression, fault: Expression, handlers: IEnumerable_1<CatchBlock>): TryExpression;
    static makeUnary2(unaryType: ExpressionType, operand: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static makeUnary2(unaryType: ExpressionType, operand: Expression, type_: Type): UnaryExpression;
    static memberBind2(member: MemberInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    static memberBind2(member: MemberInfo, bindings: MemberBinding[]): MemberMemberBinding;
    static memberBind2(propertyAccessor: MethodInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    static memberBind2(propertyAccessor: MethodInfo, bindings: MemberBinding[]): MemberMemberBinding;
    static memberInit2(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
    static memberInit2(newExpression: NewExpression, bindings: MemberBinding[]): MemberInitExpression;
    static modulo2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static modulo2(left: Expression, right: Expression): BinaryExpression;
    static moduloAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static moduloAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static moduloAssign3(left: Expression, right: Expression): BinaryExpression;
    static multiply2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static multiply2(left: Expression, right: Expression): BinaryExpression;
    static multiplyAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static multiplyAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static multiplyAssign3(left: Expression, right: Expression): BinaryExpression;
    static multiplyAssignChecked3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static multiplyAssignChecked3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static multiplyAssignChecked3(left: Expression, right: Expression): BinaryExpression;
    static multiplyChecked2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static multiplyChecked2(left: Expression, right: Expression): BinaryExpression;
    static negate2(expression: Expression, method: MethodInfo): UnaryExpression;
    static negate2(expression: Expression): UnaryExpression;
    static negateChecked2(expression: Expression, method: MethodInfo): UnaryExpression;
    static negateChecked2(expression: Expression): UnaryExpression;
    static new_4(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: IEnumerable_1<MemberInfo>): NewExpression;
    static new_4(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: MemberInfo[]): NewExpression;
    static new_4(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>): NewExpression;
    static new_4(constructor_: ConstructorInfo, arguments: Expression[]): NewExpression;
    static new_4(constructor_: ConstructorInfo): NewExpression;
    static new_4(type_: Type): NewExpression;
    static newArrayBounds2(type_: Type, bounds: IEnumerable_1<Expression>): NewArrayExpression;
    static newArrayBounds2(type_: Type, bounds: Expression[]): NewArrayExpression;
    static newArrayInit2(type_: Type, initializers: IEnumerable_1<Expression>): NewArrayExpression;
    static newArrayInit2(type_: Type, initializers: Expression[]): NewArrayExpression;
    static not2(expression: Expression, method: MethodInfo): UnaryExpression;
    static not2(expression: Expression): UnaryExpression;
    static notEqual2(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static notEqual2(left: Expression, right: Expression): BinaryExpression;
    static onesComplement2(expression: Expression, method: MethodInfo): UnaryExpression;
    static onesComplement2(expression: Expression): UnaryExpression;
    static or2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static or2(left: Expression, right: Expression): BinaryExpression;
    static orAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static orAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static orAssign3(left: Expression, right: Expression): BinaryExpression;
    static orElse2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static orElse2(left: Expression, right: Expression): BinaryExpression;
    static parameter2(type_: Type, name: string): ParameterExpression;
    static parameter2(type_: Type): ParameterExpression;
    static postDecrementAssign2(expression: Expression, method: MethodInfo): UnaryExpression;
    static postDecrementAssign2(expression: Expression): UnaryExpression;
    static postIncrementAssign2(expression: Expression, method: MethodInfo): UnaryExpression;
    static postIncrementAssign2(expression: Expression): UnaryExpression;
    static power2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static power2(left: Expression, right: Expression): BinaryExpression;
    static powerAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static powerAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static powerAssign3(left: Expression, right: Expression): BinaryExpression;
    static preDecrementAssign2(expression: Expression, method: MethodInfo): UnaryExpression;
    static preDecrementAssign2(expression: Expression): UnaryExpression;
    static preIncrementAssign2(expression: Expression, method: MethodInfo): UnaryExpression;
    static preIncrementAssign2(expression: Expression): UnaryExpression;
    static property7(expression: Expression, propertyAccessor: MethodInfo): MemberExpression;
    static property7(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    static property7(instance: Expression, indexer: PropertyInfo, arguments: Expression[]): IndexExpression;
    static property7(expression: Expression, property: PropertyInfo): MemberExpression;
    static property7(instance: Expression, propertyName: string, arguments: Expression[]): IndexExpression;
    static property7(expression: Expression, propertyName: string): MemberExpression;
    static property7(expression: Expression, type_: Type, propertyName: string): MemberExpression;
    static propertyOrField(expression: Expression, propertyOrFieldName: string): MemberExpression;
    static quote(expression: Expression): UnaryExpression;
    static referenceEqual(left: Expression, right: Expression): BinaryExpression;
    static referenceNotEqual(left: Expression, right: Expression): BinaryExpression;
    static rethrow(): UnaryExpression;
    static rethrow(type_: Type): UnaryExpression;
    static return_4(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static return_4(target: LabelTarget, value: Expression): GotoExpression;
    static return_4(target: LabelTarget, type_: Type): GotoExpression;
    static return_4(target: LabelTarget): GotoExpression;
    static rightShift2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static rightShift2(left: Expression, right: Expression): BinaryExpression;
    static rightShiftAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static rightShiftAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static rightShiftAssign3(left: Expression, right: Expression): BinaryExpression;
    static runtimeVariables2(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
    static runtimeVariables2(variables: ParameterExpression[]): RuntimeVariablesExpression;
    static subtract2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static subtract2(left: Expression, right: Expression): BinaryExpression;
    static subtractAssign3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static subtractAssign3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static subtractAssign3(left: Expression, right: Expression): BinaryExpression;
    static subtractAssignChecked3(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static subtractAssignChecked3(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static subtractAssignChecked3(left: Expression, right: Expression): BinaryExpression;
    static subtractChecked2(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static subtractChecked2(left: Expression, right: Expression): BinaryExpression;
    static switch_2(switchValue: Expression, defaultBody: Expression, cases: SwitchCase[]): SwitchExpression;
    static switch_2(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    static switch_2(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    static switch_2(switchValue: Expression, cases: SwitchCase[]): SwitchExpression;
    static switch_2(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    static switch_2(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    static switchCase2(body: Expression, testValues: IEnumerable_1<Expression>): SwitchCase;
    static switchCase2(body: Expression, testValues: Expression[]): SwitchCase;
    static symbolDocument4(fileName: string, language: Guid, languageVendor: Guid, documentType: Guid): SymbolDocumentInfo;
    static symbolDocument4(fileName: string, language: Guid, languageVendor: Guid): SymbolDocumentInfo;
    static symbolDocument4(fileName: string, language: Guid): SymbolDocumentInfo;
    static symbolDocument4(fileName: string): SymbolDocumentInfo;
    static throw_2(value: Expression, type_: Type): UnaryExpression;
    static throw_2(value: Expression): UnaryExpression;
    static tryCatch(body: Expression, handlers: CatchBlock[]): TryExpression;
    static tryCatchFinally(body: Expression, finally_: Expression, handlers: CatchBlock[]): TryExpression;
    static tryFault(body: Expression, fault: Expression): TryExpression;
    static tryFinally(body: Expression, finally_: Expression): TryExpression;
    static tryGetActionType(typeArgs: Type[], actionType: { value: ref<Type> }): boolean;
    static tryGetFuncType(typeArgs: Type[], funcType: { value: ref<Type> }): boolean;
    static typeAs(expression: Expression, type_: Type): UnaryExpression;
    static typeEqual(expression: Expression, type_: Type): TypeBinaryExpression;
    static typeIs(expression: Expression, type_: Type): TypeBinaryExpression;
    static unaryPlus2(expression: Expression, method: MethodInfo): UnaryExpression;
    static unaryPlus2(expression: Expression): UnaryExpression;
    static unbox(expression: Expression, type_: Type): UnaryExpression;
    static variable2(type_: Type, name: string): ParameterExpression;
    static variable2(type_: Type): ParameterExpression;
}


export type Expression = Expression$instance;

export class Expression_1$instance<TDelegate> extends LambdaExpression$instance {
    compile(): TDelegate;
    compile(preferInterpretation: boolean): TDelegate;
    compile(debugInfoGenerator: DebugInfoGenerator): TDelegate;
    compile(): Function;
    compile(preferInterpretation: boolean): Function;
    compile(debugInfoGenerator: DebugInfoGenerator): Function;
    update(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
}


export type Expression_1<TDelegate> = Expression_1$instance<TDelegate>;

export abstract class ExpressionVisitor$instance {
    visit(node: Expression): Expression;
    visit(nodes: ReadOnlyCollection_1<Expression>): ReadOnlyCollection_1<Expression>;
    visitAndConvert<T extends Expression>(node: T, callerName: string): T;
    visitAndConvert<T extends Expression>(nodes: ReadOnlyCollection_1<T>, callerName: string): ReadOnlyCollection_1<T>;
    static visit<T>(nodes: ReadOnlyCollection_1<T>, elementVisitor: Func_2<T, T>): ReadOnlyCollection_1<T>;
}


export type ExpressionVisitor = ExpressionVisitor$instance;

export class GotoExpression$instance extends Expression$instance {
    readonly kind: GotoExpressionKind;
    readonly nodeType: ExpressionType;
    readonly target: LabelTarget;
    readonly type_: Type;
    readonly value: Expression;
    update(target: LabelTarget, value: Expression): GotoExpression;
}


export type GotoExpression = GotoExpression$instance;

export class IndexExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly indexer: PropertyInfo;
    readonly nodeType: ExpressionType;
    readonly object_: Expression;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(object_: Expression, arguments: IEnumerable_1<Expression>): IndexExpression;
}


export interface __IndexExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface IndexExpression$instance extends IArgumentProvider$instance {}

export type IndexExpression = IndexExpression$instance & __IndexExpression$views;


export class InvocationExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly expression: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
}


export interface __InvocationExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface InvocationExpression$instance extends IArgumentProvider$instance {}

export type InvocationExpression = InvocationExpression$instance & __InvocationExpression$views;


export class LabelExpression$instance extends Expression$instance {
    readonly defaultValue: Expression;
    readonly nodeType: ExpressionType;
    readonly target: LabelTarget;
    readonly type_: Type;
    update(target: LabelTarget, defaultValue: Expression): LabelExpression;
}


export type LabelExpression = LabelExpression$instance;

export class LabelTarget$instance {
    readonly name: string;
    readonly type_: Type;
    toString(): string;
}


export type LabelTarget = LabelTarget$instance;

export abstract class LambdaExpression$instance extends Expression$instance {
    readonly body: Expression;
    readonly name: string;
    readonly nodeType: ExpressionType;
    readonly parameters: ReadOnlyCollection_1<ParameterExpression>;
    readonly returnType: Type;
    readonly tailCall: boolean;
    readonly type_: Type;
    compile(): Function;
    compile(preferInterpretation: boolean): Function;
    compile(debugInfoGenerator: DebugInfoGenerator): Function;
    static readonly canCompileToIL: boolean;
    static readonly canInterpret: boolean;
}


export type LambdaExpression = LambdaExpression$instance;

export class ListInitExpression$instance extends Expression$instance {
    readonly canReduce: boolean;
    readonly initializers: ReadOnlyCollection_1<ElementInit>;
    readonly newExpression: NewExpression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
}


export type ListInitExpression = ListInitExpression$instance;

export class LoopExpression$instance extends Expression$instance {
    readonly body: Expression;
    readonly breakLabel: LabelTarget;
    readonly continueLabel: LabelTarget;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    update(breakLabel: LabelTarget, continueLabel: LabelTarget, body: Expression): LoopExpression;
}


export type LoopExpression = LoopExpression$instance;

export class MemberAssignment$instance extends MemberBinding$instance {
    readonly expression: Expression;
    update(expression: Expression): MemberAssignment;
}


export type MemberAssignment = MemberAssignment$instance;

export abstract class MemberBinding$instance {
    readonly bindingType: MemberBindingType;
    readonly member: MemberInfo;
    toString(): string;
}


export type MemberBinding = MemberBinding$instance;

export class MemberExpression$instance extends Expression$instance {
    readonly expression: Expression;
    readonly member: MemberInfo;
    readonly nodeType: ExpressionType;
    update(expression: Expression): MemberExpression;
}


export type MemberExpression = MemberExpression$instance;

export class MemberInitExpression$instance extends Expression$instance {
    readonly bindings: ReadOnlyCollection_1<MemberBinding>;
    readonly canReduce: boolean;
    readonly newExpression: NewExpression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
}


export type MemberInitExpression = MemberInitExpression$instance;

export class MemberListBinding$instance extends MemberBinding$instance {
    readonly initializers: ReadOnlyCollection_1<ElementInit>;
    update(initializers: IEnumerable_1<ElementInit>): MemberListBinding;
}


export type MemberListBinding = MemberListBinding$instance;

export class MemberMemberBinding$instance extends MemberBinding$instance {
    readonly bindings: ReadOnlyCollection_1<MemberBinding>;
    update(bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
}


export type MemberMemberBinding = MemberMemberBinding$instance;

export class MethodCallExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly method: MethodInfo;
    readonly nodeType: ExpressionType;
    readonly object_: Expression;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(object_: Expression, arguments: IEnumerable_1<Expression>): MethodCallExpression;
}


export interface __MethodCallExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface MethodCallExpression$instance extends IArgumentProvider$instance {}

export type MethodCallExpression = MethodCallExpression$instance & __MethodCallExpression$views;


export class NewArrayExpression$instance extends Expression$instance {
    readonly expressions: ReadOnlyCollection_1<Expression>;
    readonly type_: Type;
    update(expressions: IEnumerable_1<Expression>): NewArrayExpression;
}


export type NewArrayExpression = NewArrayExpression$instance;

export class NewExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly constructor_: ConstructorInfo;
    readonly members: ReadOnlyCollection_1<MemberInfo>;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(arguments: IEnumerable_1<Expression>): NewExpression;
}


export interface __NewExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface NewExpression$instance extends IArgumentProvider$instance {}

export type NewExpression = NewExpression$instance & __NewExpression$views;


export class ParameterExpression$instance extends Expression$instance {
    readonly isByRef: boolean;
    readonly name: string;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
}


export type ParameterExpression = ParameterExpression$instance;

export class RuntimeVariablesExpression$instance extends Expression$instance {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly variables: ReadOnlyCollection_1<ParameterExpression>;
    update(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
}


export type RuntimeVariablesExpression = RuntimeVariablesExpression$instance;

export class SwitchCase$instance {
    readonly body: Expression;
    readonly testValues: ReadOnlyCollection_1<Expression>;
    toString(): string;
    update(testValues: IEnumerable_1<Expression>, body: Expression): SwitchCase;
}


export type SwitchCase = SwitchCase$instance;

export class SwitchExpression$instance extends Expression$instance {
    readonly cases: ReadOnlyCollection_1<SwitchCase>;
    readonly comparison: MethodInfo;
    readonly defaultBody: Expression;
    readonly nodeType: ExpressionType;
    readonly switchValue: Expression;
    readonly type_: Type;
    update(switchValue: Expression, cases: IEnumerable_1<SwitchCase>, defaultBody: Expression): SwitchExpression;
}


export type SwitchExpression = SwitchExpression$instance;

export class SymbolDocumentInfo$instance {
    readonly documentType: Guid;
    readonly fileName: string;
    readonly language: Guid;
    readonly languageVendor: Guid;
}


export type SymbolDocumentInfo = SymbolDocumentInfo$instance;

export class TryExpression$instance extends Expression$instance {
    readonly body: Expression;
    readonly fault: Expression;
    readonly finally_: Expression;
    readonly handlers: ReadOnlyCollection_1<CatchBlock>;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    update(body: Expression, handlers: IEnumerable_1<CatchBlock>, finally_: Expression, fault: Expression): TryExpression;
}


export type TryExpression = TryExpression$instance;

export class TypeBinaryExpression$instance extends Expression$instance {
    readonly expression: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly typeOperand: Type;
    update(expression: Expression): TypeBinaryExpression;
}


export type TypeBinaryExpression = TypeBinaryExpression$instance;

export class UnaryExpression$instance extends Expression$instance {
    readonly canReduce: boolean;
    readonly isLifted: boolean;
    readonly isLiftedToNull: boolean;
    readonly method: MethodInfo;
    readonly nodeType: ExpressionType;
    readonly operand: Expression;
    readonly type_: Type;
    reduce(): Expression;
    update(operand: Expression): UnaryExpression;
}


export type UnaryExpression = UnaryExpression$instance;

