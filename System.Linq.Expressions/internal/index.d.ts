// Generated by tsbindgen - Architecture
// Namespace: System.Linq.Expressions
// Assembly: System.Linq.Expressions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { ConstructorInfo, FieldInfo, MemberInfo, MethodInfo, PropertyInfo } from "../../System.Reflection/internal/index.js";
import type { CallSiteBinder, DebugInfoGenerator } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Delegate, Enum, Func_2, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ExpressionType {
    add = 0,
    addChecked = 1,
    and = 2,
    andAlso = 3,
    arrayLength = 4,
    arrayIndex = 5,
    call = 6,
    coalesce = 7,
    conditional = 8,
    constant = 9,
    convert = 10,
    convertChecked = 11,
    divide = 12,
    equal = 13,
    exclusiveOr = 14,
    greaterThan = 15,
    greaterThanOrEqual = 16,
    invoke = 17,
    lambda = 18,
    leftShift = 19,
    lessThan = 20,
    lessThanOrEqual = 21,
    listInit = 22,
    memberAccess = 23,
    memberInit = 24,
    modulo = 25,
    multiply = 26,
    multiplyChecked = 27,
    negate = 28,
    unaryPlus = 29,
    negateChecked = 30,
    new_ = 31,
    newArrayInit = 32,
    newArrayBounds = 33,
    not = 34,
    notEqual = 35,
    or = 36,
    orElse = 37,
    parameter = 38,
    power = 39,
    quote = 40,
    rightShift = 41,
    subtract = 42,
    subtractChecked = 43,
    typeAs = 44,
    typeIs = 45,
    assign = 46,
    block = 47,
    debugInfo = 48,
    decrement = 49,
    dynamic = 50,
    default_ = 51,
    extension = 52,
    goto = 53,
    increment = 54,
    index = 55,
    label = 56,
    runtimeVariables = 57,
    loop = 58,
    switch_ = 59,
    throw_ = 60,
    try_ = 61,
    unbox = 62,
    addAssign = 63,
    andAssign = 64,
    divideAssign = 65,
    exclusiveOrAssign = 66,
    leftShiftAssign = 67,
    moduloAssign = 68,
    multiplyAssign = 69,
    orAssign = 70,
    powerAssign = 71,
    rightShiftAssign = 72,
    subtractAssign = 73,
    addAssignChecked = 74,
    multiplyAssignChecked = 75,
    subtractAssignChecked = 76,
    preIncrementAssign = 77,
    preDecrementAssign = 78,
    postIncrementAssign = 79,
    postDecrementAssign = 80,
    typeEqual = 81,
    onesComplement = 82,
    isTrue = 83,
    isFalse = 84
}


export enum GotoExpressionKind {
    goto = 0,
    return_ = 1,
    break_ = 2,
    continue_ = 3
}


export enum MemberBindingType {
    assignment = 0,
    memberBinding = 1,
    listBinding = 2
}


export interface IArgumentProvider$instance {
    readonly ArgumentCount: int;
    GetArgument(index: int): Expression;
}


export type IArgumentProvider = IArgumentProvider$instance;

export interface IDynamicExpression$instance {
    readonly DelegateType: Type;
    readonly ArgumentCount: int;
    CreateCallSite(): any;
    GetArgument(index: int): Expression;
    Rewrite(args: Expression[]): Expression;
}


export type IDynamicExpression = IDynamicExpression$instance;

export class BinaryExpression$instance extends Expression$instance {
    readonly canReduce: boolean;
    readonly conversion: LambdaExpression;
    readonly isLifted: boolean;
    readonly isLiftedToNull: boolean;
    readonly left: Expression;
    readonly method: MethodInfo;
    readonly right: Expression;
    reduce(): Expression;
    update(left: Expression, conversion: LambdaExpression, right: Expression): BinaryExpression;
}


export type BinaryExpression = BinaryExpression$instance;

export class BlockExpression$instance extends Expression$instance {
    readonly expressions: ReadOnlyCollection_1<Expression>;
    readonly nodeType: ExpressionType;
    readonly result: Expression;
    readonly type_: Type;
    readonly variables: ReadOnlyCollection_1<ParameterExpression>;
    update(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
}


export type BlockExpression = BlockExpression$instance;

export class CatchBlock$instance {
    readonly body: Expression;
    readonly filter: Expression;
    readonly test: Type;
    readonly variable: ParameterExpression;
    toString(): string;
    update(variable: ParameterExpression, filter: Expression, body: Expression): CatchBlock;
}


export type CatchBlock = CatchBlock$instance;

export class ConditionalExpression$instance extends Expression$instance {
    readonly ifFalse: Expression;
    readonly ifTrue: Expression;
    readonly nodeType: ExpressionType;
    readonly test: Expression;
    readonly type_: Type;
    update(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
}


export type ConditionalExpression = ConditionalExpression$instance;

export class ConstantExpression$instance extends Expression$instance {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly value: any;
}


export type ConstantExpression = ConstantExpression$instance;

export class DebugInfoExpression$instance extends Expression$instance {
    readonly document: SymbolDocumentInfo;
    readonly endColumn: int;
    readonly endLine: int;
    readonly isClear: boolean;
    readonly nodeType: ExpressionType;
    readonly startColumn: int;
    readonly startLine: int;
    readonly type_: Type;
}


export type DebugInfoExpression = DebugInfoExpression$instance;

export class DefaultExpression$instance extends Expression$instance {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
}


export type DefaultExpression = DefaultExpression$instance;

export class DynamicExpression$instance extends Expression$instance {
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly binder: CallSiteBinder;
    readonly canReduce: boolean;
    readonly delegateType: Type;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(arguments: IEnumerable_1<Expression>): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
}


export interface __DynamicExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
    readonly As_IDynamicExpression: IDynamicExpression$instance;
}

export type DynamicExpression = DynamicExpression$instance & __DynamicExpression$views;


export class DynamicExpressionVisitor$instance extends ExpressionVisitor$instance {
    constructor();
}


export type DynamicExpressionVisitor = DynamicExpressionVisitor$instance;

export class ElementInit$instance {
    readonly addMethod: MethodInfo;
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    getArgument(index: int): Expression;
    toString(): string;
    update(arguments: IEnumerable_1<Expression>): ElementInit;
}


export interface __ElementInit$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type ElementInit = ElementInit$instance & __ElementInit$views;


export abstract class Expression$instance {
    readonly canReduce: boolean;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    reduceAndCheck(): Expression;
    reduceExtensions(): Expression;
    toString(): string;
    static Add(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Add(left: Expression, right: Expression): BinaryExpression;
    static AddAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static AddAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AddAssign(left: Expression, right: Expression): BinaryExpression;
    static AddAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static AddAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AddAssignChecked(left: Expression, right: Expression): BinaryExpression;
    static AddChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AddChecked(left: Expression, right: Expression): BinaryExpression;
    static And(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static And(left: Expression, right: Expression): BinaryExpression;
    static AndAlso(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AndAlso(left: Expression, right: Expression): BinaryExpression;
    static AndAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static AndAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static AndAssign(left: Expression, right: Expression): BinaryExpression;
    static ArrayAccess(array: Expression, indexes: IEnumerable_1<Expression>): IndexExpression;
    static ArrayAccess(array: Expression, indexes: Expression[]): IndexExpression;
    static ArrayIndex(array: Expression, indexes: IEnumerable_1<Expression>): MethodCallExpression;
    static ArrayIndex(array: Expression, index: Expression): BinaryExpression;
    static ArrayIndex(array: Expression, indexes: Expression[]): MethodCallExpression;
    static ArrayLength(array: Expression): UnaryExpression;
    static Assign(left: Expression, right: Expression): BinaryExpression;
    static Bind(member: MemberInfo, expression: Expression): MemberAssignment;
    static Bind(propertyAccessor: MethodInfo, expression: Expression): MemberAssignment;
    static Block(expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    static Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): BlockExpression;
    static Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): BlockExpression;
    static Block(arg0: Expression, arg1: Expression, arg2: Expression): BlockExpression;
    static Block(arg0: Expression, arg1: Expression): BlockExpression;
    static Block(expressions: Expression[]): BlockExpression;
    static Block(type_: Type, expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: IEnumerable_1<Expression>): BlockExpression;
    static Block(type_: Type, variables: IEnumerable_1<ParameterExpression>, expressions: Expression[]): BlockExpression;
    static Block(type_: Type, expressions: Expression[]): BlockExpression;
    static Break(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static Break(target: LabelTarget, value: Expression): GotoExpression;
    static Break(target: LabelTarget, type_: Type): GotoExpression;
    static Break(target: LabelTarget): GotoExpression;
    static Call(instance: Expression, method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    static Call(instance: Expression, method: MethodInfo): MethodCallExpression;
    static Call(instance: Expression, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    static Call(method: MethodInfo, arguments: IEnumerable_1<Expression>): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arg0: Expression): MethodCallExpression;
    static Call(method: MethodInfo, arguments: Expression[]): MethodCallExpression;
    static Call(type_: Type, methodName: string, typeArguments: Type[], arguments: Expression[]): MethodCallExpression;
    static Catch(variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    static Catch(variable: ParameterExpression, body: Expression): CatchBlock;
    static Catch(type_: Type, body: Expression, filter: Expression): CatchBlock;
    static Catch(type_: Type, body: Expression): CatchBlock;
    static ClearDebugInfo(document: SymbolDocumentInfo): DebugInfoExpression;
    static Coalesce(left: Expression, right: Expression, conversion: LambdaExpression): BinaryExpression;
    static Coalesce(left: Expression, right: Expression): BinaryExpression;
    static Condition(test: Expression, ifTrue: Expression, ifFalse: Expression, type_: Type): ConditionalExpression;
    static Condition(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    static Constant(value: any, type_: Type): ConstantExpression;
    static Constant(value: any): ConstantExpression;
    static Continue(target: LabelTarget, type_: Type): GotoExpression;
    static Continue(target: LabelTarget): GotoExpression;
    static Convert(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static Convert(expression: Expression, type_: Type): UnaryExpression;
    static ConvertChecked(expression: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static ConvertChecked(expression: Expression, type_: Type): UnaryExpression;
    static DebugInfo(document: SymbolDocumentInfo, startLine: int, startColumn: int, endLine: int, endColumn: int): DebugInfoExpression;
    static Decrement(expression: Expression, method: MethodInfo): UnaryExpression;
    static Decrement(expression: Expression): UnaryExpression;
    static Default(type_: Type): DefaultExpression;
    static Divide(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Divide(left: Expression, right: Expression): BinaryExpression;
    static DivideAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static DivideAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static DivideAssign(left: Expression, right: Expression): BinaryExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    static Dynamic(binder: CallSiteBinder, returnType: Type, arguments: Expression[]): DynamicExpression;
    static ElementInit(addMethod: MethodInfo, arguments: IEnumerable_1<Expression>): ElementInit;
    static ElementInit(addMethod: MethodInfo, arguments: Expression[]): ElementInit;
    static Empty(): DefaultExpression;
    static Equal(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static Equal(left: Expression, right: Expression): BinaryExpression;
    static ExclusiveOr(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static ExclusiveOr(left: Expression, right: Expression): BinaryExpression;
    static ExclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static ExclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static ExclusiveOrAssign(left: Expression, right: Expression): BinaryExpression;
    static Field(expression: Expression, field: FieldInfo): MemberExpression;
    static Field(expression: Expression, fieldName: string): MemberExpression;
    static Field(expression: Expression, type_: Type, fieldName: string): MemberExpression;
    static GetActionType(typeArgs: Type[]): Type;
    static GetDelegateType(typeArgs: Type[]): Type;
    static GetFuncType(typeArgs: Type[]): Type;
    static Goto(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static Goto(target: LabelTarget, value: Expression): GotoExpression;
    static Goto(target: LabelTarget, type_: Type): GotoExpression;
    static Goto(target: LabelTarget): GotoExpression;
    static GreaterThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static GreaterThan(left: Expression, right: Expression): BinaryExpression;
    static GreaterThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static GreaterThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    static IfThen(test: Expression, ifTrue: Expression): ConditionalExpression;
    static IfThenElse(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    static Increment(expression: Expression, method: MethodInfo): UnaryExpression;
    static Increment(expression: Expression): UnaryExpression;
    static Invoke(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
    static Invoke(expression: Expression, arguments: Expression[]): InvocationExpression;
    static IsFalse(expression: Expression, method: MethodInfo): UnaryExpression;
    static IsFalse(expression: Expression): UnaryExpression;
    static IsTrue(expression: Expression, method: MethodInfo): UnaryExpression;
    static IsTrue(expression: Expression): UnaryExpression;
    static Label(): LabelTarget;
    static Label(target: LabelTarget, defaultValue: Expression): LabelExpression;
    static Label(target: LabelTarget): LabelExpression;
    static Label(name: string): LabelTarget;
    static Label(type_: Type, name: string): LabelTarget;
    static Label(type_: Type): LabelTarget;
    static Lambda<TDelegate>(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    static Lambda(body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, parameters: ParameterExpression[]): Expression_1<TDelegate>;
    static Lambda(body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda<TDelegate>(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
    static Lambda(body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, tailCall: boolean, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, parameters: ParameterExpression[]): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, name: string, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static Lambda(delegateType: Type, body: Expression, name: string, parameters: IEnumerable_1<ParameterExpression>): LambdaExpression;
    static LeftShift(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static LeftShift(left: Expression, right: Expression): BinaryExpression;
    static LeftShiftAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static LeftShiftAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static LeftShiftAssign(left: Expression, right: Expression): BinaryExpression;
    static LessThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static LessThan(left: Expression, right: Expression): BinaryExpression;
    static LessThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static LessThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    static ListBind(member: MemberInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    static ListBind(member: MemberInfo, initializers: ElementInit[]): MemberListBinding;
    static ListBind(propertyAccessor: MethodInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    static ListBind(propertyAccessor: MethodInfo, initializers: ElementInit[]): MemberListBinding;
    static ListInit(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
    static ListInit(newExpression: NewExpression, initializers: IEnumerable_1<Expression>): ListInitExpression;
    static ListInit(newExpression: NewExpression, initializers: ElementInit[]): ListInitExpression;
    static ListInit(newExpression: NewExpression, initializers: Expression[]): ListInitExpression;
    static ListInit(newExpression: NewExpression, addMethod: MethodInfo, initializers: IEnumerable_1<Expression>): ListInitExpression;
    static ListInit(newExpression: NewExpression, addMethod: MethodInfo, initializers: Expression[]): ListInitExpression;
    static Loop(body: Expression, break_: LabelTarget, continue_: LabelTarget): LoopExpression;
    static Loop(body: Expression, break_: LabelTarget): LoopExpression;
    static Loop(body: Expression): LoopExpression;
    static MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression): BinaryExpression;
    static MakeCatchBlock(type_: Type, variable: ParameterExpression, body: Expression, filter: Expression): CatchBlock;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression>): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    static MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: Expression[]): DynamicExpression;
    static MakeGoto(kind: GotoExpressionKind, target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static MakeIndex(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    static MakeMemberAccess(expression: Expression, member: MemberInfo): MemberExpression;
    static MakeTry(type_: Type, body: Expression, finally_: Expression, fault: Expression, handlers: IEnumerable_1<CatchBlock>): TryExpression;
    static MakeUnary(unaryType: ExpressionType, operand: Expression, type_: Type, method: MethodInfo): UnaryExpression;
    static MakeUnary(unaryType: ExpressionType, operand: Expression, type_: Type): UnaryExpression;
    static MemberBind(member: MemberInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    static MemberBind(member: MemberInfo, bindings: MemberBinding[]): MemberMemberBinding;
    static MemberBind(propertyAccessor: MethodInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    static MemberBind(propertyAccessor: MethodInfo, bindings: MemberBinding[]): MemberMemberBinding;
    static MemberInit(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
    static MemberInit(newExpression: NewExpression, bindings: MemberBinding[]): MemberInitExpression;
    static Modulo(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Modulo(left: Expression, right: Expression): BinaryExpression;
    static ModuloAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static ModuloAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static ModuloAssign(left: Expression, right: Expression): BinaryExpression;
    static Multiply(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Multiply(left: Expression, right: Expression): BinaryExpression;
    static MultiplyAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static MultiplyAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static MultiplyAssign(left: Expression, right: Expression): BinaryExpression;
    static MultiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static MultiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static MultiplyAssignChecked(left: Expression, right: Expression): BinaryExpression;
    static MultiplyChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static MultiplyChecked(left: Expression, right: Expression): BinaryExpression;
    static Negate(expression: Expression, method: MethodInfo): UnaryExpression;
    static Negate(expression: Expression): UnaryExpression;
    static NegateChecked(expression: Expression, method: MethodInfo): UnaryExpression;
    static NegateChecked(expression: Expression): UnaryExpression;
    static New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: IEnumerable_1<MemberInfo>): NewExpression;
    static New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>, members: MemberInfo[]): NewExpression;
    static New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression>): NewExpression;
    static New(constructor_: ConstructorInfo, arguments: Expression[]): NewExpression;
    static New(constructor_: ConstructorInfo): NewExpression;
    static New(type_: Type): NewExpression;
    static NewArrayBounds(type_: Type, bounds: IEnumerable_1<Expression>): NewArrayExpression;
    static NewArrayBounds(type_: Type, bounds: Expression[]): NewArrayExpression;
    static NewArrayInit(type_: Type, initializers: IEnumerable_1<Expression>): NewArrayExpression;
    static NewArrayInit(type_: Type, initializers: Expression[]): NewArrayExpression;
    static Not(expression: Expression, method: MethodInfo): UnaryExpression;
    static Not(expression: Expression): UnaryExpression;
    static NotEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo): BinaryExpression;
    static NotEqual(left: Expression, right: Expression): BinaryExpression;
    static OnesComplement(expression: Expression, method: MethodInfo): UnaryExpression;
    static OnesComplement(expression: Expression): UnaryExpression;
    static Or(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Or(left: Expression, right: Expression): BinaryExpression;
    static OrAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static OrAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static OrAssign(left: Expression, right: Expression): BinaryExpression;
    static OrElse(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static OrElse(left: Expression, right: Expression): BinaryExpression;
    static Parameter(type_: Type, name: string): ParameterExpression;
    static Parameter(type_: Type): ParameterExpression;
    static PostDecrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PostDecrementAssign(expression: Expression): UnaryExpression;
    static PostIncrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PostIncrementAssign(expression: Expression): UnaryExpression;
    static Power(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Power(left: Expression, right: Expression): BinaryExpression;
    static PowerAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static PowerAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static PowerAssign(left: Expression, right: Expression): BinaryExpression;
    static PreDecrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PreDecrementAssign(expression: Expression): UnaryExpression;
    static PreIncrementAssign(expression: Expression, method: MethodInfo): UnaryExpression;
    static PreIncrementAssign(expression: Expression): UnaryExpression;
    static Property(expression: Expression, propertyAccessor: MethodInfo): MemberExpression;
    static Property(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1<Expression>): IndexExpression;
    static Property(instance: Expression, indexer: PropertyInfo, arguments: Expression[]): IndexExpression;
    static Property(expression: Expression, property: PropertyInfo): MemberExpression;
    static Property(instance: Expression, propertyName: string, arguments: Expression[]): IndexExpression;
    static Property(expression: Expression, propertyName: string): MemberExpression;
    static Property(expression: Expression, type_: Type, propertyName: string): MemberExpression;
    static PropertyOrField(expression: Expression, propertyOrFieldName: string): MemberExpression;
    static Quote(expression: Expression): UnaryExpression;
    static ReferenceEqual(left: Expression, right: Expression): BinaryExpression;
    static ReferenceNotEqual(left: Expression, right: Expression): BinaryExpression;
    static Rethrow(): UnaryExpression;
    static Rethrow(type_: Type): UnaryExpression;
    static Return(target: LabelTarget, value: Expression, type_: Type): GotoExpression;
    static Return(target: LabelTarget, value: Expression): GotoExpression;
    static Return(target: LabelTarget, type_: Type): GotoExpression;
    static Return(target: LabelTarget): GotoExpression;
    static RightShift(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static RightShift(left: Expression, right: Expression): BinaryExpression;
    static RightShiftAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static RightShiftAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static RightShiftAssign(left: Expression, right: Expression): BinaryExpression;
    static RuntimeVariables(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
    static RuntimeVariables(variables: ParameterExpression[]): RuntimeVariablesExpression;
    static Subtract(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static Subtract(left: Expression, right: Expression): BinaryExpression;
    static SubtractAssign(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static SubtractAssign(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static SubtractAssign(left: Expression, right: Expression): BinaryExpression;
    static SubtractAssignChecked(left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression): BinaryExpression;
    static SubtractAssignChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static SubtractAssignChecked(left: Expression, right: Expression): BinaryExpression;
    static SubtractChecked(left: Expression, right: Expression, method: MethodInfo): BinaryExpression;
    static SubtractChecked(left: Expression, right: Expression): BinaryExpression;
    static Switch(switchValue: Expression, defaultBody: Expression, cases: SwitchCase[]): SwitchExpression;
    static Switch(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    static Switch(switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    static Switch(switchValue: Expression, cases: SwitchCase[]): SwitchExpression;
    static Switch(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1<SwitchCase>): SwitchExpression;
    static Switch(type_: Type, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: SwitchCase[]): SwitchExpression;
    static SwitchCase(body: Expression, testValues: IEnumerable_1<Expression>): SwitchCase;
    static SwitchCase(body: Expression, testValues: Expression[]): SwitchCase;
    static SymbolDocument(fileName: string, language: Guid, languageVendor: Guid, documentType: Guid): SymbolDocumentInfo;
    static SymbolDocument(fileName: string, language: Guid, languageVendor: Guid): SymbolDocumentInfo;
    static SymbolDocument(fileName: string, language: Guid): SymbolDocumentInfo;
    static SymbolDocument(fileName: string): SymbolDocumentInfo;
    static Throw(value: Expression, type_: Type): UnaryExpression;
    static Throw(value: Expression): UnaryExpression;
    static TryCatch(body: Expression, handlers: CatchBlock[]): TryExpression;
    static TryCatchFinally(body: Expression, finally_: Expression, handlers: CatchBlock[]): TryExpression;
    static TryFault(body: Expression, fault: Expression): TryExpression;
    static TryFinally(body: Expression, finally_: Expression): TryExpression;
    static TryGetActionType(typeArgs: Type[], actionType: { value: TSByRef<Type> }): boolean;
    static TryGetFuncType(typeArgs: Type[], funcType: { value: TSByRef<Type> }): boolean;
    static TypeAs(expression: Expression, type_: Type): UnaryExpression;
    static TypeEqual(expression: Expression, type_: Type): TypeBinaryExpression;
    static TypeIs(expression: Expression, type_: Type): TypeBinaryExpression;
    static UnaryPlus(expression: Expression, method: MethodInfo): UnaryExpression;
    static UnaryPlus(expression: Expression): UnaryExpression;
    static Unbox(expression: Expression, type_: Type): UnaryExpression;
    static Variable(type_: Type, name: string): ParameterExpression;
    static Variable(type_: Type): ParameterExpression;
}


export type Expression = Expression$instance;

export class Expression_1$instance<TDelegate> extends LambdaExpression$instance {
    compile(): TDelegate;
    compile(preferInterpretation: boolean): TDelegate;
    compile(debugInfoGenerator: DebugInfoGenerator): TDelegate;
    compile(): Function;
    compile(preferInterpretation: boolean): Function;
    compile(debugInfoGenerator: DebugInfoGenerator): Function;
    update(body: Expression, parameters: IEnumerable_1<ParameterExpression>): Expression_1<TDelegate>;
}


export type Expression_1<TDelegate> = Expression_1$instance<TDelegate>;

export abstract class ExpressionVisitor$instance {
    visit(node: Expression): Expression;
    visit(nodes: ReadOnlyCollection_1<Expression>): ReadOnlyCollection_1<Expression>;
    visitAndConvert<T extends Expression>(node: T, callerName: string): T;
    visitAndConvert<T extends Expression>(nodes: ReadOnlyCollection_1<T>, callerName: string): ReadOnlyCollection_1<T>;
    static Visit<T>(nodes: ReadOnlyCollection_1<T>, elementVisitor: Func_2<T, T>): ReadOnlyCollection_1<T>;
}


export type ExpressionVisitor = ExpressionVisitor$instance;

export class GotoExpression$instance extends Expression$instance {
    readonly kind: GotoExpressionKind;
    readonly nodeType: ExpressionType;
    readonly target: LabelTarget;
    readonly type_: Type;
    readonly value: Expression;
    update(target: LabelTarget, value: Expression): GotoExpression;
}


export type GotoExpression = GotoExpression$instance;

export class IndexExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly indexer: PropertyInfo;
    readonly nodeType: ExpressionType;
    readonly object_: Expression;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(object_: Expression, arguments: IEnumerable_1<Expression>): IndexExpression;
}


export interface __IndexExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type IndexExpression = IndexExpression$instance & __IndexExpression$views;


export class InvocationExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly expression: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(expression: Expression, arguments: IEnumerable_1<Expression>): InvocationExpression;
}


export interface __InvocationExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type InvocationExpression = InvocationExpression$instance & __InvocationExpression$views;


export class LabelExpression$instance extends Expression$instance {
    readonly defaultValue: Expression;
    readonly nodeType: ExpressionType;
    readonly target: LabelTarget;
    readonly type_: Type;
    update(target: LabelTarget, defaultValue: Expression): LabelExpression;
}


export type LabelExpression = LabelExpression$instance;

export class LabelTarget$instance {
    readonly name: string;
    readonly type_: Type;
    toString(): string;
}


export type LabelTarget = LabelTarget$instance;

export abstract class LambdaExpression$instance extends Expression$instance {
    readonly body: Expression;
    readonly name: string;
    readonly nodeType: ExpressionType;
    readonly parameters: ReadOnlyCollection_1<ParameterExpression>;
    readonly returnType: Type;
    readonly tailCall: boolean;
    readonly type_: Type;
    compile(): Function;
    compile(preferInterpretation: boolean): Function;
    compile(debugInfoGenerator: DebugInfoGenerator): Function;
    static readonly CanCompileToIL: boolean;
    static readonly CanInterpret: boolean;
}


export type LambdaExpression = LambdaExpression$instance;

export class ListInitExpression$instance extends Expression$instance {
    readonly canReduce: boolean;
    readonly initializers: ReadOnlyCollection_1<ElementInit>;
    readonly newExpression: NewExpression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
}


export type ListInitExpression = ListInitExpression$instance;

export class LoopExpression$instance extends Expression$instance {
    readonly body: Expression;
    readonly breakLabel: LabelTarget;
    readonly continueLabel: LabelTarget;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    update(breakLabel: LabelTarget, continueLabel: LabelTarget, body: Expression): LoopExpression;
}


export type LoopExpression = LoopExpression$instance;

export class MemberAssignment$instance extends MemberBinding$instance {
    readonly expression: Expression;
    update(expression: Expression): MemberAssignment;
}


export type MemberAssignment = MemberAssignment$instance;

export abstract class MemberBinding$instance {
    readonly bindingType: MemberBindingType;
    readonly member: MemberInfo;
    toString(): string;
}


export type MemberBinding = MemberBinding$instance;

export class MemberExpression$instance extends Expression$instance {
    readonly expression: Expression;
    readonly member: MemberInfo;
    readonly nodeType: ExpressionType;
    update(expression: Expression): MemberExpression;
}


export type MemberExpression = MemberExpression$instance;

export class MemberInitExpression$instance extends Expression$instance {
    readonly bindings: ReadOnlyCollection_1<MemberBinding>;
    readonly canReduce: boolean;
    readonly newExpression: NewExpression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    reduce(): Expression;
    update(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
}


export type MemberInitExpression = MemberInitExpression$instance;

export class MemberListBinding$instance extends MemberBinding$instance {
    readonly initializers: ReadOnlyCollection_1<ElementInit>;
    update(initializers: IEnumerable_1<ElementInit>): MemberListBinding;
}


export type MemberListBinding = MemberListBinding$instance;

export class MemberMemberBinding$instance extends MemberBinding$instance {
    readonly bindings: ReadOnlyCollection_1<MemberBinding>;
    update(bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
}


export type MemberMemberBinding = MemberMemberBinding$instance;

export class MethodCallExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly method: MethodInfo;
    readonly nodeType: ExpressionType;
    readonly object_: Expression;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(object_: Expression, arguments: IEnumerable_1<Expression>): MethodCallExpression;
}


export interface __MethodCallExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type MethodCallExpression = MethodCallExpression$instance & __MethodCallExpression$views;


export class NewArrayExpression$instance extends Expression$instance {
    readonly expressions: ReadOnlyCollection_1<Expression>;
    readonly type_: Type;
    update(expressions: IEnumerable_1<Expression>): NewArrayExpression;
}


export type NewArrayExpression = NewArrayExpression$instance;

export class NewExpression$instance extends Expression$instance {
    readonly argumentCount: int;
    readonly arguments: ReadOnlyCollection_1<Expression>;
    readonly constructor_: ConstructorInfo;
    readonly members: ReadOnlyCollection_1<MemberInfo>;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    getArgument(index: int): Expression;
    update(arguments: IEnumerable_1<Expression>): NewExpression;
}


export interface __NewExpression$views {
    readonly As_IArgumentProvider: IArgumentProvider$instance;
}

export type NewExpression = NewExpression$instance & __NewExpression$views;


export class ParameterExpression$instance extends Expression$instance {
    readonly isByRef: boolean;
    readonly name: string;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
}


export type ParameterExpression = ParameterExpression$instance;

export class RuntimeVariablesExpression$instance extends Expression$instance {
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly variables: ReadOnlyCollection_1<ParameterExpression>;
    update(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
}


export type RuntimeVariablesExpression = RuntimeVariablesExpression$instance;

export class SwitchCase$instance {
    readonly body: Expression;
    readonly testValues: ReadOnlyCollection_1<Expression>;
    toString(): string;
    update(testValues: IEnumerable_1<Expression>, body: Expression): SwitchCase;
}


export type SwitchCase = SwitchCase$instance;

export class SwitchExpression$instance extends Expression$instance {
    readonly cases: ReadOnlyCollection_1<SwitchCase>;
    readonly comparison: MethodInfo;
    readonly defaultBody: Expression;
    readonly nodeType: ExpressionType;
    readonly switchValue: Expression;
    readonly type_: Type;
    update(switchValue: Expression, cases: IEnumerable_1<SwitchCase>, defaultBody: Expression): SwitchExpression;
}


export type SwitchExpression = SwitchExpression$instance;

export class SymbolDocumentInfo$instance {
    readonly documentType: Guid;
    readonly fileName: string;
    readonly language: Guid;
    readonly languageVendor: Guid;
}


export type SymbolDocumentInfo = SymbolDocumentInfo$instance;

export class TryExpression$instance extends Expression$instance {
    readonly body: Expression;
    readonly fault: Expression;
    readonly finally_: Expression;
    readonly handlers: ReadOnlyCollection_1<CatchBlock>;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    update(body: Expression, handlers: IEnumerable_1<CatchBlock>, finally_: Expression, fault: Expression): TryExpression;
}


export type TryExpression = TryExpression$instance;

export class TypeBinaryExpression$instance extends Expression$instance {
    readonly expression: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    readonly typeOperand: Type;
    update(expression: Expression): TypeBinaryExpression;
}


export type TypeBinaryExpression = TypeBinaryExpression$instance;

export class UnaryExpression$instance extends Expression$instance {
    readonly canReduce: boolean;
    readonly isLifted: boolean;
    readonly isLiftedToNull: boolean;
    readonly method: MethodInfo;
    readonly nodeType: ExpressionType;
    readonly operand: Expression;
    readonly type_: Type;
    reduce(): Expression;
    update(operand: Expression): UnaryExpression;
}


export type UnaryExpression = UnaryExpression$instance;

