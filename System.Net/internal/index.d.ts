// Generated by tsbindgen - Architecture
// Namespace: System.Net
// Assembly: System.Private.CoreLib, System.Net.Primitives, System.Net.WebProxy, System.Net.WebClient, System.Net.NameResolution, System.Net.WebHeaderCollection, System.Net.HttpListener, System.Net.Requests

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyCollection_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Specialized_Internal from "../../System.Collections.Specialized/internal/index.js";
import type { NameObjectCollectionBase_KeysCollection, NameValueCollection, StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, AsyncCompletedEventHandler, Component, IComponent, IContainer, ISite, ProgressChangedEventArgs, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import type { BinaryWriter, Stream, TextWriter } from "../../System.IO/internal/index.js";
import type { RequestCachePolicy } from "../../System.Net.Cache/internal/index.js";
import type { AuthenticationLevel, EncryptionPolicy, RemoteCertificateValidationCallback } from "../../System.Net.Security/internal/index.js";
import type { AddressFamily } from "../../System.Net.Sockets/internal/index.js";
import type { HttpListenerWebSocketContext } from "../../System.Net.WebSockets/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ChannelBinding, ChannelBindingKind, ExtendedProtectionPolicy, ServiceNameCollection } from "../../System.Security.Authentication.ExtendedProtection/internal/index.js";
import type { Claim, ClaimsIdentity } from "../../System.Security.Claims/internal/index.js";
import type { X509Certificate, X509Certificate2, X509CertificateCollection } from "../../System.Security.Cryptography.X509Certificates/internal/index.js";
import * as System_Security_Principal_Internal from "../../System.Security.Principal/internal/index.js";
import type { GenericIdentity, IIdentity, IPrincipal, TokenImpersonationLevel } from "../../System.Security.Principal/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Delegate, Enum, EventArgs, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Uri, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AuthenticationSchemes {
    None = 0,
    Digest = 1,
    Negotiate = 2,
    Ntlm = 4,
    Basic = 8,
    Anonymous = 32768,
    IntegratedWindowsAuthentication = 6
}


export enum CookieVariant {
    Unknown = 0,
    Plain = 1,
    Rfc2109 = 2,
    Rfc2965 = 3,
    Default = 2
}


export enum DecompressionMethods {
    None = 0,
    GZip = 1,
    Deflate = 2,
    Brotli = 4,
    All = -1
}


export enum FtpStatusCode {
    Undefined = 0,
    RestartMarker = 110,
    ServiceTemporarilyNotAvailable = 120,
    DataAlreadyOpen = 125,
    OpeningData = 150,
    CommandOK = 200,
    CommandExtraneous = 202,
    DirectoryStatus = 212,
    FileStatus = 213,
    SystemType = 215,
    SendUserCommand = 220,
    ClosingControl = 221,
    ClosingData = 226,
    EnteringPassive = 227,
    LoggedInProceed = 230,
    ServerWantsSecureSession = 234,
    FileActionOK = 250,
    PathnameCreated = 257,
    SendPasswordCommand = 331,
    NeedLoginAccount = 332,
    FileCommandPending = 350,
    ServiceNotAvailable = 421,
    CantOpenData = 425,
    ConnectionClosed = 426,
    ActionNotTakenFileUnavailableOrBusy = 450,
    ActionAbortedLocalProcessingError = 451,
    ActionNotTakenInsufficientSpace = 452,
    CommandSyntaxError = 500,
    ArgumentSyntaxError = 501,
    CommandNotImplemented = 502,
    BadCommandSequence = 503,
    NotLoggedIn = 530,
    AccountNeeded = 532,
    ActionNotTakenFileUnavailable = 550,
    ActionAbortedUnknownPageType = 551,
    FileActionAborted = 552,
    ActionNotTakenFilenameNotAllowed = 553
}


export enum HttpRequestHeader {
    CacheControl = 0,
    Connection = 1,
    Date = 2,
    KeepAlive = 3,
    Pragma = 4,
    Trailer = 5,
    TransferEncoding = 6,
    Upgrade = 7,
    Via = 8,
    Warning = 9,
    Allow = 10,
    ContentLength = 11,
    ContentType = 12,
    ContentEncoding = 13,
    ContentLanguage = 14,
    ContentLocation = 15,
    ContentMd5 = 16,
    ContentRange = 17,
    Expires = 18,
    LastModified = 19,
    Accept = 20,
    AcceptCharset = 21,
    AcceptEncoding = 22,
    AcceptLanguage = 23,
    Authorization = 24,
    Cookie = 25,
    Expect = 26,
    From = 27,
    Host = 28,
    IfMatch = 29,
    IfModifiedSince = 30,
    IfNoneMatch = 31,
    IfRange = 32,
    IfUnmodifiedSince = 33,
    MaxForwards = 34,
    ProxyAuthorization = 35,
    Referer = 36,
    Range = 37,
    Te = 38,
    Translate = 39,
    UserAgent = 40
}


export enum HttpResponseHeader {
    CacheControl = 0,
    Connection = 1,
    Date = 2,
    KeepAlive = 3,
    Pragma = 4,
    Trailer = 5,
    TransferEncoding = 6,
    Upgrade = 7,
    Via = 8,
    Warning = 9,
    Allow = 10,
    ContentLength = 11,
    ContentType = 12,
    ContentEncoding = 13,
    ContentLanguage = 14,
    ContentLocation = 15,
    ContentMd5 = 16,
    ContentRange = 17,
    Expires = 18,
    LastModified = 19,
    AcceptRanges = 20,
    Age = 21,
    ETag = 22,
    Location = 23,
    ProxyAuthenticate = 24,
    RetryAfter = 25,
    Server = 26,
    SetCookie = 27,
    Vary = 28,
    WwwAuthenticate = 29
}


export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    UnprocessableContent = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511
}


export enum SecurityProtocolType {
    SystemDefault = 0,
    Ssl3 = 48,
    Tls = 192,
    Tls11 = 768,
    Tls12 = 3072,
    Tls13 = 12288
}


export enum WebExceptionStatus {
    Success = 0,
    NameResolutionFailure = 1,
    ConnectFailure = 2,
    ReceiveFailure = 3,
    SendFailure = 4,
    PipelineFailure = 5,
    RequestCanceled = 6,
    ProtocolError = 7,
    ConnectionClosed = 8,
    TrustFailure = 9,
    SecureChannelFailure = 10,
    ServerProtocolViolation = 11,
    KeepAliveFailure = 12,
    Pending = 13,
    Timeout = 14,
    ProxyNameResolutionFailure = 15,
    UnknownError = 16,
    MessageLengthLimitExceeded = 17,
    CacheEntryNotFound = 18,
    RequestProhibitedByCachePolicy = 19,
    RequestProhibitedByProxy = 20
}


export interface IAuthenticationModule$instance {
    readonly CanPreAuthenticate: boolean;
    readonly AuthenticationType: string;
    Authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    PreAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
}


export type IAuthenticationModule = IAuthenticationModule$instance;

export interface ICredentialPolicy$instance {
    ShouldSendCredential(challengeUri: Uri, request: WebRequest, credential: NetworkCredential, authenticationModule: IAuthenticationModule): boolean;
}


export type ICredentialPolicy = ICredentialPolicy$instance;

export interface ICredentials$instance {
    GetCredential(uri: Uri, authType: string): NetworkCredential;
}


export type ICredentials = ICredentials$instance;

export interface ICredentialsByHost$instance {
    GetCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export type ICredentialsByHost = ICredentialsByHost$instance;

export interface IWebProxy$instance {
    Credentials: ICredentials;
    GetProxy(destination: Uri): Uri;
    IsBypassed(host: Uri): boolean;
}


export type IWebProxy = IWebProxy$instance;

export interface IWebProxyScript$instance {
    Close(): void;
    Load(scriptLocation: Uri, script: string, helperType: Type): boolean;
    Run(url: string, host: string): string;
}


export type IWebProxyScript = IWebProxyScript$instance;

export interface IWebRequestCreate$instance {
    Create(uri: Uri): WebRequest;
}


export type IWebRequestCreate = IWebRequestCreate$instance;

export class IPNetwork$instance {
    constructor(baseAddress: IPAddress, prefixLength: int);
    readonly BaseAddress: IPAddress;
    readonly PrefixLength: int;
    Contains(address: IPAddress): boolean;
    Equals(other: IPNetwork): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    TryFormat(destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    TryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPNetwork;
    static Parse(s: ReadOnlySpan_1<CLROf<string>>): IPNetwork;
    static Parse(s: string): IPNetwork;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: TSByRef<IPNetwork> }): boolean;
    static TryParse(s: ReadOnlySpan_1<CLROf<string>>, result: { value: TSByRef<IPNetwork> }): boolean;
    static TryParse(s: string, result: { value: TSByRef<IPNetwork> }): boolean;
}


export interface __IPNetwork$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<IPNetwork>;
    readonly As_IFormattable: System_Internal.IFormattable$instance;
    readonly As_IParsable_1_of_Decimal: System_Internal.IParsable_1$instance<any>;
    readonly As_ISpanFormattable: System_Internal.ISpanFormattable$instance;
    readonly As_ISpanParsable_1_of_Decimal: System_Internal.ISpanParsable_1$instance<any>;
    readonly As_IUtf8SpanFormattable: System_Internal.IUtf8SpanFormattable$instance;
    readonly As_IUtf8SpanParsable_1_of_Decimal: System_Internal.IUtf8SpanParsable_1$instance<any>;

    // Structural method bridges for numeric interface constraints
    Equals(other: IPNetwork): boolean;
}

export type IPNetwork = IPNetwork$instance & __IPNetwork$views;


export class AuthenticationManager$instance {
    static CredentialPolicy: ICredentialPolicy;
    static readonly CustomTargetNameDictionary: StringDictionary;
    static readonly RegisteredModules: IEnumerator;
    static Authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    static PreAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
    static Register(authenticationModule: IAuthenticationModule): void;
    static Unregister(authenticationModule: IAuthenticationModule): void;
    static Unregister(authenticationScheme: string): void;
}


export type AuthenticationManager = AuthenticationManager$instance;

export class AuthenticationSchemeSelector$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(httpRequest: HttpListenerRequest, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): AuthenticationSchemes;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(httpRequest: HttpListenerRequest): AuthenticationSchemes;
}


export interface __AuthenticationSchemeSelector$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AuthenticationSchemeSelector = AuthenticationSchemeSelector$instance & __AuthenticationSchemeSelector$views;


export class Authorization$instance {
    constructor(token: string);
    constructor(token: string, finished: boolean);
    constructor(token: string, finished: boolean, connectionGroupId: string);
    readonly Complete: boolean;
    readonly ConnectionGroupId: string;
    readonly Message: string;
    MutuallyAuthenticated: boolean;
    ProtectionRealm: string[];
}


export type Authorization = Authorization$instance;

export class BindIPEndPoint$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(servicePoint: ServicePoint, remoteEndPoint: IPEndPoint, retryCount: int, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): IPEndPoint;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(servicePoint: ServicePoint, remoteEndPoint: IPEndPoint, retryCount: int): IPEndPoint;
}


export interface __BindIPEndPoint$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BindIPEndPoint = BindIPEndPoint$instance & __BindIPEndPoint$views;


export class Cookie$instance {
    constructor();
    constructor(name: string, value: string);
    constructor(name: string, value: string, path: string);
    constructor(name: string, value: string, path: string, domain: string);
    Comment: string;
    CommentUri: Uri;
    Discard: boolean;
    Domain: string;
    Expired: boolean;
    Expires: DateTime;
    HttpOnly: boolean;
    Name: string;
    Path: string;
    Port: string;
    Secure: boolean;
    readonly TimeStamp: DateTime;
    Value: string;
    Version: int;
    Equals(comparand: any): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export type Cookie = Cookie$instance;

export class CookieCollection$instance {
    constructor();
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: any;
    Add(cookie: Cookie): void;
    Add(cookies: CookieCollection): void;
    Clear(): void;
    Contains(cookie: Cookie): boolean;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: Cookie[], index: int): void;
    get_Item(index: int): Cookie;
    get_Item(name: string): Cookie;
    GetEnumerator(): IEnumerator;
    Remove(cookie: Cookie): boolean;
}


export interface __CookieCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<Cookie>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<Cookie>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Cookie>;
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type CookieCollection = CookieCollection$instance & __CookieCollection$views;


export class CookieContainer$instance {
    constructor();
    constructor(capacity: int);
    constructor(capacity: int, perDomainCapacity: int, maxCookieSize: int);
    Capacity: int;
    readonly Count: int;
    MaxCookieSize: int;
    PerDomainCapacity: int;
    Add(cookie: Cookie): void;
    Add(cookies: CookieCollection): void;
    Add(uri: Uri, cookie: Cookie): void;
    Add(uri: Uri, cookies: CookieCollection): void;
    GetAllCookies(): CookieCollection;
    GetCookieHeader(uri: Uri): string;
    GetCookies(uri: Uri): CookieCollection;
    SetCookies(uri: Uri, cookieHeader: string): void;
    static readonly DefaultCookieLimit: int;
    static readonly DefaultPerDomainCookieLimit: int;
    static readonly DefaultCookieLengthLimit: int;
}


export type CookieContainer = CookieContainer$instance;

export class CookieException$instance extends System_Internal.FormatException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __CookieException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CookieException = CookieException$instance & __CookieException$views;


export class CredentialCache$instance {
    constructor();
    Add(uriPrefix: Uri, authType: string, cred: NetworkCredential): void;
    Add(host: string, port: int, authenticationType: string, credential: NetworkCredential): void;
    GetCredential(uriPrefix: Uri, authType: string): NetworkCredential;
    GetCredential(host: string, port: int, authenticationType: string): NetworkCredential;
    GetEnumerator(): IEnumerator;
    Remove(uriPrefix: Uri, authType: string): void;
    Remove(host: string, port: int, authenticationType: string): void;
    static readonly DefaultCredentials: ICredentials;
    static readonly DefaultNetworkCredentials: NetworkCredential;
}


export interface __CredentialCache$views {
    readonly As_ICredentials: ICredentials$instance;
    readonly As_ICredentialsByHost: ICredentialsByHost$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type CredentialCache = CredentialCache$instance & __CredentialCache$views;


export class DnsEndPoint$instance extends EndPoint$instance {
    constructor(host: string, port: int);
    constructor(host: string, port: int, addressFamily: AddressFamily);
    readonly AddressFamily: AddressFamily;
    readonly Host: string;
    readonly Port: int;
    Equals(comparand: any): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export type DnsEndPoint = DnsEndPoint$instance;

export class DownloadDataCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: byte[];
}


export type DownloadDataCompletedEventArgs = DownloadDataCompletedEventArgs$instance;

export class DownloadDataCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: DownloadDataCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: DownloadDataCompletedEventArgs): void;
}


export interface __DownloadDataCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DownloadDataCompletedEventHandler = DownloadDataCompletedEventHandler$instance & __DownloadDataCompletedEventHandler$views;


export class DownloadProgressChangedEventArgs$instance extends System_ComponentModel_Internal.ProgressChangedEventArgs$instance {
    readonly BytesReceived: long;
    readonly TotalBytesToReceive: long;
}


export type DownloadProgressChangedEventArgs = DownloadProgressChangedEventArgs$instance;

export class DownloadProgressChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: DownloadProgressChangedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: DownloadProgressChangedEventArgs): void;
}


export interface __DownloadProgressChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DownloadProgressChangedEventHandler = DownloadProgressChangedEventHandler$instance & __DownloadProgressChangedEventHandler$views;


export class DownloadStringCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: string;
}


export type DownloadStringCompletedEventArgs = DownloadStringCompletedEventArgs$instance;

export class DownloadStringCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: DownloadStringCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: DownloadStringCompletedEventArgs): void;
}


export interface __DownloadStringCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DownloadStringCompletedEventHandler = DownloadStringCompletedEventHandler$instance & __DownloadStringCompletedEventHandler$views;


export abstract class EndPoint$instance {
    readonly AddressFamily: AddressFamily;
    Create(socketAddress: SocketAddress): EndPoint;
    Serialize(): SocketAddress;
}


export type EndPoint = EndPoint$instance;

export class FileWebRequest$instance extends WebRequest$instance {
    ConnectionGroupName: string;
    ContentLength: long;
    ContentType: string;
    Credentials: ICredentials;
    readonly Headers: WebHeaderCollection;
    Method: string;
    PreAuthenticate: boolean;
    Proxy: IWebProxy;
    readonly RequestUri: Uri;
    Timeout: int;
    UseDefaultCredentials: boolean;
    Abort(): void;
    BeginGetRequestStream(callback: AsyncCallback, state: any): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: any): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetRequestStream(): Stream;
    GetRequestStreamAsync(): Task_1<Stream>;
    GetRequestStreamAsync(): Task_1<Stream>;
    GetResponse(): WebResponse;
    GetResponseAsync(): Task_1<WebResponse>;
    GetResponseAsync(): Task_1<WebResponse>;
}


export interface __FileWebRequest$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileWebRequest = FileWebRequest$instance & __FileWebRequest$views;


export class FileWebResponse$instance extends WebResponse$instance {
    readonly ContentLength: long;
    readonly ContentType: string;
    readonly Headers: WebHeaderCollection;
    readonly ResponseUri: Uri;
    readonly SupportsHeaders: boolean;
    Close(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetResponseStream(): Stream;
}


export interface __FileWebResponse$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileWebResponse = FileWebResponse$instance & __FileWebResponse$views;


export class FtpWebRequest$instance extends WebRequest$instance {
    CachePolicy: RequestCachePolicy;
    ClientCertificates: X509CertificateCollection;
    ConnectionGroupName: string;
    ContentLength: long;
    ContentOffset: long;
    ContentType: string;
    Credentials: ICredentials;
    EnableSsl: boolean;
    Headers: WebHeaderCollection;
    KeepAlive: boolean;
    Method: string;
    PreAuthenticate: boolean;
    Proxy: IWebProxy;
    ReadWriteTimeout: int;
    RenameTo: string;
    readonly RequestUri: Uri;
    readonly ServicePoint: ServicePoint;
    Timeout: int;
    UseBinary: boolean;
    UseDefaultCredentials: boolean;
    UsePassive: boolean;
    Abort(): void;
    BeginGetRequestStream(callback: AsyncCallback, state: any): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: any): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetRequestStream(): Stream;
    GetResponse(): WebResponse;
    static DefaultCachePolicy: RequestCachePolicy;
}


export interface __FtpWebRequest$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FtpWebRequest = FtpWebRequest$instance & __FtpWebRequest$views;


export class FtpWebResponse$instance extends WebResponse$instance {
    readonly BannerMessage: string;
    readonly ContentLength: long;
    readonly ExitMessage: string;
    readonly Headers: WebHeaderCollection;
    readonly LastModified: DateTime;
    readonly ResponseUri: Uri;
    readonly StatusCode: FtpStatusCode;
    readonly StatusDescription: string;
    readonly SupportsHeaders: boolean;
    readonly WelcomeMessage: string;
    Close(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetResponseStream(): Stream;
}


export interface __FtpWebResponse$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FtpWebResponse = FtpWebResponse$instance & __FtpWebResponse$views;


export class GlobalProxySelection$instance {
    constructor();
    static Select: IWebProxy;
    static GetEmptyWebProxy(): IWebProxy;
}


export type GlobalProxySelection = GlobalProxySelection$instance;

export class HttpContinueDelegate$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(StatusCode: int, httpHeaders: WebHeaderCollection, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(StatusCode: int, httpHeaders: WebHeaderCollection): void;
}


export interface __HttpContinueDelegate$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpContinueDelegate = HttpContinueDelegate$instance & __HttpContinueDelegate$views;


export class HttpListener$instance {
    constructor();
    AuthenticationSchemes: AuthenticationSchemes;
    AuthenticationSchemeSelectorDelegate: AuthenticationSchemeSelector;
    readonly DefaultServiceNames: ServiceNameCollection;
    ExtendedProtectionPolicy: ExtendedProtectionPolicy;
    ExtendedProtectionSelectorDelegate: HttpListener_ExtendedProtectionSelector;
    IgnoreWriteExceptions: boolean;
    readonly IsListening: boolean;
    readonly Prefixes: HttpListenerPrefixCollection;
    Realm: string;
    readonly TimeoutManager: HttpListenerTimeoutManager;
    UnsafeConnectionNtlmAuthentication: boolean;
    Abort(): void;
    BeginGetContext(callback: AsyncCallback, state: any): IAsyncResult;
    Close(): void;
    EndGetContext(asyncResult: IAsyncResult): HttpListenerContext;
    GetContext(): HttpListenerContext;
    GetContextAsync(): Task_1<HttpListenerContext>;
    Start(): void;
    Stop(): void;
    static readonly IsSupported: boolean;
}


export interface __HttpListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type HttpListener = HttpListener$instance & __HttpListener$views;


export class HttpListener_ExtendedProtectionSelector$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(request: HttpListenerRequest, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): ExtendedProtectionPolicy;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(request: HttpListenerRequest): ExtendedProtectionPolicy;
}


export interface __HttpListener_ExtendedProtectionSelector$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpListener_ExtendedProtectionSelector = HttpListener_ExtendedProtectionSelector$instance & __HttpListener_ExtendedProtectionSelector$views;


export class HttpListenerBasicIdentity$instance extends System_Security_Principal_Internal.GenericIdentity$instance {
    constructor(username: string, password: string);
    readonly Password: string;
}


export interface __HttpListenerBasicIdentity$views {
    readonly As_IIdentity: System_Security_Principal_Internal.IIdentity$instance;
}

export type HttpListenerBasicIdentity = HttpListenerBasicIdentity$instance & __HttpListenerBasicIdentity$views;


export class HttpListenerContext$instance {
    readonly Request: HttpListenerRequest;
    readonly Response: HttpListenerResponse;
    readonly User: IPrincipal;
    AcceptWebSocketAsync(subProtocol: string): Task_1<HttpListenerWebSocketContext>;
    AcceptWebSocketAsync(subProtocol: string, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    AcceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    AcceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan, internalBuffer: ArraySegment_1<CLROf<byte>>): Task_1<HttpListenerWebSocketContext>;
}


export type HttpListenerContext = HttpListenerContext$instance;

export class HttpListenerException$instance extends System_ComponentModel_Internal.Win32Exception$instance {
    constructor();
    constructor(errorCode: int);
    constructor(errorCode: int, message: string);
    readonly ErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __HttpListenerException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpListenerException = HttpListenerException$instance & __HttpListenerException$views;


export class HttpListenerPrefixCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Add(uriPrefix: string): void;
    Clear(): void;
    Contains(uriPrefix: string): boolean;
    CopyTo(array: ClrArray, offset: int): void;
    CopyTo(array: string[], offset: int): void;
    GetEnumerator(): IEnumerator_1<CLROf<string>>;
    Remove(uriPrefix: string): boolean;
}


export interface __HttpListenerPrefixCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<CLROf<string>>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<CLROf<string>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type HttpListenerPrefixCollection = HttpListenerPrefixCollection$instance & __HttpListenerPrefixCollection$views;


export class HttpListenerRequest$instance {
    readonly AcceptTypes: string[];
    readonly ClientCertificateError: int;
    readonly ContentEncoding: Encoding;
    readonly ContentLength64: long;
    readonly ContentType: string;
    readonly Cookies: CookieCollection;
    readonly HasEntityBody: boolean;
    readonly Headers: NameValueCollection;
    readonly HttpMethod: string;
    readonly InputStream: Stream;
    readonly IsAuthenticated: boolean;
    readonly IsLocal: boolean;
    readonly IsSecureConnection: boolean;
    readonly IsWebSocketRequest: boolean;
    readonly KeepAlive: boolean;
    readonly LocalEndPoint: IPEndPoint;
    readonly ProtocolVersion: Version;
    readonly QueryString: NameValueCollection;
    readonly RawUrl: string;
    readonly RemoteEndPoint: IPEndPoint;
    readonly RequestTraceIdentifier: Guid;
    readonly ServiceName: string;
    readonly TransportContext: TransportContext;
    readonly Url: Uri;
    readonly UrlReferrer: Uri;
    readonly UserAgent: string;
    readonly UserHostAddress: string;
    readonly UserHostName: string;
    readonly UserLanguages: string[];
    BeginGetClientCertificate(requestCallback: AsyncCallback, state: any): IAsyncResult;
    EndGetClientCertificate(asyncResult: IAsyncResult): X509Certificate2;
    GetClientCertificate(): X509Certificate2;
    GetClientCertificateAsync(): Task_1<X509Certificate2>;
}


export type HttpListenerRequest = HttpListenerRequest$instance;

export class HttpListenerResponse$instance {
    ContentEncoding: Encoding;
    ContentLength64: long;
    ContentType: string;
    Cookies: CookieCollection;
    Headers: WebHeaderCollection;
    KeepAlive: boolean;
    readonly OutputStream: Stream;
    ProtocolVersion: Version;
    RedirectLocation: string;
    SendChunked: boolean;
    StatusCode: int;
    StatusDescription: string;
    Abort(): void;
    AddHeader(name: string, value: string): void;
    AppendCookie(cookie: Cookie): void;
    AppendHeader(name: string, value: string): void;
    Close(): void;
    Close(responseEntity: byte[], willBlock: boolean): void;
    CopyFrom(templateResponse: HttpListenerResponse): void;
    Redirect(url: string): void;
    SetCookie(cookie: Cookie): void;
}


export interface __HttpListenerResponse$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type HttpListenerResponse = HttpListenerResponse$instance & __HttpListenerResponse$views;


export class HttpListenerTimeoutManager$instance {
    DrainEntityBody: TimeSpan;
    EntityBody: TimeSpan;
    HeaderWait: TimeSpan;
    IdleConnection: TimeSpan;
    MinSendBytesPerSecond: long;
    RequestQueue: TimeSpan;
}


export type HttpListenerTimeoutManager = HttpListenerTimeoutManager$instance;

export class HttpWebRequest$instance extends WebRequest$instance {
    Accept: string;
    readonly Address: Uri;
    AllowAutoRedirect: boolean;
    AllowReadStreamBuffering: boolean;
    AllowWriteStreamBuffering: boolean;
    AutomaticDecompression: DecompressionMethods;
    ClientCertificates: X509CertificateCollection;
    Connection: string;
    ConnectionGroupName: string;
    ContentLength: long;
    ContentType: string;
    ContinueDelegate: HttpContinueDelegate;
    ContinueTimeout: int;
    CookieContainer: CookieContainer;
    Credentials: ICredentials;
    Date: DateTime;
    Expect: string;
    readonly HaveResponse: boolean;
    Headers: WebHeaderCollection;
    Host: string;
    IfModifiedSince: DateTime;
    KeepAlive: boolean;
    MaximumAutomaticRedirections: int;
    MaximumResponseHeadersLength: int;
    MediaType: string;
    Method: string;
    Pipelined: boolean;
    PreAuthenticate: boolean;
    ProtocolVersion: Version;
    Proxy: IWebProxy;
    ReadWriteTimeout: int;
    Referer: string;
    readonly RequestUri: Uri;
    SendChunked: boolean;
    ServerCertificateValidationCallback: RemoteCertificateValidationCallback;
    readonly ServicePoint: ServicePoint;
    readonly SupportsCookieContainer: boolean;
    Timeout: int;
    TransferEncoding: string;
    UnsafeAuthenticatedConnectionSharing: boolean;
    UseDefaultCredentials: boolean;
    UserAgent: string;
    Abort(): void;
    AddRange(from_: int, to: int): void;
    AddRange(from_: long, to: long): void;
    AddRange(range: int): void;
    AddRange(range: long): void;
    AddRange(rangeSpecifier: string, from_: int, to: int): void;
    AddRange(rangeSpecifier: string, from_: long, to: long): void;
    AddRange(rangeSpecifier: string, range: int): void;
    AddRange(rangeSpecifier: string, range: long): void;
    BeginGetRequestStream(callback: AsyncCallback, state: any): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: any): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetRequestStream(): Stream;
    GetResponse(): WebResponse;
    static DefaultMaximumResponseHeadersLength: int;
    static DefaultMaximumErrorResponseLength: int;
    static DefaultCachePolicy: RequestCachePolicy;
}


export interface __HttpWebRequest$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpWebRequest = HttpWebRequest$instance & __HttpWebRequest$views;


export class HttpWebResponse$instance extends WebResponse$instance {
    constructor();
    readonly CharacterSet: string;
    readonly ContentEncoding: string;
    readonly ContentLength: long;
    readonly ContentType: string;
    Cookies: CookieCollection;
    readonly Headers: WebHeaderCollection;
    readonly IsMutuallyAuthenticated: boolean;
    readonly LastModified: DateTime;
    readonly Method: string;
    readonly ProtocolVersion: Version;
    readonly ResponseUri: Uri;
    readonly Server: string;
    readonly StatusCode: HttpStatusCode;
    readonly StatusDescription: string;
    readonly SupportsHeaders: boolean;
    Close(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetResponseHeader(headerName: string): string;
    GetResponseStream(): Stream;
}


export interface __HttpWebResponse$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpWebResponse = HttpWebResponse$instance & __HttpWebResponse$views;


export class IPAddress$instance {
    constructor(newAddress: long);
    constructor(address: byte[], scopeid: long);
    constructor(address: ReadOnlySpan_1<CLROf<byte>>, scopeid: long);
    constructor(address: byte[]);
    constructor(address: ReadOnlySpan_1<CLROf<byte>>);
    Address: long;
    readonly AddressFamily: AddressFamily;
    readonly IsIPv4MappedToIPv6: boolean;
    readonly IsIPv6LinkLocal: boolean;
    readonly IsIPv6Multicast: boolean;
    readonly IsIPv6SiteLocal: boolean;
    readonly IsIPv6Teredo: boolean;
    readonly IsIPv6UniqueLocal: boolean;
    ScopeId: long;
    Equals(comparand: any): boolean;
    GetAddressBytes(): byte[];
    GetHashCode(): int;
    MapToIPv4(): IPAddress;
    MapToIPv6(): IPAddress;
    ToString(): string;
    TryFormat(destination: Span_1<CLROf<string>>, charsWritten: { value: TSByRef<int> }): boolean;
    TryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    TryWriteBytes(destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static readonly Any: IPAddress;
    static readonly Loopback: IPAddress;
    static readonly Broadcast: IPAddress;
    static readonly None: IPAddress;
    static readonly IPv6Any: IPAddress;
    static readonly IPv6Loopback: IPAddress;
    static readonly IPv6None: IPAddress;
    static HostToNetworkOrder(host: short): short;
    static HostToNetworkOrder(host: int): int;
    static HostToNetworkOrder(host: long): long;
    static IsLoopback(address: IPAddress): boolean;
    static IsValid(ipSpan: ReadOnlySpan_1<CLROf<string>>): boolean;
    static IsValidUtf8(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static NetworkToHostOrder(network: short): short;
    static NetworkToHostOrder(network: int): int;
    static NetworkToHostOrder(network: long): long;
    static Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPAddress;
    static Parse(ipSpan: ReadOnlySpan_1<CLROf<string>>): IPAddress;
    static Parse(ipString: string): IPAddress;
    static TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: TSByRef<IPAddress> }): boolean;
    static TryParse(ipSpan: ReadOnlySpan_1<CLROf<string>>, address: { value: TSByRef<IPAddress> }): boolean;
    static TryParse(ipString: string, address: { value: TSByRef<IPAddress> }): boolean;
}


export interface __IPAddress$views {
    readonly As_IFormattable: System_Internal.IFormattable$instance;
    readonly As_IParsable_1_of_Decimal: System_Internal.IParsable_1$instance<any>;
    readonly As_ISpanFormattable: System_Internal.ISpanFormattable$instance;
    readonly As_ISpanParsable_1_of_Decimal: System_Internal.ISpanParsable_1$instance<any>;
    readonly As_IUtf8SpanFormattable: System_Internal.IUtf8SpanFormattable$instance;
    readonly As_IUtf8SpanParsable_1_of_Decimal: System_Internal.IUtf8SpanParsable_1$instance<any>;
}

export type IPAddress = IPAddress$instance & __IPAddress$views;


export class IPEndPoint$instance extends EndPoint$instance {
    constructor(address: long, port: int);
    constructor(address: IPAddress, port: int);
    Address: IPAddress;
    readonly AddressFamily: AddressFamily;
    Port: int;
    Create(socketAddress: SocketAddress): EndPoint;
    Equals(comparand: any): boolean;
    GetHashCode(): int;
    Serialize(): SocketAddress;
    ToString(): string;
    static readonly MinPort: int;
    static readonly MaxPort: int;
    static Parse(s: ReadOnlySpan_1<CLROf<string>>): IPEndPoint;
    static Parse(s: string): IPEndPoint;
    static TryParse(s: ReadOnlySpan_1<CLROf<string>>, result: { value: TSByRef<IPEndPoint> }): boolean;
    static TryParse(s: string, result: { value: TSByRef<IPEndPoint> }): boolean;
}


export type IPEndPoint = IPEndPoint$instance;

export class IPHostEntry$instance {
    constructor();
    AddressList: IPAddress[];
    Aliases: string[];
    HostName: string;
}


export type IPHostEntry = IPHostEntry$instance;

export class NetworkCredential$instance {
    constructor();
    constructor(userName: string, password: string);
    constructor(userName: string, password: string, domain: string);
    constructor(userName: string, password: SecureString);
    constructor(userName: string, password: SecureString, domain: string);
    Domain: string;
    Password: string;
    SecurePassword: SecureString;
    UserName: string;
    GetCredential(uri: Uri, authenticationType: string): NetworkCredential;
    GetCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export interface __NetworkCredential$views {
    readonly As_ICredentials: ICredentials$instance;
    readonly As_ICredentialsByHost: ICredentialsByHost$instance;
}

export type NetworkCredential = NetworkCredential$instance & __NetworkCredential$views;


export class OpenReadCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: Stream;
}


export type OpenReadCompletedEventArgs = OpenReadCompletedEventArgs$instance;

export class OpenReadCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: OpenReadCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: OpenReadCompletedEventArgs): void;
}


export interface __OpenReadCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OpenReadCompletedEventHandler = OpenReadCompletedEventHandler$instance & __OpenReadCompletedEventHandler$views;


export class OpenWriteCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: Stream;
}


export type OpenWriteCompletedEventArgs = OpenWriteCompletedEventArgs$instance;

export class OpenWriteCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: OpenWriteCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: OpenWriteCompletedEventArgs): void;
}


export interface __OpenWriteCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OpenWriteCompletedEventHandler = OpenWriteCompletedEventHandler$instance & __OpenWriteCompletedEventHandler$views;


export class PathList$instance {
    constructor();
}


export type PathList = PathList$instance;

export class ProtocolViolationException$instance extends System_Internal.InvalidOperationException$instance {
    constructor();
    constructor(message: string);
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __ProtocolViolationException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ProtocolViolationException = ProtocolViolationException$instance & __ProtocolViolationException$views;


export class ServicePoint$instance {
    readonly Address: Uri;
    BindIPEndPointDelegate: BindIPEndPoint;
    readonly Certificate: X509Certificate;
    readonly ClientCertificate: X509Certificate;
    ConnectionLeaseTimeout: int;
    ConnectionLimit: int;
    readonly ConnectionName: string;
    readonly CurrentConnections: int;
    Expect100Continue: boolean;
    readonly IdleSince: DateTime;
    MaxIdleTime: int;
    readonly ProtocolVersion: Version;
    ReceiveBufferSize: int;
    readonly SupportsPipelining: boolean;
    UseNagleAlgorithm: boolean;
    CloseConnectionGroup(connectionGroupName: string): boolean;
    SetTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
}


export type ServicePoint = ServicePoint$instance;

export class ServicePointManager$instance {
    static readonly DefaultNonPersistentConnectionLimit: int;
    static readonly DefaultPersistentConnectionLimit: int;
    static SecurityProtocol: SecurityProtocolType;
    static MaxServicePoints: int;
    static DefaultConnectionLimit: int;
    static MaxServicePointIdleTime: int;
    static UseNagleAlgorithm: boolean;
    static Expect100Continue: boolean;
    static EnableDnsRoundRobin: boolean;
    static DnsRefreshTimeout: int;
    static ServerCertificateValidationCallback: RemoteCertificateValidationCallback;
    static ReusePort: boolean;
    static CheckCertificateRevocationList: boolean;
    static readonly EncryptionPolicy: EncryptionPolicy;
    static FindServicePoint(uriString: string, proxy: IWebProxy): ServicePoint;
    static FindServicePoint(address: Uri, proxy: IWebProxy): ServicePoint;
    static FindServicePoint(address: Uri): ServicePoint;
    static SetTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
}


export type ServicePointManager = ServicePointManager$instance;

export class SocketAddress$instance {
    constructor(family: AddressFamily);
    constructor(family: AddressFamily, size: int);
    readonly Buffer: Memory_1<CLROf<byte>>;
    readonly Family: AddressFamily;
    Item: byte;
    Size: int;
    Equals(comparand: any): boolean;
    Equals(comparand: SocketAddress): boolean;
    GetHashCode(): int;
    ToString(): string;
    static GetMaximumAddressSize(addressFamily: AddressFamily): int;
}


export interface __SocketAddress$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<SocketAddress>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SocketAddress): boolean;
}

export type SocketAddress = SocketAddress$instance & __SocketAddress$views;


export abstract class TransportContext$instance {
    abstract GetChannelBinding(kind: ChannelBindingKind): ChannelBinding;
}


export type TransportContext = TransportContext$instance;

export class UploadDataCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: byte[];
}


export type UploadDataCompletedEventArgs = UploadDataCompletedEventArgs$instance;

export class UploadDataCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: UploadDataCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: UploadDataCompletedEventArgs): void;
}


export interface __UploadDataCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadDataCompletedEventHandler = UploadDataCompletedEventHandler$instance & __UploadDataCompletedEventHandler$views;


export class UploadFileCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: byte[];
}


export type UploadFileCompletedEventArgs = UploadFileCompletedEventArgs$instance;

export class UploadFileCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: UploadFileCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: UploadFileCompletedEventArgs): void;
}


export interface __UploadFileCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadFileCompletedEventHandler = UploadFileCompletedEventHandler$instance & __UploadFileCompletedEventHandler$views;


export class UploadProgressChangedEventArgs$instance extends System_ComponentModel_Internal.ProgressChangedEventArgs$instance {
    readonly BytesReceived: long;
    readonly BytesSent: long;
    readonly TotalBytesToReceive: long;
    readonly TotalBytesToSend: long;
}


export type UploadProgressChangedEventArgs = UploadProgressChangedEventArgs$instance;

export class UploadProgressChangedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: UploadProgressChangedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: UploadProgressChangedEventArgs): void;
}


export interface __UploadProgressChangedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadProgressChangedEventHandler = UploadProgressChangedEventHandler$instance & __UploadProgressChangedEventHandler$views;


export class UploadStringCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: string;
}


export type UploadStringCompletedEventArgs = UploadStringCompletedEventArgs$instance;

export class UploadStringCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: UploadStringCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: UploadStringCompletedEventArgs): void;
}


export interface __UploadStringCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadStringCompletedEventHandler = UploadStringCompletedEventHandler$instance & __UploadStringCompletedEventHandler$views;


export class UploadValuesCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly Result: byte[];
}


export type UploadValuesCompletedEventArgs = UploadValuesCompletedEventArgs$instance;

export class UploadValuesCompletedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: UploadValuesCompletedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: UploadValuesCompletedEventArgs): void;
}


export interface __UploadValuesCompletedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadValuesCompletedEventHandler = UploadValuesCompletedEventHandler$instance & __UploadValuesCompletedEventHandler$views;


export class WebClient$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    AllowReadStreamBuffering: boolean;
    AllowWriteStreamBuffering: boolean;
    BaseAddress: string;
    CachePolicy: RequestCachePolicy;
    Credentials: ICredentials;
    Encoding: Encoding;
    Headers: WebHeaderCollection;
    readonly IsBusy: boolean;
    Proxy: IWebProxy;
    QueryString: NameValueCollection;
    readonly ResponseHeaders: WebHeaderCollection;
    UseDefaultCredentials: boolean;
    CancelAsync(): void;
    Dispose(): void;
    DownloadData(address: string): byte[];
    DownloadData(address: Uri): byte[];
    DownloadDataAsync(address: Uri): void;
    DownloadDataAsync(address: Uri, userToken: any): void;
    DownloadDataTaskAsync(address: string): Task_1<byte[]>;
    DownloadDataTaskAsync(address: Uri): Task_1<byte[]>;
    DownloadFile(address: string, fileName: string): void;
    DownloadFile(address: Uri, fileName: string): void;
    DownloadFileAsync(address: Uri, fileName: string): void;
    DownloadFileAsync(address: Uri, fileName: string, userToken: any): void;
    DownloadFileTaskAsync(address: string, fileName: string): Task;
    DownloadFileTaskAsync(address: Uri, fileName: string): Task;
    DownloadString(address: string): string;
    DownloadString(address: Uri): string;
    DownloadStringAsync(address: Uri): void;
    DownloadStringAsync(address: Uri, userToken: any): void;
    DownloadStringTaskAsync(address: string): Task_1<CLROf<string>>;
    DownloadStringTaskAsync(address: Uri): Task_1<CLROf<string>>;
    OpenRead(address: string): Stream;
    OpenRead(address: Uri): Stream;
    OpenReadAsync(address: Uri): void;
    OpenReadAsync(address: Uri, userToken: any): void;
    OpenReadTaskAsync(address: string): Task_1<Stream>;
    OpenReadTaskAsync(address: Uri): Task_1<Stream>;
    OpenWrite(address: string): Stream;
    OpenWrite(address: Uri): Stream;
    OpenWrite(address: string, method: string): Stream;
    OpenWrite(address: Uri, method: string): Stream;
    OpenWriteAsync(address: Uri): void;
    OpenWriteAsync(address: Uri, method: string): void;
    OpenWriteAsync(address: Uri, method: string, userToken: any): void;
    OpenWriteTaskAsync(address: string): Task_1<Stream>;
    OpenWriteTaskAsync(address: Uri): Task_1<Stream>;
    OpenWriteTaskAsync(address: string, method: string): Task_1<Stream>;
    OpenWriteTaskAsync(address: Uri, method: string): Task_1<Stream>;
    UploadData(address: string, data: byte[]): byte[];
    UploadData(address: Uri, data: byte[]): byte[];
    UploadData(address: string, method: string, data: byte[]): byte[];
    UploadData(address: Uri, method: string, data: byte[]): byte[];
    UploadDataAsync(address: Uri, data: byte[]): void;
    UploadDataAsync(address: Uri, method: string, data: byte[]): void;
    UploadDataAsync(address: Uri, method: string, data: byte[], userToken: any): void;
    UploadDataTaskAsync(address: string, data: byte[]): Task_1<byte[]>;
    UploadDataTaskAsync(address: Uri, data: byte[]): Task_1<byte[]>;
    UploadDataTaskAsync(address: string, method: string, data: byte[]): Task_1<byte[]>;
    UploadDataTaskAsync(address: Uri, method: string, data: byte[]): Task_1<byte[]>;
    UploadFile(address: string, fileName: string): byte[];
    UploadFile(address: Uri, fileName: string): byte[];
    UploadFile(address: string, method: string, fileName: string): byte[];
    UploadFile(address: Uri, method: string, fileName: string): byte[];
    UploadFileAsync(address: Uri, fileName: string): void;
    UploadFileAsync(address: Uri, method: string, fileName: string): void;
    UploadFileAsync(address: Uri, method: string, fileName: string, userToken: any): void;
    UploadFileTaskAsync(address: string, fileName: string): Task_1<byte[]>;
    UploadFileTaskAsync(address: Uri, fileName: string): Task_1<byte[]>;
    UploadFileTaskAsync(address: string, method: string, fileName: string): Task_1<byte[]>;
    UploadFileTaskAsync(address: Uri, method: string, fileName: string): Task_1<byte[]>;
    UploadString(address: string, data: string): string;
    UploadString(address: Uri, data: string): string;
    UploadString(address: string, method: string, data: string): string;
    UploadString(address: Uri, method: string, data: string): string;
    UploadStringAsync(address: Uri, data: string): void;
    UploadStringAsync(address: Uri, method: string, data: string): void;
    UploadStringAsync(address: Uri, method: string, data: string, userToken: any): void;
    UploadStringTaskAsync(address: string, data: string): Task_1<CLROf<string>>;
    UploadStringTaskAsync(address: Uri, data: string): Task_1<CLROf<string>>;
    UploadStringTaskAsync(address: string, method: string, data: string): Task_1<CLROf<string>>;
    UploadStringTaskAsync(address: Uri, method: string, data: string): Task_1<CLROf<string>>;
    UploadValues(address: string, data: NameValueCollection): byte[];
    UploadValues(address: Uri, data: NameValueCollection): byte[];
    UploadValues(address: string, method: string, data: NameValueCollection): byte[];
    UploadValues(address: Uri, method: string, data: NameValueCollection): byte[];
    UploadValuesAsync(address: Uri, data: NameValueCollection): void;
    UploadValuesAsync(address: Uri, method: string, data: NameValueCollection): void;
    UploadValuesAsync(address: Uri, method: string, data: NameValueCollection, userToken: any): void;
    UploadValuesTaskAsync(address: string, data: NameValueCollection): Task_1<byte[]>;
    UploadValuesTaskAsync(address: string, method: string, data: NameValueCollection): Task_1<byte[]>;
    UploadValuesTaskAsync(address: Uri, data: NameValueCollection): Task_1<byte[]>;
    UploadValuesTaskAsync(address: Uri, method: string, data: NameValueCollection): Task_1<byte[]>;
}


export interface __WebClient$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type WebClient = WebClient$instance & __WebClient$views;


export class WebException$instance extends System_Internal.InvalidOperationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, status: WebExceptionStatus);
    constructor(message: string, innerException: Exception, status: WebExceptionStatus, response: WebResponse);
    readonly Response: WebResponse;
    readonly Status: WebExceptionStatus;
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __WebException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebException = WebException$instance & __WebException$views;


export class WebHeaderCollection$instance extends System_Collections_Specialized_Internal.NameValueCollection$instance {
    constructor();
    readonly AllKeys: string[];
    readonly Count: int;
    readonly Keys: NameObjectCollectionBase_KeysCollection;
    Add(name: string, value: string): void;
    Add(c: NameValueCollection): void;
    Clear(): void;
    CopyTo(dest: ClrArray, index: int): void;
    Get(index: int): string;
    Get(name: string): string;
    GetEnumerator(): IEnumerator;
    GetKey(index: int): string;
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
    GetValues(index: int): string[];
    GetValues(header: string): string[];
    OnDeserialization(sender: any): void;
    Remove(name: string): void;
    Set(name: string, value: string): void;
    ToByteArray(): byte[];
    ToString(): string;
    static IsRestricted(headerName: string, response: boolean): boolean;
    static IsRestricted(headerName: string): boolean;
}


export interface __WebHeaderCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IDeserializationCallback: System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebHeaderCollection = WebHeaderCollection$instance & __WebHeaderCollection$views;


export class WebProxy$instance {
    constructor();
    constructor(Address: Uri);
    constructor(Address: Uri, BypassOnLocal: boolean);
    constructor(Address: Uri, BypassOnLocal: boolean, BypassList: string[]);
    constructor(Address: Uri, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials);
    constructor(Host: string, Port: int);
    constructor(Address: string);
    constructor(Address: string, BypassOnLocal: boolean);
    constructor(Address: string, BypassOnLocal: boolean, BypassList: string[]);
    constructor(Address: string, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials);
    Address: Uri;
    readonly BypassArrayList: ArrayList;
    BypassList: string[];
    BypassProxyOnLocal: boolean;
    Credentials: ICredentials;
    UseDefaultCredentials: boolean;
    GetProxy(destination: Uri): Uri;
    IsBypassed(host: Uri): boolean;
    static GetDefaultProxy(): WebProxy;
}


export interface __WebProxy$views {
    readonly As_IWebProxy: IWebProxy$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebProxy = WebProxy$instance & __WebProxy$views;


export abstract class WebRequest$instance extends System_Internal.MarshalByRefObject$instance {
    AuthenticationLevel: AuthenticationLevel;
    CachePolicy: RequestCachePolicy;
    ConnectionGroupName: string;
    ContentLength: long;
    ContentType: string;
    Credentials: ICredentials;
    Headers: WebHeaderCollection;
    ImpersonationLevel: TokenImpersonationLevel;
    Method: string;
    PreAuthenticate: boolean;
    Proxy: IWebProxy;
    readonly RequestUri: Uri;
    Timeout: int;
    UseDefaultCredentials: boolean;
    Abort(): void;
    BeginGetRequestStream(callback: AsyncCallback, state: any): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: any): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetRequestStream(): Stream;
    GetRequestStreamAsync(): Task_1<Stream>;
    GetResponse(): WebResponse;
    GetResponseAsync(): Task_1<WebResponse>;
    static DefaultCachePolicy: RequestCachePolicy;
    static DefaultWebProxy: IWebProxy;
    static Create(requestUriString: string): WebRequest;
    static Create(requestUri: Uri): WebRequest;
    static CreateDefault(requestUri: Uri): WebRequest;
    static CreateHttp(requestUriString: string): HttpWebRequest;
    static CreateHttp(requestUri: Uri): HttpWebRequest;
    static GetSystemWebProxy(): IWebProxy;
    static RegisterPrefix(prefix: string, creator: IWebRequestCreate): boolean;
}


export interface __WebRequest$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebRequest = WebRequest$instance & __WebRequest$views;


export abstract class WebResponse$instance extends System_Internal.MarshalByRefObject$instance {
    ContentLength: long;
    ContentType: string;
    readonly Headers: WebHeaderCollection;
    readonly IsFromCache: boolean;
    readonly IsMutuallyAuthenticated: boolean;
    readonly ResponseUri: Uri;
    readonly SupportsHeaders: boolean;
    Close(): void;
    Dispose(): void;
    GetResponseStream(): Stream;
}


export interface __WebResponse$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebResponse = WebResponse$instance & __WebResponse$views;


export class WriteStreamClosedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    readonly Error: Exception;
}


export type WriteStreamClosedEventArgs = WriteStreamClosedEventArgs$instance;

export class WriteStreamClosedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: WriteStreamClosedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: WriteStreamClosedEventArgs): void;
}


export interface __WriteStreamClosedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WriteStreamClosedEventHandler = WriteStreamClosedEventHandler$instance & __WriteStreamClosedEventHandler$views;


export abstract class Dns$instance {
    static BeginGetHostAddresses(hostNameOrAddress: string, requestCallback: AsyncCallback, state: any): IAsyncResult;
    static BeginGetHostByName(hostName: string, requestCallback: AsyncCallback, stateObject: any): IAsyncResult;
    static BeginGetHostEntry(address: IPAddress, requestCallback: AsyncCallback, stateObject: any): IAsyncResult;
    static BeginGetHostEntry(hostNameOrAddress: string, requestCallback: AsyncCallback, stateObject: any): IAsyncResult;
    static BeginResolve(hostName: string, requestCallback: AsyncCallback, stateObject: any): IAsyncResult;
    static EndGetHostAddresses(asyncResult: IAsyncResult): IPAddress[];
    static EndGetHostByName(asyncResult: IAsyncResult): IPHostEntry;
    static EndGetHostEntry(asyncResult: IAsyncResult): IPHostEntry;
    static EndResolve(asyncResult: IAsyncResult): IPHostEntry;
    static GetHostAddresses(hostNameOrAddress: string, family: AddressFamily): IPAddress[];
    static GetHostAddresses(hostNameOrAddress: string): IPAddress[];
    static GetHostAddressesAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPAddress[]>;
    static GetHostAddressesAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPAddress[]>;
    static GetHostAddressesAsync(hostNameOrAddress: string): Task_1<IPAddress[]>;
    static GetHostByAddress(address: IPAddress): IPHostEntry;
    static GetHostByAddress(address: string): IPHostEntry;
    static GetHostByName(hostName: string): IPHostEntry;
    static GetHostEntry(address: IPAddress): IPHostEntry;
    static GetHostEntry(hostNameOrAddress: string, family: AddressFamily): IPHostEntry;
    static GetHostEntry(hostNameOrAddress: string): IPHostEntry;
    static GetHostEntryAsync(address: IPAddress): Task_1<IPHostEntry>;
    static GetHostEntryAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPHostEntry>;
    static GetHostEntryAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPHostEntry>;
    static GetHostEntryAsync(hostNameOrAddress: string): Task_1<IPHostEntry>;
    static GetHostName(): string;
    static Resolve(hostName: string): IPHostEntry;
}


export type Dns = Dns$instance;

export abstract class HttpVersion$instance {
    static readonly Unknown: Version;
    static readonly Version10: Version;
    static readonly Version11: Version;
    static readonly Version20: Version;
    static readonly Version30: Version;
}


export type HttpVersion = HttpVersion$instance;

export abstract class WebRequestMethods$instance {
}


export type WebRequestMethods = WebRequestMethods$instance;

export abstract class WebRequestMethods_File$instance {
    static readonly DownloadFile: string;
    static readonly UploadFile: string;
}


export type WebRequestMethods_File = WebRequestMethods_File$instance;

export abstract class WebRequestMethods_Ftp$instance {
    static readonly DownloadFile: string;
    static readonly ListDirectory: string;
    static readonly UploadFile: string;
    static readonly DeleteFile: string;
    static readonly AppendFile: string;
    static readonly GetFileSize: string;
    static readonly UploadFileWithUniqueName: string;
    static readonly MakeDirectory: string;
    static readonly RemoveDirectory: string;
    static readonly ListDirectoryDetails: string;
    static readonly GetDateTimestamp: string;
    static readonly PrintWorkingDirectory: string;
    static readonly Rename: string;
}


export type WebRequestMethods_Ftp = WebRequestMethods_Ftp$instance;

export abstract class WebRequestMethods_Http$instance {
    static readonly Get: string;
    static readonly Connect: string;
    static readonly Head: string;
    static readonly Put: string;
    static readonly Post: string;
    static readonly MkCol: string;
}


export type WebRequestMethods_Http = WebRequestMethods_Http$instance;

export abstract class WebUtility$instance {
    static HtmlDecode(value: string, output: TextWriter): void;
    static HtmlDecode(value: string): string;
    static HtmlEncode(value: string, output: TextWriter): void;
    static HtmlEncode(value: string): string;
    static UrlDecode(encodedValue: string): string;
    static UrlDecodeToBytes(encodedValue: byte[], offset: int, count: int): byte[];
    static UrlEncode(value: string): string;
    static UrlEncodeToBytes(value: byte[], offset: int, count: int): byte[];
}


export type WebUtility = WebUtility$instance;

