// Generated by tsbindgen - Architecture
// Namespace: System.Net
// Assembly: System.Net.HttpListener, System.Net.NameResolution, System.Net.Primitives, System.Net.Requests, System.Net.WebClient, System.Net.WebHeaderCollection, System.Net.WebProxy, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyCollection_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Specialized_Internal from "../../System.Collections.Specialized/internal/index.js";
import type { NameObjectCollectionBase_KeysCollection, NameValueCollection, StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, AsyncCompletedEventHandler, Component, IComponent, IContainer, ISite, ProgressChangedEventArgs, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import type { BinaryWriter, Stream, TextWriter } from "../../System.IO/internal/index.js";
import type { RequestCachePolicy } from "../../System.Net.Cache/internal/index.js";
import type { AuthenticationLevel, EncryptionPolicy, RemoteCertificateValidationCallback } from "../../System.Net.Security/internal/index.js";
import type { AddressFamily } from "../../System.Net.Sockets/internal/index.js";
import type { HttpListenerWebSocketContext } from "../../System.Net.WebSockets/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ChannelBinding, ChannelBindingKind, ExtendedProtectionPolicy, ServiceNameCollection } from "../../System.Security.Authentication.ExtendedProtection/internal/index.js";
import type { Claim, ClaimsIdentity } from "../../System.Security.Claims/internal/index.js";
import type { X509Certificate, X509Certificate2, X509CertificateCollection } from "../../System.Security.Cryptography.X509Certificates/internal/index.js";
import * as System_Security_Principal_Internal from "../../System.Security.Principal/internal/index.js";
import type { GenericIdentity, IIdentity, IPrincipal, TokenImpersonationLevel } from "../../System.Security.Principal/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Delegate, Enum, EventArgs, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Uri, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AuthenticationSchemes {
    none = 0,
    digest = 1,
    negotiate = 2,
    ntlm = 4,
    basic = 8,
    anonymous = 32768,
    integratedWindowsAuthentication = 6
}


export enum CookieVariant {
    unknown_ = 0,
    plain = 1,
    rfc2109 = 2,
    rfc2965 = 3,
    default_ = 2
}


export enum DecompressionMethods {
    none = 0,
    gZip = 1,
    deflate = 2,
    brotli = 4,
    all = -1
}


export enum FtpStatusCode {
    undefined = 0,
    restartMarker = 110,
    serviceTemporarilyNotAvailable = 120,
    dataAlreadyOpen = 125,
    openingData = 150,
    commandOK = 200,
    commandExtraneous = 202,
    directoryStatus = 212,
    fileStatus = 213,
    systemType = 215,
    sendUserCommand = 220,
    closingControl = 221,
    closingData = 226,
    enteringPassive = 227,
    loggedInProceed = 230,
    serverWantsSecureSession = 234,
    fileActionOK = 250,
    pathnameCreated = 257,
    sendPasswordCommand = 331,
    needLoginAccount = 332,
    fileCommandPending = 350,
    serviceNotAvailable = 421,
    cantOpenData = 425,
    connectionClosed = 426,
    actionNotTakenFileUnavailableOrBusy = 450,
    actionAbortedLocalProcessingError = 451,
    actionNotTakenInsufficientSpace = 452,
    commandSyntaxError = 500,
    argumentSyntaxError = 501,
    commandNotImplemented = 502,
    badCommandSequence = 503,
    notLoggedIn = 530,
    accountNeeded = 532,
    actionNotTakenFileUnavailable = 550,
    actionAbortedUnknownPageType = 551,
    fileActionAborted = 552,
    actionNotTakenFilenameNotAllowed = 553
}


export enum HttpRequestHeader {
    cacheControl = 0,
    connection = 1,
    date = 2,
    keepAlive = 3,
    pragma = 4,
    trailer = 5,
    transferEncoding = 6,
    upgrade = 7,
    via = 8,
    warning = 9,
    allow = 10,
    contentLength = 11,
    contentType = 12,
    contentEncoding = 13,
    contentLanguage = 14,
    contentLocation = 15,
    contentMd5 = 16,
    contentRange = 17,
    expires = 18,
    lastModified = 19,
    accept = 20,
    acceptCharset = 21,
    acceptEncoding = 22,
    acceptLanguage = 23,
    authorization = 24,
    cookie = 25,
    expect = 26,
    from_ = 27,
    host = 28,
    ifMatch = 29,
    ifModifiedSince = 30,
    ifNoneMatch = 31,
    ifRange = 32,
    ifUnmodifiedSince = 33,
    maxForwards = 34,
    proxyAuthorization = 35,
    referer = 36,
    range = 37,
    te = 38,
    translate = 39,
    userAgent = 40
}


export enum HttpResponseHeader {
    cacheControl = 0,
    connection = 1,
    date = 2,
    keepAlive = 3,
    pragma = 4,
    trailer = 5,
    transferEncoding = 6,
    upgrade = 7,
    via = 8,
    warning = 9,
    allow = 10,
    contentLength = 11,
    contentType = 12,
    contentEncoding = 13,
    contentLanguage = 14,
    contentLocation = 15,
    contentMd5 = 16,
    contentRange = 17,
    expires = 18,
    lastModified = 19,
    acceptRanges = 20,
    age = 21,
    eTag = 22,
    location = 23,
    proxyAuthenticate = 24,
    retryAfter = 25,
    server = 26,
    setCookie = 27,
    vary = 28,
    wwwAuthenticate = 29
}


export enum HttpStatusCode {
    continue_ = 100,
    switchingProtocols = 101,
    processing = 102,
    earlyHints = 103,
    OK = 200,
    created = 201,
    accepted = 202,
    nonAuthoritativeInformation = 203,
    noContent = 204,
    resetContent = 205,
    partialContent = 206,
    multiStatus = 207,
    alreadyReported = 208,
    imUsed = 226,
    multipleChoices = 300,
    ambiguous = 300,
    movedPermanently = 301,
    moved = 301,
    found = 302,
    redirect = 302,
    seeOther = 303,
    redirectMethod = 303,
    notModified = 304,
    useProxy = 305,
    unused = 306,
    temporaryRedirect = 307,
    redirectKeepVerb = 307,
    permanentRedirect = 308,
    badRequest = 400,
    unauthorized = 401,
    paymentRequired = 402,
    forbidden = 403,
    notFound = 404,
    methodNotAllowed = 405,
    notAcceptable = 406,
    proxyAuthenticationRequired = 407,
    requestTimeout = 408,
    conflict = 409,
    gone = 410,
    lengthRequired = 411,
    preconditionFailed = 412,
    requestEntityTooLarge = 413,
    requestUriTooLong = 414,
    unsupportedMediaType = 415,
    requestedRangeNotSatisfiable = 416,
    expectationFailed = 417,
    misdirectedRequest = 421,
    unprocessableEntity = 422,
    unprocessableContent = 422,
    locked = 423,
    failedDependency = 424,
    upgradeRequired = 426,
    preconditionRequired = 428,
    tooManyRequests = 429,
    requestHeaderFieldsTooLarge = 431,
    unavailableForLegalReasons = 451,
    internalServerError = 500,
    notImplemented = 501,
    badGateway = 502,
    serviceUnavailable = 503,
    gatewayTimeout = 504,
    httpVersionNotSupported = 505,
    variantAlsoNegotiates = 506,
    insufficientStorage = 507,
    loopDetected = 508,
    notExtended = 510,
    networkAuthenticationRequired = 511
}


export enum SecurityProtocolType {
    systemDefault = 0,
    ssl3 = 48,
    tls = 192,
    tls11 = 768,
    tls12 = 3072,
    tls13 = 12288
}


export enum WebExceptionStatus {
    success = 0,
    nameResolutionFailure = 1,
    connectFailure = 2,
    receiveFailure = 3,
    sendFailure = 4,
    pipelineFailure = 5,
    requestCanceled = 6,
    protocolError = 7,
    connectionClosed = 8,
    trustFailure = 9,
    secureChannelFailure = 10,
    serverProtocolViolation = 11,
    keepAliveFailure = 12,
    pending = 13,
    timeout = 14,
    proxyNameResolutionFailure = 15,
    unknownError = 16,
    messageLengthLimitExceeded = 17,
    cacheEntryNotFound = 18,
    requestProhibitedByCachePolicy = 19,
    requestProhibitedByProxy = 20
}


export interface IAuthenticationModule$instance {
    readonly canPreAuthenticate: boolean;
    readonly authenticationType: string;
    authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    preAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
}


export type IAuthenticationModule = IAuthenticationModule$instance;

export interface ICredentialPolicy$instance {
    shouldSendCredential(challengeUri: Uri, request: WebRequest, credential: NetworkCredential, authenticationModule: IAuthenticationModule): boolean;
}


export type ICredentialPolicy = ICredentialPolicy$instance;

export interface ICredentials$instance {
    getCredential(uri: Uri, authType: string): NetworkCredential;
}


export type ICredentials = ICredentials$instance;

export interface ICredentialsByHost$instance {
    getCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export type ICredentialsByHost = ICredentialsByHost$instance;

export interface IWebProxy$instance {
    credentials: ICredentials;
    getProxy(destination: Uri): Uri;
    isBypassed(host: Uri): boolean;
}


export type IWebProxy = IWebProxy$instance;

export interface IWebProxyScript$instance {
    close(): void;
    load(scriptLocation: Uri, script: string, helperType: Type): boolean;
    run(url: string, host: string): string;
}


export type IWebProxyScript = IWebProxyScript$instance;

export interface IWebRequestCreate$instance {
    create(uri: Uri): WebRequest;
}


export type IWebRequestCreate = IWebRequestCreate$instance;

export class IPNetwork$instance {
    constructor(baseAddress: IPAddress, prefixLength: int);
    readonly baseAddress: IPAddress;
    readonly prefixLength: int;
    contains(address: IPAddress): boolean;
    equals(other: IPNetwork): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPNetwork;
    static parse(s: ReadOnlySpan_1<CLROf<char>>): IPNetwork;
    static parse(s: string): IPNetwork;
    static tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<IPNetwork> }): boolean;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<IPNetwork> }): boolean;
    static tryParse(s: string, result: { value: ref<IPNetwork> }): boolean;
}


export interface __IPNetwork$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<IPNetwork>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<IPNetwork>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<IPNetwork>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<IPNetwork>;

    // Structural method bridges for numeric interface constraints
    Equals(other: IPNetwork): boolean;
}

export interface IPNetwork$instance extends System_Internal.ISpanParsable_1$instance<IPNetwork> {}

export type IPNetwork = IPNetwork$instance & __IPNetwork$views;


export class AuthenticationManager$instance {
    static credentialPolicy: ICredentialPolicy;
    static readonly customTargetNameDictionary: StringDictionary;
    static readonly registeredModules: IEnumerator;
    static authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    static preAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
    static register(authenticationModule: IAuthenticationModule): void;
    static unregister(authenticationModule: IAuthenticationModule): void;
    static unregister(authenticationScheme: string): void;
}


export type AuthenticationManager = AuthenticationManager$instance;

export class AuthenticationSchemeSelector$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(httpRequest: HttpListenerRequest, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): AuthenticationSchemes;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(httpRequest: HttpListenerRequest): AuthenticationSchemes;
}


export interface __AuthenticationSchemeSelector$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AuthenticationSchemeSelector = AuthenticationSchemeSelector$instance & __AuthenticationSchemeSelector$views;


export class Authorization$instance {
    constructor(token: string);
    constructor(token: string, finished: boolean);
    constructor(token: string, finished: boolean, connectionGroupId: string);
    readonly complete: boolean;
    readonly connectionGroupId: string;
    readonly message: string;
    mutuallyAuthenticated: boolean;
    protectionRealm: string[];
}


export type Authorization = Authorization$instance;

export class BindIPEndPoint$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(servicePoint: ServicePoint, remoteEndPoint: IPEndPoint, retryCount: int, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): IPEndPoint;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(servicePoint: ServicePoint, remoteEndPoint: IPEndPoint, retryCount: int): IPEndPoint;
}


export interface __BindIPEndPoint$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BindIPEndPoint = BindIPEndPoint$instance & __BindIPEndPoint$views;


export class Cookie$instance {
    constructor();
    constructor(name: string, value: string);
    constructor(name: string, value: string, path: string);
    constructor(name: string, value: string, path: string, domain: string);
    comment: string;
    commentUri: Uri;
    discard: boolean;
    domain: string;
    expired: boolean;
    expires: DateTime;
    httpOnly: boolean;
    name: string;
    path: string;
    port: string;
    secure: boolean;
    readonly timeStamp: DateTime;
    value: string;
    version: int;
    equals(comparand: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export type Cookie = Cookie$instance;

export class CookieCollection$instance {
    constructor();
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    add(cookie: Cookie): void;
    add(cookies: CookieCollection): void;
    clear(): void;
    contains(cookie: Cookie): boolean;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: Cookie[], index: int): void;
    get_Item(index: int): Cookie;
    get_Item(name: string): Cookie;
    getEnumerator(): IEnumerator;
    remove(cookie: Cookie): boolean;
}


export interface __CookieCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Cookie>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Cookie>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Cookie>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type CookieCollection = CookieCollection$instance & __CookieCollection$views;


export class CookieContainer$instance {
    constructor();
    constructor(capacity: int);
    constructor(capacity: int, perDomainCapacity: int, maxCookieSize: int);
    capacity: int;
    readonly count: int;
    maxCookieSize: int;
    perDomainCapacity: int;
    add(cookie: Cookie): void;
    add(cookies: CookieCollection): void;
    add(uri: Uri, cookie: Cookie): void;
    add(uri: Uri, cookies: CookieCollection): void;
    getAllCookies(): CookieCollection;
    getCookieHeader(uri: Uri): string;
    getCookies(uri: Uri): CookieCollection;
    setCookies(uri: Uri, cookieHeader: string): void;
    static readonly defaultCookieLimit: int;
    static readonly defaultPerDomainCookieLimit: int;
    static readonly defaultCookieLengthLimit: int;
}


export type CookieContainer = CookieContainer$instance;

export class CookieException$instance extends System_Internal.FormatException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __CookieException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CookieException = CookieException$instance & __CookieException$views;


export class CredentialCache$instance {
    constructor();
    add(uriPrefix: Uri, authType: string, cred: NetworkCredential): void;
    add(host: string, port: int, authenticationType: string, credential: NetworkCredential): void;
    getCredential(uriPrefix: Uri, authType: string): NetworkCredential;
    getCredential(host: string, port: int, authenticationType: string): NetworkCredential;
    getEnumerator(): IEnumerator;
    remove(uriPrefix: Uri, authType: string): void;
    remove(host: string, port: int, authenticationType: string): void;
    static readonly defaultCredentials: ICredentials;
    static readonly defaultNetworkCredentials: NetworkCredential;
}


export interface __CredentialCache$views {
    As_ICredentials(): ICredentials$instance;
    As_ICredentialsByHost(): ICredentialsByHost$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface CredentialCache$instance extends System_Collections_Internal.IEnumerable$instance {}

export type CredentialCache = CredentialCache$instance & __CredentialCache$views;


export class DnsEndPoint$instance extends EndPoint$instance {
    constructor(host: string, port: int);
    constructor(host: string, port: int, addressFamily: AddressFamily);
    readonly addressFamily: AddressFamily;
    readonly host: string;
    readonly port: int;
    equals(comparand: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export type DnsEndPoint = DnsEndPoint$instance;

export class DownloadDataCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: byte[];
}


export type DownloadDataCompletedEventArgs = DownloadDataCompletedEventArgs$instance;

export class DownloadDataCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: DownloadDataCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: DownloadDataCompletedEventArgs): void;
}


export interface __DownloadDataCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DownloadDataCompletedEventHandler = DownloadDataCompletedEventHandler$instance & __DownloadDataCompletedEventHandler$views;


export class DownloadProgressChangedEventArgs$instance extends System_ComponentModel_Internal.ProgressChangedEventArgs$instance {
    readonly bytesReceived: long;
    readonly totalBytesToReceive: long;
}


export type DownloadProgressChangedEventArgs = DownloadProgressChangedEventArgs$instance;

export class DownloadProgressChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: DownloadProgressChangedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: DownloadProgressChangedEventArgs): void;
}


export interface __DownloadProgressChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DownloadProgressChangedEventHandler = DownloadProgressChangedEventHandler$instance & __DownloadProgressChangedEventHandler$views;


export class DownloadStringCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: string;
}


export type DownloadStringCompletedEventArgs = DownloadStringCompletedEventArgs$instance;

export class DownloadStringCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: DownloadStringCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: DownloadStringCompletedEventArgs): void;
}


export interface __DownloadStringCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DownloadStringCompletedEventHandler = DownloadStringCompletedEventHandler$instance & __DownloadStringCompletedEventHandler$views;


export abstract class EndPoint$instance {
    readonly addressFamily: AddressFamily;
    create(socketAddress: SocketAddress): EndPoint;
    serialize(): SocketAddress;
}


export type EndPoint = EndPoint$instance;

export class FileWebRequest$instance extends WebRequest$instance {
    connectionGroupName: string;
    contentLength: long;
    contentType: string;
    credentials: ICredentials;
    readonly headers: WebHeaderCollection;
    method: string;
    preAuthenticate: boolean;
    proxy: IWebProxy;
    readonly requestUri: Uri;
    timeout: int;
    useDefaultCredentials: boolean;
    abort(): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRequestStream(): Stream;
    getRequestStreamAsync(): Task_1<Stream>;
    getRequestStreamAsync(): Task_1<Stream>;
    getResponse(): WebResponse;
    getResponseAsync(): Task_1<WebResponse>;
    getResponseAsync(): Task_1<WebResponse>;
}


export interface __FileWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileWebRequest = FileWebRequest$instance & __FileWebRequest$views;


export class FileWebResponse$instance extends WebResponse$instance {
    readonly contentLength: long;
    readonly contentType: string;
    readonly headers: WebHeaderCollection;
    readonly responseUri: Uri;
    readonly supportsHeaders: boolean;
    close(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getResponseStream(): Stream;
}


export interface __FileWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileWebResponse = FileWebResponse$instance & __FileWebResponse$views;


export class FtpWebRequest$instance extends WebRequest$instance {
    cachePolicy: RequestCachePolicy;
    clientCertificates: X509CertificateCollection;
    connectionGroupName: string;
    contentLength: long;
    contentOffset: long;
    contentType: string;
    credentials: ICredentials;
    enableSsl: boolean;
    headers: WebHeaderCollection;
    keepAlive: boolean;
    method: string;
    preAuthenticate: boolean;
    proxy: IWebProxy;
    readWriteTimeout: int;
    renameTo: string;
    readonly requestUri: Uri;
    readonly servicePoint: ServicePoint;
    timeout: int;
    useBinary: boolean;
    useDefaultCredentials: boolean;
    usePassive: boolean;
    abort(): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRequestStream(): Stream;
    getResponse(): WebResponse;
    static defaultCachePolicy: RequestCachePolicy;
}


export interface __FtpWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FtpWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FtpWebRequest = FtpWebRequest$instance & __FtpWebRequest$views;


export class FtpWebResponse$instance extends WebResponse$instance {
    readonly bannerMessage: string;
    readonly contentLength: long;
    readonly exitMessage: string;
    readonly headers: WebHeaderCollection;
    readonly lastModified: DateTime;
    readonly responseUri: Uri;
    readonly statusCode: FtpStatusCode;
    readonly statusDescription: string;
    readonly supportsHeaders: boolean;
    readonly welcomeMessage: string;
    close(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getResponseStream(): Stream;
}


export interface __FtpWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FtpWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FtpWebResponse = FtpWebResponse$instance & __FtpWebResponse$views;


export class GlobalProxySelection$instance {
    constructor();
    static select: IWebProxy;
    static getEmptyWebProxy(): IWebProxy;
}


export type GlobalProxySelection = GlobalProxySelection$instance;

export class HttpContinueDelegate$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(StatusCode: int, httpHeaders: WebHeaderCollection, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(StatusCode: int, httpHeaders: WebHeaderCollection): void;
}


export interface __HttpContinueDelegate$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpContinueDelegate = HttpContinueDelegate$instance & __HttpContinueDelegate$views;


export class HttpListener$instance {
    constructor();
    authenticationSchemes: AuthenticationSchemes;
    authenticationSchemeSelectorDelegate: AuthenticationSchemeSelector;
    readonly defaultServiceNames: ServiceNameCollection;
    extendedProtectionPolicy: ExtendedProtectionPolicy;
    extendedProtectionSelectorDelegate: HttpListener_ExtendedProtectionSelector;
    ignoreWriteExceptions: boolean;
    readonly isListening: boolean;
    readonly prefixes: HttpListenerPrefixCollection;
    realm: string;
    readonly timeoutManager: HttpListenerTimeoutManager;
    unsafeConnectionNtlmAuthentication: boolean;
    abort(): void;
    beginGetContext(callback: AsyncCallback, state: unknown): IAsyncResult;
    close(): void;
    endGetContext(asyncResult: IAsyncResult): HttpListenerContext;
    getContext(): HttpListenerContext;
    getContextAsync(): Task_1<HttpListenerContext>;
    start(): void;
    stop(): void;
    static readonly isSupported: boolean;
}


export interface __HttpListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface HttpListener$instance extends System_Internal.IDisposable$instance {}

export type HttpListener = HttpListener$instance & __HttpListener$views;


export class HttpListener_ExtendedProtectionSelector$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(request: HttpListenerRequest, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): ExtendedProtectionPolicy;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(request: HttpListenerRequest): ExtendedProtectionPolicy;
}


export interface __HttpListener_ExtendedProtectionSelector$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpListener_ExtendedProtectionSelector = HttpListener_ExtendedProtectionSelector$instance & __HttpListener_ExtendedProtectionSelector$views;


export class HttpListenerBasicIdentity$instance extends System_Security_Principal_Internal.GenericIdentity$instance {
    constructor(username: string, password: string);
    readonly password: string;
}


export interface __HttpListenerBasicIdentity$views {
    As_IIdentity(): System_Security_Principal_Internal.IIdentity$instance;
}

export interface HttpListenerBasicIdentity$instance extends System_Security_Principal_Internal.IIdentity$instance {}

export type HttpListenerBasicIdentity = HttpListenerBasicIdentity$instance & __HttpListenerBasicIdentity$views;


export class HttpListenerContext$instance {
    readonly request: HttpListenerRequest;
    readonly response: HttpListenerResponse;
    readonly user: IPrincipal;
    acceptWebSocketAsync(subProtocol: string): Task_1<HttpListenerWebSocketContext>;
    acceptWebSocketAsync(subProtocol: string, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    acceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    acceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan, internalBuffer: ArraySegment_1<CLROf<byte>>): Task_1<HttpListenerWebSocketContext>;
}


export type HttpListenerContext = HttpListenerContext$instance;

export class HttpListenerException$instance extends System_ComponentModel_Internal.Win32Exception$instance {
    constructor();
    constructor(errorCode: int);
    constructor(errorCode: int, message: string);
    readonly errorCode: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __HttpListenerException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpListenerException = HttpListenerException$instance & __HttpListenerException$views;


export class HttpListenerPrefixCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    add(uriPrefix: string): void;
    clear(): void;
    contains(uriPrefix: string): boolean;
    copyTo(array: ClrArray, offset: int): void;
    copyTo(array: string[], offset: int): void;
    getEnumerator(): IEnumerator_1<CLROf<string>>;
    remove(uriPrefix: string): boolean;
}


export interface __HttpListenerPrefixCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<CLROf<string>>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CLROf<string>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpListenerPrefixCollection = HttpListenerPrefixCollection$instance & __HttpListenerPrefixCollection$views;


export class HttpListenerRequest$instance {
    readonly acceptTypes: string[];
    readonly clientCertificateError: int;
    readonly contentEncoding: Encoding;
    readonly contentLength64: long;
    readonly contentType: string;
    readonly cookies: CookieCollection;
    readonly hasEntityBody: boolean;
    readonly headers: NameValueCollection;
    readonly httpMethod: string;
    readonly inputStream: Stream;
    readonly isAuthenticated: boolean;
    readonly isLocal: boolean;
    readonly isSecureConnection: boolean;
    readonly isWebSocketRequest: boolean;
    readonly keepAlive: boolean;
    readonly localEndPoint: IPEndPoint;
    readonly protocolVersion: Version;
    readonly queryString: NameValueCollection;
    readonly rawUrl: string;
    readonly remoteEndPoint: IPEndPoint;
    readonly requestTraceIdentifier: Guid;
    readonly serviceName: string;
    readonly transportContext: TransportContext;
    readonly url: Uri;
    readonly urlReferrer: Uri;
    readonly userAgent: string;
    readonly userHostAddress: string;
    readonly userHostName: string;
    readonly userLanguages: string[];
    beginGetClientCertificate(requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    endGetClientCertificate(asyncResult: IAsyncResult): X509Certificate2;
    getClientCertificate(): X509Certificate2;
    getClientCertificateAsync(): Task_1<X509Certificate2>;
}


export type HttpListenerRequest = HttpListenerRequest$instance;

export class HttpListenerResponse$instance {
    contentEncoding: Encoding;
    contentLength64: long;
    contentType: string;
    cookies: CookieCollection;
    headers: WebHeaderCollection;
    keepAlive: boolean;
    readonly outputStream: Stream;
    protocolVersion: Version;
    redirectLocation: string;
    sendChunked: boolean;
    statusCode: int;
    statusDescription: string;
    abort(): void;
    addHeader(name: string, value: string): void;
    appendCookie(cookie: Cookie): void;
    appendHeader(name: string, value: string): void;
    close(): void;
    close(responseEntity: byte[], willBlock: boolean): void;
    copyFrom(templateResponse: HttpListenerResponse): void;
    redirect(url: string): void;
    setCookie(cookie: Cookie): void;
}


export interface __HttpListenerResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface HttpListenerResponse$instance extends System_Internal.IDisposable$instance {}

export type HttpListenerResponse = HttpListenerResponse$instance & __HttpListenerResponse$views;


export class HttpListenerTimeoutManager$instance {
    drainEntityBody: TimeSpan;
    entityBody: TimeSpan;
    headerWait: TimeSpan;
    idleConnection: TimeSpan;
    minSendBytesPerSecond: long;
    requestQueue: TimeSpan;
}


export type HttpListenerTimeoutManager = HttpListenerTimeoutManager$instance;

export class HttpWebRequest$instance extends WebRequest$instance {
    accept: string;
    readonly address: Uri;
    allowAutoRedirect: boolean;
    allowReadStreamBuffering: boolean;
    allowWriteStreamBuffering: boolean;
    automaticDecompression: DecompressionMethods;
    clientCertificates: X509CertificateCollection;
    connection: string;
    connectionGroupName: string;
    contentLength: long;
    contentType: string;
    continueDelegate: HttpContinueDelegate;
    continueTimeout: int;
    cookieContainer: CookieContainer;
    credentials: ICredentials;
    date: DateTime;
    expect: string;
    readonly haveResponse: boolean;
    headers: WebHeaderCollection;
    host: string;
    ifModifiedSince: DateTime;
    keepAlive: boolean;
    maximumAutomaticRedirections: int;
    maximumResponseHeadersLength: int;
    mediaType: string;
    method: string;
    pipelined: boolean;
    preAuthenticate: boolean;
    protocolVersion: Version;
    proxy: IWebProxy;
    readWriteTimeout: int;
    referer: string;
    readonly requestUri: Uri;
    sendChunked: boolean;
    serverCertificateValidationCallback: RemoteCertificateValidationCallback;
    readonly servicePoint: ServicePoint;
    readonly supportsCookieContainer: boolean;
    timeout: int;
    transferEncoding: string;
    unsafeAuthenticatedConnectionSharing: boolean;
    useDefaultCredentials: boolean;
    userAgent: string;
    abort(): void;
    addRange(from_: int, to: int): void;
    addRange(from_: long, to: long): void;
    addRange(range: int): void;
    addRange(range: long): void;
    addRange(rangeSpecifier: string, from_: int, to: int): void;
    addRange(rangeSpecifier: string, from_: long, to: long): void;
    addRange(rangeSpecifier: string, range: int): void;
    addRange(rangeSpecifier: string, range: long): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRequestStream(): Stream;
    getResponse(): WebResponse;
    static defaultMaximumResponseHeadersLength: int;
    static defaultMaximumErrorResponseLength: int;
    static defaultCachePolicy: RequestCachePolicy;
}


export interface __HttpWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HttpWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HttpWebRequest = HttpWebRequest$instance & __HttpWebRequest$views;


export class HttpWebResponse$instance extends WebResponse$instance {
    constructor();
    readonly characterSet: string;
    readonly contentEncoding: string;
    readonly contentLength: long;
    readonly contentType: string;
    cookies: CookieCollection;
    readonly headers: WebHeaderCollection;
    readonly isMutuallyAuthenticated: boolean;
    readonly lastModified: DateTime;
    readonly method: string;
    readonly protocolVersion: Version;
    readonly responseUri: Uri;
    readonly server: string;
    readonly statusCode: HttpStatusCode;
    readonly statusDescription: string;
    readonly supportsHeaders: boolean;
    close(): void;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getResponseHeader(headerName: string): string;
    getResponseStream(): Stream;
}


export interface __HttpWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HttpWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HttpWebResponse = HttpWebResponse$instance & __HttpWebResponse$views;


export class IPAddress$instance {
    constructor(newAddress: long);
    constructor(address: byte[], scopeid: long);
    constructor(address: ReadOnlySpan_1<CLROf<byte>>, scopeid: long);
    constructor(address: byte[]);
    constructor(address: ReadOnlySpan_1<CLROf<byte>>);
    address: long;
    readonly addressFamily: AddressFamily;
    readonly isIPv4MappedToIPv6: boolean;
    readonly isIPv6LinkLocal: boolean;
    readonly isIPv6Multicast: boolean;
    readonly isIPv6SiteLocal: boolean;
    readonly isIPv6Teredo: boolean;
    readonly isIPv6UniqueLocal: boolean;
    scopeId: long;
    equals(comparand: unknown): boolean;
    getAddressBytes(): byte[];
    getHashCode(): int;
    mapToIPv4(): IPAddress;
    mapToIPv6(): IPAddress;
    toString(): string;
    tryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    tryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    tryWriteBytes(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static readonly any_: IPAddress;
    static readonly loopback: IPAddress;
    static readonly broadcast: IPAddress;
    static readonly none: IPAddress;
    static readonly iPv6Any: IPAddress;
    static readonly iPv6Loopback: IPAddress;
    static readonly iPv6None: IPAddress;
    static hostToNetworkOrder(host: short): short;
    static hostToNetworkOrder(host: int): int;
    static hostToNetworkOrder(host: long): long;
    static isLoopback(address: IPAddress): boolean;
    static isValid(ipSpan: ReadOnlySpan_1<CLROf<char>>): boolean;
    static isValidUtf8(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static networkToHostOrder(network: short): short;
    static networkToHostOrder(network: int): int;
    static networkToHostOrder(network: long): long;
    static parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPAddress;
    static parse(ipSpan: ReadOnlySpan_1<CLROf<char>>): IPAddress;
    static parse(ipString: string): IPAddress;
    static tryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<IPAddress> }): boolean;
    static tryParse(ipSpan: ReadOnlySpan_1<CLROf<char>>, address: { value: ref<IPAddress> }): boolean;
    static tryParse(ipString: string, address: { value: ref<IPAddress> }): boolean;
}


export interface __IPAddress$views {
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<IPAddress>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<IPAddress>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<IPAddress>;
}

export interface IPAddress$instance extends System_Internal.ISpanParsable_1$instance<IPAddress> {}

export type IPAddress = IPAddress$instance & __IPAddress$views;


export class IPEndPoint$instance extends EndPoint$instance {
    constructor(address: long, port: int);
    constructor(address: IPAddress, port: int);
    address: IPAddress;
    readonly addressFamily: AddressFamily;
    port: int;
    create(socketAddress: SocketAddress): EndPoint;
    equals(comparand: unknown): boolean;
    getHashCode(): int;
    serialize(): SocketAddress;
    toString(): string;
    static readonly minPort: int;
    static readonly maxPort: int;
    static parse(s: ReadOnlySpan_1<CLROf<char>>): IPEndPoint;
    static parse(s: string): IPEndPoint;
    static tryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<IPEndPoint> }): boolean;
    static tryParse(s: string, result: { value: ref<IPEndPoint> }): boolean;
}


export type IPEndPoint = IPEndPoint$instance;

export class IPHostEntry$instance {
    constructor();
    addressList: IPAddress[];
    aliases: string[];
    hostName: string;
}


export type IPHostEntry = IPHostEntry$instance;

export class NetworkCredential$instance {
    constructor();
    constructor(userName: string, password: string);
    constructor(userName: string, password: string, domain: string);
    constructor(userName: string, password: SecureString);
    constructor(userName: string, password: SecureString, domain: string);
    domain: string;
    password: string;
    securePassword: SecureString;
    userName: string;
    getCredential(uri: Uri, authenticationType: string): NetworkCredential;
    getCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export interface __NetworkCredential$views {
    As_ICredentials(): ICredentials$instance;
    As_ICredentialsByHost(): ICredentialsByHost$instance;
}

export type NetworkCredential = NetworkCredential$instance & __NetworkCredential$views;


export class OpenReadCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: Stream;
}


export type OpenReadCompletedEventArgs = OpenReadCompletedEventArgs$instance;

export class OpenReadCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: OpenReadCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: OpenReadCompletedEventArgs): void;
}


export interface __OpenReadCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OpenReadCompletedEventHandler = OpenReadCompletedEventHandler$instance & __OpenReadCompletedEventHandler$views;


export class OpenWriteCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: Stream;
}


export type OpenWriteCompletedEventArgs = OpenWriteCompletedEventArgs$instance;

export class OpenWriteCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: OpenWriteCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: OpenWriteCompletedEventArgs): void;
}


export interface __OpenWriteCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OpenWriteCompletedEventHandler = OpenWriteCompletedEventHandler$instance & __OpenWriteCompletedEventHandler$views;


export class PathList$instance {
    constructor();
}


export type PathList = PathList$instance;

export class ProtocolViolationException$instance extends System_Internal.InvalidOperationException$instance {
    constructor();
    constructor(message: string);
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __ProtocolViolationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ProtocolViolationException = ProtocolViolationException$instance & __ProtocolViolationException$views;


export class ServicePoint$instance {
    readonly address: Uri;
    bindIPEndPointDelegate: BindIPEndPoint;
    readonly certificate: X509Certificate;
    readonly clientCertificate: X509Certificate;
    connectionLeaseTimeout: int;
    connectionLimit: int;
    readonly connectionName: string;
    readonly currentConnections: int;
    expect100Continue: boolean;
    readonly idleSince: DateTime;
    maxIdleTime: int;
    readonly protocolVersion: Version;
    receiveBufferSize: int;
    readonly supportsPipelining: boolean;
    useNagleAlgorithm: boolean;
    closeConnectionGroup(connectionGroupName: string): boolean;
    setTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
}


export type ServicePoint = ServicePoint$instance;

export class ServicePointManager$instance {
    static readonly defaultNonPersistentConnectionLimit: int;
    static readonly defaultPersistentConnectionLimit: int;
    static securityProtocol: SecurityProtocolType;
    static maxServicePoints: int;
    static defaultConnectionLimit: int;
    static maxServicePointIdleTime: int;
    static useNagleAlgorithm: boolean;
    static expect100Continue: boolean;
    static enableDnsRoundRobin: boolean;
    static dnsRefreshTimeout: int;
    static serverCertificateValidationCallback: RemoteCertificateValidationCallback;
    static reusePort: boolean;
    static checkCertificateRevocationList: boolean;
    static readonly encryptionPolicy: EncryptionPolicy;
    static findServicePoint(uriString: string, proxy: IWebProxy): ServicePoint;
    static findServicePoint(address: Uri, proxy: IWebProxy): ServicePoint;
    static findServicePoint(address: Uri): ServicePoint;
    static setTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
}


export type ServicePointManager = ServicePointManager$instance;

export class SocketAddress$instance {
    constructor(family: AddressFamily);
    constructor(family: AddressFamily, size: int);
    readonly buffer: Memory_1<CLROf<byte>>;
    readonly family: AddressFamily;
    item: byte;
    size: int;
    equals(comparand: unknown): boolean;
    equals(comparand: SocketAddress): boolean;
    getHashCode(): int;
    toString(): string;
    static getMaximumAddressSize(addressFamily: AddressFamily): int;
}


export interface __SocketAddress$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SocketAddress>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SocketAddress): boolean;
}

export type SocketAddress = SocketAddress$instance & __SocketAddress$views;


export abstract class TransportContext$instance {
    abstract getChannelBinding(kind: ChannelBindingKind): ChannelBinding;
}


export type TransportContext = TransportContext$instance;

export class UploadDataCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: byte[];
}


export type UploadDataCompletedEventArgs = UploadDataCompletedEventArgs$instance;

export class UploadDataCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: UploadDataCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: UploadDataCompletedEventArgs): void;
}


export interface __UploadDataCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadDataCompletedEventHandler = UploadDataCompletedEventHandler$instance & __UploadDataCompletedEventHandler$views;


export class UploadFileCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: byte[];
}


export type UploadFileCompletedEventArgs = UploadFileCompletedEventArgs$instance;

export class UploadFileCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: UploadFileCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: UploadFileCompletedEventArgs): void;
}


export interface __UploadFileCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadFileCompletedEventHandler = UploadFileCompletedEventHandler$instance & __UploadFileCompletedEventHandler$views;


export class UploadProgressChangedEventArgs$instance extends System_ComponentModel_Internal.ProgressChangedEventArgs$instance {
    readonly bytesReceived: long;
    readonly bytesSent: long;
    readonly totalBytesToReceive: long;
    readonly totalBytesToSend: long;
}


export type UploadProgressChangedEventArgs = UploadProgressChangedEventArgs$instance;

export class UploadProgressChangedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: UploadProgressChangedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: UploadProgressChangedEventArgs): void;
}


export interface __UploadProgressChangedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadProgressChangedEventHandler = UploadProgressChangedEventHandler$instance & __UploadProgressChangedEventHandler$views;


export class UploadStringCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: string;
}


export type UploadStringCompletedEventArgs = UploadStringCompletedEventArgs$instance;

export class UploadStringCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: UploadStringCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: UploadStringCompletedEventArgs): void;
}


export interface __UploadStringCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadStringCompletedEventHandler = UploadStringCompletedEventHandler$instance & __UploadStringCompletedEventHandler$views;


export class UploadValuesCompletedEventArgs$instance extends System_ComponentModel_Internal.AsyncCompletedEventArgs$instance {
    readonly result: byte[];
}


export type UploadValuesCompletedEventArgs = UploadValuesCompletedEventArgs$instance;

export class UploadValuesCompletedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: UploadValuesCompletedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: UploadValuesCompletedEventArgs): void;
}


export interface __UploadValuesCompletedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UploadValuesCompletedEventHandler = UploadValuesCompletedEventHandler$instance & __UploadValuesCompletedEventHandler$views;


export class WebClient$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    allowReadStreamBuffering: boolean;
    allowWriteStreamBuffering: boolean;
    baseAddress: string;
    cachePolicy: RequestCachePolicy;
    credentials: ICredentials;
    encoding: Encoding;
    headers: WebHeaderCollection;
    readonly isBusy: boolean;
    proxy: IWebProxy;
    queryString: NameValueCollection;
    readonly responseHeaders: WebHeaderCollection;
    useDefaultCredentials: boolean;
    cancelAsync(): void;
    dispose(): void;
    downloadData(address: string): byte[];
    downloadData(address: Uri): byte[];
    downloadDataAsync(address: Uri): void;
    downloadDataAsync(address: Uri, userToken: unknown): void;
    downloadDataTaskAsync(address: string): Task_1<byte[]>;
    downloadDataTaskAsync(address: Uri): Task_1<byte[]>;
    downloadFile(address: string, fileName: string): void;
    downloadFile(address: Uri, fileName: string): void;
    downloadFileAsync(address: Uri, fileName: string): void;
    downloadFileAsync(address: Uri, fileName: string, userToken: unknown): void;
    downloadFileTaskAsync(address: string, fileName: string): Task;
    downloadFileTaskAsync(address: Uri, fileName: string): Task;
    downloadString(address: string): string;
    downloadString(address: Uri): string;
    downloadStringAsync(address: Uri): void;
    downloadStringAsync(address: Uri, userToken: unknown): void;
    downloadStringTaskAsync(address: string): Task_1<CLROf<string>>;
    downloadStringTaskAsync(address: Uri): Task_1<CLROf<string>>;
    openRead(address: string): Stream;
    openRead(address: Uri): Stream;
    openReadAsync(address: Uri): void;
    openReadAsync(address: Uri, userToken: unknown): void;
    openReadTaskAsync(address: string): Task_1<Stream>;
    openReadTaskAsync(address: Uri): Task_1<Stream>;
    openWrite(address: string): Stream;
    openWrite(address: Uri): Stream;
    openWrite(address: string, method: string): Stream;
    openWrite(address: Uri, method: string): Stream;
    openWriteAsync(address: Uri): void;
    openWriteAsync(address: Uri, method: string): void;
    openWriteAsync(address: Uri, method: string, userToken: unknown): void;
    openWriteTaskAsync(address: string): Task_1<Stream>;
    openWriteTaskAsync(address: Uri): Task_1<Stream>;
    openWriteTaskAsync(address: string, method: string): Task_1<Stream>;
    openWriteTaskAsync(address: Uri, method: string): Task_1<Stream>;
    uploadData(address: string, data: byte[]): byte[];
    uploadData(address: Uri, data: byte[]): byte[];
    uploadData(address: string, method: string, data: byte[]): byte[];
    uploadData(address: Uri, method: string, data: byte[]): byte[];
    uploadDataAsync(address: Uri, data: byte[]): void;
    uploadDataAsync(address: Uri, method: string, data: byte[]): void;
    uploadDataAsync(address: Uri, method: string, data: byte[], userToken: unknown): void;
    uploadDataTaskAsync(address: string, data: byte[]): Task_1<byte[]>;
    uploadDataTaskAsync(address: Uri, data: byte[]): Task_1<byte[]>;
    uploadDataTaskAsync(address: string, method: string, data: byte[]): Task_1<byte[]>;
    uploadDataTaskAsync(address: Uri, method: string, data: byte[]): Task_1<byte[]>;
    uploadFile(address: string, fileName: string): byte[];
    uploadFile(address: Uri, fileName: string): byte[];
    uploadFile(address: string, method: string, fileName: string): byte[];
    uploadFile(address: Uri, method: string, fileName: string): byte[];
    uploadFileAsync(address: Uri, fileName: string): void;
    uploadFileAsync(address: Uri, method: string, fileName: string): void;
    uploadFileAsync(address: Uri, method: string, fileName: string, userToken: unknown): void;
    uploadFileTaskAsync(address: string, fileName: string): Task_1<byte[]>;
    uploadFileTaskAsync(address: Uri, fileName: string): Task_1<byte[]>;
    uploadFileTaskAsync(address: string, method: string, fileName: string): Task_1<byte[]>;
    uploadFileTaskAsync(address: Uri, method: string, fileName: string): Task_1<byte[]>;
    uploadString(address: string, data: string): string;
    uploadString(address: Uri, data: string): string;
    uploadString(address: string, method: string, data: string): string;
    uploadString(address: Uri, method: string, data: string): string;
    uploadStringAsync(address: Uri, data: string): void;
    uploadStringAsync(address: Uri, method: string, data: string): void;
    uploadStringAsync(address: Uri, method: string, data: string, userToken: unknown): void;
    uploadStringTaskAsync(address: string, data: string): Task_1<CLROf<string>>;
    uploadStringTaskAsync(address: Uri, data: string): Task_1<CLROf<string>>;
    uploadStringTaskAsync(address: string, method: string, data: string): Task_1<CLROf<string>>;
    uploadStringTaskAsync(address: Uri, method: string, data: string): Task_1<CLROf<string>>;
    uploadValues(address: string, data: NameValueCollection): byte[];
    uploadValues(address: Uri, data: NameValueCollection): byte[];
    uploadValues(address: string, method: string, data: NameValueCollection): byte[];
    uploadValues(address: Uri, method: string, data: NameValueCollection): byte[];
    uploadValuesAsync(address: Uri, data: NameValueCollection): void;
    uploadValuesAsync(address: Uri, method: string, data: NameValueCollection): void;
    uploadValuesAsync(address: Uri, method: string, data: NameValueCollection, userToken: unknown): void;
    uploadValuesTaskAsync(address: string, data: NameValueCollection): Task_1<byte[]>;
    uploadValuesTaskAsync(address: string, method: string, data: NameValueCollection): Task_1<byte[]>;
    uploadValuesTaskAsync(address: Uri, data: NameValueCollection): Task_1<byte[]>;
    uploadValuesTaskAsync(address: Uri, method: string, data: NameValueCollection): Task_1<byte[]>;
}


export interface __WebClient$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface WebClient$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type WebClient = WebClient$instance & __WebClient$views;


export class WebException$instance extends System_Internal.InvalidOperationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, status: WebExceptionStatus);
    constructor(message: string, innerException: Exception, status: WebExceptionStatus, response: WebResponse);
    readonly response: WebResponse;
    readonly status: WebExceptionStatus;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export interface __WebException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebException = WebException$instance & __WebException$views;


export class WebHeaderCollection$instance extends System_Collections_Specialized_Internal.NameValueCollection$instance {
    constructor();
    readonly allKeys: string[];
    readonly count: int;
    readonly keys: NameObjectCollectionBase_KeysCollection;
    add(header: HttpResponseHeader, value: string): void;
    add(name: string, value: string): void;
    add(c: NameValueCollection): void;
    clear(): void;
    copyTo(dest: ClrArray, index: int): void;
    get_(index: int): string;
    get_(name: string): string;
    getEnumerator(): IEnumerator;
    getKey(index: int): string;
    getObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
    getValues(index: int): string[];
    getValues(header: string): string[];
    onDeserialization(sender: unknown): void;
    remove(header: HttpResponseHeader): void;
    remove(name: string): void;
    set_(name: string, value: string): void;
    set_(header: HttpResponseHeader, value: string): void;
    toByteArray(): byte[];
    toString(): string;
    static isRestricted(headerName: string, response: boolean): boolean;
    static isRestricted(headerName: string): boolean;
}


export interface __WebHeaderCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebHeaderCollection = WebHeaderCollection$instance & __WebHeaderCollection$views;


export class WebProxy$instance {
    constructor();
    constructor(Address: Uri);
    constructor(Address: Uri, BypassOnLocal: boolean);
    constructor(Address: Uri, BypassOnLocal: boolean, BypassList: string[]);
    constructor(Address: Uri, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials);
    constructor(Host: string, Port: int);
    constructor(Address: string);
    constructor(Address: string, BypassOnLocal: boolean);
    constructor(Address: string, BypassOnLocal: boolean, BypassList: string[]);
    constructor(Address: string, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials);
    address: Uri;
    readonly bypassArrayList: ArrayList;
    bypassList: string[];
    bypassProxyOnLocal: boolean;
    credentials: ICredentials;
    useDefaultCredentials: boolean;
    getProxy(destination: Uri): Uri;
    isBypassed(host: Uri): boolean;
    static getDefaultProxy(): WebProxy;
}


export interface __WebProxy$views {
    As_IWebProxy(): IWebProxy$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebProxy$instance extends IWebProxy$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebProxy = WebProxy$instance & __WebProxy$views;


export abstract class WebRequest$instance extends System_Internal.MarshalByRefObject$instance {
    authenticationLevel: AuthenticationLevel;
    cachePolicy: RequestCachePolicy;
    connectionGroupName: string;
    contentLength: long;
    contentType: string;
    credentials: ICredentials;
    headers: WebHeaderCollection;
    impersonationLevel: TokenImpersonationLevel;
    method: string;
    preAuthenticate: boolean;
    proxy: IWebProxy;
    readonly requestUri: Uri;
    timeout: int;
    useDefaultCredentials: boolean;
    abort(): void;
    beginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    beginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    endGetRequestStream(asyncResult: IAsyncResult): Stream;
    endGetResponse(asyncResult: IAsyncResult): WebResponse;
    getRequestStream(): Stream;
    getRequestStreamAsync(): Task_1<Stream>;
    getResponse(): WebResponse;
    getResponseAsync(): Task_1<WebResponse>;
    static defaultCachePolicy: RequestCachePolicy;
    static defaultWebProxy: IWebProxy;
    static create(requestUriString: string): WebRequest;
    static create(requestUri: Uri): WebRequest;
    static createDefault(requestUri: Uri): WebRequest;
    static createHttp(requestUriString: string): HttpWebRequest;
    static createHttp(requestUri: Uri): HttpWebRequest;
    static getSystemWebProxy(): IWebProxy;
    static registerPrefix(prefix: string, creator: IWebRequestCreate): boolean;
}


export interface __WebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebRequest = WebRequest$instance & __WebRequest$views;


export abstract class WebResponse$instance extends System_Internal.MarshalByRefObject$instance {
    contentLength: long;
    contentType: string;
    readonly headers: WebHeaderCollection;
    readonly isFromCache: boolean;
    readonly isMutuallyAuthenticated: boolean;
    readonly responseUri: Uri;
    readonly supportsHeaders: boolean;
    close(): void;
    dispose(): void;
    getResponseStream(): Stream;
}


export interface __WebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebResponse$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebResponse = WebResponse$instance & __WebResponse$views;


export class WriteStreamClosedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor();
    readonly error: Exception;
}


export type WriteStreamClosedEventArgs = WriteStreamClosedEventArgs$instance;

export class WriteStreamClosedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: WriteStreamClosedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: WriteStreamClosedEventArgs): void;
}


export interface __WriteStreamClosedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WriteStreamClosedEventHandler = WriteStreamClosedEventHandler$instance & __WriteStreamClosedEventHandler$views;


export abstract class Dns$instance {
    static beginGetHostAddresses(hostNameOrAddress: string, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    static beginGetHostByName(hostName: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static beginGetHostEntry(address: IPAddress, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static beginGetHostEntry(hostNameOrAddress: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static beginResolve(hostName: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static endGetHostAddresses(asyncResult: IAsyncResult): IPAddress[];
    static endGetHostByName(asyncResult: IAsyncResult): IPHostEntry;
    static endGetHostEntry(asyncResult: IAsyncResult): IPHostEntry;
    static endResolve(asyncResult: IAsyncResult): IPHostEntry;
    static getHostAddresses(hostNameOrAddress: string, family: AddressFamily): IPAddress[];
    static getHostAddresses(hostNameOrAddress: string): IPAddress[];
    static getHostAddressesAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPAddress[]>;
    static getHostAddressesAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPAddress[]>;
    static getHostAddressesAsync(hostNameOrAddress: string): Task_1<IPAddress[]>;
    static getHostByAddress(address: IPAddress): IPHostEntry;
    static getHostByAddress(address: string): IPHostEntry;
    static getHostByName(hostName: string): IPHostEntry;
    static getHostEntry(address: IPAddress): IPHostEntry;
    static getHostEntry(hostNameOrAddress: string, family: AddressFamily): IPHostEntry;
    static getHostEntry(hostNameOrAddress: string): IPHostEntry;
    static getHostEntryAsync(address: IPAddress): Task_1<IPHostEntry>;
    static getHostEntryAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPHostEntry>;
    static getHostEntryAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPHostEntry>;
    static getHostEntryAsync(hostNameOrAddress: string): Task_1<IPHostEntry>;
    static getHostName(): string;
    static resolve(hostName: string): IPHostEntry;
}


export type Dns = Dns$instance;

export abstract class HttpVersion$instance {
    static readonly unknown_: Version;
    static readonly version10: Version;
    static readonly version11: Version;
    static readonly version20: Version;
    static readonly version30: Version;
}


export type HttpVersion = HttpVersion$instance;

export abstract class WebRequestMethods$instance {
}


export type WebRequestMethods = WebRequestMethods$instance;

export abstract class WebRequestMethods_File$instance {
    static readonly downloadFile: string;
    static readonly uploadFile: string;
}


export type WebRequestMethods_File = WebRequestMethods_File$instance;

export abstract class WebRequestMethods_Ftp$instance {
    static readonly downloadFile: string;
    static readonly listDirectory: string;
    static readonly uploadFile: string;
    static readonly deleteFile: string;
    static readonly appendFile: string;
    static readonly getFileSize: string;
    static readonly uploadFileWithUniqueName: string;
    static readonly makeDirectory: string;
    static readonly removeDirectory: string;
    static readonly listDirectoryDetails: string;
    static readonly getDateTimestamp: string;
    static readonly printWorkingDirectory: string;
    static readonly rename: string;
}


export type WebRequestMethods_Ftp = WebRequestMethods_Ftp$instance;

export abstract class WebRequestMethods_Http$instance {
    static readonly get_: string;
    static readonly connect: string;
    static readonly head: string;
    static readonly put: string;
    static readonly post: string;
    static readonly mkCol: string;
}


export type WebRequestMethods_Http = WebRequestMethods_Http$instance;

export abstract class WebUtility$instance {
    static htmlDecode(value: string, output: TextWriter): void;
    static htmlDecode(value: string): string;
    static htmlEncode(value: string, output: TextWriter): void;
    static htmlEncode(value: string): string;
    static urlDecode(encodedValue: string): string;
    static urlDecodeToBytes(encodedValue: byte[], offset: int, count: int): byte[];
    static urlEncode(value: string): string;
    static urlEncodeToBytes(value: byte[], offset: int, count: int): byte[];
}


export type WebUtility = WebUtility$instance;

