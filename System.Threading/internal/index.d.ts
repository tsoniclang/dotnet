// Generated by tsbindgen - Architecture
// Namespace: System.Threading
// Assembly: System.Private.CoreLib, System.Threading, System.Threading.AccessControl

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { SafeWaitHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { EventWaitHandleRights, EventWaitHandleSecurity, MutexRights, MutexSecurity, SemaphoreRights, SemaphoreSecurity } from "../../System.Security.AccessControl/internal/index.js";
import type { IPrincipal } from "../../System.Security.Principal/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, AppDomain, ApplicationException, AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, Double, Enum, EventArgs, Exception, Func_1, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, LocalDataStoreSlot, MarshalByRefObject, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, SByte, Single, String as ClrString, SystemException, TimeProvider, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ApartmentState {
    sta = 0,
    mta = 1,
    unknown_ = 2
}


export enum EventResetMode {
    autoReset = 0,
    manualReset = 1
}


export enum LazyThreadSafetyMode {
    none = 0,
    publicationOnly = 1,
    executionAndPublication = 2
}


export enum LockRecursionPolicy {
    noRecursion = 0,
    supportsRecursion = 1
}


export enum ThreadPriority {
    lowest = 0,
    belowNormal = 1,
    normal = 2,
    aboveNormal = 3,
    highest = 4
}


export enum ThreadState {
    running = 0,
    stopRequested = 1,
    suspendRequested = 2,
    background = 4,
    unstarted = 8,
    stopped = 16,
    waitSleepJoin = 32,
    suspended = 64,
    abortRequested = 128,
    aborted = 256
}


export interface IThreadPoolWorkItem$instance {
    Execute(): void;
}


export type IThreadPoolWorkItem = IThreadPoolWorkItem$instance;

export interface ITimer$instance {
    Change(dueTime: TimeSpan, period: TimeSpan): boolean;
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export type ITimer = ITimer$instance;

export class AsyncFlowControl$instance {
    dispose(): void;
    equals(obj: any): boolean;
    equals(obj: AsyncFlowControl): boolean;
    getHashCode(): int;
    undo(): void;
}


export interface __AsyncFlowControl$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<AsyncFlowControl>;

    // Structural method bridges for numeric interface constraints
    Equals(other: AsyncFlowControl): boolean;
}

export type AsyncFlowControl = AsyncFlowControl$instance & __AsyncFlowControl$views;


export class AsyncLocalValueChangedArgs_1$instance<T> {
    readonly currentValue: T;
    readonly previousValue: T;
    readonly threadContextChanged: boolean;
}


export type AsyncLocalValueChangedArgs_1<T> = AsyncLocalValueChangedArgs_1$instance<T>;

export class CancellationToken$instance {
    constructor(canceled: boolean);
    readonly canBeCanceled: boolean;
    readonly isCancellationRequested: boolean;
    readonly waitHandle: WaitHandle;
    equals(other: CancellationToken): boolean;
    equals(other: any): boolean;
    getHashCode(): int;
    register(callback: Action): CancellationTokenRegistration;
    register(callback: Action, useSynchronizationContext: boolean): CancellationTokenRegistration;
    register(callback: Action_1<any>, state: any): CancellationTokenRegistration;
    register(callback: Action_2<any, CancellationToken>, state: any): CancellationTokenRegistration;
    register(callback: Action_1<any>, state: any, useSynchronizationContext: boolean): CancellationTokenRegistration;
    throwIfCancellationRequested(): void;
    unsafeRegister(callback: Action_1<any>, state: any): CancellationTokenRegistration;
    unsafeRegister(callback: Action_2<any, CancellationToken>, state: any): CancellationTokenRegistration;
    static readonly None: CancellationToken;
}


export interface __CancellationToken$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CancellationToken>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationToken): boolean;
}

export type CancellationToken = CancellationToken$instance & __CancellationToken$views;


export class CancellationTokenRegistration$instance {
    readonly token: CancellationToken;
    dispose(): void;
    disposeAsync(): ValueTask;
    equals(obj: any): boolean;
    equals(other: CancellationTokenRegistration): boolean;
    getHashCode(): int;
    unregister(): boolean;
}


export interface __CancellationTokenRegistration$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<CancellationTokenRegistration>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationTokenRegistration): boolean;
}

export type CancellationTokenRegistration = CancellationTokenRegistration$instance & __CancellationTokenRegistration$views;


export class Lock_Scope$instance {
    dispose(): void;
}


export type Lock_Scope = Lock_Scope$instance;

export class LockCookie$instance {
    equals(obj: any): boolean;
    equals(obj: LockCookie): boolean;
    getHashCode(): int;
}


export interface __LockCookie$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<LockCookie>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LockCookie): boolean;
}

export type LockCookie = LockCookie$instance & __LockCookie$views;


export class NamedWaitHandleOptions$instance {
    currentSessionOnly: boolean;
    currentUserOnly: boolean;
}


export type NamedWaitHandleOptions = NamedWaitHandleOptions$instance;

export class NativeOverlapped$instance {
    InternalLow: nint;
    InternalHigh: nint;
    OffsetLow: int;
    OffsetHigh: int;
    EventHandle: nint;
}


export type NativeOverlapped = NativeOverlapped$instance;

export class SpinLock$instance {
    constructor(enableThreadOwnerTracking: boolean);
    readonly isHeld: boolean;
    readonly isHeldByCurrentThread: boolean;
    readonly isThreadOwnerTrackingEnabled: boolean;
    enter(lockTaken: { value: TSByRef<boolean> }): void;
    exit(): void;
    exit(useMemoryBarrier: boolean): void;
    tryEnter(lockTaken: { value: TSByRef<boolean> }): void;
    tryEnter(timeout: TimeSpan, lockTaken: { value: TSByRef<boolean> }): void;
    tryEnter(millisecondsTimeout: int, lockTaken: { value: TSByRef<boolean> }): void;
}


export type SpinLock = SpinLock$instance;

export class SpinWait$instance {
    readonly count: int;
    readonly nextSpinWillYield: boolean;
    reset(): void;
    spinOnce(): void;
    spinOnce(sleep1Threshold: int): void;
    static SpinUntil(condition: Func_1<CLROf<boolean>>, millisecondsTimeout: int): boolean;
    static SpinUntil(condition: Func_1<CLROf<boolean>>, timeout: TimeSpan): boolean;
    static SpinUntil(condition: Func_1<CLROf<boolean>>): void;
}


export type SpinWait = SpinWait$instance;

export class AbandonedMutexException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(location: int, handle: WaitHandle);
    constructor(message: string, location: int, handle: WaitHandle);
    constructor(message: string, inner: Exception, location: int, handle: WaitHandle);
    readonly mutex: Mutex;
    readonly mutexIndex: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AbandonedMutexException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AbandonedMutexException = AbandonedMutexException$instance & __AbandonedMutexException$views;


export class AsyncLocal_1$instance<T> {
    constructor();
    constructor(valueChangedHandler: Action_1<AsyncLocalValueChangedArgs_1<T>>);
    value: T;
}


export type AsyncLocal_1<T> = AsyncLocal_1$instance<T>;

export class AutoResetEvent$instance extends EventWaitHandle$instance {
    constructor(initialState: boolean);
    dispose(): void;
}


export interface __AutoResetEvent$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AutoResetEvent = AutoResetEvent$instance & __AutoResetEvent$views;


export class Barrier$instance {
    constructor(participantCount: int);
    constructor(participantCount: int, postPhaseAction: Action_1<Barrier>);
    readonly currentPhaseNumber: long;
    readonly participantCount: int;
    readonly participantsRemaining: int;
    addParticipant(): long;
    addParticipants(participantCount: int): long;
    dispose(): void;
    removeParticipant(): void;
    removeParticipants(participantCount: int): void;
    signalAndWait(): void;
    signalAndWait(cancellationToken: CancellationToken): void;
    signalAndWait(timeout: TimeSpan): boolean;
    signalAndWait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    signalAndWait(millisecondsTimeout: int): boolean;
    signalAndWait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export interface __Barrier$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Barrier = Barrier$instance & __Barrier$views;


export class BarrierPostPhaseException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(innerException: Exception);
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __BarrierPostPhaseException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BarrierPostPhaseException = BarrierPostPhaseException$instance & __BarrierPostPhaseException$views;


export class CancellationTokenSource$instance {
    constructor();
    constructor(delay: TimeSpan);
    constructor(delay: TimeSpan, timeProvider: TimeProvider);
    constructor(millisecondsDelay: int);
    readonly isCancellationRequested: boolean;
    readonly token: CancellationToken;
    cancel(): void;
    cancel(throwOnFirstException: boolean): void;
    cancelAfter(delay: TimeSpan): void;
    cancelAfter(millisecondsDelay: int): void;
    cancelAsync(): Task;
    dispose(): void;
    tryReset(): boolean;
    static CreateLinkedTokenSource(tokens: ReadOnlySpan_1<CancellationToken>): CancellationTokenSource;
    static CreateLinkedTokenSource(token1: CancellationToken, token2: CancellationToken): CancellationTokenSource;
    static CreateLinkedTokenSource(token: CancellationToken): CancellationTokenSource;
    static CreateLinkedTokenSource(tokens: CancellationToken[]): CancellationTokenSource;
}


export interface __CancellationTokenSource$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type CancellationTokenSource = CancellationTokenSource$instance & __CancellationTokenSource$views;


export class CompressedStack$instance {
    createCopy(): CompressedStack;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static Capture(): CompressedStack;
    static GetCompressedStack(): CompressedStack;
    static Run(compressedStack: CompressedStack, callback: ContextCallback, state: any): void;
}


export interface __CompressedStack$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CompressedStack = CompressedStack$instance & __CompressedStack$views;


export class ContextCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(state: any, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(state: any): void;
}


export interface __ContextCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ContextCallback = ContextCallback$instance & __ContextCallback$views;


export class CountdownEvent$instance {
    constructor(initialCount: int);
    readonly currentCount: int;
    readonly initialCount: int;
    readonly isSet: boolean;
    readonly waitHandle: WaitHandle;
    addCount(): void;
    addCount(signalCount: int): void;
    dispose(): void;
    reset(): void;
    reset(count: int): void;
    signal(): boolean;
    signal(signalCount: int): boolean;
    tryAddCount(): boolean;
    tryAddCount(signalCount: int): boolean;
    wait(): void;
    wait(cancellationToken: CancellationToken): void;
    wait(timeout: TimeSpan): boolean;
    wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    wait(millisecondsTimeout: int): boolean;
    wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export interface __CountdownEvent$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type CountdownEvent = CountdownEvent$instance & __CountdownEvent$views;


export class EventWaitHandle$instance extends WaitHandle$instance {
    constructor(initialState: boolean, mode: EventResetMode);
    constructor(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions);
    constructor(initialState: boolean, mode: EventResetMode, name: string);
    constructor(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions, createdNew: TSByRef<boolean>);
    constructor(initialState: boolean, mode: EventResetMode, name: string, createdNew: TSByRef<boolean>);
    dispose(): void;
    reset(): boolean;
    set_(): boolean;
    static OpenExisting(name: string, options: NamedWaitHandleOptions): EventWaitHandle;
    static OpenExisting(name: string): EventWaitHandle;
    static TryOpenExisting(name: string, result: { value: TSByRef<EventWaitHandle> }): boolean;
    static TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: TSByRef<EventWaitHandle> }): boolean;
}


export interface __EventWaitHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type EventWaitHandle = EventWaitHandle$instance & __EventWaitHandle$views;


export class ExecutionContext$instance {
    createCopy(): ExecutionContext;
    dispose(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    static Capture(): ExecutionContext;
    static IsFlowSuppressed(): boolean;
    static Restore(executionContext: ExecutionContext): void;
    static RestoreFlow(): void;
    static Run(executionContext: ExecutionContext, callback: ContextCallback, state: any): void;
    static SuppressFlow(): AsyncFlowControl;
}


export interface __ExecutionContext$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExecutionContext = ExecutionContext$instance & __ExecutionContext$views;


export class HostExecutionContext$instance {
    constructor();
    constructor(state: any);
    createCopy(): HostExecutionContext;
    dispose(): void;
    dispose(disposing: boolean): void;
}


export interface __HostExecutionContext$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type HostExecutionContext = HostExecutionContext$instance & __HostExecutionContext$views;


export class HostExecutionContextManager$instance {
    constructor();
    capture(): HostExecutionContext;
    revert(previousState: any): void;
    setHostExecutionContext(hostExecutionContext: HostExecutionContext): any;
}


export type HostExecutionContextManager = HostExecutionContextManager$instance;

export class IOCompletionCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(errorCode: uint, numBytes: uint, pOVERLAP: TSUnsafePointer<NativeOverlapped>, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(errorCode: uint, numBytes: uint, pOVERLAP: TSUnsafePointer<NativeOverlapped>): void;
}


export interface __IOCompletionCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IOCompletionCallback = IOCompletionCallback$instance & __IOCompletionCallback$views;


export class Lock$instance {
    constructor();
    readonly isHeldByCurrentThread: boolean;
    enter(): void;
    enterScope(): Lock_Scope;
    exit(): void;
    tryEnter(): boolean;
    tryEnter(millisecondsTimeout: int): boolean;
    tryEnter(timeout: TimeSpan): boolean;
}


export type Lock = Lock$instance;

export class LockRecursionException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __LockRecursionException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LockRecursionException = LockRecursionException$instance & __LockRecursionException$views;


export class ManualResetEvent$instance extends EventWaitHandle$instance {
    constructor(initialState: boolean);
    dispose(): void;
}


export interface __ManualResetEvent$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ManualResetEvent = ManualResetEvent$instance & __ManualResetEvent$views;


export class ManualResetEventSlim$instance {
    constructor();
    constructor(initialState: boolean);
    constructor(initialState: boolean, spinCount: int);
    readonly isSet: boolean;
    readonly spinCount: int;
    readonly waitHandle: WaitHandle;
    dispose(): void;
    reset(): void;
    set_(): void;
    wait(): void;
    wait(cancellationToken: CancellationToken): void;
    wait(timeout: TimeSpan): boolean;
    wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    wait(millisecondsTimeout: int): boolean;
    wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export interface __ManualResetEventSlim$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ManualResetEventSlim = ManualResetEventSlim$instance & __ManualResetEventSlim$views;


export class Mutex$instance extends WaitHandle$instance {
    constructor(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions, createdNew: TSByRef<boolean>);
    constructor(initiallyOwned: boolean, name: string, createdNew: TSByRef<boolean>);
    constructor(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions);
    constructor(initiallyOwned: boolean, name: string);
    constructor(name: string, options: NamedWaitHandleOptions);
    constructor(initiallyOwned: boolean);
    constructor();
    dispose(): void;
    releaseMutex(): void;
    static OpenExisting(name: string, options: NamedWaitHandleOptions): Mutex;
    static OpenExisting(name: string): Mutex;
    static TryOpenExisting(name: string, result: { value: TSByRef<Mutex> }): boolean;
    static TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: TSByRef<Mutex> }): boolean;
}


export interface __Mutex$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Mutex = Mutex$instance & __Mutex$views;


export class Overlapped$instance {
    constructor();
    constructor(offsetLo: int, offsetHi: int, hEvent: nint, ar: IAsyncResult);
    constructor(offsetLo: int, offsetHi: int, hEvent: int, ar: IAsyncResult);
    asyncResult: IAsyncResult;
    eventHandle: int;
    eventHandleIntPtr: nint;
    offsetHigh: int;
    offsetLow: int;
    pack(iocb: IOCompletionCallback): TSUnsafePointer<NativeOverlapped>;
    pack(iocb: IOCompletionCallback, userData: any): TSUnsafePointer<NativeOverlapped>;
    unsafePack(iocb: IOCompletionCallback): TSUnsafePointer<NativeOverlapped>;
    unsafePack(iocb: IOCompletionCallback, userData: any): TSUnsafePointer<NativeOverlapped>;
    static Free(nativeOverlappedPtr: TSUnsafePointer<NativeOverlapped>): void;
    static Unpack(nativeOverlappedPtr: TSUnsafePointer<NativeOverlapped>): Overlapped;
}


export type Overlapped = Overlapped$instance;

export class ParameterizedThreadStart$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(obj: any, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(obj: any): void;
}


export interface __ParameterizedThreadStart$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ParameterizedThreadStart = ParameterizedThreadStart$instance & __ParameterizedThreadStart$views;


export class PeriodicTimer$instance {
    constructor(period: TimeSpan);
    constructor(period: TimeSpan, timeProvider: TimeProvider);
    period: TimeSpan;
    dispose(): void;
    waitForNextTickAsync(cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
}


export interface __PeriodicTimer$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type PeriodicTimer = PeriodicTimer$instance & __PeriodicTimer$views;


export class PreAllocatedOverlapped$instance {
    constructor(callback: IOCompletionCallback, state: any, pinData: any);
    dispose(): void;
    static UnsafeCreate(callback: IOCompletionCallback, state: any, pinData: any): PreAllocatedOverlapped;
}


export interface __PreAllocatedOverlapped$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type PreAllocatedOverlapped = PreAllocatedOverlapped$instance & __PreAllocatedOverlapped$views;


export class ReaderWriterLock$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    constructor();
    readonly isReaderLockHeld: boolean;
    readonly isWriterLockHeld: boolean;
    readonly writerSeqNum: int;
    acquireReaderLock(millisecondsTimeout: int): void;
    acquireReaderLock(timeout: TimeSpan): void;
    acquireWriterLock(millisecondsTimeout: int): void;
    acquireWriterLock(timeout: TimeSpan): void;
    anyWritersSince(seqNum: int): boolean;
    downgradeFromWriterLock(lockCookie: { value: TSByRef<LockCookie> }): void;
    releaseLock(): LockCookie;
    releaseReaderLock(): void;
    releaseWriterLock(): void;
    restoreLock(lockCookie: { value: TSByRef<LockCookie> }): void;
    upgradeToWriterLock(millisecondsTimeout: int): LockCookie;
    upgradeToWriterLock(timeout: TimeSpan): LockCookie;
}


export type ReaderWriterLock = ReaderWriterLock$instance;

export class ReaderWriterLockSlim$instance {
    constructor();
    constructor(recursionPolicy: LockRecursionPolicy);
    readonly currentReadCount: int;
    readonly isReadLockHeld: boolean;
    readonly isUpgradeableReadLockHeld: boolean;
    readonly isWriteLockHeld: boolean;
    readonly recursionPolicy: LockRecursionPolicy;
    readonly recursiveReadCount: int;
    readonly recursiveUpgradeCount: int;
    readonly recursiveWriteCount: int;
    readonly waitingReadCount: int;
    readonly waitingUpgradeCount: int;
    readonly waitingWriteCount: int;
    dispose(): void;
    enterReadLock(): void;
    enterUpgradeableReadLock(): void;
    enterWriteLock(): void;
    exitReadLock(): void;
    exitUpgradeableReadLock(): void;
    exitWriteLock(): void;
    tryEnterReadLock(timeout: TimeSpan): boolean;
    tryEnterReadLock(millisecondsTimeout: int): boolean;
    tryEnterUpgradeableReadLock(timeout: TimeSpan): boolean;
    tryEnterUpgradeableReadLock(millisecondsTimeout: int): boolean;
    tryEnterWriteLock(timeout: TimeSpan): boolean;
    tryEnterWriteLock(millisecondsTimeout: int): boolean;
}


export interface __ReaderWriterLockSlim$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ReaderWriterLockSlim = ReaderWriterLockSlim$instance & __ReaderWriterLockSlim$views;


export class RegisteredWaitHandle$instance extends System_Internal.MarshalByRefObject$instance {
    unregister(waitObject: WaitHandle): boolean;
}


export type RegisteredWaitHandle = RegisteredWaitHandle$instance;

export class Semaphore$instance extends WaitHandle$instance {
    constructor(initialCount: int, maximumCount: int);
    constructor(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions);
    constructor(initialCount: int, maximumCount: int, name: string);
    constructor(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions, createdNew: TSByRef<boolean>);
    constructor(initialCount: int, maximumCount: int, name: string, createdNew: TSByRef<boolean>);
    dispose(): void;
    release(): int;
    release(releaseCount: int): int;
    static OpenExisting(name: string, options: NamedWaitHandleOptions): Semaphore;
    static OpenExisting(name: string): Semaphore;
    static TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: TSByRef<Semaphore> }): boolean;
    static TryOpenExisting(name: string, result: { value: TSByRef<Semaphore> }): boolean;
}


export interface __Semaphore$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Semaphore = Semaphore$instance & __Semaphore$views;


export class SemaphoreFullException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SemaphoreFullException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SemaphoreFullException = SemaphoreFullException$instance & __SemaphoreFullException$views;


export class SemaphoreSlim$instance {
    constructor(initialCount: int);
    constructor(initialCount: int, maxCount: int);
    readonly availableWaitHandle: WaitHandle;
    readonly currentCount: int;
    dispose(): void;
    release(): int;
    release(releaseCount: int): int;
    wait(): void;
    wait(cancellationToken: CancellationToken): void;
    wait(timeout: TimeSpan): boolean;
    wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    wait(millisecondsTimeout: int): boolean;
    wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    waitAsync(): Task;
    waitAsync(cancellationToken: CancellationToken): Task;
    waitAsync(millisecondsTimeout: int): Task_1<CLROf<boolean>>;
    waitAsync(timeout: TimeSpan): Task_1<CLROf<boolean>>;
    waitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    waitAsync(millisecondsTimeout: int, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
}


export interface __SemaphoreSlim$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type SemaphoreSlim = SemaphoreSlim$instance & __SemaphoreSlim$views;


export class SendOrPostCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(state: any, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(state: any): void;
}


export interface __SendOrPostCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SendOrPostCallback = SendOrPostCallback$instance & __SendOrPostCallback$views;


export class SynchronizationContext$instance {
    constructor();
    createCopy(): SynchronizationContext;
    isWaitNotificationRequired(): boolean;
    operationCompleted(): void;
    operationStarted(): void;
    post(d: SendOrPostCallback, state: any): void;
    send(d: SendOrPostCallback, state: any): void;
    wait(waitHandles: nint[], waitAll: boolean, millisecondsTimeout: int): int;
    static readonly Current: SynchronizationContext;
    static SetSynchronizationContext(syncContext: SynchronizationContext): void;
}


export type SynchronizationContext = SynchronizationContext$instance;

export class SynchronizationLockException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SynchronizationLockException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SynchronizationLockException = SynchronizationLockException$instance & __SynchronizationLockException$views;


export class Thread$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    constructor(start: ThreadStart);
    constructor(start: ThreadStart, maxStackSize: int);
    constructor(start: ParameterizedThreadStart);
    constructor(start: ParameterizedThreadStart, maxStackSize: int);
    apartmentState: ApartmentState;
    currentCulture: CultureInfo;
    currentUICulture: CultureInfo;
    readonly executionContext: ExecutionContext;
    readonly isAlive: boolean;
    isBackground: boolean;
    readonly isThreadPoolThread: boolean;
    readonly managedThreadId: int;
    name: string;
    priority: ThreadPriority;
    readonly threadState: ThreadState;
    abort(): void;
    abort(stateInfo: any): void;
    disableComObjectEagerCleanup(): void;
    getApartmentState(): ApartmentState;
    getCompressedStack(): CompressedStack;
    getHashCode(): int;
    interrupt(): void;
    join(millisecondsTimeout: int): boolean;
    join(): void;
    join(timeout: TimeSpan): boolean;
    resume(): void;
    setApartmentState(state: ApartmentState): void;
    setCompressedStack(stack: CompressedStack): void;
    start(parameter: any): void;
    start(): void;
    suspend(): void;
    trySetApartmentState(state: ApartmentState): boolean;
    unsafeStart(parameter: any): void;
    unsafeStart(): void;
    static CurrentPrincipal: IPrincipal;
    static readonly CurrentThread: Thread;
    static AllocateDataSlot(): LocalDataStoreSlot;
    static AllocateNamedDataSlot(name: string): LocalDataStoreSlot;
    static BeginCriticalRegion(): void;
    static BeginThreadAffinity(): void;
    static EndCriticalRegion(): void;
    static EndThreadAffinity(): void;
    static FreeNamedDataSlot(name: string): void;
    static GetCurrentProcessorId(): int;
    static GetData(slot: LocalDataStoreSlot): any;
    static GetDomain(): AppDomain;
    static GetDomainID(): int;
    static GetNamedDataSlot(name: string): LocalDataStoreSlot;
    static MemoryBarrier(): void;
    static ResetAbort(): void;
    static SetData(slot: LocalDataStoreSlot, data: any): void;
    static Sleep(millisecondsTimeout: int): void;
    static Sleep(timeout: TimeSpan): void;
    static SpinWait(iterations: int): void;
    static VolatileRead(address: { value: TSByRef<byte> }): byte;
    static VolatileRead(address: { value: TSByRef<double> }): double;
    static VolatileRead(address: { value: TSByRef<short> }): short;
    static VolatileRead(address: { value: TSByRef<int> }): int;
    static VolatileRead(address: { value: TSByRef<long> }): long;
    static VolatileRead(address: { value: TSByRef<nint> }): nint;
    static VolatileRead(address: { value: TSByRef<any> }): any;
    static VolatileRead(address: { value: TSByRef<sbyte> }): sbyte;
    static VolatileRead(address: { value: TSByRef<float> }): float;
    static VolatileRead(address: { value: TSByRef<ushort> }): ushort;
    static VolatileRead(address: { value: TSByRef<uint> }): uint;
    static VolatileRead(address: { value: TSByRef<ulong> }): ulong;
    static VolatileRead(address: { value: TSByRef<nuint> }): nuint;
    static VolatileWrite(address: { value: TSByRef<byte> }, value: byte): void;
    static VolatileWrite(address: { value: TSByRef<double> }, value: double): void;
    static VolatileWrite(address: { value: TSByRef<short> }, value: short): void;
    static VolatileWrite(address: { value: TSByRef<int> }, value: int): void;
    static VolatileWrite(address: { value: TSByRef<long> }, value: long): void;
    static VolatileWrite(address: { value: TSByRef<nint> }, value: nint): void;
    static VolatileWrite(address: { value: TSByRef<any> }, value: any): void;
    static VolatileWrite(address: { value: TSByRef<sbyte> }, value: sbyte): void;
    static VolatileWrite(address: { value: TSByRef<float> }, value: float): void;
    static VolatileWrite(address: { value: TSByRef<ushort> }, value: ushort): void;
    static VolatileWrite(address: { value: TSByRef<uint> }, value: uint): void;
    static VolatileWrite(address: { value: TSByRef<ulong> }, value: ulong): void;
    static VolatileWrite(address: { value: TSByRef<nuint> }, value: nuint): void;
    static Yield(): boolean;
}


export type Thread = Thread$instance;

export class ThreadAbortException$instance extends System_Internal.SystemException$instance {
    readonly exceptionState: any;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadAbortException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadAbortException = ThreadAbortException$instance & __ThreadAbortException$views;


export class ThreadExceptionEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(t: Exception);
    readonly exception: Exception;
}


export type ThreadExceptionEventArgs = ThreadExceptionEventArgs$instance;

export class ThreadExceptionEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: ThreadExceptionEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: ThreadExceptionEventArgs): void;
}


export interface __ThreadExceptionEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadExceptionEventHandler = ThreadExceptionEventHandler$instance & __ThreadExceptionEventHandler$views;


export class ThreadInterruptedException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadInterruptedException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadInterruptedException = ThreadInterruptedException$instance & __ThreadInterruptedException$views;


export class ThreadLocal_1$instance<T> {
    constructor();
    constructor(trackAllValues: boolean);
    constructor(valueFactory: Func_1<T>);
    constructor(valueFactory: Func_1<T>, trackAllValues: boolean);
    readonly isValueCreated: boolean;
    value: T;
    readonly values: IList_1<T>;
    dispose(): void;
    toString(): string;
}


export interface __ThreadLocal_1$views<T> {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ThreadLocal_1<T> = ThreadLocal_1$instance<T> & __ThreadLocal_1$views<T>;


export class ThreadPoolBoundHandle$instance {
    readonly handle: SafeHandle;
    allocateNativeOverlapped(callback: IOCompletionCallback, state: any, pinData: any): TSUnsafePointer<NativeOverlapped>;
    allocateNativeOverlapped(preAllocated: PreAllocatedOverlapped): TSUnsafePointer<NativeOverlapped>;
    dispose(): void;
    freeNativeOverlapped(overlapped: TSUnsafePointer<NativeOverlapped>): void;
    unsafeAllocateNativeOverlapped(callback: IOCompletionCallback, state: any, pinData: any): TSUnsafePointer<NativeOverlapped>;
    static BindHandle(handle: SafeHandle): ThreadPoolBoundHandle;
    static GetNativeOverlappedState(overlapped: TSUnsafePointer<NativeOverlapped>): any;
}


export interface __ThreadPoolBoundHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ThreadPoolBoundHandle = ThreadPoolBoundHandle$instance & __ThreadPoolBoundHandle$views;


export class ThreadStart$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(): void;
}


export interface __ThreadStart$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStart = ThreadStart$instance & __ThreadStart$views;


export class ThreadStartException$instance extends System_Internal.SystemException$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadStartException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStartException = ThreadStartException$instance & __ThreadStartException$views;


export class ThreadStateException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadStateException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStateException = ThreadStateException$instance & __ThreadStateException$views;


export class Timer$instance extends System_Internal.MarshalByRefObject$instance {
    constructor(callback: TimerCallback, state: any, dueTime: int, period: int);
    constructor(callback: TimerCallback, state: any, dueTime: TimeSpan, period: TimeSpan);
    constructor(callback: TimerCallback, state: any, dueTime: uint, period: uint);
    constructor(callback: TimerCallback, state: any, dueTime: long, period: long);
    constructor(callback: TimerCallback);
    change(dueTime: int, period: int): boolean;
    change(dueTime: TimeSpan, period: TimeSpan): boolean;
    change(dueTime: uint, period: uint): boolean;
    change(dueTime: long, period: long): boolean;
    dispose(notifyObject: WaitHandle): boolean;
    dispose(): void;
    disposeAsync(): ValueTask;
    static readonly ActiveCount: long;
}


export interface __Timer$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_ITimer: ITimer$instance;
}

export type Timer = Timer$instance & __Timer$views;


export class TimerCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(state: any, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(state: any): void;
}


export interface __TimerCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TimerCallback = TimerCallback$instance & __TimerCallback$views;


export class WaitCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(state: any, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(state: any): void;
}


export interface __WaitCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitCallback = WaitCallback$instance & __WaitCallback$views;


export abstract class WaitHandle$instance extends System_Internal.MarshalByRefObject$instance {
    handle: nint;
    safeWaitHandle: SafeWaitHandle;
    close(): void;
    dispose(): void;
    waitOne(millisecondsTimeout: int): boolean;
    waitOne(timeout: TimeSpan): boolean;
    waitOne(): boolean;
    waitOne(millisecondsTimeout: int, exitContext: boolean): boolean;
    waitOne(timeout: TimeSpan, exitContext: boolean): boolean;
    static readonly WaitTimeout: int;
    static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, millisecondsTimeout: int, exitContext: boolean): boolean;
    static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, timeout: TimeSpan, exitContext: boolean): boolean;
    static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle): boolean;
    static WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): boolean;
    static WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: int): boolean;
    static WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): boolean;
    static WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan): boolean;
    static WaitAll(waitHandles: WaitHandle[]): boolean;
    static WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): int;
    static WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: int): int;
    static WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): int;
    static WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan): int;
    static WaitAny(waitHandles: WaitHandle[]): int;
}


export interface __WaitHandle$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type WaitHandle = WaitHandle$instance & __WaitHandle$views;


export class WaitHandleCannotBeOpenedException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __WaitHandleCannotBeOpenedException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitHandleCannotBeOpenedException = WaitHandleCannotBeOpenedException$instance & __WaitHandleCannotBeOpenedException$views;


export class WaitOrTimerCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(state: any, timedOut: boolean, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(state: any, timedOut: boolean): void;
}


export interface __WaitOrTimerCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitOrTimerCallback = WaitOrTimerCallback$instance & __WaitOrTimerCallback$views;


export abstract class EventWaitHandleAcl$instance {
    static Create(initialState: boolean, mode: EventResetMode, name: string, createdNew: { value: TSByRef<boolean> }, eventSecurity: EventWaitHandleSecurity): EventWaitHandle;
    static OpenExisting(name: string, rights: EventWaitHandleRights): EventWaitHandle;
    static TryOpenExisting(name: string, rights: EventWaitHandleRights, result: { value: TSByRef<EventWaitHandle> }): boolean;
}


export type EventWaitHandleAcl = EventWaitHandleAcl$instance;

export abstract class Interlocked$instance {
    static Add(location1: { value: TSByRef<int> }, value: int): int;
    static Add(location1: { value: TSByRef<long> }, value: long): long;
    static Add(location1: { value: TSByRef<uint> }, value: uint): uint;
    static Add(location1: { value: TSByRef<ulong> }, value: ulong): ulong;
    static And(location1: { value: TSByRef<int> }, value: int): int;
    static And(location1: { value: TSByRef<long> }, value: long): long;
    static And(location1: { value: TSByRef<uint> }, value: uint): uint;
    static And(location1: { value: TSByRef<ulong> }, value: ulong): ulong;
    static CompareExchange(location1: { value: TSByRef<byte> }, value: byte, comparand: byte): byte;
    static CompareExchange(location1: { value: TSByRef<double> }, value: double, comparand: double): double;
    static CompareExchange(location1: { value: TSByRef<short> }, value: short, comparand: short): short;
    static CompareExchange(location1: { value: TSByRef<int> }, value: int, comparand: int): int;
    static CompareExchange(location1: { value: TSByRef<long> }, value: long, comparand: long): long;
    static CompareExchange(location1: { value: TSByRef<nint> }, value: nint, comparand: nint): nint;
    static CompareExchange(location1: { value: TSByRef<any> }, value: any, comparand: any): any;
    static CompareExchange(location1: { value: TSByRef<sbyte> }, value: sbyte, comparand: sbyte): sbyte;
    static CompareExchange(location1: { value: TSByRef<float> }, value: float, comparand: float): float;
    static CompareExchange(location1: { value: TSByRef<ushort> }, value: ushort, comparand: ushort): ushort;
    static CompareExchange(location1: { value: TSByRef<uint> }, value: uint, comparand: uint): uint;
    static CompareExchange(location1: { value: TSByRef<ulong> }, value: ulong, comparand: ulong): ulong;
    static CompareExchange(location1: { value: TSByRef<nuint> }, value: nuint, comparand: nuint): nuint;
    static CompareExchange<T>(location1: { value: TSByRef<T> }, value: T, comparand: T): T;
    static Decrement(location: { value: TSByRef<int> }): int;
    static Decrement(location: { value: TSByRef<long> }): long;
    static Decrement(location: { value: TSByRef<uint> }): uint;
    static Decrement(location: { value: TSByRef<ulong> }): ulong;
    static Exchange(location1: { value: TSByRef<byte> }, value: byte): byte;
    static Exchange(location1: { value: TSByRef<double> }, value: double): double;
    static Exchange(location1: { value: TSByRef<short> }, value: short): short;
    static Exchange(location1: { value: TSByRef<int> }, value: int): int;
    static Exchange(location1: { value: TSByRef<long> }, value: long): long;
    static Exchange(location1: { value: TSByRef<nint> }, value: nint): nint;
    static Exchange(location1: { value: TSByRef<any> }, value: any): any;
    static Exchange(location1: { value: TSByRef<sbyte> }, value: sbyte): sbyte;
    static Exchange(location1: { value: TSByRef<float> }, value: float): float;
    static Exchange(location1: { value: TSByRef<ushort> }, value: ushort): ushort;
    static Exchange(location1: { value: TSByRef<uint> }, value: uint): uint;
    static Exchange(location1: { value: TSByRef<ulong> }, value: ulong): ulong;
    static Exchange(location1: { value: TSByRef<nuint> }, value: nuint): nuint;
    static Exchange<T>(location1: { value: TSByRef<T> }, value: T): T;
    static Increment(location: { value: TSByRef<int> }): int;
    static Increment(location: { value: TSByRef<long> }): long;
    static Increment(location: { value: TSByRef<uint> }): uint;
    static Increment(location: { value: TSByRef<ulong> }): ulong;
    static MemoryBarrier(): void;
    static MemoryBarrierProcessWide(): void;
    static Or(location1: { value: TSByRef<int> }, value: int): int;
    static Or(location1: { value: TSByRef<long> }, value: long): long;
    static Or(location1: { value: TSByRef<uint> }, value: uint): uint;
    static Or(location1: { value: TSByRef<ulong> }, value: ulong): ulong;
    static Read(location: { value: TSByRef<long> }): long;
    static Read(location: { value: TSByRef<ulong> }): ulong;
}


export type Interlocked = Interlocked$instance;

export abstract class LazyInitializer$instance {
    static EnsureInitialized<T>(target: { value: TSByRef<T> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: TSByRef<T> }, initialized: { value: TSByRef<boolean> }, syncLock: { value: TSByRef<any> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: TSByRef<T> }, initialized: { value: TSByRef<boolean> }, syncLock: { value: TSByRef<any> }): T;
    static EnsureInitialized<T>(target: { value: TSByRef<T> }, syncLock: { value: TSByRef<any> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: TSByRef<T> }): T;
}


export type LazyInitializer = LazyInitializer$instance;

export abstract class Monitor$instance {
    static readonly LockContentionCount: long;
    static Enter(obj: any, lockTaken: { value: TSByRef<boolean> }): void;
    static Enter(obj: any): void;
    static Exit(obj: any): void;
    static IsEntered(obj: any): boolean;
    static Pulse(obj: any): void;
    static PulseAll(obj: any): void;
    static TryEnter(obj: any, lockTaken: { value: TSByRef<boolean> }): void;
    static TryEnter(obj: any, millisecondsTimeout: int, lockTaken: { value: TSByRef<boolean> }): void;
    static TryEnter(obj: any, millisecondsTimeout: int): boolean;
    static TryEnter(obj: any, timeout: TimeSpan, lockTaken: { value: TSByRef<boolean> }): void;
    static TryEnter(obj: any, timeout: TimeSpan): boolean;
    static TryEnter(obj: any): boolean;
    static Wait(obj: any, millisecondsTimeout: int, exitContext: boolean): boolean;
    static Wait(obj: any, millisecondsTimeout: int): boolean;
    static Wait(obj: any, timeout: TimeSpan, exitContext: boolean): boolean;
    static Wait(obj: any, timeout: TimeSpan): boolean;
    static Wait(obj: any): boolean;
}


export type Monitor = Monitor$instance;

export abstract class MutexAcl$instance {
    static Create(initiallyOwned: boolean, name: string, createdNew: { value: TSByRef<boolean> }, mutexSecurity: MutexSecurity): Mutex;
    static OpenExisting(name: string, rights: MutexRights): Mutex;
    static TryOpenExisting(name: string, rights: MutexRights, result: { value: TSByRef<Mutex> }): boolean;
}


export type MutexAcl = MutexAcl$instance;

export abstract class SemaphoreAcl$instance {
    static Create(initialCount: int, maximumCount: int, name: string, createdNew: { value: TSByRef<boolean> }, semaphoreSecurity: SemaphoreSecurity): Semaphore;
    static OpenExisting(name: string, rights: SemaphoreRights): Semaphore;
    static TryOpenExisting(name: string, rights: SemaphoreRights, result: { value: TSByRef<Semaphore> }): boolean;
}


export type SemaphoreAcl = SemaphoreAcl$instance;

export abstract class ThreadingAclExtensions$instance {
    static GetAccessControl(handle: EventWaitHandle): EventWaitHandleSecurity;
    static GetAccessControl(mutex: Mutex): MutexSecurity;
    static GetAccessControl(semaphore: Semaphore): SemaphoreSecurity;
    static SetAccessControl(handle: EventWaitHandle, eventSecurity: EventWaitHandleSecurity): void;
    static SetAccessControl(mutex: Mutex, mutexSecurity: MutexSecurity): void;
    static SetAccessControl(semaphore: Semaphore, semaphoreSecurity: SemaphoreSecurity): void;
}


export type ThreadingAclExtensions = ThreadingAclExtensions$instance;

export abstract class ThreadPool$instance {
    static readonly PendingWorkItemCount: long;
    static readonly ThreadCount: int;
    static readonly CompletedWorkItemCount: long;
    static BindHandle(osHandle: nint): boolean;
    static BindHandle(osHandle: SafeHandle): boolean;
    static GetAvailableThreads(workerThreads: { value: TSByRef<int> }, completionPortThreads: { value: TSByRef<int> }): void;
    static GetMaxThreads(workerThreads: { value: TSByRef<int> }, completionPortThreads: { value: TSByRef<int> }): void;
    static GetMinThreads(workerThreads: { value: TSByRef<int> }, completionPortThreads: { value: TSByRef<int> }): void;
    static QueueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static QueueUserWorkItem(callBack: WaitCallback, state: any): boolean;
    static QueueUserWorkItem(callBack: WaitCallback): boolean;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static SetMaxThreads(workerThreads: int, completionPortThreads: int): boolean;
    static SetMinThreads(workerThreads: int, completionPortThreads: int): boolean;
    static UnsafeQueueNativeOverlapped(overlapped: TSUnsafePointer<NativeOverlapped>): boolean;
    static UnsafeQueueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static UnsafeQueueUserWorkItem(callBack: IThreadPoolWorkItem, preferLocal: boolean): boolean;
    static UnsafeQueueUserWorkItem(callBack: WaitCallback, state: any): boolean;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: any, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
}


export type ThreadPool = ThreadPool$instance;

export abstract class Timeout$instance {
    static readonly infiniteTimeSpan: TimeSpan;
    static readonly Infinite: int;
}


export type Timeout = Timeout$instance;

export abstract class Volatile$instance {
    static Read(location: { value: TSByRef<boolean> }): boolean;
    static Read(location: { value: TSByRef<byte> }): byte;
    static Read(location: { value: TSByRef<double> }): double;
    static Read(location: { value: TSByRef<short> }): short;
    static Read(location: { value: TSByRef<int> }): int;
    static Read(location: { value: TSByRef<long> }): long;
    static Read(location: { value: TSByRef<nint> }): nint;
    static Read(location: { value: TSByRef<sbyte> }): sbyte;
    static Read(location: { value: TSByRef<float> }): float;
    static Read(location: { value: TSByRef<ushort> }): ushort;
    static Read(location: { value: TSByRef<uint> }): uint;
    static Read(location: { value: TSByRef<ulong> }): ulong;
    static Read(location: { value: TSByRef<nuint> }): nuint;
    static Read<T>(location: { value: TSByRef<T> }): T;
    static ReadBarrier(): void;
    static Write(location: { value: TSByRef<boolean> }, value: boolean): void;
    static Write(location: { value: TSByRef<byte> }, value: byte): void;
    static Write(location: { value: TSByRef<double> }, value: double): void;
    static Write(location: { value: TSByRef<short> }, value: short): void;
    static Write(location: { value: TSByRef<int> }, value: int): void;
    static Write(location: { value: TSByRef<long> }, value: long): void;
    static Write(location: { value: TSByRef<nint> }, value: nint): void;
    static Write(location: { value: TSByRef<sbyte> }, value: sbyte): void;
    static Write(location: { value: TSByRef<float> }, value: float): void;
    static Write(location: { value: TSByRef<ushort> }, value: ushort): void;
    static Write(location: { value: TSByRef<uint> }, value: uint): void;
    static Write(location: { value: TSByRef<ulong> }, value: ulong): void;
    static Write(location: { value: TSByRef<nuint> }, value: nuint): void;
    static Write<T>(location: { value: TSByRef<T> }, value: T): void;
    static WriteBarrier(): void;
}


export type Volatile = Volatile$instance;

export abstract class WaitHandleExtensions$instance {
    static GetSafeWaitHandle(waitHandle: WaitHandle): SafeWaitHandle;
    static SetSafeWaitHandle(waitHandle: WaitHandle, value: SafeWaitHandle): void;
}


export type WaitHandleExtensions = WaitHandleExtensions$instance;

