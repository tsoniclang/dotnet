// Generated by tsbindgen - Architecture
// Namespace: System.Threading
// Assembly: System.Private.CoreLib, System.Threading, System.Threading.AccessControl

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeWaitHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { EventWaitHandleRights, EventWaitHandleSecurity, MutexRights, MutexSecurity, SemaphoreRights, SemaphoreSecurity } from "../../System.Security.AccessControl/internal/index.js";
import type { IPrincipal } from "../../System.Security.Principal/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, AppDomain, ApplicationException, AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, Double, Enum, EventArgs, Exception, Func_1, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, LocalDataStoreSlot, MarshalByRefObject, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, SByte, Single, String as ClrString, SystemException, TimeProvider, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ApartmentState {
    STA = 0,
    MTA = 1,
    Unknown = 2
}


export enum EventResetMode {
    AutoReset = 0,
    ManualReset = 1
}


export enum LazyThreadSafetyMode {
    None = 0,
    PublicationOnly = 1,
    ExecutionAndPublication = 2
}


export enum LockRecursionPolicy {
    NoRecursion = 0,
    SupportsRecursion = 1
}


export enum ThreadPriority {
    Lowest = 0,
    BelowNormal = 1,
    Normal = 2,
    AboveNormal = 3,
    Highest = 4
}


export enum ThreadState {
    Running = 0,
    StopRequested = 1,
    SuspendRequested = 2,
    Background = 4,
    Unstarted = 8,
    Stopped = 16,
    WaitSleepJoin = 32,
    Suspended = 64,
    AbortRequested = 128,
    Aborted = 256
}


export interface IThreadPoolWorkItem$instance {
    Execute(): void;
}


export type IThreadPoolWorkItem = IThreadPoolWorkItem$instance;

export interface ITimer$instance {
    Change(dueTime: TimeSpan, period: TimeSpan): boolean;
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export type ITimer = ITimer$instance;

export class AsyncFlowControl$instance {
    Dispose(): void;
    Equals(obj: unknown): boolean;
    Equals(obj: AsyncFlowControl): boolean;
    GetHashCode(): int;
    Undo(): void;
}


export interface __AsyncFlowControl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<AsyncFlowControl>;

    // Structural method bridges for numeric interface constraints
    Equals(other: AsyncFlowControl): boolean;
}

export type AsyncFlowControl = AsyncFlowControl$instance & __AsyncFlowControl$views;


export class AsyncLocalValueChangedArgs_1$instance<T> {
    readonly CurrentValue: T;
    readonly PreviousValue: T;
    readonly ThreadContextChanged: boolean;
}


export type AsyncLocalValueChangedArgs_1<T> = AsyncLocalValueChangedArgs_1$instance<T>;

export class CancellationToken$instance {
    constructor(canceled: boolean);
    readonly CanBeCanceled: boolean;
    readonly IsCancellationRequested: boolean;
    readonly WaitHandle: WaitHandle;
    Equals(other: CancellationToken): boolean;
    Equals(other: unknown): boolean;
    GetHashCode(): int;
    Register(callback: Action): CancellationTokenRegistration;
    Register(callback: Action, useSynchronizationContext: boolean): CancellationTokenRegistration;
    Register(callback: Action_1<unknown>, state: unknown): CancellationTokenRegistration;
    Register(callback: Action_2<unknown, CancellationToken>, state: unknown): CancellationTokenRegistration;
    Register(callback: Action_1<unknown>, state: unknown, useSynchronizationContext: boolean): CancellationTokenRegistration;
    ThrowIfCancellationRequested(): void;
    UnsafeRegister(callback: Action_1<unknown>, state: unknown): CancellationTokenRegistration;
    UnsafeRegister(callback: Action_2<unknown, CancellationToken>, state: unknown): CancellationTokenRegistration;
    static readonly None: CancellationToken;
}


export interface __CancellationToken$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CancellationToken>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationToken): boolean;
}

export type CancellationToken = CancellationToken$instance & __CancellationToken$views;


export class CancellationTokenRegistration$instance {
    readonly Token: CancellationToken;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Equals(obj: unknown): boolean;
    Equals(other: CancellationTokenRegistration): boolean;
    GetHashCode(): int;
    Unregister(): boolean;
}


export interface __CancellationTokenRegistration$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CancellationTokenRegistration>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationTokenRegistration): boolean;
}

export type CancellationTokenRegistration = CancellationTokenRegistration$instance & __CancellationTokenRegistration$views;


export class Lock_Scope$instance {
    Dispose(): void;
}


export type Lock_Scope = Lock_Scope$instance;

export class LockCookie$instance {
    Equals(obj: unknown): boolean;
    Equals(obj: LockCookie): boolean;
    GetHashCode(): int;
}


export interface __LockCookie$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LockCookie>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LockCookie): boolean;
}

export type LockCookie = LockCookie$instance & __LockCookie$views;


export class NamedWaitHandleOptions$instance {
    CurrentSessionOnly: boolean;
    CurrentUserOnly: boolean;
}


export type NamedWaitHandleOptions = NamedWaitHandleOptions$instance;

export class NativeOverlapped$instance {
    InternalLow: nint;
    InternalHigh: nint;
    OffsetLow: int;
    OffsetHigh: int;
    EventHandle: nint;
}


export type NativeOverlapped = NativeOverlapped$instance;

export class SpinLock$instance {
    constructor(enableThreadOwnerTracking: boolean);
    readonly IsHeld: boolean;
    readonly IsHeldByCurrentThread: boolean;
    readonly IsThreadOwnerTrackingEnabled: boolean;
    Enter(lockTaken: { value: ref<boolean> }): void;
    Exit(): void;
    Exit(useMemoryBarrier: boolean): void;
    TryEnter(lockTaken: { value: ref<boolean> }): void;
    TryEnter(timeout: TimeSpan, lockTaken: { value: ref<boolean> }): void;
    TryEnter(millisecondsTimeout: int, lockTaken: { value: ref<boolean> }): void;
}


export type SpinLock = SpinLock$instance;

export class SpinWait$instance {
    readonly Count: int;
    readonly NextSpinWillYield: boolean;
    Reset(): void;
    SpinOnce(): void;
    SpinOnce(sleep1Threshold: int): void;
    static SpinUntil(condition: Func_1<CLROf<boolean>>, millisecondsTimeout: int): boolean;
    static SpinUntil(condition: Func_1<CLROf<boolean>>, timeout: TimeSpan): boolean;
    static SpinUntil(condition: Func_1<CLROf<boolean>>): void;
}


export type SpinWait = SpinWait$instance;

export class AbandonedMutexException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(location: int, handle: WaitHandle);
    constructor(message: string, location: int, handle: WaitHandle);
    constructor(message: string, inner: Exception, location: int, handle: WaitHandle);
    readonly Mutex: Mutex;
    readonly MutexIndex: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AbandonedMutexException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AbandonedMutexException = AbandonedMutexException$instance & __AbandonedMutexException$views;


export class AsyncLocal_1$instance<T> {
    constructor();
    constructor(valueChangedHandler: Action_1<AsyncLocalValueChangedArgs_1<T>>);
    Value: T;
}


export type AsyncLocal_1<T> = AsyncLocal_1$instance<T>;

export class AutoResetEvent$instance extends EventWaitHandle$instance {
    constructor(initialState: boolean);
    Dispose(): void;
}


export interface __AutoResetEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AutoResetEvent = AutoResetEvent$instance & __AutoResetEvent$views;


export class Barrier$instance {
    constructor(participantCount: int);
    constructor(participantCount: int, postPhaseAction: Action_1<Barrier>);
    readonly CurrentPhaseNumber: long;
    readonly ParticipantCount: int;
    readonly ParticipantsRemaining: int;
    AddParticipant(): long;
    AddParticipants(participantCount: int): long;
    Dispose(): void;
    RemoveParticipant(): void;
    RemoveParticipants(participantCount: int): void;
    SignalAndWait(): void;
    SignalAndWait(cancellationToken: CancellationToken): void;
    SignalAndWait(timeout: TimeSpan): boolean;
    SignalAndWait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    SignalAndWait(millisecondsTimeout: int): boolean;
    SignalAndWait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export interface __Barrier$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Barrier = Barrier$instance & __Barrier$views;


export class BarrierPostPhaseException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(innerException: Exception);
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __BarrierPostPhaseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BarrierPostPhaseException = BarrierPostPhaseException$instance & __BarrierPostPhaseException$views;


export class CancellationTokenSource$instance {
    constructor();
    constructor(delay: TimeSpan);
    constructor(delay: TimeSpan, timeProvider: TimeProvider);
    constructor(millisecondsDelay: int);
    readonly IsCancellationRequested: boolean;
    readonly Token: CancellationToken;
    Cancel(): void;
    Cancel(throwOnFirstException: boolean): void;
    CancelAfter(delay: TimeSpan): void;
    CancelAfter(millisecondsDelay: int): void;
    CancelAsync(): Task;
    Dispose(): void;
    TryReset(): boolean;
    static CreateLinkedTokenSource(tokens: ReadOnlySpan_1<CancellationToken>): CancellationTokenSource;
    static CreateLinkedTokenSource(token1: CancellationToken, token2: CancellationToken): CancellationTokenSource;
    static CreateLinkedTokenSource(token: CancellationToken): CancellationTokenSource;
    static CreateLinkedTokenSource(tokens: CancellationToken[]): CancellationTokenSource;
}


export interface __CancellationTokenSource$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type CancellationTokenSource = CancellationTokenSource$instance & __CancellationTokenSource$views;


export class CompressedStack$instance {
    CreateCopy(): CompressedStack;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    static Capture(): CompressedStack;
    static GetCompressedStack(): CompressedStack;
    static Run(compressedStack: CompressedStack, callback: ContextCallback, state: unknown): void;
}


export interface __CompressedStack$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CompressedStack = CompressedStack$instance & __CompressedStack$views;


export class ContextCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(state: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(state: unknown): void;
}


export interface __ContextCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ContextCallback = ContextCallback$instance & __ContextCallback$views;


export class CountdownEvent$instance {
    constructor(initialCount: int);
    readonly CurrentCount: int;
    readonly InitialCount: int;
    readonly IsSet: boolean;
    readonly WaitHandle: WaitHandle;
    AddCount(): void;
    AddCount(signalCount: int): void;
    Dispose(): void;
    Reset(): void;
    Reset(count: int): void;
    Signal(): boolean;
    Signal(signalCount: int): boolean;
    TryAddCount(): boolean;
    TryAddCount(signalCount: int): boolean;
    Wait(): void;
    Wait(cancellationToken: CancellationToken): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export interface __CountdownEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type CountdownEvent = CountdownEvent$instance & __CountdownEvent$views;


export class EventWaitHandle$instance extends WaitHandle$instance {
    constructor(initialState: boolean, mode: EventResetMode);
    constructor(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions);
    constructor(initialState: boolean, mode: EventResetMode, name: string);
    constructor(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>);
    constructor(initialState: boolean, mode: EventResetMode, name: string, createdNew: ref<boolean>);
    Dispose(): void;
    Reset(): boolean;
    Set(): boolean;
    static OpenExisting(name: string, options: NamedWaitHandleOptions): EventWaitHandle;
    static OpenExisting(name: string): EventWaitHandle;
    static TryOpenExisting(name: string, result: { value: ref<EventWaitHandle> }): boolean;
    static TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<EventWaitHandle> }): boolean;
}


export interface __EventWaitHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type EventWaitHandle = EventWaitHandle$instance & __EventWaitHandle$views;


export class ExecutionContext$instance {
    CreateCopy(): ExecutionContext;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    static Capture(): ExecutionContext;
    static IsFlowSuppressed(): boolean;
    static Restore(executionContext: ExecutionContext): void;
    static RestoreFlow(): void;
    static Run(executionContext: ExecutionContext, callback: ContextCallback, state: unknown): void;
    static SuppressFlow(): AsyncFlowControl;
}


export interface __ExecutionContext$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExecutionContext = ExecutionContext$instance & __ExecutionContext$views;


export class HostExecutionContext$instance {
    constructor();
    constructor(state: unknown);
    CreateCopy(): HostExecutionContext;
    Dispose(): void;
    Dispose(disposing: boolean): void;
}


export interface __HostExecutionContext$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type HostExecutionContext = HostExecutionContext$instance & __HostExecutionContext$views;


export class HostExecutionContextManager$instance {
    constructor();
    Capture(): HostExecutionContext;
    Revert(previousState: unknown): void;
    SetHostExecutionContext(hostExecutionContext: HostExecutionContext): unknown;
}


export type HostExecutionContextManager = HostExecutionContextManager$instance;

export class IOCompletionCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(errorCode: uint, numBytes: uint, pOVERLAP: ptr<NativeOverlapped>, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(errorCode: uint, numBytes: uint, pOVERLAP: ptr<NativeOverlapped>): void;
}


export interface __IOCompletionCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IOCompletionCallback = IOCompletionCallback$instance & __IOCompletionCallback$views;


export class Lock$instance {
    constructor();
    readonly IsHeldByCurrentThread: boolean;
    Enter(): void;
    EnterScope(): Lock_Scope;
    Exit(): void;
    TryEnter(): boolean;
    TryEnter(millisecondsTimeout: int): boolean;
    TryEnter(timeout: TimeSpan): boolean;
}


export type Lock = Lock$instance;

export class LockRecursionException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __LockRecursionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LockRecursionException = LockRecursionException$instance & __LockRecursionException$views;


export class ManualResetEvent$instance extends EventWaitHandle$instance {
    constructor(initialState: boolean);
    Dispose(): void;
}


export interface __ManualResetEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ManualResetEvent = ManualResetEvent$instance & __ManualResetEvent$views;


export class ManualResetEventSlim$instance {
    constructor();
    constructor(initialState: boolean);
    constructor(initialState: boolean, spinCount: int);
    readonly IsSet: boolean;
    readonly SpinCount: int;
    readonly WaitHandle: WaitHandle;
    Dispose(): void;
    Reset(): void;
    Set(): void;
    Wait(): void;
    Wait(cancellationToken: CancellationToken): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export interface __ManualResetEventSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ManualResetEventSlim = ManualResetEventSlim$instance & __ManualResetEventSlim$views;


export class Mutex$instance extends WaitHandle$instance {
    constructor(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>);
    constructor(initiallyOwned: boolean, name: string, createdNew: ref<boolean>);
    constructor(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions);
    constructor(initiallyOwned: boolean, name: string);
    constructor(name: string, options: NamedWaitHandleOptions);
    constructor(initiallyOwned: boolean);
    constructor();
    Dispose(): void;
    ReleaseMutex(): void;
    static OpenExisting(name: string, options: NamedWaitHandleOptions): Mutex;
    static OpenExisting(name: string): Mutex;
    static TryOpenExisting(name: string, result: { value: ref<Mutex> }): boolean;
    static TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<Mutex> }): boolean;
}


export interface __Mutex$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Mutex = Mutex$instance & __Mutex$views;


export class Overlapped$instance {
    constructor();
    constructor(offsetLo: int, offsetHi: int, hEvent: nint, ar: IAsyncResult);
    constructor(offsetLo: int, offsetHi: int, hEvent: int, ar: IAsyncResult);
    AsyncResult: IAsyncResult;
    EventHandle: int;
    EventHandleIntPtr: nint;
    OffsetHigh: int;
    OffsetLow: int;
    Pack(iocb: IOCompletionCallback): ptr<NativeOverlapped>;
    Pack(iocb: IOCompletionCallback, userData: unknown): ptr<NativeOverlapped>;
    UnsafePack(iocb: IOCompletionCallback): ptr<NativeOverlapped>;
    UnsafePack(iocb: IOCompletionCallback, userData: unknown): ptr<NativeOverlapped>;
    static Free(nativeOverlappedPtr: ptr<NativeOverlapped>): void;
    static Unpack(nativeOverlappedPtr: ptr<NativeOverlapped>): Overlapped;
}


export type Overlapped = Overlapped$instance;

export class ParameterizedThreadStart$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(obj: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(obj: unknown): void;
}


export interface __ParameterizedThreadStart$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ParameterizedThreadStart = ParameterizedThreadStart$instance & __ParameterizedThreadStart$views;


export class PeriodicTimer$instance {
    constructor(period: TimeSpan);
    constructor(period: TimeSpan, timeProvider: TimeProvider);
    Period: TimeSpan;
    Dispose(): void;
    WaitForNextTickAsync(cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
}


export interface __PeriodicTimer$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type PeriodicTimer = PeriodicTimer$instance & __PeriodicTimer$views;


export class PreAllocatedOverlapped$instance {
    constructor(callback: IOCompletionCallback, state: unknown, pinData: unknown);
    Dispose(): void;
    static UnsafeCreate(callback: IOCompletionCallback, state: unknown, pinData: unknown): PreAllocatedOverlapped;
}


export interface __PreAllocatedOverlapped$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type PreAllocatedOverlapped = PreAllocatedOverlapped$instance & __PreAllocatedOverlapped$views;


export class ReaderWriterLock$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    constructor();
    readonly IsReaderLockHeld: boolean;
    readonly IsWriterLockHeld: boolean;
    readonly WriterSeqNum: int;
    AcquireReaderLock(millisecondsTimeout: int): void;
    AcquireReaderLock(timeout: TimeSpan): void;
    AcquireWriterLock(millisecondsTimeout: int): void;
    AcquireWriterLock(timeout: TimeSpan): void;
    AnyWritersSince(seqNum: int): boolean;
    DowngradeFromWriterLock(lockCookie: { value: ref<LockCookie> }): void;
    ReleaseLock(): LockCookie;
    ReleaseReaderLock(): void;
    ReleaseWriterLock(): void;
    RestoreLock(lockCookie: { value: ref<LockCookie> }): void;
    UpgradeToWriterLock(millisecondsTimeout: int): LockCookie;
    UpgradeToWriterLock(timeout: TimeSpan): LockCookie;
}


export type ReaderWriterLock = ReaderWriterLock$instance;

export class ReaderWriterLockSlim$instance {
    constructor();
    constructor(recursionPolicy: LockRecursionPolicy);
    readonly CurrentReadCount: int;
    readonly IsReadLockHeld: boolean;
    readonly IsUpgradeableReadLockHeld: boolean;
    readonly IsWriteLockHeld: boolean;
    readonly RecursionPolicy: LockRecursionPolicy;
    readonly RecursiveReadCount: int;
    readonly RecursiveUpgradeCount: int;
    readonly RecursiveWriteCount: int;
    readonly WaitingReadCount: int;
    readonly WaitingUpgradeCount: int;
    readonly WaitingWriteCount: int;
    Dispose(): void;
    EnterReadLock(): void;
    EnterUpgradeableReadLock(): void;
    EnterWriteLock(): void;
    ExitReadLock(): void;
    ExitUpgradeableReadLock(): void;
    ExitWriteLock(): void;
    TryEnterReadLock(timeout: TimeSpan): boolean;
    TryEnterReadLock(millisecondsTimeout: int): boolean;
    TryEnterUpgradeableReadLock(timeout: TimeSpan): boolean;
    TryEnterUpgradeableReadLock(millisecondsTimeout: int): boolean;
    TryEnterWriteLock(timeout: TimeSpan): boolean;
    TryEnterWriteLock(millisecondsTimeout: int): boolean;
}


export interface __ReaderWriterLockSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ReaderWriterLockSlim = ReaderWriterLockSlim$instance & __ReaderWriterLockSlim$views;


export class RegisteredWaitHandle$instance extends System_Internal.MarshalByRefObject$instance {
    Unregister(waitObject: WaitHandle): boolean;
}


export type RegisteredWaitHandle = RegisteredWaitHandle$instance;

export class Semaphore$instance extends WaitHandle$instance {
    constructor(initialCount: int, maximumCount: int);
    constructor(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions);
    constructor(initialCount: int, maximumCount: int, name: string);
    constructor(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>);
    constructor(initialCount: int, maximumCount: int, name: string, createdNew: ref<boolean>);
    Dispose(): void;
    Release(): int;
    Release(releaseCount: int): int;
    static OpenExisting(name: string, options: NamedWaitHandleOptions): Semaphore;
    static OpenExisting(name: string): Semaphore;
    static TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<Semaphore> }): boolean;
    static TryOpenExisting(name: string, result: { value: ref<Semaphore> }): boolean;
}


export interface __Semaphore$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Semaphore = Semaphore$instance & __Semaphore$views;


export class SemaphoreFullException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SemaphoreFullException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SemaphoreFullException = SemaphoreFullException$instance & __SemaphoreFullException$views;


export class SemaphoreSlim$instance {
    constructor(initialCount: int);
    constructor(initialCount: int, maxCount: int);
    readonly AvailableWaitHandle: WaitHandle;
    readonly CurrentCount: int;
    Dispose(): void;
    Release(): int;
    Release(releaseCount: int): int;
    Wait(): void;
    Wait(cancellationToken: CancellationToken): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    WaitAsync(): Task;
    WaitAsync(cancellationToken: CancellationToken): Task;
    WaitAsync(millisecondsTimeout: int): Task_1<CLROf<boolean>>;
    WaitAsync(timeout: TimeSpan): Task_1<CLROf<boolean>>;
    WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    WaitAsync(millisecondsTimeout: int, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
}


export interface __SemaphoreSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SemaphoreSlim = SemaphoreSlim$instance & __SemaphoreSlim$views;


export class SendOrPostCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(state: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(state: unknown): void;
}


export interface __SendOrPostCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SendOrPostCallback = SendOrPostCallback$instance & __SendOrPostCallback$views;


export class SynchronizationContext$instance {
    constructor();
    CreateCopy(): SynchronizationContext;
    IsWaitNotificationRequired(): boolean;
    OperationCompleted(): void;
    OperationStarted(): void;
    Post(d: SendOrPostCallback, state: unknown): void;
    Send(d: SendOrPostCallback, state: unknown): void;
    Wait(waitHandles: nint[], waitAll: boolean, millisecondsTimeout: int): int;
    static readonly Current: SynchronizationContext;
    static SetSynchronizationContext(syncContext: SynchronizationContext): void;
}


export type SynchronizationContext = SynchronizationContext$instance;

export class SynchronizationLockException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SynchronizationLockException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SynchronizationLockException = SynchronizationLockException$instance & __SynchronizationLockException$views;


export class Thread$instance extends System_Runtime_ConstrainedExecution_Internal.CriticalFinalizerObject$instance {
    constructor(start: ThreadStart);
    constructor(start: ThreadStart, maxStackSize: int);
    constructor(start: ParameterizedThreadStart);
    constructor(start: ParameterizedThreadStart, maxStackSize: int);
    ApartmentState: ApartmentState;
    CurrentCulture: CultureInfo;
    CurrentUICulture: CultureInfo;
    readonly ExecutionContext: ExecutionContext;
    readonly IsAlive: boolean;
    IsBackground: boolean;
    readonly IsThreadPoolThread: boolean;
    readonly ManagedThreadId: int;
    Name: string;
    Priority: ThreadPriority;
    readonly ThreadState: ThreadState;
    Abort(): void;
    Abort(stateInfo: unknown): void;
    DisableComObjectEagerCleanup(): void;
    GetApartmentState(): ApartmentState;
    GetCompressedStack(): CompressedStack;
    GetHashCode(): int;
    Interrupt(): void;
    Join(millisecondsTimeout: int): boolean;
    Join(): void;
    Join(timeout: TimeSpan): boolean;
    Resume(): void;
    SetApartmentState(state: ApartmentState): void;
    SetCompressedStack(stack: CompressedStack): void;
    Start(parameter: unknown): void;
    Start(): void;
    Suspend(): void;
    TrySetApartmentState(state: ApartmentState): boolean;
    UnsafeStart(parameter: unknown): void;
    UnsafeStart(): void;
    static CurrentPrincipal: IPrincipal;
    static readonly CurrentThread: Thread;
    static AllocateDataSlot(): LocalDataStoreSlot;
    static AllocateNamedDataSlot(name: string): LocalDataStoreSlot;
    static BeginCriticalRegion(): void;
    static BeginThreadAffinity(): void;
    static EndCriticalRegion(): void;
    static EndThreadAffinity(): void;
    static FreeNamedDataSlot(name: string): void;
    static GetCurrentProcessorId(): int;
    static GetData(slot: LocalDataStoreSlot): unknown;
    static GetDomain(): AppDomain;
    static GetDomainID(): int;
    static GetNamedDataSlot(name: string): LocalDataStoreSlot;
    static MemoryBarrier(): void;
    static ResetAbort(): void;
    static SetData(slot: LocalDataStoreSlot, data: unknown): void;
    static Sleep(millisecondsTimeout: int): void;
    static Sleep(timeout: TimeSpan): void;
    static SpinWait(iterations: int): void;
    static VolatileRead(address: { value: ref<byte> }): byte;
    static VolatileRead(address: { value: ref<double> }): double;
    static VolatileRead(address: { value: ref<short> }): short;
    static VolatileRead(address: { value: ref<int> }): int;
    static VolatileRead(address: { value: ref<long> }): long;
    static VolatileRead(address: { value: ref<nint> }): nint;
    static VolatileRead(address: { value: ref<unknown> }): unknown;
    static VolatileRead(address: { value: ref<sbyte> }): sbyte;
    static VolatileRead(address: { value: ref<float> }): float;
    static VolatileRead(address: { value: ref<ushort> }): ushort;
    static VolatileRead(address: { value: ref<uint> }): uint;
    static VolatileRead(address: { value: ref<ulong> }): ulong;
    static VolatileRead(address: { value: ref<nuint> }): nuint;
    static VolatileWrite(address: { value: ref<byte> }, value: byte): void;
    static VolatileWrite(address: { value: ref<double> }, value: double): void;
    static VolatileWrite(address: { value: ref<short> }, value: short): void;
    static VolatileWrite(address: { value: ref<int> }, value: int): void;
    static VolatileWrite(address: { value: ref<long> }, value: long): void;
    static VolatileWrite(address: { value: ref<nint> }, value: nint): void;
    static VolatileWrite(address: { value: ref<unknown> }, value: unknown): void;
    static VolatileWrite(address: { value: ref<sbyte> }, value: sbyte): void;
    static VolatileWrite(address: { value: ref<float> }, value: float): void;
    static VolatileWrite(address: { value: ref<ushort> }, value: ushort): void;
    static VolatileWrite(address: { value: ref<uint> }, value: uint): void;
    static VolatileWrite(address: { value: ref<ulong> }, value: ulong): void;
    static VolatileWrite(address: { value: ref<nuint> }, value: nuint): void;
    static Yield(): boolean;
}


export type Thread = Thread$instance;

export class ThreadAbortException$instance extends System_Internal.SystemException$instance {
    readonly ExceptionState: unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadAbortException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadAbortException = ThreadAbortException$instance & __ThreadAbortException$views;


export class ThreadExceptionEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(t: Exception);
    readonly Exception: Exception;
}


export type ThreadExceptionEventArgs = ThreadExceptionEventArgs$instance;

export class ThreadExceptionEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(sender: unknown, e: ThreadExceptionEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: unknown, e: ThreadExceptionEventArgs): void;
}


export interface __ThreadExceptionEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadExceptionEventHandler = ThreadExceptionEventHandler$instance & __ThreadExceptionEventHandler$views;


export class ThreadInterruptedException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadInterruptedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadInterruptedException = ThreadInterruptedException$instance & __ThreadInterruptedException$views;


export class ThreadLocal_1$instance<T> {
    constructor();
    constructor(trackAllValues: boolean);
    constructor(valueFactory: Func_1<T>);
    constructor(valueFactory: Func_1<T>, trackAllValues: boolean);
    readonly IsValueCreated: boolean;
    Value: T;
    readonly Values: IList_1<T>;
    Dispose(): void;
    ToString(): string;
}


export interface __ThreadLocal_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ThreadLocal_1<T> = ThreadLocal_1$instance<T> & __ThreadLocal_1$views<T>;


export class ThreadPoolBoundHandle$instance {
    readonly Handle: SafeHandle;
    AllocateNativeOverlapped(callback: IOCompletionCallback, state: unknown, pinData: unknown): ptr<NativeOverlapped>;
    AllocateNativeOverlapped(preAllocated: PreAllocatedOverlapped): ptr<NativeOverlapped>;
    Dispose(): void;
    FreeNativeOverlapped(overlapped: ptr<NativeOverlapped>): void;
    UnsafeAllocateNativeOverlapped(callback: IOCompletionCallback, state: unknown, pinData: unknown): ptr<NativeOverlapped>;
    static BindHandle(handle: SafeHandle): ThreadPoolBoundHandle;
    static GetNativeOverlappedState(overlapped: ptr<NativeOverlapped>): unknown;
}


export interface __ThreadPoolBoundHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ThreadPoolBoundHandle = ThreadPoolBoundHandle$instance & __ThreadPoolBoundHandle$views;


export class ThreadStart$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(): void;
}


export interface __ThreadStart$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStart = ThreadStart$instance & __ThreadStart$views;


export class ThreadStartException$instance extends System_Internal.SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadStartException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStartException = ThreadStartException$instance & __ThreadStartException$views;


export class ThreadStateException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __ThreadStateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStateException = ThreadStateException$instance & __ThreadStateException$views;


export class Timer$instance extends System_Internal.MarshalByRefObject$instance {
    constructor(callback: TimerCallback, state: unknown, dueTime: int, period: int);
    constructor(callback: TimerCallback, state: unknown, dueTime: TimeSpan, period: TimeSpan);
    constructor(callback: TimerCallback, state: unknown, dueTime: uint, period: uint);
    constructor(callback: TimerCallback, state: unknown, dueTime: long, period: long);
    constructor(callback: TimerCallback);
    Change(dueTime: int, period: int): boolean;
    Change(dueTime: TimeSpan, period: TimeSpan): boolean;
    Change(dueTime: uint, period: uint): boolean;
    Change(dueTime: long, period: long): boolean;
    Dispose(notifyObject: WaitHandle): boolean;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    static readonly ActiveCount: long;
}


export interface __Timer$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ITimer(): ITimer$instance;
}

export type Timer = Timer$instance & __Timer$views;


export class TimerCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(state: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(state: unknown): void;
}


export interface __TimerCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TimerCallback = TimerCallback$instance & __TimerCallback$views;


export class WaitCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(state: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(state: unknown): void;
}


export interface __WaitCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitCallback = WaitCallback$instance & __WaitCallback$views;


export abstract class WaitHandle$instance extends System_Internal.MarshalByRefObject$instance {
    Handle: nint;
    SafeWaitHandle: SafeWaitHandle;
    Close(): void;
    Dispose(): void;
    WaitOne(millisecondsTimeout: int): boolean;
    WaitOne(timeout: TimeSpan): boolean;
    WaitOne(): boolean;
    WaitOne(millisecondsTimeout: int, exitContext: boolean): boolean;
    WaitOne(timeout: TimeSpan, exitContext: boolean): boolean;
    static readonly WaitTimeout: int;
    static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, millisecondsTimeout: int, exitContext: boolean): boolean;
    static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, timeout: TimeSpan, exitContext: boolean): boolean;
    static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle): boolean;
    static WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): boolean;
    static WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: int): boolean;
    static WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): boolean;
    static WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan): boolean;
    static WaitAll(waitHandles: WaitHandle[]): boolean;
    static WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): int;
    static WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: int): int;
    static WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): int;
    static WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan): int;
    static WaitAny(waitHandles: WaitHandle[]): int;
}


export interface __WaitHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type WaitHandle = WaitHandle$instance & __WaitHandle$views;


export class WaitHandleCannotBeOpenedException$instance extends System_Internal.ApplicationException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __WaitHandleCannotBeOpenedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitHandleCannotBeOpenedException = WaitHandleCannotBeOpenedException$instance & __WaitHandleCannotBeOpenedException$views;


export class WaitOrTimerCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(state: unknown, timedOut: boolean, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(state: unknown, timedOut: boolean): void;
}


export interface __WaitOrTimerCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitOrTimerCallback = WaitOrTimerCallback$instance & __WaitOrTimerCallback$views;


export abstract class EventWaitHandleAcl$instance {
    static Create(initialState: boolean, mode: EventResetMode, name: string, createdNew: { value: ref<boolean> }, eventSecurity: EventWaitHandleSecurity): EventWaitHandle;
    static OpenExisting(name: string, rights: EventWaitHandleRights): EventWaitHandle;
    static TryOpenExisting(name: string, rights: EventWaitHandleRights, result: { value: ref<EventWaitHandle> }): boolean;
}


export type EventWaitHandleAcl = EventWaitHandleAcl$instance;

export abstract class Interlocked$instance {
    static Add(location1: { value: ref<int> }, value: int): int;
    static Add(location1: { value: ref<long> }, value: long): long;
    static Add(location1: { value: ref<uint> }, value: uint): uint;
    static Add(location1: { value: ref<ulong> }, value: ulong): ulong;
    static And(location1: { value: ref<int> }, value: int): int;
    static And(location1: { value: ref<long> }, value: long): long;
    static And(location1: { value: ref<uint> }, value: uint): uint;
    static And(location1: { value: ref<ulong> }, value: ulong): ulong;
    static CompareExchange(location1: { value: ref<byte> }, value: byte, comparand: byte): byte;
    static CompareExchange(location1: { value: ref<double> }, value: double, comparand: double): double;
    static CompareExchange(location1: { value: ref<short> }, value: short, comparand: short): short;
    static CompareExchange(location1: { value: ref<int> }, value: int, comparand: int): int;
    static CompareExchange(location1: { value: ref<long> }, value: long, comparand: long): long;
    static CompareExchange(location1: { value: ref<nint> }, value: nint, comparand: nint): nint;
    static CompareExchange(location1: { value: ref<unknown> }, value: unknown, comparand: unknown): unknown;
    static CompareExchange(location1: { value: ref<sbyte> }, value: sbyte, comparand: sbyte): sbyte;
    static CompareExchange(location1: { value: ref<float> }, value: float, comparand: float): float;
    static CompareExchange(location1: { value: ref<ushort> }, value: ushort, comparand: ushort): ushort;
    static CompareExchange(location1: { value: ref<uint> }, value: uint, comparand: uint): uint;
    static CompareExchange(location1: { value: ref<ulong> }, value: ulong, comparand: ulong): ulong;
    static CompareExchange(location1: { value: ref<nuint> }, value: nuint, comparand: nuint): nuint;
    static CompareExchange<T>(location1: { value: ref<T> }, value: T, comparand: T): T;
    static Decrement(location: { value: ref<int> }): int;
    static Decrement(location: { value: ref<long> }): long;
    static Decrement(location: { value: ref<uint> }): uint;
    static Decrement(location: { value: ref<ulong> }): ulong;
    static Exchange(location1: { value: ref<byte> }, value: byte): byte;
    static Exchange(location1: { value: ref<double> }, value: double): double;
    static Exchange(location1: { value: ref<short> }, value: short): short;
    static Exchange(location1: { value: ref<int> }, value: int): int;
    static Exchange(location1: { value: ref<long> }, value: long): long;
    static Exchange(location1: { value: ref<nint> }, value: nint): nint;
    static Exchange(location1: { value: ref<unknown> }, value: unknown): unknown;
    static Exchange(location1: { value: ref<sbyte> }, value: sbyte): sbyte;
    static Exchange(location1: { value: ref<float> }, value: float): float;
    static Exchange(location1: { value: ref<ushort> }, value: ushort): ushort;
    static Exchange(location1: { value: ref<uint> }, value: uint): uint;
    static Exchange(location1: { value: ref<ulong> }, value: ulong): ulong;
    static Exchange(location1: { value: ref<nuint> }, value: nuint): nuint;
    static Exchange<T>(location1: { value: ref<T> }, value: T): T;
    static Increment(location: { value: ref<int> }): int;
    static Increment(location: { value: ref<long> }): long;
    static Increment(location: { value: ref<uint> }): uint;
    static Increment(location: { value: ref<ulong> }): ulong;
    static MemoryBarrier(): void;
    static MemoryBarrierProcessWide(): void;
    static Or(location1: { value: ref<int> }, value: int): int;
    static Or(location1: { value: ref<long> }, value: long): long;
    static Or(location1: { value: ref<uint> }, value: uint): uint;
    static Or(location1: { value: ref<ulong> }, value: ulong): ulong;
    static Read(location: { value: ref<long> }): long;
    static Read(location: { value: ref<ulong> }): ulong;
}


export type Interlocked = Interlocked$instance;

export abstract class LazyInitializer$instance {
    static EnsureInitialized<T>(target: { value: ref<T> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: ref<T> }, initialized: { value: ref<boolean> }, syncLock: { value: ref<unknown> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: ref<T> }, initialized: { value: ref<boolean> }, syncLock: { value: ref<unknown> }): T;
    static EnsureInitialized<T>(target: { value: ref<T> }, syncLock: { value: ref<unknown> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: ref<T> }): T;
}


export type LazyInitializer = LazyInitializer$instance;

export abstract class Monitor$instance {
    static readonly LockContentionCount: long;
    static Enter(obj: unknown, lockTaken: { value: ref<boolean> }): void;
    static Enter(obj: unknown): void;
    static Exit(obj: unknown): void;
    static IsEntered(obj: unknown): boolean;
    static Pulse(obj: unknown): void;
    static PulseAll(obj: unknown): void;
    static TryEnter(obj: unknown, lockTaken: { value: ref<boolean> }): void;
    static TryEnter(obj: unknown, millisecondsTimeout: int, lockTaken: { value: ref<boolean> }): void;
    static TryEnter(obj: unknown, millisecondsTimeout: int): boolean;
    static TryEnter(obj: unknown, timeout: TimeSpan, lockTaken: { value: ref<boolean> }): void;
    static TryEnter(obj: unknown, timeout: TimeSpan): boolean;
    static TryEnter(obj: unknown): boolean;
    static Wait(obj: unknown, millisecondsTimeout: int, exitContext: boolean): boolean;
    static Wait(obj: unknown, millisecondsTimeout: int): boolean;
    static Wait(obj: unknown, timeout: TimeSpan, exitContext: boolean): boolean;
    static Wait(obj: unknown, timeout: TimeSpan): boolean;
    static Wait(obj: unknown): boolean;
}


export type Monitor = Monitor$instance;

export abstract class MutexAcl$instance {
    static Create(initiallyOwned: boolean, name: string, createdNew: { value: ref<boolean> }, mutexSecurity: MutexSecurity): Mutex;
    static OpenExisting(name: string, rights: MutexRights): Mutex;
    static TryOpenExisting(name: string, rights: MutexRights, result: { value: ref<Mutex> }): boolean;
}


export type MutexAcl = MutexAcl$instance;

export abstract class SemaphoreAcl$instance {
    static Create(initialCount: int, maximumCount: int, name: string, createdNew: { value: ref<boolean> }, semaphoreSecurity: SemaphoreSecurity): Semaphore;
    static OpenExisting(name: string, rights: SemaphoreRights): Semaphore;
    static TryOpenExisting(name: string, rights: SemaphoreRights, result: { value: ref<Semaphore> }): boolean;
}


export type SemaphoreAcl = SemaphoreAcl$instance;

export abstract class ThreadingAclExtensions$instance {
    static GetAccessControl(handle: EventWaitHandle): EventWaitHandleSecurity;
    static GetAccessControl(mutex: Mutex): MutexSecurity;
    static GetAccessControl(semaphore: Semaphore): SemaphoreSecurity;
    static SetAccessControl(handle: EventWaitHandle, eventSecurity: EventWaitHandleSecurity): void;
    static SetAccessControl(mutex: Mutex, mutexSecurity: MutexSecurity): void;
    static SetAccessControl(semaphore: Semaphore, semaphoreSecurity: SemaphoreSecurity): void;
}


export type ThreadingAclExtensions = ThreadingAclExtensions$instance;

export abstract class ThreadPool$instance {
    static readonly PendingWorkItemCount: long;
    static readonly ThreadCount: int;
    static readonly CompletedWorkItemCount: long;
    static BindHandle(osHandle: nint): boolean;
    static BindHandle(osHandle: SafeHandle): boolean;
    static GetAvailableThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static GetMaxThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static GetMinThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static QueueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static QueueUserWorkItem(callBack: WaitCallback, state: unknown): boolean;
    static QueueUserWorkItem(callBack: WaitCallback): boolean;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static SetMaxThreads(workerThreads: int, completionPortThreads: int): boolean;
    static SetMinThreads(workerThreads: int, completionPortThreads: int): boolean;
    static UnsafeQueueNativeOverlapped(overlapped: ptr<NativeOverlapped>): boolean;
    static UnsafeQueueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static UnsafeQueueUserWorkItem(callBack: IThreadPoolWorkItem, preferLocal: boolean): boolean;
    static UnsafeQueueUserWorkItem(callBack: WaitCallback, state: unknown): boolean;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
}


export type ThreadPool = ThreadPool$instance;

export abstract class Timeout$instance {
    static readonly InfiniteTimeSpan: TimeSpan;
    static readonly Infinite: int;
}


export type Timeout = Timeout$instance;

export abstract class Volatile$instance {
    static Read(location: { value: ref<boolean> }): boolean;
    static Read(location: { value: ref<byte> }): byte;
    static Read(location: { value: ref<double> }): double;
    static Read(location: { value: ref<short> }): short;
    static Read(location: { value: ref<int> }): int;
    static Read(location: { value: ref<long> }): long;
    static Read(location: { value: ref<nint> }): nint;
    static Read(location: { value: ref<sbyte> }): sbyte;
    static Read(location: { value: ref<float> }): float;
    static Read(location: { value: ref<ushort> }): ushort;
    static Read(location: { value: ref<uint> }): uint;
    static Read(location: { value: ref<ulong> }): ulong;
    static Read(location: { value: ref<nuint> }): nuint;
    static Read<T>(location: { value: ref<T> }): T;
    static ReadBarrier(): void;
    static Write(location: { value: ref<boolean> }, value: boolean): void;
    static Write(location: { value: ref<byte> }, value: byte): void;
    static Write(location: { value: ref<double> }, value: double): void;
    static Write(location: { value: ref<short> }, value: short): void;
    static Write(location: { value: ref<int> }, value: int): void;
    static Write(location: { value: ref<long> }, value: long): void;
    static Write(location: { value: ref<nint> }, value: nint): void;
    static Write(location: { value: ref<sbyte> }, value: sbyte): void;
    static Write(location: { value: ref<float> }, value: float): void;
    static Write(location: { value: ref<ushort> }, value: ushort): void;
    static Write(location: { value: ref<uint> }, value: uint): void;
    static Write(location: { value: ref<ulong> }, value: ulong): void;
    static Write(location: { value: ref<nuint> }, value: nuint): void;
    static Write<T>(location: { value: ref<T> }, value: T): void;
    static WriteBarrier(): void;
}


export type Volatile = Volatile$instance;

export abstract class WaitHandleExtensions$instance {
    static GetSafeWaitHandle(waitHandle: WaitHandle): SafeWaitHandle;
    static SetSafeWaitHandle(waitHandle: WaitHandle, value: SafeWaitHandle): void;
}


export type WaitHandleExtensions = WaitHandleExtensions$instance;

