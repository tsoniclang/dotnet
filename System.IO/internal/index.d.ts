// Generated by tsbindgen - Architecture
// Namespace: System.IO
// Assembly: System.IO.FileSystem.AccessControl, System.IO.FileSystem.DriveInfo, System.IO.FileSystem.Watcher, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeFileHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, IComponent, IContainer, ISite, ISupportInitialize, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import type { SafeBuffer } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { AccessControlSections, DirectorySecurity, FileSecurity, FileSystemRights } from "../../System.Security.AccessControl/internal/index.js";
import type { Encoding, StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, Half, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DriveType {
    unknown_ = 0,
    noRootDirectory = 1,
    removable = 2,
    fixed = 3,
    network = 4,
    cdRom = 5,
    ram = 6
}


export enum FileAccess {
    read = 1,
    write = 2,
    readWrite = 3
}


export enum FileAttributes {
    none = 0,
    readOnly = 1,
    hidden = 2,
    system = 4,
    directory = 16,
    archive = 32,
    device = 64,
    normal = 128,
    temporary = 256,
    sparseFile = 512,
    reparsePoint = 1024,
    compressed = 2048,
    offline = 4096,
    notContentIndexed = 8192,
    encrypted = 16384,
    integrityStream = 32768,
    noScrubData = 131072
}


export enum FileMode {
    createNew = 1,
    create = 2,
    open = 3,
    openOrCreate = 4,
    truncate = 5,
    append = 6
}


export enum FileOptions {
    none = 0,
    writeThrough = -2147483648,
    asynchronous = 1073741824,
    randomAccess = 268435456,
    deleteOnClose = 67108864,
    sequentialScan = 134217728,
    encrypted = 16384
}


export enum FileShare {
    none = 0,
    read = 1,
    write = 2,
    readWrite = 3,
    delete_ = 4,
    inheritable = 16
}


export enum HandleInheritability {
    none = 0,
    inheritable = 1
}


export enum MatchCasing {
    platformDefault = 0,
    caseSensitive = 1,
    caseInsensitive = 2
}


export enum MatchType {
    simple = 0,
    win32 = 1
}


export enum NotifyFilters {
    fileName = 1,
    directoryName = 2,
    attributes = 4,
    size = 8,
    lastWrite = 16,
    lastAccess = 32,
    creationTime = 64,
    security = 256
}


export enum SearchOption {
    topDirectoryOnly = 0,
    allDirectories = 1
}


export enum SeekOrigin {
    begin = 0,
    current = 1,
    end = 2
}


export enum UnixFileMode {
    none = 0,
    otherExecute = 1,
    otherWrite = 2,
    otherRead = 4,
    groupExecute = 8,
    groupWrite = 16,
    groupRead = 32,
    userExecute = 64,
    userWrite = 128,
    userRead = 256,
    stickyBit = 512,
    setGroup = 1024,
    setUser = 2048
}


export enum WatcherChangeTypes {
    created = 1,
    deleted = 2,
    changed = 4,
    renamed = 8,
    all = 15
}


export class WaitForChangedResult$instance {
    changeType: WatcherChangeTypes;
    name: string;
    oldName: string;
    timedOut: boolean;
}


export type WaitForChangedResult = WaitForChangedResult$instance;

export class BinaryReader$instance {
    constructor(input: Stream);
    constructor(input: Stream, encoding: Encoding);
    constructor(input: Stream, encoding: Encoding, leaveOpen: boolean);
    readonly baseStream: Stream;
    close(): void;
    dispose(): void;
    peekChar(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    read(buffer: byte[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read7BitEncodedInt(): int;
    read7BitEncodedInt64(): long;
    readBoolean(): boolean;
    readByte(): byte;
    readBytes(count: int): byte[];
    readChar(): char;
    readChars(count: int): char[];
    readDecimal(): decimal;
    readDouble(): double;
    readExactly(buffer: Span_1<CLROf<byte>>): void;
    readHalf(): half;
    readInt16(): short;
    readInt32(): int;
    readInt64(): long;
    readSByte(): sbyte;
    readSingle(): float;
    readString(): string;
    readUInt16(): ushort;
    readUInt32(): uint;
    readUInt64(): ulong;
}


export interface __BinaryReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type BinaryReader = BinaryReader$instance & __BinaryReader$views;


export class BinaryWriter$instance {
    constructor(output: Stream);
    constructor(output: Stream, encoding: Encoding);
    constructor(output: Stream, encoding: Encoding, leaveOpen: boolean);
    readonly baseStream: Stream;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    seek(offset: int, origin: SeekOrigin): long;
    write(value: boolean): void;
    write(value: byte): void;
    write(value: sbyte): void;
    write(buffer: byte[]): void;
    write(buffer: byte[], index: int, count: int): void;
    write(ch: char): void;
    write(chars: char[]): void;
    write(chars: char[], index: int, count: int): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: short): void;
    write(value: ushort): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: half): void;
    write(value: string): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(chars: ReadOnlySpan_1<CLROf<char>>): void;
    write7BitEncodedInt(value: int): void;
    write7BitEncodedInt64(value: long): void;
    static readonly null_: BinaryWriter;
}


export interface __BinaryWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type BinaryWriter = BinaryWriter$instance & __BinaryWriter$views;


export class BufferedStream$instance extends Stream$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, bufferSize: int);
    readonly bufferSize: int;
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly length: long;
    position: long;
    readonly underlyingStream: Stream;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(destination: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export interface __BufferedStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type BufferedStream = BufferedStream$instance & __BufferedStream$views;


export class DirectoryInfo$instance extends FileSystemInfo$instance {
    constructor(path: string);
    readonly exists: boolean;
    readonly name: string;
    readonly parent: DirectoryInfo;
    readonly root: DirectoryInfo;
    create(): void;
    createSubdirectory(path: string): DirectoryInfo;
    delete_(): void;
    enumerateDirectories(): IEnumerable_1<DirectoryInfo>;
    enumerateDirectories(searchPattern: string): IEnumerable_1<DirectoryInfo>;
    enumerateDirectories(searchPattern: string, searchOption: SearchOption): IEnumerable_1<DirectoryInfo>;
    enumerateDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<DirectoryInfo>;
    enumerateFiles(): IEnumerable_1<FileInfo>;
    enumerateFiles(searchPattern: string): IEnumerable_1<FileInfo>;
    enumerateFiles(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileInfo>;
    enumerateFiles(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileInfo>;
    enumerateFileSystemInfos(): IEnumerable_1<FileSystemInfo>;
    enumerateFileSystemInfos(searchPattern: string): IEnumerable_1<FileSystemInfo>;
    enumerateFileSystemInfos(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileSystemInfo>;
    enumerateFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileSystemInfo>;
    getDirectories(): DirectoryInfo[];
    getDirectories(searchPattern: string): DirectoryInfo[];
    getDirectories(searchPattern: string, searchOption: SearchOption): DirectoryInfo[];
    getDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): DirectoryInfo[];
    getFiles(): FileInfo[];
    getFiles(searchPattern: string): FileInfo[];
    getFiles(searchPattern: string, searchOption: SearchOption): FileInfo[];
    getFiles(searchPattern: string, enumerationOptions: EnumerationOptions): FileInfo[];
    getFileSystemInfos(): FileSystemInfo[];
    getFileSystemInfos(searchPattern: string): FileSystemInfo[];
    getFileSystemInfos(searchPattern: string, searchOption: SearchOption): FileSystemInfo[];
    getFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): FileSystemInfo[];
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    moveTo(destDirName: string): void;
}


export interface __DirectoryInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryInfo = DirectoryInfo$instance & __DirectoryInfo$views;


export class DirectoryNotFoundException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DirectoryNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryNotFoundException = DirectoryNotFoundException$instance & __DirectoryNotFoundException$views;


export class DriveInfo$instance {
    constructor(driveName: string);
    readonly availableFreeSpace: long;
    readonly driveFormat: string;
    readonly driveType: DriveType;
    readonly isReady: boolean;
    readonly name: string;
    readonly rootDirectory: DirectoryInfo;
    readonly totalFreeSpace: long;
    readonly totalSize: long;
    volumeLabel: string;
    toString(): string;
    static GetDrives(): DriveInfo[];
}


export interface __DriveInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DriveInfo = DriveInfo$instance & __DriveInfo$views;


export class DriveNotFoundException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DriveNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DriveNotFoundException = DriveNotFoundException$instance & __DriveNotFoundException$views;


export class EndOfStreamException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __EndOfStreamException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EndOfStreamException = EndOfStreamException$instance & __EndOfStreamException$views;


export class EnumerationOptions$instance {
    constructor();
    attributesToSkip: FileAttributes;
    bufferSize: int;
    ignoreInaccessible: boolean;
    matchCasing: MatchCasing;
    matchType: MatchType;
    maxRecursionDepth: int;
    recurseSubdirectories: boolean;
    returnSpecialDirectories: boolean;
}


export type EnumerationOptions = EnumerationOptions$instance;

export class ErrorEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(exception: Exception);
    getException(): Exception;
}


export type ErrorEventArgs = ErrorEventArgs$instance;

export class ErrorEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: ErrorEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: ErrorEventArgs): void;
}


export interface __ErrorEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ErrorEventHandler = ErrorEventHandler$instance & __ErrorEventHandler$views;


export class FileInfo$instance extends FileSystemInfo$instance {
    constructor(fileName: string);
    readonly directory: DirectoryInfo;
    readonly directoryName: string;
    readonly exists: boolean;
    isReadOnly: boolean;
    readonly length: long;
    readonly name: string;
    appendText(): StreamWriter;
    copyTo(destFileName: string): FileInfo;
    copyTo(destFileName: string, overwrite: boolean): FileInfo;
    create(): FileStream;
    createText(): StreamWriter;
    decrypt(): void;
    delete_(): void;
    encrypt(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    moveTo(destFileName: string): void;
    moveTo(destFileName: string, overwrite: boolean): void;
    open(options: FileStreamOptions): FileStream;
    open(mode: FileMode): FileStream;
    open(mode: FileMode, access: FileAccess): FileStream;
    open(mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    openRead(): FileStream;
    openText(): StreamReader;
    openWrite(): FileStream;
    replace(destinationFileName: string, destinationBackupFileName: string): FileInfo;
    replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): FileInfo;
}


export interface __FileInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileInfo = FileInfo$instance & __FileInfo$views;


export class FileLoadException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, fileName: string);
    constructor(message: string, fileName: string, inner: Exception);
    readonly fileName: string;
    readonly fusionLog: string;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __FileLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileLoadException = FileLoadException$instance & __FileLoadException$views;


export class FileNotFoundException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, fileName: string);
    constructor(message: string, fileName: string, innerException: Exception);
    readonly fileName: string;
    readonly fusionLog: string;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export interface __FileNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileNotFoundException = FileNotFoundException$instance & __FileNotFoundException$views;


export class FileStream$instance extends Stream$instance {
    constructor(handle: nint, access: FileAccess);
    constructor(handle: nint, access: FileAccess, ownsHandle: boolean);
    constructor(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int);
    constructor(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int, isAsync: boolean);
    constructor(handle: SafeFileHandle, access: FileAccess);
    constructor(handle: SafeFileHandle, access: FileAccess, bufferSize: int);
    constructor(handle: SafeFileHandle, access: FileAccess, bufferSize: int, isAsync: boolean);
    constructor(path: string, mode: FileMode);
    constructor(path: string, mode: FileMode, access: FileAccess);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, useAsync: boolean);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, options: FileOptions);
    constructor(path: string, options: FileStreamOptions);
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly handle: nint;
    readonly isAsync: boolean;
    readonly length: long;
    readonly name: string;
    position: long;
    readonly safeFileHandle: SafeFileHandle;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    lock(position: long, length: long): void;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, origin: SeekOrigin): long;
    setLength(value: long): void;
    unlock(position: long, length: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export interface __FileStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type FileStream = FileStream$instance & __FileStream$views;


export class FileStreamOptions$instance {
    constructor();
    access: FileAccess;
    bufferSize: int;
    mode: FileMode;
    options: FileOptions;
    preallocationSize: long;
    share: FileShare;
    unixCreateMode: Nullable_1<UnixFileMode>;
}


export type FileStreamOptions = FileStreamOptions$instance;

export class FileSystemEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(changeType: WatcherChangeTypes, directory: string, name: string);
    readonly changeType: WatcherChangeTypes;
    readonly fullPath: string;
    readonly name: string;
}


export type FileSystemEventArgs = FileSystemEventArgs$instance;

export class FileSystemEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: FileSystemEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: FileSystemEventArgs): void;
}


export interface __FileSystemEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileSystemEventHandler = FileSystemEventHandler$instance & __FileSystemEventHandler$views;


export abstract class FileSystemInfo$instance extends System_Internal.MarshalByRefObject$instance {
    attributes: FileAttributes;
    creationTime: DateTime;
    creationTimeUtc: DateTime;
    readonly exists: boolean;
    readonly extension: string;
    readonly fullName: string;
    lastAccessTime: DateTime;
    lastAccessTimeUtc: DateTime;
    lastWriteTime: DateTime;
    lastWriteTimeUtc: DateTime;
    readonly linkTarget: string;
    readonly name: string;
    unixFileMode: UnixFileMode;
    createAsSymbolicLink(pathToTarget: string): void;
    abstract delete_(): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    refresh(): void;
    resolveLinkTarget(returnFinalTarget: boolean): FileSystemInfo;
    toString(): string;
}


export interface __FileSystemInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileSystemInfo = FileSystemInfo$instance & __FileSystemInfo$views;


export class FileSystemWatcher$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    constructor(path: string);
    constructor(path: string, filter: string);
    enableRaisingEvents: boolean;
    filter: string;
    readonly filters: Collection_1<CLROf<string>>;
    includeSubdirectories: boolean;
    internalBufferSize: int;
    notifyFilter: NotifyFilters;
    path: string;
    site: ISite;
    synchronizingObject: ISynchronizeInvoke;
    beginInit(): void;
    dispose(): void;
    endInit(): void;
    waitForChanged(changeType: WatcherChangeTypes): WaitForChangedResult;
    waitForChanged(changeType: WatcherChangeTypes, timeout: int): WaitForChangedResult;
    waitForChanged(changeType: WatcherChangeTypes, timeout: TimeSpan): WaitForChangedResult;
}


export interface __FileSystemWatcher$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_ISupportInitialize(): System_ComponentModel_Internal.ISupportInitialize$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type FileSystemWatcher = FileSystemWatcher$instance & __FileSystemWatcher$views;


export class InternalBufferOverflowException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InternalBufferOverflowException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InternalBufferOverflowException = InternalBufferOverflowException$instance & __InternalBufferOverflowException$views;


export class InvalidDataException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidDataException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidDataException = InvalidDataException$instance & __InvalidDataException$views;


export class IOException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, hresult: int);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __IOException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IOException = IOException$instance & __IOException$views;


export class MemoryStream$instance extends Stream$instance {
    constructor();
    constructor(capacity: int);
    constructor(buffer: byte[]);
    constructor(buffer: byte[], writable: boolean);
    constructor(buffer: byte[], index: int, count: int);
    constructor(buffer: byte[], index: int, count: int, writable: boolean);
    constructor(buffer: byte[], index: int, count: int, writable: boolean, publiclyVisible: boolean);
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    capacity: int;
    readonly length: long;
    position: long;
    copyTo(destination: Stream, bufferSize: int): void;
    copyTo(destination: Stream): void;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    getBuffer(): byte[];
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, loc: SeekOrigin): long;
    setLength(value: long): void;
    toArray(): byte[];
    tryGetBuffer(buffer: { value: ref<ArraySegment_1<CLROf<byte>>> }): boolean;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
    writeTo(stream: Stream): void;
}


export interface __MemoryStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MemoryStream = MemoryStream$instance & __MemoryStream$views;


export class PathTooLongException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __PathTooLongException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PathTooLongException = PathTooLongException$instance & __PathTooLongException$views;


export class RenamedEventArgs$instance extends FileSystemEventArgs$instance {
    constructor(changeType: WatcherChangeTypes, directory: string, name: string, oldName: string);
    readonly oldFullPath: string;
    readonly oldName: string;
}


export type RenamedEventArgs = RenamedEventArgs$instance;

export class RenamedEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(sender: unknown, e: RenamedEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: unknown, e: RenamedEventArgs): void;
}


export interface __RenamedEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RenamedEventHandler = RenamedEventHandler$instance & __RenamedEventHandler$views;


export abstract class Stream$instance extends System_Internal.MarshalByRefObject$instance {
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canTimeout: boolean;
    readonly canWrite: boolean;
    readonly length: long;
    position: long;
    readTimeout: int;
    writeTimeout: int;
    beginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    beginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    close(): void;
    copyTo(destination: Stream): void;
    copyTo(destination: Stream, bufferSize: int): void;
    copyToAsync(destination: Stream): Task;
    copyToAsync(destination: Stream, bufferSize: int): Task;
    copyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    copyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    endRead(asyncResult: IAsyncResult): int;
    endWrite(asyncResult: IAsyncResult): void;
    abstract flush(): void;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAtLeast(buffer: Span_1<CLROf<byte>>, minimumBytes: int, throwOnEndOfStream?: boolean): int;
    readAtLeastAsync(buffer: Memory_1<CLROf<byte>>, minimumBytes: int, throwOnEndOfStream?: boolean, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    readExactly(buffer: Span_1<CLROf<byte>>): void;
    readExactly(buffer: byte[], offset: int, count: int): void;
    readExactlyAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    readExactlyAsync(buffer: byte[], offset: int, count: int, cancellationToken?: CancellationToken): ValueTask;
    abstract seek(offset: long, origin: SeekOrigin): long;
    abstract setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
    static readonly null_: Stream;
    static Synchronized(stream: Stream): Stream;
}


export interface __Stream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Stream = Stream$instance & __Stream$views;


export class StreamReader$instance extends TextReader$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, detectEncodingFromByteOrderMarks: boolean);
    constructor(stream: Stream, encoding: Encoding);
    constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean);
    constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int);
    constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int, leaveOpen: boolean);
    constructor(path: string);
    constructor(path: string, detectEncodingFromByteOrderMarks: boolean);
    constructor(path: string, encoding: Encoding);
    constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean);
    constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int);
    constructor(path: string, options: FileStreamOptions);
    constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, options: FileStreamOptions);
    readonly baseStream: Stream;
    readonly currentEncoding: Encoding;
    readonly endOfStream: boolean;
    close(): void;
    discardBufferedData(): void;
    dispose(): void;
    peek(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    read(buffer: Span_1<CLROf<char>>): int;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlock(buffer: char[], index: int, count: int): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readLine(): string;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readToEnd(): string;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
}


export interface __StreamReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StreamReader = StreamReader$instance & __StreamReader$views;


export class StreamWriter$instance extends TextWriter$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, encoding: Encoding);
    constructor(stream: Stream, encoding: Encoding, bufferSize: int);
    constructor(stream: Stream, encoding: Encoding, bufferSize: int, leaveOpen: boolean);
    constructor(path: string);
    constructor(path: string, append: boolean);
    constructor(path: string, append: boolean, encoding: Encoding);
    constructor(path: string, append: boolean, encoding: Encoding, bufferSize: int);
    constructor(path: string, options: FileStreamOptions);
    constructor(path: string, encoding: Encoding, options: FileStreamOptions);
    autoFlush: boolean;
    readonly baseStream: Stream;
    readonly encoding: Encoding;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    write(value: char): void;
    write(buffer: char[]): void;
    write(buffer: char[], index: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: string): void;
    write(format: string, arg0: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    write(format: string, arg: unknown[]): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: boolean): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: unknown): void;
    write(value: StringBuilder): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeAsync(value: char): Task;
    writeAsync(value: string): Task;
    writeAsync(buffer: char[], index: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeAsync(buffer: char[]): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLine(value: string): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(format: string, arg0: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    writeLine(format: string, arg: unknown[]): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLine(): void;
    writeLine(value: char): void;
    writeLine(buffer: char[]): void;
    writeLine(buffer: char[], index: int, count: int): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: boolean): void;
    writeLine(value: int): void;
    writeLine(value: uint): void;
    writeLine(value: long): void;
    writeLine(value: ulong): void;
    writeLine(value: float): void;
    writeLine(value: double): void;
    writeLine(value: decimal): void;
    writeLine(value: StringBuilder): void;
    writeLine(value: unknown): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLineAsync(): Task;
    writeLineAsync(value: char): Task;
    writeLineAsync(value: string): Task;
    writeLineAsync(buffer: char[], index: int, count: int): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[]): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
}


export interface __StreamWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StreamWriter = StreamWriter$instance & __StreamWriter$views;


export class StringReader$instance extends TextReader$instance {
    constructor(s: string);
    close(): void;
    dispose(): void;
    peek(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    read(buffer: Span_1<CLROf<char>>): int;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlock(buffer: char[], index: int, count: int): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readLine(): string;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readToEnd(): string;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
}


export interface __StringReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringReader = StringReader$instance & __StringReader$views;


export class StringWriter$instance extends TextWriter$instance {
    constructor();
    constructor(formatProvider: IFormatProvider);
    constructor(sb: StringBuilder);
    constructor(sb: StringBuilder, formatProvider: IFormatProvider);
    readonly encoding: Encoding;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    getStringBuilder(): StringBuilder;
    toString(): string;
    write(value: char): void;
    write(buffer: char[], index: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: string): void;
    write(value: StringBuilder): void;
    write(buffer: char[]): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: boolean): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: unknown): void;
    write(format: string, arg0: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    write(format: string, arg: unknown[]): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeAsync(value: char): Task;
    writeAsync(value: string): Task;
    writeAsync(buffer: char[], index: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeAsync(buffer: char[]): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: StringBuilder): void;
    writeLine(): void;
    writeLine(value: char): void;
    writeLine(buffer: char[]): void;
    writeLine(buffer: char[], index: int, count: int): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: boolean): void;
    writeLine(value: int): void;
    writeLine(value: uint): void;
    writeLine(value: long): void;
    writeLine(value: ulong): void;
    writeLine(value: float): void;
    writeLine(value: double): void;
    writeLine(value: decimal): void;
    writeLine(value: string): void;
    writeLine(value: unknown): void;
    writeLine(format: string, arg0: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    writeLine(format: string, arg: unknown[]): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLineAsync(value: char): Task;
    writeLineAsync(value: string): Task;
    writeLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[], index: int, count: int): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[]): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(): Task;
}


export interface __StringWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringWriter = StringWriter$instance & __StringWriter$views;


export abstract class TextReader$instance extends System_Internal.MarshalByRefObject$instance {
    close(): void;
    dispose(): void;
    peek(): int;
    read(): int;
    read(buffer: char[], index: int, count: int): int;
    read(buffer: Span_1<CLROf<char>>): int;
    readAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readBlock(buffer: char[], index: int, count: int): int;
    readBlock(buffer: Span_1<CLROf<char>>): int;
    readBlockAsync(buffer: char[], index: int, count: int): Task_1<CLROf<int>>;
    readBlockAsync(buffer: Memory_1<CLROf<char>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readLine(): string;
    readLineAsync(): Task_1<CLROf<string>>;
    readLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    readToEnd(): string;
    readToEndAsync(): Task_1<CLROf<string>>;
    readToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    static readonly null_: TextReader;
    static Synchronized(reader: TextReader): TextReader;
}


export interface __TextReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TextReader = TextReader$instance & __TextReader$views;


export abstract class TextWriter$instance extends System_Internal.MarshalByRefObject$instance {
    readonly encoding: Encoding;
    readonly formatProvider: IFormatProvider;
    newLine: string;
    close(): void;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(): Task;
    flushAsync(cancellationToken: CancellationToken): Task;
    write(value: char): void;
    write(buffer: char[]): void;
    write(buffer: char[], index: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    write(value: boolean): void;
    write(value: int): void;
    write(value: uint): void;
    write(value: long): void;
    write(value: ulong): void;
    write(value: float): void;
    write(value: double): void;
    write(value: decimal): void;
    write(value: string): void;
    write(value: unknown): void;
    write(value: StringBuilder): void;
    write(format: string, arg0: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown): void;
    write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    write(format: string, arg: unknown[]): void;
    write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeAsync(value: char): Task;
    writeAsync(value: string): Task;
    writeAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeAsync(buffer: char[]): Task;
    writeAsync(buffer: char[], index: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLine(): void;
    writeLine(value: char): void;
    writeLine(buffer: char[]): void;
    writeLine(buffer: char[], index: int, count: int): void;
    writeLine(buffer: ReadOnlySpan_1<CLROf<char>>): void;
    writeLine(value: boolean): void;
    writeLine(value: int): void;
    writeLine(value: uint): void;
    writeLine(value: long): void;
    writeLine(value: ulong): void;
    writeLine(value: float): void;
    writeLine(value: double): void;
    writeLine(value: decimal): void;
    writeLine(value: string): void;
    writeLine(value: StringBuilder): void;
    writeLine(value: unknown): void;
    writeLine(format: string, arg0: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown): void;
    writeLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    writeLine(format: string, arg: unknown[]): void;
    writeLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    writeLineAsync(value: char): Task;
    writeLineAsync(value: string): Task;
    writeLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    writeLineAsync(buffer: char[]): Task;
    writeLineAsync(buffer: char[], index: int, count: int): Task;
    writeLineAsync(buffer: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    writeLineAsync(): Task;
    static readonly null_: TextWriter;
    static CreateBroadcasting(writers: TextWriter[]): TextWriter;
    static Synchronized(writer: TextWriter): TextWriter;
}


export interface __TextWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TextWriter = TextWriter$instance & __TextWriter$views;


export class UnmanagedMemoryAccessor$instance {
    constructor(buffer: SafeBuffer, offset: long, capacity: long);
    constructor(buffer: SafeBuffer, offset: long, capacity: long, access: FileAccess);
    readonly canRead: boolean;
    readonly canWrite: boolean;
    readonly capacity: long;
    dispose(): void;
    read<T extends unknown>(position: long, structure: { value: ref<T> }): void;
    readArray<T extends unknown>(position: long, array: T[], offset: int, count: int): int;
    readBoolean(position: long): boolean;
    readByte(position: long): byte;
    readChar(position: long): char;
    readDecimal(position: long): decimal;
    readDouble(position: long): double;
    readInt16(position: long): short;
    readInt32(position: long): int;
    readInt64(position: long): long;
    readSByte(position: long): sbyte;
    readSingle(position: long): float;
    readUInt16(position: long): ushort;
    readUInt32(position: long): uint;
    readUInt64(position: long): ulong;
    write(position: long, value: boolean): void;
    write(position: long, value: byte): void;
    write(position: long, value: char): void;
    write(position: long, value: short): void;
    write(position: long, value: int): void;
    write(position: long, value: long): void;
    write(position: long, value: decimal): void;
    write(position: long, value: float): void;
    write(position: long, value: double): void;
    write(position: long, value: sbyte): void;
    write(position: long, value: ushort): void;
    write(position: long, value: uint): void;
    write(position: long, value: ulong): void;
    write<T extends unknown>(position: long, structure: { value: ref<T> }): void;
    writeArray<T extends unknown>(position: long, array: T[], offset: int, count: int): void;
}


export interface __UnmanagedMemoryAccessor$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type UnmanagedMemoryAccessor = UnmanagedMemoryAccessor$instance & __UnmanagedMemoryAccessor$views;


export class UnmanagedMemoryStream$instance extends Stream$instance {
    constructor(buffer: SafeBuffer, offset: long, length: long);
    constructor(buffer: SafeBuffer, offset: long, length: long, access: FileAccess);
    constructor(pointer: ptr<byte>, length: long);
    constructor(pointer: ptr<byte>, length: long, capacity: long, access: FileAccess);
    readonly canRead: boolean;
    readonly canSeek: boolean;
    readonly canWrite: boolean;
    readonly capacity: long;
    readonly length: long;
    position: long;
    positionPointer: ptr<byte>;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(cancellationToken: CancellationToken): Task;
    flushAsync(): Task;
    read(buffer: byte[], offset: int, count: int): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    read(buffer: Span_1<CLROf<byte>>): int;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    readAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    readAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    readByte(): int;
    seek(offset: long, loc: SeekOrigin): long;
    setLength(value: long): void;
    write(buffer: byte[], offset: int, count: int): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    writeAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeAsync(buffer: byte[], offset: int, count: int): Task;
    writeAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    writeByte(value: byte): void;
}


export interface __UnmanagedMemoryStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type UnmanagedMemoryStream = UnmanagedMemoryStream$instance & __UnmanagedMemoryStream$views;


export abstract class Directory$instance {
    static CreateDirectory(path: string, unixCreateMode: UnixFileMode): DirectoryInfo;
    static CreateDirectory(path: string): DirectoryInfo;
    static CreateSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static CreateTempSubdirectory(prefix?: string): DirectoryInfo;
    static Delete(path: string, recursive: boolean): void;
    static Delete(path: string): void;
    static EnumerateDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static EnumerateDirectories(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static EnumerateDirectories(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static EnumerateDirectories(path: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string): IEnumerable_1<CLROf<string>>;
    static Exists(path: string): boolean;
    static GetCreationTime(path: string): DateTime;
    static GetCreationTimeUtc(path: string): DateTime;
    static GetCurrentDirectory(): string;
    static GetDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetDirectories(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetDirectories(path: string, searchPattern: string): string[];
    static GetDirectories(path: string): string[];
    static GetDirectoryRoot(path: string): string;
    static GetFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetFiles(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetFiles(path: string, searchPattern: string): string[];
    static GetFiles(path: string): string[];
    static GetFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetFileSystemEntries(path: string, searchPattern: string): string[];
    static GetFileSystemEntries(path: string): string[];
    static GetLastAccessTime(path: string): DateTime;
    static GetLastAccessTimeUtc(path: string): DateTime;
    static GetLastWriteTime(path: string): DateTime;
    static GetLastWriteTimeUtc(path: string): DateTime;
    static GetLogicalDrives(): string[];
    static GetParent(path: string): DirectoryInfo;
    static Move(sourceDirName: string, destDirName: string): void;
    static ResolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo;
    static SetCreationTime(path: string, creationTime: DateTime): void;
    static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static SetCurrentDirectory(path: string): void;
    static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
}


export type Directory = Directory$instance;

export abstract class File$instance {
    static AppendAllBytes(path: string, bytes: byte[]): void;
    static AppendAllBytes(path: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    static AppendAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static AppendAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): Task;
    static AppendAllLines(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding): void;
    static AppendAllLines(path: string, contents: IEnumerable_1<CLROf<string>>): void;
    static AppendAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static AppendAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>, encoding: Encoding): void;
    static AppendAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>): void;
    static AppendAllText(path: string, contents: string, encoding: Encoding): void;
    static AppendAllText(path: string, contents: string): void;
    static AppendAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
    static AppendText(path: string): StreamWriter;
    static Copy(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static Copy(sourceFileName: string, destFileName: string): void;
    static Create(path: string, bufferSize: int, options: FileOptions): FileStream;
    static Create(path: string, bufferSize: int): FileStream;
    static Create(path: string): FileStream;
    static CreateSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static CreateText(path: string): StreamWriter;
    static Decrypt(path: string): void;
    static Delete(path: string): void;
    static Encrypt(path: string): void;
    static Exists(path: string): boolean;
    static GetAttributes(fileHandle: SafeFileHandle): FileAttributes;
    static GetAttributes(path: string): FileAttributes;
    static GetCreationTime(fileHandle: SafeFileHandle): DateTime;
    static GetCreationTime(path: string): DateTime;
    static GetCreationTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetCreationTimeUtc(path: string): DateTime;
    static GetLastAccessTime(fileHandle: SafeFileHandle): DateTime;
    static GetLastAccessTime(path: string): DateTime;
    static GetLastAccessTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetLastAccessTimeUtc(path: string): DateTime;
    static GetLastWriteTime(fileHandle: SafeFileHandle): DateTime;
    static GetLastWriteTime(path: string): DateTime;
    static GetLastWriteTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetLastWriteTimeUtc(path: string): DateTime;
    static GetUnixFileMode(fileHandle: SafeFileHandle): UnixFileMode;
    static GetUnixFileMode(path: string): UnixFileMode;
    static Move(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static Move(sourceFileName: string, destFileName: string): void;
    static Open(path: string, mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    static Open(path: string, mode: FileMode, access: FileAccess): FileStream;
    static Open(path: string, mode: FileMode): FileStream;
    static Open(path: string, options: FileStreamOptions): FileStream;
    static OpenHandle(path: string, mode?: FileMode, access?: FileAccess, share?: FileShare, options?: FileOptions, preallocationSize?: long): SafeFileHandle;
    static OpenRead(path: string): FileStream;
    static OpenText(path: string): StreamReader;
    static OpenWrite(path: string): FileStream;
    static ReadAllBytes(path: string): byte[];
    static ReadAllBytesAsync(path: string, cancellationToken?: CancellationToken): Task_1<byte[]>;
    static ReadAllLines(path: string, encoding: Encoding): string[];
    static ReadAllLines(path: string): string[];
    static ReadAllLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<string[]>;
    static ReadAllLinesAsync(path: string, cancellationToken?: CancellationToken): Task_1<string[]>;
    static ReadAllText(path: string, encoding: Encoding): string;
    static ReadAllText(path: string): string;
    static ReadAllTextAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<CLROf<string>>;
    static ReadAllTextAsync(path: string, cancellationToken?: CancellationToken): Task_1<CLROf<string>>;
    static ReadLines(path: string, encoding: Encoding): IEnumerable_1<CLROf<string>>;
    static ReadLines(path: string): IEnumerable_1<CLROf<string>>;
    static ReadLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): IAsyncEnumerable_1<CLROf<string>>;
    static ReadLinesAsync(path: string, cancellationToken?: CancellationToken): IAsyncEnumerable_1<CLROf<string>>;
    static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): void;
    static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void;
    static ResolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo;
    static SetAttributes(fileHandle: SafeFileHandle, fileAttributes: FileAttributes): void;
    static SetAttributes(path: string, fileAttributes: FileAttributes): void;
    static SetCreationTime(fileHandle: SafeFileHandle, creationTime: DateTime): void;
    static SetCreationTime(path: string, creationTime: DateTime): void;
    static SetCreationTimeUtc(fileHandle: SafeFileHandle, creationTimeUtc: DateTime): void;
    static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static SetLastAccessTime(fileHandle: SafeFileHandle, lastAccessTime: DateTime): void;
    static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static SetLastAccessTimeUtc(fileHandle: SafeFileHandle, lastAccessTimeUtc: DateTime): void;
    static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static SetLastWriteTime(fileHandle: SafeFileHandle, lastWriteTime: DateTime): void;
    static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static SetLastWriteTimeUtc(fileHandle: SafeFileHandle, lastWriteTimeUtc: DateTime): void;
    static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
    static SetUnixFileMode(fileHandle: SafeFileHandle, mode: UnixFileMode): void;
    static SetUnixFileMode(path: string, mode: UnixFileMode): void;
    static WriteAllBytes(path: string, bytes: byte[]): void;
    static WriteAllBytes(path: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    static WriteAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static WriteAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): Task;
    static WriteAllLines(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding): void;
    static WriteAllLines(path: string, contents: IEnumerable_1<CLROf<string>>): void;
    static WriteAllLines(path: string, contents: string[], encoding: Encoding): void;
    static WriteAllLines(path: string, contents: string[]): void;
    static WriteAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static WriteAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>, encoding: Encoding): void;
    static WriteAllText(path: string, contents: ReadOnlySpan_1<CLROf<char>>): void;
    static WriteAllText(path: string, contents: string, encoding: Encoding): void;
    static WriteAllText(path: string, contents: string): void;
    static WriteAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<char>>, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
}


export type File = File$instance;

export abstract class FileSystemAclExtensions$instance {
    static Create(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static Create(fileInfo: FileInfo, mode: FileMode, rights: FileSystemRights, share: FileShare, bufferSize: int, options: FileOptions, fileSecurity: FileSecurity): FileStream;
    static CreateDirectory(directorySecurity: DirectorySecurity, path: string): DirectoryInfo;
    static GetAccessControl(directoryInfo: DirectoryInfo, includeSections: AccessControlSections): DirectorySecurity;
    static GetAccessControl(directoryInfo: DirectoryInfo): DirectorySecurity;
    static GetAccessControl(fileInfo: FileInfo, includeSections: AccessControlSections): FileSecurity;
    static GetAccessControl(fileInfo: FileInfo): FileSecurity;
    static GetAccessControl(fileStream: FileStream): FileSecurity;
    static SetAccessControl(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static SetAccessControl(fileInfo: FileInfo, fileSecurity: FileSecurity): void;
    static SetAccessControl(fileStream: FileStream, fileSecurity: FileSecurity): void;
}


export type FileSystemAclExtensions = FileSystemAclExtensions$instance;

export abstract class Path$instance {
    static readonly directorySeparatorChar: char;
    static readonly altDirectorySeparatorChar: char;
    static readonly volumeSeparatorChar: char;
    static readonly pathSeparator: char;
    static readonly invalidPathChars: char[];
    static ChangeExtension(path: string, extension: string): string;
    static Combine(paths: ReadOnlySpan_1<CLROf<string>>): string;
    static Combine(path1: string, path2: string, path3: string, path4: string): string;
    static Combine(path1: string, path2: string, path3: string): string;
    static Combine(path1: string, path2: string): string;
    static Combine(paths: string[]): string;
    static EndsInDirectorySeparator(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static EndsInDirectorySeparator(path: string): boolean;
    static Exists(path: string): boolean;
    static GetDirectoryName(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static GetDirectoryName(path: string): string;
    static GetExtension(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static GetExtension(path: string): string;
    static GetFileName(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static GetFileName(path: string): string;
    static GetFileNameWithoutExtension(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static GetFileNameWithoutExtension(path: string): string;
    static GetFullPath(path: string, basePath: string): string;
    static GetFullPath(path: string): string;
    static GetInvalidFileNameChars(): char[];
    static GetInvalidPathChars(): char[];
    static GetPathRoot(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static GetPathRoot(path: string): string;
    static GetRandomFileName(): string;
    static GetRelativePath(relativeTo: string, path: string): string;
    static GetTempFileName(): string;
    static GetTempPath(): string;
    static HasExtension(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static HasExtension(path: string): boolean;
    static IsPathFullyQualified(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static IsPathFullyQualified(path: string): boolean;
    static IsPathRooted(path: ReadOnlySpan_1<CLROf<char>>): boolean;
    static IsPathRooted(path: string): boolean;
    static Join(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, path3: ReadOnlySpan_1<CLROf<char>>, path4: ReadOnlySpan_1<CLROf<char>>): string;
    static Join(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, path3: ReadOnlySpan_1<CLROf<char>>): string;
    static Join(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>): string;
    static Join(paths: ReadOnlySpan_1<CLROf<string>>): string;
    static Join(path1: string, path2: string, path3: string, path4: string): string;
    static Join(path1: string, path2: string, path3: string): string;
    static Join(path1: string, path2: string): string;
    static Join(paths: string[]): string;
    static TrimEndingDirectorySeparator(path: ReadOnlySpan_1<CLROf<char>>): ReadOnlySpan_1<CLROf<char>>;
    static TrimEndingDirectorySeparator(path: string): string;
    static TryJoin(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, path3: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static TryJoin(path1: ReadOnlySpan_1<CLROf<char>>, path2: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export type Path = Path$instance;

export abstract class RandomAccess$instance {
    static FlushToDisk(handle: SafeFileHandle): void;
    static GetLength(handle: SafeFileHandle): long;
    static Read(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<CLROf<byte>>>, fileOffset: long): long;
    static Read(handle: SafeFileHandle, buffer: Span_1<CLROf<byte>>, fileOffset: long): int;
    static ReadAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<CLROf<byte>>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<CLROf<long>>;
    static ReadAsync(handle: SafeFileHandle, buffer: Memory_1<CLROf<byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static SetLength(handle: SafeFileHandle, length: long): void;
    static Write(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<CLROf<byte>>>, fileOffset: long): void;
    static Write(handle: SafeFileHandle, buffer: ReadOnlySpan_1<CLROf<byte>>, fileOffset: long): void;
    static WriteAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<CLROf<byte>>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
    static WriteAsync(handle: SafeFileHandle, buffer: ReadOnlyMemory_1<CLROf<byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
}


export type RandomAccess = RandomAccess$instance;

