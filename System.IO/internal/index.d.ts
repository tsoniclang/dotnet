// Generated by tsbindgen - Architecture
// Namespace: System.IO
// Assembly: System.IO.FileSystem.AccessControl, System.IO.FileSystem.DriveInfo, System.IO.FileSystem.Watcher, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeFileHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, IComponent, IContainer, ISite, ISupportInitialize, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import type { SafeBuffer } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { AccessControlSections, DirectorySecurity, FileSecurity, FileSystemRights } from "../../System.Security.AccessControl/internal/index.js";
import type { Encoding, StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, Half, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DriveType {
    Unknown = 0,
    NoRootDirectory = 1,
    Removable = 2,
    Fixed = 3,
    Network = 4,
    CDRom = 5,
    Ram = 6
}


export enum FileAccess {
    Read = 1,
    Write = 2,
    ReadWrite = 3
}


export enum FileAttributes {
    None = 0,
    ReadOnly = 1,
    Hidden = 2,
    System = 4,
    Directory = 16,
    Archive = 32,
    Device = 64,
    Normal = 128,
    Temporary = 256,
    SparseFile = 512,
    ReparsePoint = 1024,
    Compressed = 2048,
    Offline = 4096,
    NotContentIndexed = 8192,
    Encrypted = 16384,
    IntegrityStream = 32768,
    NoScrubData = 131072
}


export enum FileMode {
    CreateNew = 1,
    Create = 2,
    Open = 3,
    OpenOrCreate = 4,
    Truncate = 5,
    Append = 6
}


export enum FileOptions {
    None = 0,
    WriteThrough = -2147483648,
    Asynchronous = 1073741824,
    RandomAccess = 268435456,
    DeleteOnClose = 67108864,
    SequentialScan = 134217728,
    Encrypted = 16384
}


export enum FileShare {
    None = 0,
    Read = 1,
    Write = 2,
    ReadWrite = 3,
    Delete = 4,
    Inheritable = 16
}


export enum HandleInheritability {
    None = 0,
    Inheritable = 1
}


export enum MatchCasing {
    PlatformDefault = 0,
    CaseSensitive = 1,
    CaseInsensitive = 2
}


export enum MatchType {
    Simple = 0,
    Win32 = 1
}


export enum NotifyFilters {
    FileName = 1,
    DirectoryName = 2,
    Attributes = 4,
    Size = 8,
    LastWrite = 16,
    LastAccess = 32,
    CreationTime = 64,
    Security = 256
}


export enum SearchOption {
    TopDirectoryOnly = 0,
    AllDirectories = 1
}


export enum SeekOrigin {
    Begin = 0,
    Current = 1,
    End = 2
}


export enum UnixFileMode {
    None = 0,
    OtherExecute = 1,
    OtherWrite = 2,
    OtherRead = 4,
    GroupExecute = 8,
    GroupWrite = 16,
    GroupRead = 32,
    UserExecute = 64,
    UserWrite = 128,
    UserRead = 256,
    StickyBit = 512,
    SetGroup = 1024,
    SetUser = 2048
}


export enum WatcherChangeTypes {
    Created = 1,
    Deleted = 2,
    Changed = 4,
    Renamed = 8,
    All = 15
}


export class WaitForChangedResult$instance {
    ChangeType: WatcherChangeTypes;
    Name: string;
    OldName: string;
    TimedOut: boolean;
}


export type WaitForChangedResult = WaitForChangedResult$instance;

export class BinaryReader$instance {
    constructor(input: Stream);
    constructor(input: Stream, encoding: Encoding);
    constructor(input: Stream, encoding: Encoding, leaveOpen: boolean);
    readonly BaseStream: Stream;
    Close(): void;
    Dispose(): void;
    PeekChar(): int;
    Read(): int;
    Read(buffer: string[], index: int, count: int): int;
    Read(buffer: Span_1<CLROf<string>>): int;
    Read(buffer: byte[], index: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    Read7BitEncodedInt(): int;
    Read7BitEncodedInt64(): long;
    ReadBoolean(): boolean;
    ReadByte(): byte;
    ReadBytes(count: int): byte[];
    ReadChar(): string;
    ReadChars(count: int): string[];
    ReadDecimal(): decimal;
    ReadDouble(): double;
    ReadExactly(buffer: Span_1<CLROf<byte>>): void;
    ReadHalf(): half;
    ReadInt16(): short;
    ReadInt32(): int;
    ReadInt64(): long;
    ReadSByte(): sbyte;
    ReadSingle(): float;
    ReadString(): string;
    ReadUInt16(): ushort;
    ReadUInt32(): uint;
    ReadUInt64(): ulong;
}


export interface __BinaryReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type BinaryReader = BinaryReader$instance & __BinaryReader$views;


export class BinaryWriter$instance {
    constructor(output: Stream);
    constructor(output: Stream, encoding: Encoding);
    constructor(output: Stream, encoding: Encoding, leaveOpen: boolean);
    readonly BaseStream: Stream;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    Seek(offset: int, origin: SeekOrigin): long;
    Write(value: boolean): void;
    Write(value: byte): void;
    Write(value: sbyte): void;
    Write(buffer: byte[]): void;
    Write(buffer: byte[], index: int, count: int): void;
    Write(ch: string): void;
    Write(chars: string[]): void;
    Write(chars: string[], index: int, count: int): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: short): void;
    Write(value: ushort): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: half): void;
    Write(value: string): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(chars: ReadOnlySpan_1<CLROf<string>>): void;
    Write7BitEncodedInt(value: int): void;
    Write7BitEncodedInt64(value: long): void;
    static readonly Null: BinaryWriter;
}


export interface __BinaryWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type BinaryWriter = BinaryWriter$instance & __BinaryWriter$views;


export class BufferedStream$instance extends Stream$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, bufferSize: int);
    readonly BufferSize: int;
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly Length: long;
    Position: long;
    readonly UnderlyingStream: Stream;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(destination: Span_1<CLROf<byte>>): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export interface __BufferedStream$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type BufferedStream = BufferedStream$instance & __BufferedStream$views;


export class DirectoryInfo$instance extends FileSystemInfo$instance {
    constructor(path: string);
    readonly Exists: boolean;
    readonly Name: string;
    readonly Parent: DirectoryInfo;
    readonly Root: DirectoryInfo;
    Create(): void;
    CreateSubdirectory(path: string): DirectoryInfo;
    Delete(): void;
    EnumerateDirectories(): IEnumerable_1<DirectoryInfo>;
    EnumerateDirectories(searchPattern: string): IEnumerable_1<DirectoryInfo>;
    EnumerateDirectories(searchPattern: string, searchOption: SearchOption): IEnumerable_1<DirectoryInfo>;
    EnumerateDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<DirectoryInfo>;
    EnumerateFiles(): IEnumerable_1<FileInfo>;
    EnumerateFiles(searchPattern: string): IEnumerable_1<FileInfo>;
    EnumerateFiles(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileInfo>;
    EnumerateFiles(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileInfo>;
    EnumerateFileSystemInfos(): IEnumerable_1<FileSystemInfo>;
    EnumerateFileSystemInfos(searchPattern: string): IEnumerable_1<FileSystemInfo>;
    EnumerateFileSystemInfos(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileSystemInfo>;
    EnumerateFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileSystemInfo>;
    GetDirectories(): DirectoryInfo[];
    GetDirectories(searchPattern: string): DirectoryInfo[];
    GetDirectories(searchPattern: string, searchOption: SearchOption): DirectoryInfo[];
    GetDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): DirectoryInfo[];
    GetFiles(): FileInfo[];
    GetFiles(searchPattern: string): FileInfo[];
    GetFiles(searchPattern: string, searchOption: SearchOption): FileInfo[];
    GetFiles(searchPattern: string, enumerationOptions: EnumerationOptions): FileInfo[];
    GetFileSystemInfos(): FileSystemInfo[];
    GetFileSystemInfos(searchPattern: string): FileSystemInfo[];
    GetFileSystemInfos(searchPattern: string, searchOption: SearchOption): FileSystemInfo[];
    GetFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): FileSystemInfo[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    MoveTo(destDirName: string): void;
}


export interface __DirectoryInfo$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryInfo = DirectoryInfo$instance & __DirectoryInfo$views;


export class DirectoryNotFoundException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DirectoryNotFoundException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryNotFoundException = DirectoryNotFoundException$instance & __DirectoryNotFoundException$views;


export class DriveInfo$instance {
    constructor(driveName: string);
    readonly AvailableFreeSpace: long;
    readonly DriveFormat: string;
    readonly DriveType: DriveType;
    readonly IsReady: boolean;
    readonly Name: string;
    readonly RootDirectory: DirectoryInfo;
    readonly TotalFreeSpace: long;
    readonly TotalSize: long;
    VolumeLabel: string;
    ToString(): string;
    static GetDrives(): DriveInfo[];
}


export interface __DriveInfo$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DriveInfo = DriveInfo$instance & __DriveInfo$views;


export class DriveNotFoundException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DriveNotFoundException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DriveNotFoundException = DriveNotFoundException$instance & __DriveNotFoundException$views;


export class EndOfStreamException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __EndOfStreamException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EndOfStreamException = EndOfStreamException$instance & __EndOfStreamException$views;


export class EnumerationOptions$instance {
    constructor();
    AttributesToSkip: FileAttributes;
    BufferSize: int;
    IgnoreInaccessible: boolean;
    MatchCasing: MatchCasing;
    MatchType: MatchType;
    MaxRecursionDepth: int;
    RecurseSubdirectories: boolean;
    ReturnSpecialDirectories: boolean;
}


export type EnumerationOptions = EnumerationOptions$instance;

export class ErrorEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(exception: Exception);
    GetException(): Exception;
}


export type ErrorEventArgs = ErrorEventArgs$instance;

export class ErrorEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: ErrorEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: ErrorEventArgs): void;
}


export interface __ErrorEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ErrorEventHandler = ErrorEventHandler$instance & __ErrorEventHandler$views;


export class FileInfo$instance extends FileSystemInfo$instance {
    constructor(fileName: string);
    readonly Directory: DirectoryInfo;
    readonly DirectoryName: string;
    readonly Exists: boolean;
    IsReadOnly: boolean;
    readonly Length: long;
    readonly Name: string;
    AppendText(): StreamWriter;
    CopyTo(destFileName: string): FileInfo;
    CopyTo(destFileName: string, overwrite: boolean): FileInfo;
    Create(): FileStream;
    CreateText(): StreamWriter;
    Decrypt(): void;
    Delete(): void;
    Encrypt(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    MoveTo(destFileName: string): void;
    MoveTo(destFileName: string, overwrite: boolean): void;
    Open(options: FileStreamOptions): FileStream;
    Open(mode: FileMode): FileStream;
    Open(mode: FileMode, access: FileAccess): FileStream;
    Open(mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    OpenRead(): FileStream;
    OpenText(): StreamReader;
    OpenWrite(): FileStream;
    Replace(destinationFileName: string, destinationBackupFileName: string): FileInfo;
    Replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): FileInfo;
}


export interface __FileInfo$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileInfo = FileInfo$instance & __FileInfo$views;


export class FileLoadException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    constructor(message: string, fileName: string);
    constructor(message: string, fileName: string, inner: Exception);
    readonly FileName: string;
    readonly FusionLog: string;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export interface __FileLoadException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileLoadException = FileLoadException$instance & __FileLoadException$views;


export class FileNotFoundException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    constructor(message: string, fileName: string);
    constructor(message: string, fileName: string, innerException: Exception);
    readonly FileName: string;
    readonly FusionLog: string;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export interface __FileNotFoundException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileNotFoundException = FileNotFoundException$instance & __FileNotFoundException$views;


export class FileStream$instance extends Stream$instance {
    constructor(handle: nint, access: FileAccess);
    constructor(handle: nint, access: FileAccess, ownsHandle: boolean);
    constructor(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int);
    constructor(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int, isAsync: boolean);
    constructor(handle: SafeFileHandle, access: FileAccess);
    constructor(handle: SafeFileHandle, access: FileAccess, bufferSize: int);
    constructor(handle: SafeFileHandle, access: FileAccess, bufferSize: int, isAsync: boolean);
    constructor(path: string, mode: FileMode);
    constructor(path: string, mode: FileMode, access: FileAccess);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, useAsync: boolean);
    constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, options: FileOptions);
    constructor(path: string, options: FileStreamOptions);
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly Handle: nint;
    readonly IsAsync: boolean;
    readonly Length: long;
    readonly Name: string;
    Position: long;
    readonly SafeFileHandle: SafeFileHandle;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Lock(position: long, length: long): void;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Unlock(position: long, length: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export interface __FileStream$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type FileStream = FileStream$instance & __FileStream$views;


export class FileStreamOptions$instance {
    constructor();
    Access: FileAccess;
    BufferSize: int;
    Mode: FileMode;
    Options: FileOptions;
    PreallocationSize: long;
    Share: FileShare;
    UnixCreateMode: Nullable_1<UnixFileMode>;
}


export type FileStreamOptions = FileStreamOptions$instance;

export class FileSystemEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(changeType: WatcherChangeTypes, directory: string, name: string);
    readonly ChangeType: WatcherChangeTypes;
    readonly FullPath: string;
    readonly Name: string;
}


export type FileSystemEventArgs = FileSystemEventArgs$instance;

export class FileSystemEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: FileSystemEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: FileSystemEventArgs): void;
}


export interface __FileSystemEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileSystemEventHandler = FileSystemEventHandler$instance & __FileSystemEventHandler$views;


export abstract class FileSystemInfo$instance extends System_Internal.MarshalByRefObject$instance {
    Attributes: FileAttributes;
    CreationTime: DateTime;
    CreationTimeUtc: DateTime;
    readonly Exists: boolean;
    readonly Extension: string;
    readonly FullName: string;
    LastAccessTime: DateTime;
    LastAccessTimeUtc: DateTime;
    LastWriteTime: DateTime;
    LastWriteTimeUtc: DateTime;
    readonly LinkTarget: string;
    readonly Name: string;
    UnixFileMode: UnixFileMode;
    CreateAsSymbolicLink(pathToTarget: string): void;
    abstract Delete(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Refresh(): void;
    ResolveLinkTarget(returnFinalTarget: boolean): FileSystemInfo;
    ToString(): string;
}


export interface __FileSystemInfo$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileSystemInfo = FileSystemInfo$instance & __FileSystemInfo$views;


export class FileSystemWatcher$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    constructor(path: string);
    constructor(path: string, filter: string);
    EnableRaisingEvents: boolean;
    Filter: string;
    readonly Filters: Collection_1<CLROf<string>>;
    IncludeSubdirectories: boolean;
    InternalBufferSize: int;
    NotifyFilter: NotifyFilters;
    Path: string;
    Site: ISite;
    SynchronizingObject: ISynchronizeInvoke;
    BeginInit(): void;
    Dispose(): void;
    EndInit(): void;
    WaitForChanged(changeType: WatcherChangeTypes): WaitForChangedResult;
    WaitForChanged(changeType: WatcherChangeTypes, timeout: int): WaitForChangedResult;
    WaitForChanged(changeType: WatcherChangeTypes, timeout: TimeSpan): WaitForChangedResult;
}


export interface __FileSystemWatcher$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_ISupportInitialize: System_ComponentModel_Internal.ISupportInitialize$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type FileSystemWatcher = FileSystemWatcher$instance & __FileSystemWatcher$views;


export class InternalBufferOverflowException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InternalBufferOverflowException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InternalBufferOverflowException = InternalBufferOverflowException$instance & __InternalBufferOverflowException$views;


export class InvalidDataException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidDataException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidDataException = InvalidDataException$instance & __InvalidDataException$views;


export class IOException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, hresult: int);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __IOException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IOException = IOException$instance & __IOException$views;


export class MemoryStream$instance extends Stream$instance {
    constructor();
    constructor(capacity: int);
    constructor(buffer: byte[]);
    constructor(buffer: byte[], writable: boolean);
    constructor(buffer: byte[], index: int, count: int);
    constructor(buffer: byte[], index: int, count: int, writable: boolean);
    constructor(buffer: byte[], index: int, count: int, writable: boolean, publiclyVisible: boolean);
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    Capacity: int;
    readonly Length: long;
    Position: long;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    GetBuffer(): byte[];
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, loc: SeekOrigin): long;
    SetLength(value: long): void;
    ToArray(): byte[];
    TryGetBuffer(buffer: { value: ref<ArraySegment_1<CLROf<byte>>> }): boolean;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
    WriteTo(stream: Stream): void;
}


export interface __MemoryStream$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type MemoryStream = MemoryStream$instance & __MemoryStream$views;


export class PathTooLongException$instance extends IOException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __PathTooLongException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PathTooLongException = PathTooLongException$instance & __PathTooLongException$views;


export class RenamedEventArgs$instance extends FileSystemEventArgs$instance {
    constructor(changeType: WatcherChangeTypes, directory: string, name: string, oldName: string);
    readonly OldFullPath: string;
    readonly OldName: string;
}


export type RenamedEventArgs = RenamedEventArgs$instance;

export class RenamedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: RenamedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: RenamedEventArgs): void;
}


export interface __RenamedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RenamedEventHandler = RenamedEventHandler$instance & __RenamedEventHandler$views;


export abstract class Stream$instance extends System_Internal.MarshalByRefObject$instance {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanTimeout: boolean;
    readonly CanWrite: boolean;
    readonly Length: long;
    Position: long;
    ReadTimeout: int;
    WriteTimeout: int;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: any): IAsyncResult;
    Close(): void;
    CopyTo(destination: Stream): void;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    abstract Flush(): void;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAtLeast(buffer: Span_1<CLROf<byte>>, minimumBytes: int, throwOnEndOfStream?: boolean): int;
    ReadAtLeastAsync(buffer: Memory_1<CLROf<byte>>, minimumBytes: int, throwOnEndOfStream?: boolean, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    ReadExactly(buffer: Span_1<CLROf<byte>>): void;
    ReadExactly(buffer: byte[], offset: int, count: int): void;
    ReadExactlyAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    ReadExactlyAsync(buffer: byte[], offset: int, count: int, cancellationToken?: CancellationToken): ValueTask;
    abstract Seek(offset: long, origin: SeekOrigin): long;
    abstract SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
    static readonly Null: Stream;
    static Synchronized(stream: Stream): Stream;
}


export interface __Stream$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Stream = Stream$instance & __Stream$views;


export class StreamReader$instance extends TextReader$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, detectEncodingFromByteOrderMarks: boolean);
    constructor(stream: Stream, encoding: Encoding);
    constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean);
    constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int);
    constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int, leaveOpen: boolean);
    constructor(path: string);
    constructor(path: string, detectEncodingFromByteOrderMarks: boolean);
    constructor(path: string, encoding: Encoding);
    constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean);
    constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int);
    constructor(path: string, options: FileStreamOptions);
    constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, options: FileStreamOptions);
    readonly BaseStream: Stream;
    readonly CurrentEncoding: Encoding;
    readonly EndOfStream: boolean;
    Close(): void;
    DiscardBufferedData(): void;
    Dispose(): void;
    Peek(): int;
    Read(): int;
    Read(buffer: string[], index: int, count: int): int;
    Read(buffer: Span_1<CLROf<string>>): int;
    Read(buffer: Span_1<CLROf<string>>): int;
    ReadAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadBlock(buffer: string[], index: int, count: int): int;
    ReadBlock(buffer: Span_1<CLROf<string>>): int;
    ReadBlock(buffer: Span_1<CLROf<string>>): int;
    ReadBlockAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadBlockAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadBlockAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadBlockAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadLine(): string;
    ReadLineAsync(): Task_1<CLROf<string>>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    ReadLineAsync(): Task_1<CLROf<string>>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    ReadToEnd(): string;
    ReadToEndAsync(): Task_1<CLROf<string>>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    ReadToEndAsync(): Task_1<CLROf<string>>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
}


export interface __StreamReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type StreamReader = StreamReader$instance & __StreamReader$views;


export class StreamWriter$instance extends TextWriter$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, encoding: Encoding);
    constructor(stream: Stream, encoding: Encoding, bufferSize: int);
    constructor(stream: Stream, encoding: Encoding, bufferSize: int, leaveOpen: boolean);
    constructor(path: string);
    constructor(path: string, append: boolean);
    constructor(path: string, append: boolean, encoding: Encoding);
    constructor(path: string, append: boolean, encoding: Encoding, bufferSize: int);
    constructor(path: string, options: FileStreamOptions);
    constructor(path: string, encoding: Encoding, options: FileStreamOptions);
    AutoFlush: boolean;
    readonly BaseStream: Stream;
    readonly Encoding: Encoding;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    Write(value: string): void;
    Write(buffer: string[]): void;
    Write(buffer: string[], index: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    Write(value: string): void;
    Write(format: string, arg0: any): void;
    Write(format: string, arg0: any, arg1: any): void;
    Write(format: string, arg0: any, arg1: any, arg2: any): void;
    Write(format: string, arg: any[]): void;
    Write(format: string, arg: ReadOnlySpan_1<any>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    Write(value: boolean): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: any): void;
    Write(value: StringBuilder): void;
    Write(format: string, arg: ReadOnlySpan_1<any>): void;
    WriteAsync(value: string): Task;
    WriteAsync(value: string): Task;
    WriteAsync(buffer: string[], index: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteAsync(buffer: string[]): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteLine(value: string): void;
    WriteLine(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    WriteLine(format: string, arg0: any): void;
    WriteLine(format: string, arg0: any, arg1: any): void;
    WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
    WriteLine(format: string, arg: any[]): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<any>): void;
    WriteLine(): void;
    WriteLine(value: string): void;
    WriteLine(buffer: string[]): void;
    WriteLine(buffer: string[], index: int, count: int): void;
    WriteLine(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    WriteLine(value: boolean): void;
    WriteLine(value: int): void;
    WriteLine(value: uint): void;
    WriteLine(value: long): void;
    WriteLine(value: ulong): void;
    WriteLine(value: float): void;
    WriteLine(value: double): void;
    WriteLine(value: decimal): void;
    WriteLine(value: StringBuilder): void;
    WriteLine(value: any): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<any>): void;
    WriteLineAsync(): Task;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(buffer: string[], index: int, count: int): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: string[]): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
}


export interface __StreamWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type StreamWriter = StreamWriter$instance & __StreamWriter$views;


export class StringReader$instance extends TextReader$instance {
    constructor(s: string);
    Close(): void;
    Dispose(): void;
    Peek(): int;
    Read(): int;
    Read(buffer: string[], index: int, count: int): int;
    Read(buffer: Span_1<CLROf<string>>): int;
    Read(buffer: Span_1<CLROf<string>>): int;
    ReadAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadBlock(buffer: Span_1<CLROf<string>>): int;
    ReadBlock(buffer: string[], index: int, count: int): int;
    ReadBlock(buffer: Span_1<CLROf<string>>): int;
    ReadBlockAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadBlockAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadBlockAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadBlockAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadLine(): string;
    ReadLineAsync(): Task_1<CLROf<string>>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    ReadLineAsync(): Task_1<CLROf<string>>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    ReadToEnd(): string;
    ReadToEndAsync(): Task_1<CLROf<string>>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    ReadToEndAsync(): Task_1<CLROf<string>>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
}


export interface __StringReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type StringReader = StringReader$instance & __StringReader$views;


export class StringWriter$instance extends TextWriter$instance {
    constructor();
    constructor(formatProvider: IFormatProvider);
    constructor(sb: StringBuilder);
    constructor(sb: StringBuilder, formatProvider: IFormatProvider);
    readonly Encoding: Encoding;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    GetStringBuilder(): StringBuilder;
    ToString(): string;
    Write(value: string): void;
    Write(buffer: string[], index: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    Write(value: string): void;
    Write(value: StringBuilder): void;
    Write(buffer: string[]): void;
    Write(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    Write(value: boolean): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: any): void;
    Write(format: string, arg0: any): void;
    Write(format: string, arg0: any, arg1: any): void;
    Write(format: string, arg0: any, arg1: any, arg2: any): void;
    Write(format: string, arg: any[]): void;
    Write(format: string, arg: ReadOnlySpan_1<any>): void;
    WriteAsync(value: string): Task;
    WriteAsync(value: string): Task;
    WriteAsync(buffer: string[], index: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteAsync(buffer: string[]): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteLine(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    WriteLine(value: StringBuilder): void;
    WriteLine(): void;
    WriteLine(value: string): void;
    WriteLine(buffer: string[]): void;
    WriteLine(buffer: string[], index: int, count: int): void;
    WriteLine(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    WriteLine(value: boolean): void;
    WriteLine(value: int): void;
    WriteLine(value: uint): void;
    WriteLine(value: long): void;
    WriteLine(value: ulong): void;
    WriteLine(value: float): void;
    WriteLine(value: double): void;
    WriteLine(value: decimal): void;
    WriteLine(value: string): void;
    WriteLine(value: any): void;
    WriteLine(format: string, arg0: any): void;
    WriteLine(format: string, arg0: any, arg1: any): void;
    WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
    WriteLine(format: string, arg: any[]): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<any>): void;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: string[], index: int, count: int): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: string[]): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(): Task;
}


export interface __StringWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type StringWriter = StringWriter$instance & __StringWriter$views;


export abstract class TextReader$instance extends System_Internal.MarshalByRefObject$instance {
    Close(): void;
    Dispose(): void;
    Peek(): int;
    Read(): int;
    Read(buffer: string[], index: int, count: int): int;
    Read(buffer: Span_1<CLROf<string>>): int;
    ReadAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadBlock(buffer: string[], index: int, count: int): int;
    ReadBlock(buffer: Span_1<CLROf<string>>): int;
    ReadBlockAsync(buffer: string[], index: int, count: int): Task_1<CLROf<int>>;
    ReadBlockAsync(buffer: Memory_1<CLROf<string>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadLine(): string;
    ReadLineAsync(): Task_1<CLROf<string>>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<CLROf<string>>;
    ReadToEnd(): string;
    ReadToEndAsync(): Task_1<CLROf<string>>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<CLROf<string>>;
    static readonly Null: TextReader;
    static Synchronized(reader: TextReader): TextReader;
}


export interface __TextReader$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TextReader = TextReader$instance & __TextReader$views;


export abstract class TextWriter$instance extends System_Internal.MarshalByRefObject$instance {
    readonly Encoding: Encoding;
    readonly FormatProvider: IFormatProvider;
    NewLine: string;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    Write(value: string): void;
    Write(buffer: string[]): void;
    Write(buffer: string[], index: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    Write(value: boolean): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: string): void;
    Write(value: any): void;
    Write(value: StringBuilder): void;
    Write(format: string, arg0: any): void;
    Write(format: string, arg0: any, arg1: any): void;
    Write(format: string, arg0: any, arg1: any, arg2: any): void;
    Write(format: string, arg: any[]): void;
    Write(format: string, arg: ReadOnlySpan_1<any>): void;
    WriteAsync(value: string): Task;
    WriteAsync(value: string): Task;
    WriteAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteAsync(buffer: string[]): Task;
    WriteAsync(buffer: string[], index: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteLine(): void;
    WriteLine(value: string): void;
    WriteLine(buffer: string[]): void;
    WriteLine(buffer: string[], index: int, count: int): void;
    WriteLine(buffer: ReadOnlySpan_1<CLROf<string>>): void;
    WriteLine(value: boolean): void;
    WriteLine(value: int): void;
    WriteLine(value: uint): void;
    WriteLine(value: long): void;
    WriteLine(value: ulong): void;
    WriteLine(value: float): void;
    WriteLine(value: double): void;
    WriteLine(value: decimal): void;
    WriteLine(value: string): void;
    WriteLine(value: StringBuilder): void;
    WriteLine(value: any): void;
    WriteLine(format: string, arg0: any): void;
    WriteLine(format: string, arg0: any, arg1: any): void;
    WriteLine(format: string, arg0: any, arg1: any, arg2: any): void;
    WriteLine(format: string, arg: any[]): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<any>): void;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: string[]): Task;
    WriteLineAsync(buffer: string[], index: int, count: int): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(): Task;
    static readonly Null: TextWriter;
    static CreateBroadcasting(writers: TextWriter[]): TextWriter;
    static Synchronized(writer: TextWriter): TextWriter;
}


export interface __TextWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TextWriter = TextWriter$instance & __TextWriter$views;


export class UnmanagedMemoryAccessor$instance {
    constructor(buffer: SafeBuffer, offset: long, capacity: long);
    constructor(buffer: SafeBuffer, offset: long, capacity: long, access: FileAccess);
    readonly CanRead: boolean;
    readonly CanWrite: boolean;
    readonly Capacity: long;
    Dispose(): void;
    Read<T extends any>(position: long, structure: { value: ref<T> }): void;
    ReadArray<T extends any>(position: long, array: T[], offset: int, count: int): int;
    ReadBoolean(position: long): boolean;
    ReadByte(position: long): byte;
    ReadChar(position: long): string;
    ReadDecimal(position: long): decimal;
    ReadDouble(position: long): double;
    ReadInt16(position: long): short;
    ReadInt32(position: long): int;
    ReadInt64(position: long): long;
    ReadSByte(position: long): sbyte;
    ReadSingle(position: long): float;
    ReadUInt16(position: long): ushort;
    ReadUInt32(position: long): uint;
    ReadUInt64(position: long): ulong;
    Write(position: long, value: boolean): void;
    Write(position: long, value: byte): void;
    Write(position: long, value: string): void;
    Write(position: long, value: short): void;
    Write(position: long, value: int): void;
    Write(position: long, value: long): void;
    Write(position: long, value: decimal): void;
    Write(position: long, value: float): void;
    Write(position: long, value: double): void;
    Write(position: long, value: sbyte): void;
    Write(position: long, value: ushort): void;
    Write(position: long, value: uint): void;
    Write(position: long, value: ulong): void;
    Write<T extends any>(position: long, structure: { value: ref<T> }): void;
    WriteArray<T extends any>(position: long, array: T[], offset: int, count: int): void;
}


export interface __UnmanagedMemoryAccessor$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type UnmanagedMemoryAccessor = UnmanagedMemoryAccessor$instance & __UnmanagedMemoryAccessor$views;


export class UnmanagedMemoryStream$instance extends Stream$instance {
    constructor(buffer: SafeBuffer, offset: long, length: long);
    constructor(buffer: SafeBuffer, offset: long, length: long, access: FileAccess);
    constructor(pointer: ptr<byte>, length: long);
    constructor(pointer: ptr<byte>, length: long, capacity: long, access: FileAccess);
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly Capacity: long;
    readonly Length: long;
    Position: long;
    PositionPointer: ptr<byte>;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, loc: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export interface __UnmanagedMemoryStream$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type UnmanagedMemoryStream = UnmanagedMemoryStream$instance & __UnmanagedMemoryStream$views;


export abstract class Directory$instance {
    static CreateDirectory(path: string, unixCreateMode: UnixFileMode): DirectoryInfo;
    static CreateDirectory(path: string): DirectoryInfo;
    static CreateSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static CreateTempSubdirectory(prefix?: string): DirectoryInfo;
    static Delete(path: string, recursive: boolean): void;
    static Delete(path: string): void;
    static EnumerateDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static EnumerateDirectories(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static EnumerateDirectories(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static EnumerateDirectories(path: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFiles(path: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string): IEnumerable_1<CLROf<string>>;
    static EnumerateFileSystemEntries(path: string): IEnumerable_1<CLROf<string>>;
    static Exists(path: string): boolean;
    static GetCreationTime(path: string): DateTime;
    static GetCreationTimeUtc(path: string): DateTime;
    static GetCurrentDirectory(): string;
    static GetDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetDirectories(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetDirectories(path: string, searchPattern: string): string[];
    static GetDirectories(path: string): string[];
    static GetDirectoryRoot(path: string): string;
    static GetFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetFiles(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetFiles(path: string, searchPattern: string): string[];
    static GetFiles(path: string): string[];
    static GetFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetFileSystemEntries(path: string, searchPattern: string): string[];
    static GetFileSystemEntries(path: string): string[];
    static GetLastAccessTime(path: string): DateTime;
    static GetLastAccessTimeUtc(path: string): DateTime;
    static GetLastWriteTime(path: string): DateTime;
    static GetLastWriteTimeUtc(path: string): DateTime;
    static GetLogicalDrives(): string[];
    static GetParent(path: string): DirectoryInfo;
    static Move(sourceDirName: string, destDirName: string): void;
    static ResolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo;
    static SetCreationTime(path: string, creationTime: DateTime): void;
    static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static SetCurrentDirectory(path: string): void;
    static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
}


export type Directory = Directory$instance;

export abstract class File$instance {
    static AppendAllBytes(path: string, bytes: byte[]): void;
    static AppendAllBytes(path: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    static AppendAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static AppendAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): Task;
    static AppendAllLines(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding): void;
    static AppendAllLines(path: string, contents: IEnumerable_1<CLROf<string>>): void;
    static AppendAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static AppendAllText(path: string, contents: ReadOnlySpan_1<CLROf<string>>, encoding: Encoding): void;
    static AppendAllText(path: string, contents: ReadOnlySpan_1<CLROf<string>>): void;
    static AppendAllText(path: string, contents: string, encoding: Encoding): void;
    static AppendAllText(path: string, contents: string): void;
    static AppendAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
    static AppendText(path: string): StreamWriter;
    static Copy(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static Copy(sourceFileName: string, destFileName: string): void;
    static Create(path: string, bufferSize: int, options: FileOptions): FileStream;
    static Create(path: string, bufferSize: int): FileStream;
    static Create(path: string): FileStream;
    static CreateSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static CreateText(path: string): StreamWriter;
    static Decrypt(path: string): void;
    static Delete(path: string): void;
    static Encrypt(path: string): void;
    static Exists(path: string): boolean;
    static GetAttributes(fileHandle: SafeFileHandle): FileAttributes;
    static GetAttributes(path: string): FileAttributes;
    static GetCreationTime(fileHandle: SafeFileHandle): DateTime;
    static GetCreationTime(path: string): DateTime;
    static GetCreationTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetCreationTimeUtc(path: string): DateTime;
    static GetLastAccessTime(fileHandle: SafeFileHandle): DateTime;
    static GetLastAccessTime(path: string): DateTime;
    static GetLastAccessTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetLastAccessTimeUtc(path: string): DateTime;
    static GetLastWriteTime(fileHandle: SafeFileHandle): DateTime;
    static GetLastWriteTime(path: string): DateTime;
    static GetLastWriteTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetLastWriteTimeUtc(path: string): DateTime;
    static GetUnixFileMode(fileHandle: SafeFileHandle): UnixFileMode;
    static GetUnixFileMode(path: string): UnixFileMode;
    static Move(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static Move(sourceFileName: string, destFileName: string): void;
    static Open(path: string, mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    static Open(path: string, mode: FileMode, access: FileAccess): FileStream;
    static Open(path: string, mode: FileMode): FileStream;
    static Open(path: string, options: FileStreamOptions): FileStream;
    static OpenHandle(path: string, mode?: FileMode, access?: FileAccess, share?: FileShare, options?: FileOptions, preallocationSize?: long): SafeFileHandle;
    static OpenRead(path: string): FileStream;
    static OpenText(path: string): StreamReader;
    static OpenWrite(path: string): FileStream;
    static ReadAllBytes(path: string): byte[];
    static ReadAllBytesAsync(path: string, cancellationToken?: CancellationToken): Task_1<byte[]>;
    static ReadAllLines(path: string, encoding: Encoding): string[];
    static ReadAllLines(path: string): string[];
    static ReadAllLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<string[]>;
    static ReadAllLinesAsync(path: string, cancellationToken?: CancellationToken): Task_1<string[]>;
    static ReadAllText(path: string, encoding: Encoding): string;
    static ReadAllText(path: string): string;
    static ReadAllTextAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<CLROf<string>>;
    static ReadAllTextAsync(path: string, cancellationToken?: CancellationToken): Task_1<CLROf<string>>;
    static ReadLines(path: string, encoding: Encoding): IEnumerable_1<CLROf<string>>;
    static ReadLines(path: string): IEnumerable_1<CLROf<string>>;
    static ReadLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): IAsyncEnumerable_1<CLROf<string>>;
    static ReadLinesAsync(path: string, cancellationToken?: CancellationToken): IAsyncEnumerable_1<CLROf<string>>;
    static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): void;
    static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void;
    static ResolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo;
    static SetAttributes(fileHandle: SafeFileHandle, fileAttributes: FileAttributes): void;
    static SetAttributes(path: string, fileAttributes: FileAttributes): void;
    static SetCreationTime(fileHandle: SafeFileHandle, creationTime: DateTime): void;
    static SetCreationTime(path: string, creationTime: DateTime): void;
    static SetCreationTimeUtc(fileHandle: SafeFileHandle, creationTimeUtc: DateTime): void;
    static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static SetLastAccessTime(fileHandle: SafeFileHandle, lastAccessTime: DateTime): void;
    static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static SetLastAccessTimeUtc(fileHandle: SafeFileHandle, lastAccessTimeUtc: DateTime): void;
    static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static SetLastWriteTime(fileHandle: SafeFileHandle, lastWriteTime: DateTime): void;
    static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static SetLastWriteTimeUtc(fileHandle: SafeFileHandle, lastWriteTimeUtc: DateTime): void;
    static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
    static SetUnixFileMode(fileHandle: SafeFileHandle, mode: UnixFileMode): void;
    static SetUnixFileMode(path: string, mode: UnixFileMode): void;
    static WriteAllBytes(path: string, bytes: byte[]): void;
    static WriteAllBytes(path: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    static WriteAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static WriteAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): Task;
    static WriteAllLines(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding): void;
    static WriteAllLines(path: string, contents: IEnumerable_1<CLROf<string>>): void;
    static WriteAllLines(path: string, contents: string[], encoding: Encoding): void;
    static WriteAllLines(path: string, contents: string[]): void;
    static WriteAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllLinesAsync(path: string, contents: IEnumerable_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static WriteAllText(path: string, contents: ReadOnlySpan_1<CLROf<string>>, encoding: Encoding): void;
    static WriteAllText(path: string, contents: ReadOnlySpan_1<CLROf<string>>): void;
    static WriteAllText(path: string, contents: string, encoding: Encoding): void;
    static WriteAllText(path: string, contents: string): void;
    static WriteAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<string>>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: ReadOnlyMemory_1<CLROf<string>>, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
}


export type File = File$instance;

export abstract class FileSystemAclExtensions$instance {
    static Create(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static Create(fileInfo: FileInfo, mode: FileMode, rights: FileSystemRights, share: FileShare, bufferSize: int, options: FileOptions, fileSecurity: FileSecurity): FileStream;
    static CreateDirectory(directorySecurity: DirectorySecurity, path: string): DirectoryInfo;
    static GetAccessControl(directoryInfo: DirectoryInfo, includeSections: AccessControlSections): DirectorySecurity;
    static GetAccessControl(directoryInfo: DirectoryInfo): DirectorySecurity;
    static GetAccessControl(fileInfo: FileInfo, includeSections: AccessControlSections): FileSecurity;
    static GetAccessControl(fileInfo: FileInfo): FileSecurity;
    static GetAccessControl(fileStream: FileStream): FileSecurity;
    static SetAccessControl(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static SetAccessControl(fileInfo: FileInfo, fileSecurity: FileSecurity): void;
    static SetAccessControl(fileStream: FileStream, fileSecurity: FileSecurity): void;
}


export type FileSystemAclExtensions = FileSystemAclExtensions$instance;

export abstract class Path$instance {
    static readonly DirectorySeparatorChar: string;
    static readonly AltDirectorySeparatorChar: string;
    static readonly VolumeSeparatorChar: string;
    static readonly PathSeparator: string;
    static readonly InvalidPathChars: string[];
    static ChangeExtension(path: string, extension: string): string;
    static Combine(paths: ReadOnlySpan_1<CLROf<string>>): string;
    static Combine(path1: string, path2: string, path3: string, path4: string): string;
    static Combine(path1: string, path2: string, path3: string): string;
    static Combine(path1: string, path2: string): string;
    static Combine(paths: string[]): string;
    static EndsInDirectorySeparator(path: ReadOnlySpan_1<CLROf<string>>): boolean;
    static EndsInDirectorySeparator(path: string): boolean;
    static Exists(path: string): boolean;
    static GetDirectoryName(path: ReadOnlySpan_1<CLROf<string>>): ReadOnlySpan_1<CLROf<string>>;
    static GetDirectoryName(path: string): string;
    static GetExtension(path: ReadOnlySpan_1<CLROf<string>>): ReadOnlySpan_1<CLROf<string>>;
    static GetExtension(path: string): string;
    static GetFileName(path: ReadOnlySpan_1<CLROf<string>>): ReadOnlySpan_1<CLROf<string>>;
    static GetFileName(path: string): string;
    static GetFileNameWithoutExtension(path: ReadOnlySpan_1<CLROf<string>>): ReadOnlySpan_1<CLROf<string>>;
    static GetFileNameWithoutExtension(path: string): string;
    static GetFullPath(path: string, basePath: string): string;
    static GetFullPath(path: string): string;
    static GetInvalidFileNameChars(): string[];
    static GetInvalidPathChars(): string[];
    static GetPathRoot(path: ReadOnlySpan_1<CLROf<string>>): ReadOnlySpan_1<CLROf<string>>;
    static GetPathRoot(path: string): string;
    static GetRandomFileName(): string;
    static GetRelativePath(relativeTo: string, path: string): string;
    static GetTempFileName(): string;
    static GetTempPath(): string;
    static HasExtension(path: ReadOnlySpan_1<CLROf<string>>): boolean;
    static HasExtension(path: string): boolean;
    static IsPathFullyQualified(path: ReadOnlySpan_1<CLROf<string>>): boolean;
    static IsPathFullyQualified(path: string): boolean;
    static IsPathRooted(path: ReadOnlySpan_1<CLROf<string>>): boolean;
    static IsPathRooted(path: string): boolean;
    static Join(path1: ReadOnlySpan_1<CLROf<string>>, path2: ReadOnlySpan_1<CLROf<string>>, path3: ReadOnlySpan_1<CLROf<string>>, path4: ReadOnlySpan_1<CLROf<string>>): string;
    static Join(path1: ReadOnlySpan_1<CLROf<string>>, path2: ReadOnlySpan_1<CLROf<string>>, path3: ReadOnlySpan_1<CLROf<string>>): string;
    static Join(path1: ReadOnlySpan_1<CLROf<string>>, path2: ReadOnlySpan_1<CLROf<string>>): string;
    static Join(paths: ReadOnlySpan_1<CLROf<string>>): string;
    static Join(path1: string, path2: string, path3: string, path4: string): string;
    static Join(path1: string, path2: string, path3: string): string;
    static Join(path1: string, path2: string): string;
    static Join(paths: string[]): string;
    static TrimEndingDirectorySeparator(path: ReadOnlySpan_1<CLROf<string>>): ReadOnlySpan_1<CLROf<string>>;
    static TrimEndingDirectorySeparator(path: string): string;
    static TryJoin(path1: ReadOnlySpan_1<CLROf<string>>, path2: ReadOnlySpan_1<CLROf<string>>, path3: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
    static TryJoin(path1: ReadOnlySpan_1<CLROf<string>>, path2: ReadOnlySpan_1<CLROf<string>>, destination: Span_1<CLROf<string>>, charsWritten: { value: ref<int> }): boolean;
}


export type Path = Path$instance;

export abstract class RandomAccess$instance {
    static FlushToDisk(handle: SafeFileHandle): void;
    static GetLength(handle: SafeFileHandle): long;
    static Read(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<CLROf<byte>>>, fileOffset: long): long;
    static Read(handle: SafeFileHandle, buffer: Span_1<CLROf<byte>>, fileOffset: long): int;
    static ReadAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<CLROf<byte>>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<CLROf<long>>;
    static ReadAsync(handle: SafeFileHandle, buffer: Memory_1<CLROf<byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static SetLength(handle: SafeFileHandle, length: long): void;
    static Write(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<CLROf<byte>>>, fileOffset: long): void;
    static Write(handle: SafeFileHandle, buffer: ReadOnlySpan_1<CLROf<byte>>, fileOffset: long): void;
    static WriteAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<CLROf<byte>>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
    static WriteAsync(handle: SafeFileHandle, buffer: ReadOnlyMemory_1<CLROf<byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
}


export type RandomAccess = RandomAccess$instance;

