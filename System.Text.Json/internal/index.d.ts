// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IBufferWriter_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { PipeReader, PipeWriter } from "../../System.IO.Pipelines/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { JavaScriptEncoder } from "../../System.Text.Encodings.Web/internal/index.js";
import type { JsonNode } from "../../System.Text.Json.Nodes/internal/index.js";
import type { IJsonTypeInfoResolver, JsonTypeInfo, JsonTypeInfo_1 } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonConverter, JsonIgnoreCondition, JsonNumberHandling, JsonObjectCreationHandling, JsonSerializerContext, JsonUnknownTypeHandling, JsonUnmappedMemberHandling, ReferenceHandler } from "../../System.Text.Json.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Enum, Exception, Guid, IAsyncDisposable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, SequencePosition, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum JsonCommentHandling {
    Disallow = 0,
    Skip = 1,
    Allow = 2
}


export enum JsonSerializerDefaults {
    General = 0,
    Web = 1,
    Strict = 2
}


export enum JsonTokenType {
    None = 0,
    StartObject = 1,
    EndObject = 2,
    StartArray = 3,
    EndArray = 4,
    PropertyName = 5,
    Comment = 6,
    String = 7,
    Number = 8,
    True = 9,
    False = 10,
    Null = 11
}


export enum JsonValueKind {
    Undefined = 0,
    Object = 1,
    Array = 2,
    String = 3,
    Number = 4,
    True = 5,
    False = 6,
    Null = 7
}


export class JsonDocumentOptions$instance {
    AllowDuplicateProperties: boolean;
    AllowTrailingCommas: boolean;
    CommentHandling: JsonCommentHandling;
    MaxDepth: int;
}


export type JsonDocumentOptions = JsonDocumentOptions$instance;

export class JsonElement$instance {
    readonly Item: JsonElement;
    readonly ValueKind: JsonValueKind;
    Clone(): JsonElement;
    EnumerateArray(): JsonElement_ArrayEnumerator;
    EnumerateObject(): JsonElement_ObjectEnumerator;
    GetArrayLength(): int;
    GetBoolean(): boolean;
    GetByte(): byte;
    GetBytesFromBase64(): byte[];
    GetDateTime(): DateTime;
    GetDateTimeOffset(): DateTimeOffset;
    GetDecimal(): decimal;
    GetDouble(): double;
    GetGuid(): Guid;
    GetInt16(): short;
    GetInt32(): int;
    GetInt64(): long;
    GetProperty(propertyName: string): JsonElement;
    GetProperty(propertyName: ReadOnlySpan_1<CLROf<string>>): JsonElement;
    GetProperty(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): JsonElement;
    GetPropertyCount(): int;
    GetRawText(): string;
    GetSByte(): sbyte;
    GetSingle(): float;
    GetString(): string;
    GetUInt16(): ushort;
    GetUInt32(): uint;
    GetUInt64(): ulong;
    ToString(): string;
    TryGetByte(value: { value: TSByRef<byte> }): boolean;
    TryGetBytesFromBase64(value: { value: TSByRef<byte[]> }): boolean;
    TryGetDateTime(value: { value: TSByRef<DateTime> }): boolean;
    TryGetDateTimeOffset(value: { value: TSByRef<DateTimeOffset> }): boolean;
    TryGetDecimal(value: { value: TSByRef<decimal> }): boolean;
    TryGetDouble(value: { value: TSByRef<double> }): boolean;
    TryGetGuid(value: { value: TSByRef<Guid> }): boolean;
    TryGetInt16(value: { value: TSByRef<short> }): boolean;
    TryGetInt32(value: { value: TSByRef<int> }): boolean;
    TryGetInt64(value: { value: TSByRef<long> }): boolean;
    TryGetProperty(propertyName: string, value: { value: TSByRef<JsonElement> }): boolean;
    TryGetProperty(propertyName: ReadOnlySpan_1<CLROf<string>>, value: { value: TSByRef<JsonElement> }): boolean;
    TryGetProperty(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<JsonElement> }): boolean;
    TryGetSByte(value: { value: TSByRef<sbyte> }): boolean;
    TryGetSingle(value: { value: TSByRef<float> }): boolean;
    TryGetUInt16(value: { value: TSByRef<ushort> }): boolean;
    TryGetUInt32(value: { value: TSByRef<uint> }): boolean;
    TryGetUInt64(value: { value: TSByRef<ulong> }): boolean;
    ValueEquals(text: string): boolean;
    ValueEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    ValueEquals(text: ReadOnlySpan_1<CLROf<string>>): boolean;
    WriteTo(writer: Utf8JsonWriter): void;
    static DeepEquals(element1: JsonElement, element2: JsonElement): boolean;
    static Parse(utf8Json: ReadOnlySpan_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonElement;
    static Parse(json: ReadOnlySpan_1<CLROf<string>>, options?: JsonDocumentOptions): JsonElement;
    static Parse(json: string, options?: JsonDocumentOptions): JsonElement;
    static ParseValue(reader: { value: TSByRef<Utf8JsonReader> }): JsonElement;
    static TryParseValue(reader: { value: TSByRef<Utf8JsonReader> }, element: { value: TSByRef<Nullable_1<JsonElement>> }): boolean;
}


export type JsonElement = JsonElement$instance;

export class JsonElement_ArrayEnumerator$instance {
    readonly Current: JsonElement;
    Dispose(): void;
    GetEnumerator(): JsonElement_ArrayEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __JsonElement_ArrayEnumerator$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<JsonElement>;
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<JsonElement>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type JsonElement_ArrayEnumerator = JsonElement_ArrayEnumerator$instance & __JsonElement_ArrayEnumerator$views;


export class JsonElement_ObjectEnumerator$instance {
    readonly Current: JsonProperty;
    Dispose(): void;
    GetEnumerator(): JsonElement_ObjectEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __JsonElement_ObjectEnumerator$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<JsonProperty>;
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<JsonProperty>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type JsonElement_ObjectEnumerator = JsonElement_ObjectEnumerator$instance & __JsonElement_ObjectEnumerator$views;


export class JsonEncodedText$instance {
    readonly EncodedUtf8Bytes: ReadOnlySpan_1<CLROf<byte>>;
    readonly Value: string;
    Equals(other: JsonEncodedText): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToString(): string;
    static Encode(utf8Value: ReadOnlySpan_1<CLROf<byte>>, encoder?: JavaScriptEncoder): JsonEncodedText;
    static Encode(value: ReadOnlySpan_1<CLROf<string>>, encoder?: JavaScriptEncoder): JsonEncodedText;
    static Encode(value: string, encoder?: JavaScriptEncoder): JsonEncodedText;
}


export interface __JsonEncodedText$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<JsonEncodedText>;

    // Structural method bridges for numeric interface constraints
    Equals(other: JsonEncodedText): boolean;
}

export type JsonEncodedText = JsonEncodedText$instance & __JsonEncodedText$views;


export class JsonProperty$instance {
    readonly Name: string;
    readonly Value: JsonElement;
    NameEquals(text: string): boolean;
    NameEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    NameEquals(text: ReadOnlySpan_1<CLROf<string>>): boolean;
    ToString(): string;
    WriteTo(writer: Utf8JsonWriter): void;
}


export type JsonProperty = JsonProperty$instance;

export class JsonReaderOptions$instance {
    AllowMultipleValues: boolean;
    AllowTrailingCommas: boolean;
    CommentHandling: JsonCommentHandling;
    MaxDepth: int;
}


export type JsonReaderOptions = JsonReaderOptions$instance;

export class JsonReaderState$instance {
    constructor(options: JsonReaderOptions);
    readonly Options: JsonReaderOptions;
}


export type JsonReaderState = JsonReaderState$instance;

export class JsonWriterOptions$instance {
    Encoder: JavaScriptEncoder;
    IndentCharacter: string;
    Indented: boolean;
    IndentSize: int;
    MaxDepth: int;
    NewLine: string;
    SkipValidation: boolean;
}


export type JsonWriterOptions = JsonWriterOptions$instance;

export class Utf8JsonReader$instance {
    constructor(jsonData: ReadOnlySpan_1<CLROf<byte>>, isFinalBlock: boolean, state: JsonReaderState);
    constructor(jsonData: ReadOnlySpan_1<CLROf<byte>>, options: JsonReaderOptions);
    constructor(jsonData: ReadOnlySequence_1<CLROf<byte>>, isFinalBlock: boolean, state: JsonReaderState);
    constructor(jsonData: ReadOnlySequence_1<CLROf<byte>>, options: JsonReaderOptions);
    readonly BytesConsumed: long;
    readonly CurrentDepth: int;
    readonly CurrentState: JsonReaderState;
    readonly HasValueSequence: boolean;
    readonly IsFinalBlock: boolean;
    readonly Position: SequencePosition;
    readonly TokenStartIndex: long;
    readonly TokenType: JsonTokenType;
    readonly ValueIsEscaped: boolean;
    readonly ValueSequence: ReadOnlySequence_1<CLROf<byte>>;
    readonly ValueSpan: ReadOnlySpan_1<CLROf<byte>>;
    CopyString(utf8Destination: Span_1<CLROf<byte>>): int;
    CopyString(destination: Span_1<CLROf<string>>): int;
    GetBoolean(): boolean;
    GetByte(): byte;
    GetBytesFromBase64(): byte[];
    GetComment(): string;
    GetDateTime(): DateTime;
    GetDateTimeOffset(): DateTimeOffset;
    GetDecimal(): decimal;
    GetDouble(): double;
    GetGuid(): Guid;
    GetInt16(): short;
    GetInt32(): int;
    GetInt64(): long;
    GetSByte(): sbyte;
    GetSingle(): float;
    GetString(): string;
    GetUInt16(): ushort;
    GetUInt32(): uint;
    GetUInt64(): ulong;
    Read(): boolean;
    Skip(): void;
    TryGetByte(value: { value: TSByRef<byte> }): boolean;
    TryGetBytesFromBase64(value: { value: TSByRef<byte[]> }): boolean;
    TryGetDateTime(value: { value: TSByRef<DateTime> }): boolean;
    TryGetDateTimeOffset(value: { value: TSByRef<DateTimeOffset> }): boolean;
    TryGetDecimal(value: { value: TSByRef<decimal> }): boolean;
    TryGetDouble(value: { value: TSByRef<double> }): boolean;
    TryGetGuid(value: { value: TSByRef<Guid> }): boolean;
    TryGetInt16(value: { value: TSByRef<short> }): boolean;
    TryGetInt32(value: { value: TSByRef<int> }): boolean;
    TryGetInt64(value: { value: TSByRef<long> }): boolean;
    TryGetSByte(value: { value: TSByRef<sbyte> }): boolean;
    TryGetSingle(value: { value: TSByRef<float> }): boolean;
    TryGetUInt16(value: { value: TSByRef<ushort> }): boolean;
    TryGetUInt32(value: { value: TSByRef<uint> }): boolean;
    TryGetUInt64(value: { value: TSByRef<ulong> }): boolean;
    TrySkip(): boolean;
    ValueTextEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    ValueTextEquals(text: string): boolean;
    ValueTextEquals(text: ReadOnlySpan_1<CLROf<string>>): boolean;
}


export type Utf8JsonReader = Utf8JsonReader$instance;

export class JsonDocument$instance {
    readonly RootElement: JsonElement;
    Dispose(): void;
    WriteTo(writer: Utf8JsonWriter): void;
    static Parse(utf8Json: ReadOnlySequence_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonDocument;
    static Parse(utf8Json: Stream, options?: JsonDocumentOptions): JsonDocument;
    static Parse(utf8Json: ReadOnlyMemory_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonDocument;
    static Parse(json: ReadOnlyMemory_1<CLROf<string>>, options?: JsonDocumentOptions): JsonDocument;
    static Parse(json: string, options?: JsonDocumentOptions): JsonDocument;
    static ParseAsync(utf8Json: Stream, options?: JsonDocumentOptions, cancellationToken?: CancellationToken): Task_1<JsonDocument>;
    static ParseValue(reader: { value: TSByRef<Utf8JsonReader> }): JsonDocument;
    static TryParseValue(reader: { value: TSByRef<Utf8JsonReader> }, document: { value: TSByRef<JsonDocument> }): boolean;
}


export interface __JsonDocument$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type JsonDocument = JsonDocument$instance & __JsonDocument$views;


export class JsonException$instance extends System_Internal.Exception$instance {
    constructor(message: string, path: string, lineNumber: Nullable_1<CLROf<long>>, bytePositionInLine: Nullable_1<CLROf<long>>, innerException: Exception);
    constructor(message: string, path: string, lineNumber: Nullable_1<CLROf<long>>, bytePositionInLine: Nullable_1<CLROf<long>>);
    constructor(message: string, innerException: Exception);
    constructor(message: string);
    constructor();
    readonly BytePositionInLine: Nullable_1<CLROf<long>>;
    readonly LineNumber: Nullable_1<CLROf<long>>;
    readonly Message: string;
    readonly Path: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __JsonException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type JsonException = JsonException$instance & __JsonException$views;


export abstract class JsonNamingPolicy$instance {
    abstract ConvertName(name: string): string;
    static readonly CamelCase: JsonNamingPolicy;
    static readonly SnakeCaseLower: JsonNamingPolicy;
    static readonly SnakeCaseUpper: JsonNamingPolicy;
    static readonly KebabCaseLower: JsonNamingPolicy;
    static readonly KebabCaseUpper: JsonNamingPolicy;
}


export type JsonNamingPolicy = JsonNamingPolicy$instance;

export class JsonSerializerOptions$instance {
    constructor();
    constructor(options: JsonSerializerOptions);
    constructor(defaults: JsonSerializerDefaults);
    AllowDuplicateProperties: boolean;
    AllowOutOfOrderMetadataProperties: boolean;
    AllowTrailingCommas: boolean;
    readonly Converters: IList_1<JsonConverter>;
    DefaultBufferSize: int;
    DefaultIgnoreCondition: JsonIgnoreCondition;
    DictionaryKeyPolicy: JsonNamingPolicy;
    Encoder: JavaScriptEncoder;
    IgnoreNullValues: boolean;
    IgnoreReadOnlyFields: boolean;
    IgnoreReadOnlyProperties: boolean;
    IncludeFields: boolean;
    IndentCharacter: string;
    IndentSize: int;
    readonly IsReadOnly: boolean;
    MaxDepth: int;
    NewLine: string;
    NumberHandling: JsonNumberHandling;
    PreferredObjectCreationHandling: JsonObjectCreationHandling;
    PropertyNameCaseInsensitive: boolean;
    PropertyNamingPolicy: JsonNamingPolicy;
    ReadCommentHandling: JsonCommentHandling;
    ReferenceHandler: ReferenceHandler;
    RespectNullableAnnotations: boolean;
    RespectRequiredConstructorParameters: boolean;
    TypeInfoResolver: IJsonTypeInfoResolver;
    readonly TypeInfoResolverChain: IList_1<IJsonTypeInfoResolver>;
    UnknownTypeHandling: JsonUnknownTypeHandling;
    UnmappedMemberHandling: JsonUnmappedMemberHandling;
    WriteIndented: boolean;
    AddContext<TContext extends JsonSerializerContext>(): void;
    GetConverter(typeToConvert: Type): JsonConverter;
    GetTypeInfo(type_: Type): JsonTypeInfo;
    MakeReadOnly(): void;
    MakeReadOnly(populateMissingResolver: boolean): void;
    TryGetTypeInfo(type_: Type, typeInfo: { value: TSByRef<JsonTypeInfo> }): boolean;
    static readonly Default: JsonSerializerOptions;
    static readonly Web: JsonSerializerOptions;
    static readonly Strict: JsonSerializerOptions;
}


export type JsonSerializerOptions = JsonSerializerOptions$instance;

export class Utf8JsonWriter$instance {
    constructor(bufferWriter: IBufferWriter_1<CLROf<byte>>, options: JsonWriterOptions);
    constructor(utf8Json: Stream, options: JsonWriterOptions);
    readonly BytesCommitted: long;
    readonly BytesPending: int;
    readonly CurrentDepth: int;
    readonly Options: JsonWriterOptions;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(cancellationToken?: CancellationToken): Task;
    Reset(): void;
    Reset(utf8Json: Stream): void;
    Reset(bufferWriter: IBufferWriter_1<CLROf<byte>>): void;
    WriteBase64String(propertyName: JsonEncodedText, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteBase64String(propertyName: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteBase64String(propertyName: ReadOnlySpan_1<CLROf<string>>, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteBase64String(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteBase64StringSegment(value: ReadOnlySpan_1<CLROf<byte>>, isFinalSegment: boolean): void;
    WriteBase64StringValue(bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteBoolean(propertyName: JsonEncodedText, value: boolean): void;
    WriteBoolean(propertyName: string, value: boolean): void;
    WriteBoolean(propertyName: ReadOnlySpan_1<CLROf<string>>, value: boolean): void;
    WriteBoolean(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: boolean): void;
    WriteBooleanValue(value: boolean): void;
    WriteCommentValue(value: string): void;
    WriteCommentValue(value: ReadOnlySpan_1<CLROf<string>>): void;
    WriteCommentValue(utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteEndArray(): void;
    WriteEndObject(): void;
    WriteNull(propertyName: JsonEncodedText): void;
    WriteNull(propertyName: string): void;
    WriteNull(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    WriteNull(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteNullValue(): void;
    WriteNumber(propertyName: JsonEncodedText, value: decimal): void;
    WriteNumber(propertyName: string, value: decimal): void;
    WriteNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: decimal): void;
    WriteNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: decimal): void;
    WriteNumber(propertyName: JsonEncodedText, value: double): void;
    WriteNumber(propertyName: string, value: double): void;
    WriteNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: double): void;
    WriteNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: double): void;
    WriteNumber(propertyName: JsonEncodedText, value: float): void;
    WriteNumber(propertyName: string, value: float): void;
    WriteNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: float): void;
    WriteNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: float): void;
    WriteNumber(propertyName: JsonEncodedText, value: long): void;
    WriteNumber(propertyName: string, value: long): void;
    WriteNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: long): void;
    WriteNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: long): void;
    WriteNumber(propertyName: JsonEncodedText, value: int): void;
    WriteNumber(propertyName: string, value: int): void;
    WriteNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: int): void;
    WriteNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: int): void;
    WriteNumber(propertyName: JsonEncodedText, value: ulong): void;
    WriteNumber(propertyName: string, value: ulong): void;
    WriteNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: ulong): void;
    WriteNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: ulong): void;
    WriteNumber(propertyName: JsonEncodedText, value: uint): void;
    WriteNumber(propertyName: string, value: uint): void;
    WriteNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: uint): void;
    WriteNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: uint): void;
    WriteNumberValue(value: decimal): void;
    WriteNumberValue(value: double): void;
    WriteNumberValue(value: float): void;
    WriteNumberValue(value: int): void;
    WriteNumberValue(value: long): void;
    WriteNumberValue(value: uint): void;
    WriteNumberValue(value: ulong): void;
    WritePropertyName(propertyName: JsonEncodedText): void;
    WritePropertyName(propertyName: string): void;
    WritePropertyName(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    WritePropertyName(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteRawValue(json: string, skipInputValidation?: boolean): void;
    WriteRawValue(json: ReadOnlySpan_1<CLROf<string>>, skipInputValidation?: boolean): void;
    WriteRawValue(utf8Json: ReadOnlySpan_1<CLROf<byte>>, skipInputValidation?: boolean): void;
    WriteRawValue(utf8Json: ReadOnlySequence_1<CLROf<byte>>, skipInputValidation?: boolean): void;
    WriteStartArray(): void;
    WriteStartArray(propertyName: JsonEncodedText): void;
    WriteStartArray(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteStartArray(propertyName: string): void;
    WriteStartArray(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    WriteStartObject(): void;
    WriteStartObject(propertyName: JsonEncodedText): void;
    WriteStartObject(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteStartObject(propertyName: string): void;
    WriteStartObject(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    WriteString(propertyName: JsonEncodedText, value: DateTime): void;
    WriteString(propertyName: string, value: DateTime): void;
    WriteString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: DateTime): void;
    WriteString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: DateTime): void;
    WriteString(propertyName: JsonEncodedText, value: DateTimeOffset): void;
    WriteString(propertyName: string, value: DateTimeOffset): void;
    WriteString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: DateTimeOffset): void;
    WriteString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: DateTimeOffset): void;
    WriteString(propertyName: JsonEncodedText, value: Guid): void;
    WriteString(propertyName: string, value: Guid): void;
    WriteString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: Guid): void;
    WriteString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: Guid): void;
    WriteString(propertyName: JsonEncodedText, value: JsonEncodedText): void;
    WriteString(propertyName: string, value: JsonEncodedText): void;
    WriteString(propertyName: string, value: string): void;
    WriteString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: ReadOnlySpan_1<CLROf<string>>): void;
    WriteString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteString(propertyName: JsonEncodedText, value: string): void;
    WriteString(propertyName: JsonEncodedText, value: ReadOnlySpan_1<CLROf<string>>): void;
    WriteString(propertyName: string, value: ReadOnlySpan_1<CLROf<string>>): void;
    WriteString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: ReadOnlySpan_1<CLROf<string>>): void;
    WriteString(propertyName: JsonEncodedText, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteString(propertyName: string, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteString(propertyName: ReadOnlySpan_1<CLROf<string>>, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: JsonEncodedText): void;
    WriteString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: string): void;
    WriteString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: JsonEncodedText): void;
    WriteString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: string): void;
    WriteStringValue(value: DateTime): void;
    WriteStringValue(value: DateTimeOffset): void;
    WriteStringValue(value: Guid): void;
    WriteStringValue(value: JsonEncodedText): void;
    WriteStringValue(value: string): void;
    WriteStringValue(value: ReadOnlySpan_1<CLROf<string>>): void;
    WriteStringValue(utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteStringValueSegment(value: ReadOnlySpan_1<CLROf<string>>, isFinalSegment: boolean): void;
    WriteStringValueSegment(value: ReadOnlySpan_1<CLROf<byte>>, isFinalSegment: boolean): void;
}


export interface __Utf8JsonWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Utf8JsonWriter = Utf8JsonWriter$instance & __Utf8JsonWriter$views;


export abstract class JsonSerializer$instance {
    static readonly IsReflectionEnabledByDefault: boolean;
    static Deserialize<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(utf8Json: Stream, options?: JsonSerializerOptions): TValue;
    static Deserialize(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(utf8Json: Stream, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(utf8Json: Stream, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(utf8Json: ReadOnlySpan_1<CLROf<byte>>, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(utf8Json: ReadOnlySpan_1<CLROf<byte>>, options?: JsonSerializerOptions): TValue;
    static Deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(json: ReadOnlySpan_1<CLROf<string>>, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(json: ReadOnlySpan_1<CLROf<string>>, options?: JsonSerializerOptions): TValue;
    static Deserialize(json: ReadOnlySpan_1<CLROf<string>>, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(json: ReadOnlySpan_1<CLROf<string>>, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(json: ReadOnlySpan_1<CLROf<string>>, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(json: string, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(json: string, options?: JsonSerializerOptions): TValue;
    static Deserialize(json: string, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(json: string, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(json: string, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(document: JsonDocument, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(document: JsonDocument, options?: JsonSerializerOptions): TValue;
    static Deserialize(document: JsonDocument, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(document: JsonDocument, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(document: JsonDocument, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(element: JsonElement, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(element: JsonElement, options?: JsonSerializerOptions): TValue;
    static Deserialize(element: JsonElement, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(element: JsonElement, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(element: JsonElement, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(node: JsonNode, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(node: JsonNode, options?: JsonSerializerOptions): TValue;
    static Deserialize(node: JsonNode, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(node: JsonNode, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(node: JsonNode, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(reader: { value: TSByRef<Utf8JsonReader> }, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(reader: { value: TSByRef<Utf8JsonReader> }, options?: JsonSerializerOptions): TValue;
    static Deserialize(reader: { value: TSByRef<Utf8JsonReader> }, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(reader: { value: TSByRef<Utf8JsonReader> }, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(reader: { value: TSByRef<Utf8JsonReader> }, returnType: Type, context: JsonSerializerContext): any;
    static DeserializeAsync<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync<TValue>(utf8Json: PipeReader, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: PipeReader, returnType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: PipeReader, returnType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync<TValue>(utf8Json: Stream, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: Stream, returnType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: Stream, returnType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, topLevelValues: boolean, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, topLevelValues: boolean, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, topLevelValues: boolean, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, topLevelValues: boolean, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static Serialize(utf8Json: Stream, value: any, jsonTypeInfo: JsonTypeInfo): void;
    static Serialize(utf8Json: Stream, value: any, inputType: Type, options?: JsonSerializerOptions): void;
    static Serialize(utf8Json: Stream, value: any, inputType: Type, context: JsonSerializerContext): void;
    static Serialize<TValue>(utf8Json: Stream, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): void;
    static Serialize<TValue>(utf8Json: Stream, value: TValue, options?: JsonSerializerOptions): void;
    static Serialize(value: any, jsonTypeInfo: JsonTypeInfo): string;
    static Serialize(value: any, inputType: Type, options?: JsonSerializerOptions): string;
    static Serialize(value: any, inputType: Type, context: JsonSerializerContext): string;
    static Serialize(writer: Utf8JsonWriter, value: any, jsonTypeInfo: JsonTypeInfo): void;
    static Serialize(writer: Utf8JsonWriter, value: any, inputType: Type, options?: JsonSerializerOptions): void;
    static Serialize(writer: Utf8JsonWriter, value: any, inputType: Type, context: JsonSerializerContext): void;
    static Serialize<TValue>(writer: Utf8JsonWriter, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): void;
    static Serialize<TValue>(writer: Utf8JsonWriter, value: TValue, options?: JsonSerializerOptions): void;
    static Serialize<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): string;
    static Serialize<TValue>(value: TValue, options?: JsonSerializerOptions): string;
    static SerializeAsync(utf8Json: PipeWriter, value: any, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: PipeWriter, value: any, inputType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: PipeWriter, value: any, inputType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: PipeWriter, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: PipeWriter, value: TValue, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: Stream, value: any, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: Stream, value: any, inputType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: Stream, value: any, inputType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: Stream, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: Stream, value: TValue, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeToDocument(value: any, jsonTypeInfo: JsonTypeInfo): JsonDocument;
    static SerializeToDocument(value: any, inputType: Type, options?: JsonSerializerOptions): JsonDocument;
    static SerializeToDocument(value: any, inputType: Type, context: JsonSerializerContext): JsonDocument;
    static SerializeToDocument<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonDocument;
    static SerializeToDocument<TValue>(value: TValue, options?: JsonSerializerOptions): JsonDocument;
    static SerializeToElement(value: any, jsonTypeInfo: JsonTypeInfo): JsonElement;
    static SerializeToElement(value: any, inputType: Type, options?: JsonSerializerOptions): JsonElement;
    static SerializeToElement(value: any, inputType: Type, context: JsonSerializerContext): JsonElement;
    static SerializeToElement<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonElement;
    static SerializeToElement<TValue>(value: TValue, options?: JsonSerializerOptions): JsonElement;
    static SerializeToNode(value: any, jsonTypeInfo: JsonTypeInfo): JsonNode;
    static SerializeToNode(value: any, inputType: Type, options?: JsonSerializerOptions): JsonNode;
    static SerializeToNode(value: any, inputType: Type, context: JsonSerializerContext): JsonNode;
    static SerializeToNode<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonNode;
    static SerializeToNode<TValue>(value: TValue, options?: JsonSerializerOptions): JsonNode;
    static SerializeToUtf8Bytes(value: any, jsonTypeInfo: JsonTypeInfo): byte[];
    static SerializeToUtf8Bytes(value: any, inputType: Type, options?: JsonSerializerOptions): byte[];
    static SerializeToUtf8Bytes(value: any, inputType: Type, context: JsonSerializerContext): byte[];
    static SerializeToUtf8Bytes<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): byte[];
    static SerializeToUtf8Bytes<TValue>(value: TValue, options?: JsonSerializerOptions): byte[];
}


export type JsonSerializer = JsonSerializer$instance;

