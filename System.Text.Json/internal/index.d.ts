// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { IBufferWriter_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { PipeReader, PipeWriter } from "../../System.IO.Pipelines/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { JavaScriptEncoder } from "../../System.Text.Encodings.Web/internal/index.js";
import type { JsonNode } from "../../System.Text.Json.Nodes/internal/index.js";
import type { IJsonTypeInfoResolver, JsonTypeInfo, JsonTypeInfo_1 } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonConverter, JsonIgnoreCondition, JsonNumberHandling, JsonObjectCreationHandling, JsonSerializerContext, JsonUnknownTypeHandling, JsonUnmappedMemberHandling, ReferenceHandler } from "../../System.Text.Json.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Enum, Exception, Guid, IAsyncDisposable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, SequencePosition, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum JsonCommentHandling {
    disallow = 0,
    skip = 1,
    allow = 2
}


export enum JsonSerializerDefaults {
    general = 0,
    web = 1,
    strict = 2
}


export enum JsonTokenType {
    none = 0,
    startObject = 1,
    endObject = 2,
    startArray = 3,
    endArray = 4,
    propertyName = 5,
    comment = 6,
    string_ = 7,
    number_ = 8,
    true_ = 9,
    false_ = 10,
    null_ = 11
}


export enum JsonValueKind {
    undefined = 0,
    object_ = 1,
    array = 2,
    string_ = 3,
    number_ = 4,
    true_ = 5,
    false_ = 6,
    null_ = 7
}


export class JsonDocumentOptions$instance {
    allowDuplicateProperties: boolean;
    allowTrailingCommas: boolean;
    commentHandling: JsonCommentHandling;
    maxDepth: int;
}


export type JsonDocumentOptions = JsonDocumentOptions$instance;

export class JsonElement$instance {
    readonly item: JsonElement;
    readonly valueKind: JsonValueKind;
    clone(): JsonElement;
    enumerateArray(): JsonElement_ArrayEnumerator;
    enumerateObject(): JsonElement_ObjectEnumerator;
    getArrayLength(): int;
    getBoolean(): boolean;
    getByte(): byte;
    getBytesFromBase64(): byte[];
    getDateTime(): DateTime;
    getDateTimeOffset(): DateTimeOffset;
    getDecimal(): decimal;
    getDouble(): double;
    getGuid(): Guid;
    getInt16(): short;
    getInt32(): int;
    getInt64(): long;
    getProperty(propertyName: string): JsonElement;
    getProperty(propertyName: ReadOnlySpan_1<CLROf<string>>): JsonElement;
    getProperty(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): JsonElement;
    getPropertyCount(): int;
    getRawText(): string;
    getSByte(): sbyte;
    getSingle(): float;
    getString(): string;
    getUInt16(): ushort;
    getUInt32(): uint;
    getUInt64(): ulong;
    toString(): string;
    tryGetByte(value: { value: TSByRef<byte> }): boolean;
    tryGetBytesFromBase64(value: { value: TSByRef<byte[]> }): boolean;
    tryGetDateTime(value: { value: TSByRef<DateTime> }): boolean;
    tryGetDateTimeOffset(value: { value: TSByRef<DateTimeOffset> }): boolean;
    tryGetDecimal(value: { value: TSByRef<decimal> }): boolean;
    tryGetDouble(value: { value: TSByRef<double> }): boolean;
    tryGetGuid(value: { value: TSByRef<Guid> }): boolean;
    tryGetInt16(value: { value: TSByRef<short> }): boolean;
    tryGetInt32(value: { value: TSByRef<int> }): boolean;
    tryGetInt64(value: { value: TSByRef<long> }): boolean;
    tryGetProperty(propertyName: string, value: { value: TSByRef<JsonElement> }): boolean;
    tryGetProperty(propertyName: ReadOnlySpan_1<CLROf<string>>, value: { value: TSByRef<JsonElement> }): boolean;
    tryGetProperty(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: { value: TSByRef<JsonElement> }): boolean;
    tryGetSByte(value: { value: TSByRef<sbyte> }): boolean;
    tryGetSingle(value: { value: TSByRef<float> }): boolean;
    tryGetUInt16(value: { value: TSByRef<ushort> }): boolean;
    tryGetUInt32(value: { value: TSByRef<uint> }): boolean;
    tryGetUInt64(value: { value: TSByRef<ulong> }): boolean;
    valueEquals(text: string): boolean;
    valueEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    valueEquals(text: ReadOnlySpan_1<CLROf<string>>): boolean;
    writeTo(writer: Utf8JsonWriter): void;
    static DeepEquals(element1: JsonElement, element2: JsonElement): boolean;
    static Parse(utf8Json: ReadOnlySpan_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonElement;
    static Parse(json: ReadOnlySpan_1<CLROf<string>>, options?: JsonDocumentOptions): JsonElement;
    static Parse(json: string, options?: JsonDocumentOptions): JsonElement;
    static ParseValue(reader: { value: TSByRef<Utf8JsonReader> }): JsonElement;
    static TryParseValue(reader: { value: TSByRef<Utf8JsonReader> }, element: { value: TSByRef<Nullable_1<JsonElement>> }): boolean;
}


export type JsonElement = JsonElement$instance;

export class JsonElement_ArrayEnumerator$instance {
    readonly current: JsonElement;
    dispose(): void;
    getEnumerator(): JsonElement_ArrayEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export interface __JsonElement_ArrayEnumerator$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<JsonElement>;
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<JsonElement>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type JsonElement_ArrayEnumerator = JsonElement_ArrayEnumerator$instance & __JsonElement_ArrayEnumerator$views;


export class JsonElement_ObjectEnumerator$instance {
    readonly current: JsonProperty;
    dispose(): void;
    getEnumerator(): JsonElement_ObjectEnumerator;
    moveNext(): boolean;
    reset(): void;
}


export interface __JsonElement_ObjectEnumerator$views {
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<JsonProperty>;
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<JsonProperty>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type JsonElement_ObjectEnumerator = JsonElement_ObjectEnumerator$instance & __JsonElement_ObjectEnumerator$views;


export class JsonEncodedText$instance {
    readonly encodedUtf8Bytes: ReadOnlySpan_1<CLROf<byte>>;
    readonly value: string;
    equals(other: JsonEncodedText): boolean;
    equals(obj: any): boolean;
    getHashCode(): int;
    toString(): string;
    static Encode(utf8Value: ReadOnlySpan_1<CLROf<byte>>, encoder?: JavaScriptEncoder): JsonEncodedText;
    static Encode(value: ReadOnlySpan_1<CLROf<string>>, encoder?: JavaScriptEncoder): JsonEncodedText;
    static Encode(value: string, encoder?: JavaScriptEncoder): JsonEncodedText;
}


export interface __JsonEncodedText$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<JsonEncodedText>;

    // Structural method bridges for numeric interface constraints
    Equals(other: JsonEncodedText): boolean;
}

export type JsonEncodedText = JsonEncodedText$instance & __JsonEncodedText$views;


export class JsonProperty$instance {
    readonly name: string;
    readonly value: JsonElement;
    nameEquals(text: string): boolean;
    nameEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    nameEquals(text: ReadOnlySpan_1<CLROf<string>>): boolean;
    toString(): string;
    writeTo(writer: Utf8JsonWriter): void;
}


export type JsonProperty = JsonProperty$instance;

export class JsonReaderOptions$instance {
    allowMultipleValues: boolean;
    allowTrailingCommas: boolean;
    commentHandling: JsonCommentHandling;
    maxDepth: int;
}


export type JsonReaderOptions = JsonReaderOptions$instance;

export class JsonReaderState$instance {
    constructor(options: JsonReaderOptions);
    readonly options: JsonReaderOptions;
}


export type JsonReaderState = JsonReaderState$instance;

export class JsonWriterOptions$instance {
    encoder: JavaScriptEncoder;
    indentCharacter: string;
    indented: boolean;
    indentSize: int;
    maxDepth: int;
    newLine: string;
    skipValidation: boolean;
}


export type JsonWriterOptions = JsonWriterOptions$instance;

export class Utf8JsonReader$instance {
    constructor(jsonData: ReadOnlySpan_1<CLROf<byte>>, isFinalBlock: boolean, state: JsonReaderState);
    constructor(jsonData: ReadOnlySpan_1<CLROf<byte>>, options: JsonReaderOptions);
    constructor(jsonData: ReadOnlySequence_1<CLROf<byte>>, isFinalBlock: boolean, state: JsonReaderState);
    constructor(jsonData: ReadOnlySequence_1<CLROf<byte>>, options: JsonReaderOptions);
    readonly bytesConsumed: long;
    readonly currentDepth: int;
    readonly currentState: JsonReaderState;
    readonly hasValueSequence: boolean;
    readonly isFinalBlock: boolean;
    readonly position: SequencePosition;
    readonly tokenStartIndex: long;
    readonly tokenType: JsonTokenType;
    readonly valueIsEscaped: boolean;
    readonly valueSequence: ReadOnlySequence_1<CLROf<byte>>;
    readonly valueSpan: ReadOnlySpan_1<CLROf<byte>>;
    copyString(utf8Destination: Span_1<CLROf<byte>>): int;
    copyString(destination: Span_1<CLROf<string>>): int;
    getBoolean(): boolean;
    getByte(): byte;
    getBytesFromBase64(): byte[];
    getComment(): string;
    getDateTime(): DateTime;
    getDateTimeOffset(): DateTimeOffset;
    getDecimal(): decimal;
    getDouble(): double;
    getGuid(): Guid;
    getInt16(): short;
    getInt32(): int;
    getInt64(): long;
    getSByte(): sbyte;
    getSingle(): float;
    getString(): string;
    getUInt16(): ushort;
    getUInt32(): uint;
    getUInt64(): ulong;
    read(): boolean;
    skip(): void;
    tryGetByte(value: { value: TSByRef<byte> }): boolean;
    tryGetBytesFromBase64(value: { value: TSByRef<byte[]> }): boolean;
    tryGetDateTime(value: { value: TSByRef<DateTime> }): boolean;
    tryGetDateTimeOffset(value: { value: TSByRef<DateTimeOffset> }): boolean;
    tryGetDecimal(value: { value: TSByRef<decimal> }): boolean;
    tryGetDouble(value: { value: TSByRef<double> }): boolean;
    tryGetGuid(value: { value: TSByRef<Guid> }): boolean;
    tryGetInt16(value: { value: TSByRef<short> }): boolean;
    tryGetInt32(value: { value: TSByRef<int> }): boolean;
    tryGetInt64(value: { value: TSByRef<long> }): boolean;
    tryGetSByte(value: { value: TSByRef<sbyte> }): boolean;
    tryGetSingle(value: { value: TSByRef<float> }): boolean;
    tryGetUInt16(value: { value: TSByRef<ushort> }): boolean;
    tryGetUInt32(value: { value: TSByRef<uint> }): boolean;
    tryGetUInt64(value: { value: TSByRef<ulong> }): boolean;
    trySkip(): boolean;
    valueTextEquals(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    valueTextEquals(text: string): boolean;
    valueTextEquals(text: ReadOnlySpan_1<CLROf<string>>): boolean;
}


export type Utf8JsonReader = Utf8JsonReader$instance;

export class JsonDocument$instance {
    readonly rootElement: JsonElement;
    dispose(): void;
    writeTo(writer: Utf8JsonWriter): void;
    static Parse(utf8Json: ReadOnlySequence_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonDocument;
    static Parse(utf8Json: Stream, options?: JsonDocumentOptions): JsonDocument;
    static Parse(utf8Json: ReadOnlyMemory_1<CLROf<byte>>, options?: JsonDocumentOptions): JsonDocument;
    static Parse(json: ReadOnlyMemory_1<CLROf<string>>, options?: JsonDocumentOptions): JsonDocument;
    static Parse(json: string, options?: JsonDocumentOptions): JsonDocument;
    static ParseAsync(utf8Json: Stream, options?: JsonDocumentOptions, cancellationToken?: CancellationToken): Task_1<JsonDocument>;
    static ParseValue(reader: { value: TSByRef<Utf8JsonReader> }): JsonDocument;
    static TryParseValue(reader: { value: TSByRef<Utf8JsonReader> }, document: { value: TSByRef<JsonDocument> }): boolean;
}


export interface __JsonDocument$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type JsonDocument = JsonDocument$instance & __JsonDocument$views;


export class JsonException$instance extends System_Internal.Exception$instance {
    constructor(message: string, path: string, lineNumber: Nullable_1<CLROf<long>>, bytePositionInLine: Nullable_1<CLROf<long>>, innerException: Exception);
    constructor(message: string, path: string, lineNumber: Nullable_1<CLROf<long>>, bytePositionInLine: Nullable_1<CLROf<long>>);
    constructor(message: string, innerException: Exception);
    constructor(message: string);
    constructor();
    readonly bytePositionInLine: Nullable_1<CLROf<long>>;
    readonly lineNumber: Nullable_1<CLROf<long>>;
    readonly message: string;
    readonly path: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __JsonException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type JsonException = JsonException$instance & __JsonException$views;


export abstract class JsonNamingPolicy$instance {
    abstract convertName(name: string): string;
    static readonly CamelCase: JsonNamingPolicy;
    static readonly SnakeCaseLower: JsonNamingPolicy;
    static readonly SnakeCaseUpper: JsonNamingPolicy;
    static readonly KebabCaseLower: JsonNamingPolicy;
    static readonly KebabCaseUpper: JsonNamingPolicy;
}


export type JsonNamingPolicy = JsonNamingPolicy$instance;

export class JsonSerializerOptions$instance {
    constructor();
    constructor(options: JsonSerializerOptions);
    constructor(defaults: JsonSerializerDefaults);
    allowDuplicateProperties: boolean;
    allowOutOfOrderMetadataProperties: boolean;
    allowTrailingCommas: boolean;
    readonly converters: IList_1<JsonConverter>;
    defaultBufferSize: int;
    defaultIgnoreCondition: JsonIgnoreCondition;
    dictionaryKeyPolicy: JsonNamingPolicy;
    encoder: JavaScriptEncoder;
    ignoreNullValues: boolean;
    ignoreReadOnlyFields: boolean;
    ignoreReadOnlyProperties: boolean;
    includeFields: boolean;
    indentCharacter: string;
    indentSize: int;
    readonly isReadOnly: boolean;
    maxDepth: int;
    newLine: string;
    numberHandling: JsonNumberHandling;
    preferredObjectCreationHandling: JsonObjectCreationHandling;
    propertyNameCaseInsensitive: boolean;
    propertyNamingPolicy: JsonNamingPolicy;
    readCommentHandling: JsonCommentHandling;
    referenceHandler: ReferenceHandler;
    respectNullableAnnotations: boolean;
    respectRequiredConstructorParameters: boolean;
    typeInfoResolver: IJsonTypeInfoResolver;
    readonly typeInfoResolverChain: IList_1<IJsonTypeInfoResolver>;
    unknownTypeHandling: JsonUnknownTypeHandling;
    unmappedMemberHandling: JsonUnmappedMemberHandling;
    writeIndented: boolean;
    addContext<TContext extends JsonSerializerContext>(): void;
    getConverter(typeToConvert: Type): JsonConverter;
    getTypeInfo(type_: Type): JsonTypeInfo;
    makeReadOnly(): void;
    makeReadOnly(populateMissingResolver: boolean): void;
    tryGetTypeInfo(type_: Type, typeInfo: { value: TSByRef<JsonTypeInfo> }): boolean;
    static readonly Default: JsonSerializerOptions;
    static readonly Web: JsonSerializerOptions;
    static readonly Strict: JsonSerializerOptions;
}


export type JsonSerializerOptions = JsonSerializerOptions$instance;

export class Utf8JsonWriter$instance {
    constructor(bufferWriter: IBufferWriter_1<CLROf<byte>>, options: JsonWriterOptions);
    constructor(utf8Json: Stream, options: JsonWriterOptions);
    readonly bytesCommitted: long;
    readonly bytesPending: int;
    readonly currentDepth: int;
    readonly options: JsonWriterOptions;
    dispose(): void;
    disposeAsync(): ValueTask;
    flush(): void;
    flushAsync(cancellationToken?: CancellationToken): Task;
    reset(): void;
    reset(utf8Json: Stream): void;
    reset(bufferWriter: IBufferWriter_1<CLROf<byte>>): void;
    writeBase64String(propertyName: JsonEncodedText, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64String(propertyName: string, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64String(propertyName: ReadOnlySpan_1<CLROf<string>>, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64String(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBase64StringSegment(value: ReadOnlySpan_1<CLROf<byte>>, isFinalSegment: boolean): void;
    writeBase64StringValue(bytes: ReadOnlySpan_1<CLROf<byte>>): void;
    writeBoolean(propertyName: JsonEncodedText, value: boolean): void;
    writeBoolean(propertyName: string, value: boolean): void;
    writeBoolean(propertyName: ReadOnlySpan_1<CLROf<string>>, value: boolean): void;
    writeBoolean(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: boolean): void;
    writeBooleanValue(value: boolean): void;
    writeCommentValue(value: string): void;
    writeCommentValue(value: ReadOnlySpan_1<CLROf<string>>): void;
    writeCommentValue(utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeEndArray(): void;
    writeEndObject(): void;
    writeNull(propertyName: JsonEncodedText): void;
    writeNull(propertyName: string): void;
    writeNull(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    writeNull(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeNullValue(): void;
    writeNumber(propertyName: JsonEncodedText, value: decimal): void;
    writeNumber(propertyName: string, value: decimal): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: decimal): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: decimal): void;
    writeNumber(propertyName: JsonEncodedText, value: double): void;
    writeNumber(propertyName: string, value: double): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: double): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: double): void;
    writeNumber(propertyName: JsonEncodedText, value: float): void;
    writeNumber(propertyName: string, value: float): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: float): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: float): void;
    writeNumber(propertyName: JsonEncodedText, value: long): void;
    writeNumber(propertyName: string, value: long): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: long): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: long): void;
    writeNumber(propertyName: JsonEncodedText, value: int): void;
    writeNumber(propertyName: string, value: int): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: int): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: int): void;
    writeNumber(propertyName: JsonEncodedText, value: ulong): void;
    writeNumber(propertyName: string, value: ulong): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: ulong): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: ulong): void;
    writeNumber(propertyName: JsonEncodedText, value: uint): void;
    writeNumber(propertyName: string, value: uint): void;
    writeNumber(propertyName: ReadOnlySpan_1<CLROf<string>>, value: uint): void;
    writeNumber(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: uint): void;
    writeNumberValue(value: decimal): void;
    writeNumberValue(value: double): void;
    writeNumberValue(value: float): void;
    writeNumberValue(value: int): void;
    writeNumberValue(value: long): void;
    writeNumberValue(value: uint): void;
    writeNumberValue(value: ulong): void;
    writePropertyName(propertyName: JsonEncodedText): void;
    writePropertyName(propertyName: string): void;
    writePropertyName(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    writePropertyName(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeRawValue(json: string, skipInputValidation?: boolean): void;
    writeRawValue(json: ReadOnlySpan_1<CLROf<string>>, skipInputValidation?: boolean): void;
    writeRawValue(utf8Json: ReadOnlySpan_1<CLROf<byte>>, skipInputValidation?: boolean): void;
    writeRawValue(utf8Json: ReadOnlySequence_1<CLROf<byte>>, skipInputValidation?: boolean): void;
    writeStartArray(): void;
    writeStartArray(propertyName: JsonEncodedText): void;
    writeStartArray(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeStartArray(propertyName: string): void;
    writeStartArray(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    writeStartObject(): void;
    writeStartObject(propertyName: JsonEncodedText): void;
    writeStartObject(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>): void;
    writeStartObject(propertyName: string): void;
    writeStartObject(propertyName: ReadOnlySpan_1<CLROf<string>>): void;
    writeString(propertyName: JsonEncodedText, value: DateTime): void;
    writeString(propertyName: string, value: DateTime): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: DateTime): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: DateTime): void;
    writeString(propertyName: JsonEncodedText, value: DateTimeOffset): void;
    writeString(propertyName: string, value: DateTimeOffset): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: DateTimeOffset): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: DateTimeOffset): void;
    writeString(propertyName: JsonEncodedText, value: Guid): void;
    writeString(propertyName: string, value: Guid): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: Guid): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: Guid): void;
    writeString(propertyName: JsonEncodedText, value: JsonEncodedText): void;
    writeString(propertyName: string, value: JsonEncodedText): void;
    writeString(propertyName: string, value: string): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: ReadOnlySpan_1<CLROf<string>>): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: JsonEncodedText, value: string): void;
    writeString(propertyName: JsonEncodedText, value: ReadOnlySpan_1<CLROf<string>>): void;
    writeString(propertyName: string, value: ReadOnlySpan_1<CLROf<string>>): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: ReadOnlySpan_1<CLROf<string>>): void;
    writeString(propertyName: JsonEncodedText, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: string, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<string>>, utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: JsonEncodedText): void;
    writeString(propertyName: ReadOnlySpan_1<CLROf<string>>, value: string): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: JsonEncodedText): void;
    writeString(utf8PropertyName: ReadOnlySpan_1<CLROf<byte>>, value: string): void;
    writeStringValue(value: DateTime): void;
    writeStringValue(value: DateTimeOffset): void;
    writeStringValue(value: Guid): void;
    writeStringValue(value: JsonEncodedText): void;
    writeStringValue(value: string): void;
    writeStringValue(value: ReadOnlySpan_1<CLROf<string>>): void;
    writeStringValue(utf8Value: ReadOnlySpan_1<CLROf<byte>>): void;
    writeStringValueSegment(value: ReadOnlySpan_1<CLROf<string>>, isFinalSegment: boolean): void;
    writeStringValueSegment(value: ReadOnlySpan_1<CLROf<byte>>, isFinalSegment: boolean): void;
}


export interface __Utf8JsonWriter$views {
    readonly As_IAsyncDisposable: System_Internal.IAsyncDisposable$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Utf8JsonWriter = Utf8JsonWriter$instance & __Utf8JsonWriter$views;


export abstract class JsonSerializer$instance {
    static readonly IsReflectionEnabledByDefault: boolean;
    static Deserialize<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(utf8Json: Stream, options?: JsonSerializerOptions): TValue;
    static Deserialize(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(utf8Json: Stream, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(utf8Json: Stream, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(utf8Json: ReadOnlySpan_1<CLROf<byte>>, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(utf8Json: ReadOnlySpan_1<CLROf<byte>>, options?: JsonSerializerOptions): TValue;
    static Deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(utf8Json: ReadOnlySpan_1<CLROf<byte>>, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(json: ReadOnlySpan_1<CLROf<string>>, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(json: ReadOnlySpan_1<CLROf<string>>, options?: JsonSerializerOptions): TValue;
    static Deserialize(json: ReadOnlySpan_1<CLROf<string>>, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(json: ReadOnlySpan_1<CLROf<string>>, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(json: ReadOnlySpan_1<CLROf<string>>, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(json: string, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(json: string, options?: JsonSerializerOptions): TValue;
    static Deserialize(json: string, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(json: string, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(json: string, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(document: JsonDocument, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(document: JsonDocument, options?: JsonSerializerOptions): TValue;
    static Deserialize(document: JsonDocument, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(document: JsonDocument, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(document: JsonDocument, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(element: JsonElement, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(element: JsonElement, options?: JsonSerializerOptions): TValue;
    static Deserialize(element: JsonElement, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(element: JsonElement, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(element: JsonElement, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(node: JsonNode, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(node: JsonNode, options?: JsonSerializerOptions): TValue;
    static Deserialize(node: JsonNode, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(node: JsonNode, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(node: JsonNode, returnType: Type, context: JsonSerializerContext): any;
    static Deserialize<TValue>(reader: { value: TSByRef<Utf8JsonReader> }, jsonTypeInfo: JsonTypeInfo_1<TValue>): TValue;
    static Deserialize<TValue>(reader: { value: TSByRef<Utf8JsonReader> }, options?: JsonSerializerOptions): TValue;
    static Deserialize(reader: { value: TSByRef<Utf8JsonReader> }, jsonTypeInfo: JsonTypeInfo): any;
    static Deserialize(reader: { value: TSByRef<Utf8JsonReader> }, returnType: Type, options?: JsonSerializerOptions): any;
    static Deserialize(reader: { value: TSByRef<Utf8JsonReader> }, returnType: Type, context: JsonSerializerContext): any;
    static DeserializeAsync<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync<TValue>(utf8Json: PipeReader, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: PipeReader, returnType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: PipeReader, returnType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync<TValue>(utf8Json: Stream, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<TValue>;
    static DeserializeAsync(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: Stream, returnType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsync(utf8Json: Stream, returnType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): ValueTask_1<any>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, topLevelValues: boolean, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, topLevelValues: boolean, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: PipeReader, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, topLevelValues: boolean, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, topLevelValues: boolean, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static DeserializeAsyncEnumerable<TValue>(utf8Json: Stream, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TValue>;
    static Serialize(utf8Json: Stream, value: any, jsonTypeInfo: JsonTypeInfo): void;
    static Serialize(utf8Json: Stream, value: any, inputType: Type, options?: JsonSerializerOptions): void;
    static Serialize(utf8Json: Stream, value: any, inputType: Type, context: JsonSerializerContext): void;
    static Serialize<TValue>(utf8Json: Stream, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): void;
    static Serialize<TValue>(utf8Json: Stream, value: TValue, options?: JsonSerializerOptions): void;
    static Serialize(value: any, jsonTypeInfo: JsonTypeInfo): string;
    static Serialize(value: any, inputType: Type, options?: JsonSerializerOptions): string;
    static Serialize(value: any, inputType: Type, context: JsonSerializerContext): string;
    static Serialize(writer: Utf8JsonWriter, value: any, jsonTypeInfo: JsonTypeInfo): void;
    static Serialize(writer: Utf8JsonWriter, value: any, inputType: Type, options?: JsonSerializerOptions): void;
    static Serialize(writer: Utf8JsonWriter, value: any, inputType: Type, context: JsonSerializerContext): void;
    static Serialize<TValue>(writer: Utf8JsonWriter, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): void;
    static Serialize<TValue>(writer: Utf8JsonWriter, value: TValue, options?: JsonSerializerOptions): void;
    static Serialize<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): string;
    static Serialize<TValue>(value: TValue, options?: JsonSerializerOptions): string;
    static SerializeAsync(utf8Json: PipeWriter, value: any, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: PipeWriter, value: any, inputType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: PipeWriter, value: any, inputType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: PipeWriter, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: PipeWriter, value: TValue, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: Stream, value: any, jsonTypeInfo: JsonTypeInfo, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: Stream, value: any, inputType: Type, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeAsync(utf8Json: Stream, value: any, inputType: Type, context: JsonSerializerContext, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: Stream, value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>, cancellationToken?: CancellationToken): Task;
    static SerializeAsync<TValue>(utf8Json: Stream, value: TValue, options?: JsonSerializerOptions, cancellationToken?: CancellationToken): Task;
    static SerializeToDocument(value: any, jsonTypeInfo: JsonTypeInfo): JsonDocument;
    static SerializeToDocument(value: any, inputType: Type, options?: JsonSerializerOptions): JsonDocument;
    static SerializeToDocument(value: any, inputType: Type, context: JsonSerializerContext): JsonDocument;
    static SerializeToDocument<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonDocument;
    static SerializeToDocument<TValue>(value: TValue, options?: JsonSerializerOptions): JsonDocument;
    static SerializeToElement(value: any, jsonTypeInfo: JsonTypeInfo): JsonElement;
    static SerializeToElement(value: any, inputType: Type, options?: JsonSerializerOptions): JsonElement;
    static SerializeToElement(value: any, inputType: Type, context: JsonSerializerContext): JsonElement;
    static SerializeToElement<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonElement;
    static SerializeToElement<TValue>(value: TValue, options?: JsonSerializerOptions): JsonElement;
    static SerializeToNode(value: any, jsonTypeInfo: JsonTypeInfo): JsonNode;
    static SerializeToNode(value: any, inputType: Type, options?: JsonSerializerOptions): JsonNode;
    static SerializeToNode(value: any, inputType: Type, context: JsonSerializerContext): JsonNode;
    static SerializeToNode<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): JsonNode;
    static SerializeToNode<TValue>(value: TValue, options?: JsonSerializerOptions): JsonNode;
    static SerializeToUtf8Bytes(value: any, jsonTypeInfo: JsonTypeInfo): byte[];
    static SerializeToUtf8Bytes(value: any, inputType: Type, options?: JsonSerializerOptions): byte[];
    static SerializeToUtf8Bytes(value: any, inputType: Type, context: JsonSerializerContext): byte[];
    static SerializeToUtf8Bytes<TValue>(value: TValue, jsonTypeInfo: JsonTypeInfo_1<TValue>): byte[];
    static SerializeToUtf8Bytes<TValue>(value: TValue, options?: JsonSerializerOptions): byte[];
}


export type JsonSerializer = JsonSerializer$instance;

