// Generated by tsbindgen - Architecture
// Namespace: System.Security.Claims
// Assembly: System.Security.Claims

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary_2, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { BinaryReader, BinaryWriter } from "../../System.IO/internal/index.js";
import * as System_Security_Principal_Internal from "../../System.Security.Principal/internal/index.js";
import type { IIdentity, IPrincipal } from "../../System.Security.Principal/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Func_1, Func_2, Int32, Object as ClrObject, Predicate_1, String as ClrString, StringComparison, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export class Claim$instance {
    constructor(reader: BinaryReader);
    constructor(reader: BinaryReader, subject: ClaimsIdentity);
    constructor(type_: string, value: string);
    constructor(type_: string, value: string, valueType: string);
    constructor(type_: string, value: string, valueType: string, issuer: string);
    constructor(type_: string, value: string, valueType: string, issuer: string, originalIssuer: string);
    constructor(type_: string, value: string, valueType: string, issuer: string, originalIssuer: string, subject: ClaimsIdentity);
    readonly issuer: string;
    readonly originalIssuer: string;
    readonly properties: IDictionary_2<CLROf<string>, CLROf<string>>;
    readonly subject: ClaimsIdentity;
    readonly type_: string;
    readonly value: string;
    readonly valueType: string;
    clone(): Claim;
    clone(identity: ClaimsIdentity): Claim;
    toString(): string;
    writeTo(writer: BinaryWriter): void;
}


export type Claim = Claim$instance;

export class ClaimsIdentity$instance {
    constructor();
    constructor(identity: IIdentity);
    constructor(claims: IEnumerable_1<Claim>);
    constructor(authenticationType: string);
    constructor(claims: IEnumerable_1<Claim>, authenticationType: string);
    constructor(identity: IIdentity, claims: IEnumerable_1<Claim>);
    constructor(authenticationType: string, nameType: string, roleType: string);
    constructor(claims: IEnumerable_1<Claim>, authenticationType: string, nameType: string, roleType: string);
    constructor(identity: IIdentity, claims: IEnumerable_1<Claim>, authenticationType: string, nameType: string, roleType: string);
    constructor(reader: BinaryReader);
    constructor(reader: BinaryReader, stringComparison: StringComparison);
    constructor(identity: IIdentity, claims: IEnumerable_1<Claim>, authenticationType: string, nameType: string, roleType: string, stringComparison: StringComparison);
    actor: ClaimsIdentity;
    readonly authenticationType: string;
    bootstrapContext: any;
    readonly claims: IEnumerable_1<Claim>;
    readonly isAuthenticated: boolean;
    label: string;
    readonly name: string;
    readonly nameClaimType: string;
    readonly roleClaimType: string;
    addClaim(claim: Claim): void;
    addClaims(claims: IEnumerable_1<Claim>): void;
    clone(): ClaimsIdentity;
    findAll(match: Predicate_1<Claim>): IEnumerable_1<Claim>;
    findAll(type_: string): IEnumerable_1<Claim>;
    findFirst(match: Predicate_1<Claim>): Claim;
    findFirst(type_: string): Claim;
    hasClaim(match: Predicate_1<Claim>): boolean;
    hasClaim(type_: string, value: string): boolean;
    removeClaim(claim: Claim): void;
    tryRemoveClaim(claim: Claim): boolean;
    writeTo(writer: BinaryWriter): void;
    static readonly DefaultIssuer: string;
    static readonly DefaultNameClaimType: string;
    static readonly DefaultRoleClaimType: string;
}


export interface __ClaimsIdentity$views {
    readonly As_IIdentity: System_Security_Principal_Internal.IIdentity$instance;
}

export type ClaimsIdentity = ClaimsIdentity$instance & __ClaimsIdentity$views;


export class ClaimsPrincipal$instance {
    constructor();
    constructor(identities: IEnumerable_1<ClaimsIdentity>);
    constructor(identity: IIdentity);
    constructor(principal: IPrincipal);
    constructor(reader: BinaryReader);
    readonly claims: IEnumerable_1<Claim>;
    readonly identities: IEnumerable_1<ClaimsIdentity>;
    readonly identity: IIdentity;
    addIdentities(identities: IEnumerable_1<ClaimsIdentity>): void;
    addIdentity(identity: ClaimsIdentity): void;
    clone(): ClaimsPrincipal;
    findAll(match: Predicate_1<Claim>): IEnumerable_1<Claim>;
    findAll(type_: string): IEnumerable_1<Claim>;
    findFirst(match: Predicate_1<Claim>): Claim;
    findFirst(type_: string): Claim;
    hasClaim(match: Predicate_1<Claim>): boolean;
    hasClaim(type_: string, value: string): boolean;
    isInRole(role: string): boolean;
    writeTo(writer: BinaryWriter): void;
    static PrimaryIdentitySelector: Func_2<IEnumerable_1<ClaimsIdentity>, ClaimsIdentity>;
    static ClaimsPrincipalSelector: Func_1<ClaimsPrincipal>;
    static readonly Current: ClaimsPrincipal;
}


export interface __ClaimsPrincipal$views {
    readonly As_IPrincipal: System_Security_Principal_Internal.IPrincipal$instance;
}

export type ClaimsPrincipal = ClaimsPrincipal$instance & __ClaimsPrincipal$views;


export abstract class ClaimTypes$instance {
    static readonly AuthenticationInstant: string;
    static readonly AuthenticationMethod: string;
    static readonly CookiePath: string;
    static readonly DenyOnlyPrimarySid: string;
    static readonly DenyOnlyPrimaryGroupSid: string;
    static readonly DenyOnlyWindowsDeviceGroup: string;
    static readonly Dsa: string;
    static readonly Expiration: string;
    static readonly Expired: string;
    static readonly GroupSid: string;
    static readonly IsPersistent: string;
    static readonly PrimaryGroupSid: string;
    static readonly PrimarySid: string;
    static readonly Role: string;
    static readonly SerialNumber: string;
    static readonly UserData: string;
    static readonly Version: string;
    static readonly WindowsAccountName: string;
    static readonly WindowsDeviceClaim: string;
    static readonly WindowsDeviceGroup: string;
    static readonly WindowsUserClaim: string;
    static readonly WindowsFqbnVersion: string;
    static readonly WindowsSubAuthority: string;
    static readonly Anonymous: string;
    static readonly Authentication: string;
    static readonly AuthorizationDecision: string;
    static readonly Country: string;
    static readonly DateOfBirth: string;
    static readonly Dns: string;
    static readonly DenyOnlySid: string;
    static readonly Email: string;
    static readonly Gender: string;
    static readonly GivenName: string;
    static readonly Hash: string;
    static readonly HomePhone: string;
    static readonly Locality: string;
    static readonly MobilePhone: string;
    static readonly Name: string;
    static readonly NameIdentifier: string;
    static readonly OtherPhone: string;
    static readonly PostalCode: string;
    static readonly Rsa: string;
    static readonly Sid: string;
    static readonly Spn: string;
    static readonly StateOrProvince: string;
    static readonly StreetAddress: string;
    static readonly Surname: string;
    static readonly System: string;
    static readonly Thumbprint: string;
    static readonly Upn: string;
    static readonly Uri: string;
    static readonly Webpage: string;
    static readonly X500DistinguishedName: string;
    static readonly Actor: string;
}


export type ClaimTypes = ClaimTypes$instance;

export abstract class ClaimValueTypes$instance {
    static readonly Base64Binary: string;
    static readonly Base64Octet: string;
    static readonly Boolean: string;
    static readonly Date: string;
    static readonly DateTime: string;
    static readonly Double: string;
    static readonly Fqbn: string;
    static readonly HexBinary: string;
    static readonly Integer: string;
    static readonly Integer32: string;
    static readonly Integer64: string;
    static readonly Sid: string;
    static readonly String: string;
    static readonly Time: string;
    static readonly UInteger32: string;
    static readonly UInteger64: string;
    static readonly DnsName: string;
    static readonly Email: string;
    static readonly Rsa: string;
    static readonly UpnName: string;
    static readonly DsaKeyValue: string;
    static readonly KeyInfo: string;
    static readonly RsaKeyValue: string;
    static readonly DaytimeDuration: string;
    static readonly YearMonthDuration: string;
    static readonly Rfc822Name: string;
    static readonly X500Name: string;
}


export type ClaimValueTypes = ClaimValueTypes$instance;

