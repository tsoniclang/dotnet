// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.Serialization
// Assembly: System.Private.CoreLib, System.Private.DataContractSerialization, System.Runtime.Serialization.Formatters, System.Runtime.Serialization.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { ICollection_1, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1, ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerator } from "../../System.Collections/internal/index.js";
import type { DateTimeStyles } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { Assembly, ConstructorInfo, MemberInfo, MethodBase, MethodInfo, PropertyInfo } from "../../System.Reflection/internal/index.js";
import type { TypeFilterLevel } from "../../System.Runtime.Serialization.Formatters/internal/index.js";
import type { StringBuilder } from "../../System.Text/internal/index.js";
import type { XmlSchemaSet, XmlSchemaType } from "../../System.Xml.Schema/internal/index.js";
import type { XmlDictionaryReader, XmlDictionaryString, XmlDictionaryWriter, XmlNamespaceManager, XmlNode, XmlQualifiedName, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, SByte, Single, String as ClrString, SystemException, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum EmitTypeInformation {
    asNeeded = 0,
    always = 1,
    never_ = 2
}


export enum StreamingContextStates {
    crossProcess = 1,
    crossMachine = 2,
    file = 4,
    persistence = 8,
    remoting = 16,
    other = 32,
    clone = 64,
    crossAppDomain = 128,
    all = 255
}


export interface IDeserializationCallback$instance {
    onDeserialization(sender: unknown): void;
}


export type IDeserializationCallback = IDeserializationCallback$instance;

export interface IExtensibleDataObject$instance {
    extensionData: ExtensionDataObject;
}


export type IExtensibleDataObject = IExtensibleDataObject$instance;

export interface IFormatter$instance {
    surrogateSelector: ISurrogateSelector;
    binder: SerializationBinder;
    context: StreamingContext;
    deserialize(serializationStream: Stream): unknown;
    serialize(serializationStream: Stream, graph: unknown): void;
}


export type IFormatter = IFormatter$instance;

export interface IFormatterConverter$instance {
    convert(value: unknown, type_: Type): unknown;
    convert(value: unknown, typeCode: TypeCode): unknown;
    toBoolean(value: unknown): boolean;
    toByte(value: unknown): byte;
    toChar(value: unknown): char;
    toDateTime(value: unknown): DateTime;
    toDecimal(value: unknown): decimal;
    toDouble(value: unknown): double;
    toInt16(value: unknown): short;
    toInt32(value: unknown): int;
    toInt64(value: unknown): long;
    toSByte(value: unknown): sbyte;
    toSingle(value: unknown): float;
    toString(value: unknown): string;
    toUInt16(value: unknown): ushort;
    toUInt32(value: unknown): uint;
    toUInt64(value: unknown): ulong;
}


export type IFormatterConverter = IFormatterConverter$instance;

export interface IObjectReference$instance {
    getRealObject(context: StreamingContext): unknown;
}


export type IObjectReference = IObjectReference$instance;

export interface ISafeSerializationData$instance {
    completeDeserialization(deserialized: unknown): void;
}


export type ISafeSerializationData = ISafeSerializationData$instance;

export interface ISerializable$instance {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export type ISerializable = ISerializable$instance;

export interface ISerializationSurrogate$instance {
    getObjectData(obj: unknown, info: SerializationInfo, context: StreamingContext): void;
    setObjectData(obj: unknown, info: SerializationInfo, context: StreamingContext, selector: ISurrogateSelector): unknown;
}


export type ISerializationSurrogate = ISerializationSurrogate$instance;

export interface ISerializationSurrogateProvider$instance {
    getObjectToSerialize(obj: unknown, targetType: Type): unknown;
    getSurrogateType(type_: Type): Type;
}


export type ISerializationSurrogateProvider = ISerializationSurrogateProvider$instance;

export interface ISerializationSurrogateProvider2$instance extends ISerializationSurrogateProvider {
    getCustomDataToExport(memberInfo: MemberInfo, dataContractType: Type): unknown;
    getCustomDataToExport(runtimeType: Type, dataContractType: Type): unknown;
    getKnownCustomDataTypes(customDataTypes: Collection_1<Type>): void;
    getObjectToSerialize(obj: unknown, targetType: Type): unknown;
    getReferencedTypeOnImport(typeName: string, typeNamespace: string, customData: unknown): Type;
    getSurrogateType(type_: Type): Type;
}


export interface ISerializationSurrogateProvider2$instance extends ISerializationSurrogateProvider$instance {}

export type ISerializationSurrogateProvider2 = ISerializationSurrogateProvider2$instance;

export interface ISurrogateSelector$instance {
    chainSelector(selector: ISurrogateSelector): void;
    getNextSelector(): ISurrogateSelector;
    getSurrogate(type_: Type, context: StreamingContext, selector: { value: ref<ISurrogateSelector> }): ISerializationSurrogate;
}


export type ISurrogateSelector = ISurrogateSelector$instance;

export class DeserializationToken$instance {
    dispose(): void;
}


export interface __DeserializationToken$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DeserializationToken$instance extends System_Internal.IDisposable$instance {}

export type DeserializationToken = DeserializationToken$instance & __DeserializationToken$views;


export class SerializationEntry$instance {
    readonly name: string;
    readonly objectType: Type;
    readonly value: unknown;
}


export type SerializationEntry = SerializationEntry$instance;

export class StreamingContext$instance {
    constructor(state: StreamingContextStates);
    constructor(state: StreamingContextStates, additional: unknown);
    readonly context: unknown;
    readonly state: StreamingContextStates;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export type StreamingContext = StreamingContext$instance;

export class CollectionDataContractAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    readonly isItemNameSetExplicitly: boolean;
    readonly isKeyNameSetExplicitly: boolean;
    readonly isNameSetExplicitly: boolean;
    readonly isNamespaceSetExplicitly: boolean;
    isReference: boolean;
    readonly isReferenceSetExplicitly: boolean;
    readonly isValueNameSetExplicitly: boolean;
    itemName: string;
    keyName: string;
    name: string;
    namespace_: string;
    valueName: string;
}


export type CollectionDataContractAttribute = CollectionDataContractAttribute$instance;

export class ContractNamespaceAttribute$instance extends System_Internal.Attribute$instance {
    constructor(contractNamespace: string);
    clrNamespace: string;
    readonly contractNamespace: string;
}


export type ContractNamespaceAttribute = ContractNamespaceAttribute$instance;

export class DataContractAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    readonly isNameSetExplicitly: boolean;
    readonly isNamespaceSetExplicitly: boolean;
    isReference: boolean;
    readonly isReferenceSetExplicitly: boolean;
    name: string;
    namespace_: string;
}


export type DataContractAttribute = DataContractAttribute$instance;

export abstract class DataContractResolver$instance {
    abstract resolveName(typeName: string, typeNamespace: string, declaredType: Type, knownTypeResolver: DataContractResolver): Type;
    abstract tryResolveType(type_: Type, declaredType: Type, knownTypeResolver: DataContractResolver, typeName: { value: ref<XmlDictionaryString> }, typeNamespace: { value: ref<XmlDictionaryString> }): boolean;
}


export type DataContractResolver = DataContractResolver$instance;

export class DataContractSerializer$instance extends XmlObjectSerializer$instance {
    constructor(type_: Type);
    constructor(type_: Type, knownTypes: IEnumerable_1<Type>);
    constructor(type_: Type, rootName: string, rootNamespace: string);
    constructor(type_: Type, rootName: string, rootNamespace: string, knownTypes: IEnumerable_1<Type>);
    constructor(type_: Type, rootName: XmlDictionaryString, rootNamespace: XmlDictionaryString);
    constructor(type_: Type, rootName: XmlDictionaryString, rootNamespace: XmlDictionaryString, knownTypes: IEnumerable_1<Type>);
    constructor(type_: Type, settings: DataContractSerializerSettings);
    readonly dataContractResolver: DataContractResolver;
    readonly ignoreExtensionDataObject: boolean;
    readonly knownTypes: ReadOnlyCollection_1<Type>;
    readonly maxItemsInObjectGraph: int;
    readonly preserveObjectReferences: boolean;
    readonly serializeReadOnlyTypes: boolean;
    isStartObject(reader: XmlReader): boolean;
    isStartObject(reader: XmlDictionaryReader): boolean;
    readObject(reader: XmlReader): unknown;
    readObject(reader: XmlReader, verifyObjectName: boolean): unknown;
    readObject(reader: XmlDictionaryReader, verifyObjectName: boolean): unknown;
    readObject(reader: XmlDictionaryReader, verifyObjectName: boolean, dataContractResolver: DataContractResolver): unknown;
    readObject(stream: Stream): unknown;
    readObject(reader: XmlDictionaryReader): unknown;
    writeEndObject(writer: XmlWriter): void;
    writeEndObject(writer: XmlDictionaryWriter): void;
    writeObject(writer: XmlWriter, graph: unknown): void;
    writeObject(writer: XmlDictionaryWriter, graph: unknown, dataContractResolver: DataContractResolver): void;
    writeObject(stream: Stream, graph: unknown): void;
    writeObject(writer: XmlDictionaryWriter, graph: unknown): void;
    writeObjectContent(writer: XmlWriter, graph: unknown): void;
    writeObjectContent(writer: XmlDictionaryWriter, graph: unknown): void;
    writeStartObject(writer: XmlWriter, graph: unknown): void;
    writeStartObject(writer: XmlDictionaryWriter, graph: unknown): void;
}


export type DataContractSerializer = DataContractSerializer$instance;

export class DataContractSerializerSettings$instance {
    constructor();
    dataContractResolver: DataContractResolver;
    ignoreExtensionDataObject: boolean;
    knownTypes: IEnumerable_1<Type>;
    maxItemsInObjectGraph: int;
    preserveObjectReferences: boolean;
    rootName: XmlDictionaryString;
    rootNamespace: XmlDictionaryString;
    serializeReadOnlyTypes: boolean;
}


export type DataContractSerializerSettings = DataContractSerializerSettings$instance;

export class DataMemberAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    emitDefaultValue: boolean;
    readonly isNameSetExplicitly: boolean;
    isRequired: boolean;
    name: string;
    order: int;
}


export type DataMemberAttribute = DataMemberAttribute$instance;

export class DateTimeFormat$instance {
    constructor(formatString: string);
    constructor(formatString: string, formatProvider: IFormatProvider);
    dateTimeStyles: DateTimeStyles;
    readonly formatProvider: IFormatProvider;
    readonly formatString: string;
}


export type DateTimeFormat = DateTimeFormat$instance;

export class EnumMemberAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    readonly isValueSetExplicitly: boolean;
    value: string;
}


export type EnumMemberAttribute = EnumMemberAttribute$instance;

export class ExportOptions$instance {
    constructor();
    dataContractSurrogate: ISerializationSurrogateProvider;
    readonly knownTypes: Collection_1<Type>;
}


export type ExportOptions = ExportOptions$instance;

export class ExtensionDataObject$instance {
}


export type ExtensionDataObject = ExtensionDataObject$instance;

export abstract class Formatter$instance {
    binder: SerializationBinder;
    context: StreamingContext;
    surrogateSelector: ISurrogateSelector;
    abstract deserialize(serializationStream: Stream): unknown;
    abstract serialize(serializationStream: Stream, graph: unknown): void;
}


export interface __Formatter$views {
    As_IFormatter(): IFormatter$instance;
}

export interface Formatter$instance extends IFormatter$instance {}

export type Formatter = Formatter$instance & __Formatter$views;


export class FormatterConverter$instance {
    constructor();
    convert(value: unknown, type_: Type): unknown;
    convert(value: unknown, typeCode: TypeCode): unknown;
    toBoolean(value: unknown): boolean;
    toByte(value: unknown): byte;
    toChar(value: unknown): char;
    toDateTime(value: unknown): DateTime;
    toDecimal(value: unknown): decimal;
    toDouble(value: unknown): double;
    toInt16(value: unknown): short;
    toInt32(value: unknown): int;
    toInt64(value: unknown): long;
    toSByte(value: unknown): sbyte;
    toSingle(value: unknown): float;
    toString(value: unknown): string;
    toUInt16(value: unknown): ushort;
    toUInt32(value: unknown): uint;
    toUInt64(value: unknown): ulong;
}


export interface __FormatterConverter$views {
    As_IFormatterConverter(): IFormatterConverter$instance;
}

export type FormatterConverter = FormatterConverter$instance & __FormatterConverter$views;


export class IgnoreDataMemberAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type IgnoreDataMemberAttribute = IgnoreDataMemberAttribute$instance;

export class InvalidDataContractException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __InvalidDataContractException$views {
    As_ISerializable(): ISerializable$instance;
}

export type InvalidDataContractException = InvalidDataContractException$instance & __InvalidDataContractException$views;


export class KnownTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type);
    constructor(methodName: string);
    readonly methodName: string;
    readonly type_: Type;
}


export type KnownTypeAttribute = KnownTypeAttribute$instance;

export class ObjectIDGenerator$instance {
    constructor();
    getId(obj: unknown, firstTime: { value: ref<boolean> }): long;
    hasId(obj: unknown, firstTime: { value: ref<boolean> }): long;
}


export type ObjectIDGenerator = ObjectIDGenerator$instance;

export class ObjectManager$instance {
    constructor(selector: ISurrogateSelector, context: StreamingContext);
    doFixups(): void;
    getObject(objectID: long): unknown;
    raiseDeserializationEvent(): void;
    raiseOnDeserializingEvent(obj: unknown): void;
    recordArrayElementFixup(arrayToBeFixed: long, index: int, objectRequired: long): void;
    recordArrayElementFixup(arrayToBeFixed: long, indices: int[], objectRequired: long): void;
    recordDelayedFixup(objectToBeFixed: long, memberName: string, objectRequired: long): void;
    recordFixup(objectToBeFixed: long, member: MemberInfo, objectRequired: long): void;
    registerObject(obj: unknown, objectID: long): void;
    registerObject(obj: unknown, objectID: long, info: SerializationInfo): void;
    registerObject(obj: unknown, objectID: long, info: SerializationInfo, idOfContainingObj: long, member: MemberInfo): void;
    registerObject(obj: unknown, objectID: long, info: SerializationInfo, idOfContainingObj: long, member: MemberInfo, arrayIndex: int[]): void;
}


export type ObjectManager = ObjectManager$instance;

export class OnDeserializedAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OnDeserializedAttribute = OnDeserializedAttribute$instance;

export class OnDeserializingAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OnDeserializingAttribute = OnDeserializingAttribute$instance;

export class OnSerializedAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OnSerializedAttribute = OnSerializedAttribute$instance;

export class OnSerializingAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type OnSerializingAttribute = OnSerializingAttribute$instance;

export class OptionalFieldAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    versionAdded: int;
}


export type OptionalFieldAttribute = OptionalFieldAttribute$instance;

export class SafeSerializationEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly streamingContext: StreamingContext;
    addSerializedState(serializedState: ISafeSerializationData): void;
}


export type SafeSerializationEventArgs = SafeSerializationEventArgs$instance;

export abstract class SerializationBinder$instance {
    bindToName(serializedType: Type, assemblyName: { value: ref<string> }, typeName: { value: ref<string> }): void;
    abstract bindToType(assemblyName: string, typeName: string): Type;
}


export type SerializationBinder = SerializationBinder$instance;

export class SerializationEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    beginInvoke(context: StreamingContext, callback: AsyncCallback, object_: unknown): IAsyncResult;
    clone(): unknown;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(context: StreamingContext): void;
}


export interface __SerializationEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): ISerializable$instance;
}

export type SerializationEventHandler = SerializationEventHandler$instance & __SerializationEventHandler$views;


export class SerializationException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __SerializationException$views {
    As_ISerializable(): ISerializable$instance;
}

export type SerializationException = SerializationException$instance & __SerializationException$views;


export class SerializationInfo$instance {
    constructor(type_: Type, converter: IFormatterConverter);
    constructor(type_: Type, converter: IFormatterConverter, requireSameTokenInPartialTrust: boolean);
    assemblyName: string;
    fullTypeName: string;
    readonly isAssemblyNameSetExplicit: boolean;
    readonly isFullTypeNameSetExplicit: boolean;
    readonly memberCount: int;
    readonly objectType: Type;
    addValue(name: string, value: unknown, type_: Type): void;
    addValue(name: string, value: unknown): void;
    addValue(name: string, value: boolean): void;
    addValue(name: string, value: char): void;
    addValue(name: string, value: sbyte): void;
    addValue(name: string, value: byte): void;
    addValue(name: string, value: short): void;
    addValue(name: string, value: ushort): void;
    addValue(name: string, value: int): void;
    addValue(name: string, value: uint): void;
    addValue(name: string, value: long): void;
    addValue(name: string, value: ulong): void;
    addValue(name: string, value: float): void;
    addValue(name: string, value: double): void;
    addValue(name: string, value: decimal): void;
    addValue(name: string, value: DateTime): void;
    getBoolean(name: string): boolean;
    getByte(name: string): byte;
    getChar(name: string): char;
    getDateTime(name: string): DateTime;
    getDecimal(name: string): decimal;
    getDouble(name: string): double;
    getEnumerator(): SerializationInfoEnumerator;
    getInt16(name: string): short;
    getInt32(name: string): int;
    getInt64(name: string): long;
    getSByte(name: string): sbyte;
    getSingle(name: string): float;
    getString(name: string): string;
    getUInt16(name: string): ushort;
    getUInt32(name: string): uint;
    getUInt64(name: string): ulong;
    getValue(name: string, type_: Type): unknown;
    setType(type_: Type): void;
    static startDeserialization(): DeserializationToken;
}


export type SerializationInfo = SerializationInfo$instance;

export class SerializationInfoEnumerator$instance {
    readonly current: SerializationEntry | unknown;
    readonly name: string;
    readonly objectType: Type;
    readonly value: unknown;
    moveNext(): boolean;
    reset(): void;
}


export interface __SerializationInfoEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SerializationInfoEnumerator = SerializationInfoEnumerator$instance & __SerializationInfoEnumerator$views;


export class SerializationObjectManager$instance {
    constructor(context: StreamingContext);
    raiseOnSerializedEvent(): void;
    registerObject(obj: unknown): void;
}


export type SerializationObjectManager = SerializationObjectManager$instance;

export class SurrogateSelector$instance {
    constructor();
    addSurrogate(type_: Type, context: StreamingContext, surrogate: ISerializationSurrogate): void;
    chainSelector(selector: ISurrogateSelector): void;
    getNextSelector(): ISurrogateSelector;
    getSurrogate(type_: Type, context: StreamingContext, selector: { value: ref<ISurrogateSelector> }): ISerializationSurrogate;
    removeSurrogate(type_: Type, context: StreamingContext): void;
}


export interface __SurrogateSelector$views {
    As_ISurrogateSelector(): ISurrogateSelector$instance;
}

export interface SurrogateSelector$instance extends ISurrogateSelector$instance {}

export type SurrogateSelector = SurrogateSelector$instance & __SurrogateSelector$views;


export class TypeLoadExceptionHolder$instance {
}


export type TypeLoadExceptionHolder = TypeLoadExceptionHolder$instance;

export abstract class XmlObjectSerializer$instance {
    isStartObject(reader: XmlReader): boolean;
    isStartObject(reader: XmlDictionaryReader): boolean;
    readObject(stream: Stream): unknown;
    readObject(reader: XmlReader): unknown;
    readObject(reader: XmlDictionaryReader): unknown;
    readObject(reader: XmlReader, verifyObjectName: boolean): unknown;
    readObject(reader: XmlDictionaryReader, verifyObjectName: boolean): unknown;
    writeEndObject(writer: XmlDictionaryWriter): void;
    writeEndObject(writer: XmlWriter): void;
    writeObject(stream: Stream, graph: unknown): void;
    writeObject(writer: XmlWriter, graph: unknown): void;
    writeObject(writer: XmlDictionaryWriter, graph: unknown): void;
    writeObjectContent(writer: XmlDictionaryWriter, graph: unknown): void;
    writeObjectContent(writer: XmlWriter, graph: unknown): void;
    writeStartObject(writer: XmlDictionaryWriter, graph: unknown): void;
    writeStartObject(writer: XmlWriter, graph: unknown): void;
}


export type XmlObjectSerializer = XmlObjectSerializer$instance;

export class XsdDataContractExporter$instance {
    constructor();
    constructor(schemas: XmlSchemaSet);
    options: ExportOptions;
    readonly schemas: XmlSchemaSet;
    canExport(assemblies: ICollection_1<Assembly>): boolean;
    canExport(types: ICollection_1<Type>): boolean;
    canExport(type_: Type): boolean;
    export_(assemblies: ICollection_1<Assembly>): void;
    export_(types: ICollection_1<Type>): void;
    export_(type_: Type): void;
    getRootElementName(type_: Type): XmlQualifiedName;
    getSchemaType(type_: Type): XmlSchemaType;
    getSchemaTypeName(type_: Type): XmlQualifiedName;
}


export type XsdDataContractExporter = XsdDataContractExporter$instance;

export abstract class DataContractSerializerExtensions$instance {
    static getSerializationSurrogateProvider(serializer: DataContractSerializer): ISerializationSurrogateProvider;
    static setSerializationSurrogateProvider(serializer: DataContractSerializer, provider: ISerializationSurrogateProvider): void;
}


export type DataContractSerializerExtensions = DataContractSerializerExtensions$instance;

export abstract class FormatterServices$instance {
    static checkTypeSecurity(t: Type, securityLevel: TypeFilterLevel): void;
    static getObjectData(obj: unknown, members: MemberInfo[]): unknown[];
    static getSafeUninitializedObject(type_: Type): unknown;
    static getSerializableMembers(type_: Type, context: StreamingContext): MemberInfo[];
    static getSerializableMembers(type_: Type): MemberInfo[];
    static getSurrogateForCyclicalReference(innerSurrogate: ISerializationSurrogate): ISerializationSurrogate;
    static getTypeFromAssembly(assem: Assembly, name: string): Type;
    static getUninitializedObject(type_: Type): unknown;
    static populateObjectMembers(obj: unknown, members: MemberInfo[], data: unknown[]): unknown;
}


export type FormatterServices = FormatterServices$instance;

export abstract class JsonFormatGeneratorStatics$instance {
    static readonly boxPointer: MethodInfo;
    static readonly collectionItemNameProperty: PropertyInfo;
    static readonly extensionDataObjectCtor: ConstructorInfo;
    static readonly extensionDataProperty: PropertyInfo;
    static readonly getCurrentMethod: MethodInfo;
    static readonly getItemContractMethod: MethodInfo;
    static readonly getJsonDataContractMethod: MethodInfo;
    static readonly getJsonMemberIndexMethod: MethodInfo;
    static readonly getRevisedItemContractMethod: MethodInfo;
    static readonly getUninitializedObjectMethod: MethodInfo;
    static readonly isStartElementMethod0: MethodInfo;
    static readonly isStartElementMethod2: MethodInfo;
    static readonly localNameProperty: PropertyInfo;
    static readonly namespaceProperty: PropertyInfo;
    static readonly moveNextMethod: MethodInfo;
    static readonly moveToContentMethod: MethodInfo;
    static readonly nodeTypeProperty: PropertyInfo;
    static readonly onDeserializationMethod: MethodInfo;
    static readonly readJsonValueMethod: MethodInfo;
    static readonly serializationExceptionCtor: ConstructorInfo;
    static readonly serInfoCtorArgs: Type[];
    static readonly throwDuplicateMemberExceptionMethod: MethodInfo;
    static readonly throwMissingRequiredMembersMethod: MethodInfo;
    static readonly typeHandleProperty: PropertyInfo;
    static readonly unboxPointer: MethodInfo;
    static readonly useSimpleDictionaryFormatReadProperty: PropertyInfo;
    static readonly useSimpleDictionaryFormatWriteProperty: PropertyInfo;
    static readonly writeAttributeStringMethod: MethodInfo;
    static readonly writeEndElementMethod: MethodInfo;
    static readonly writeJsonISerializableMethod: MethodInfo;
    static readonly writeJsonNameWithMappingMethod: MethodInfo;
    static readonly writeJsonValueMethod: MethodInfo;
    static readonly writeStartElementMethod: MethodInfo;
    static readonly writeStartElementStringMethod: MethodInfo;
    static readonly parseEnumMethod: MethodInfo;
    static readonly getJsonMemberNameMethod: MethodInfo;
}


export type JsonFormatGeneratorStatics = JsonFormatGeneratorStatics$instance;

export abstract class XmlSerializableServices$instance {
    static addDefaultSchema(schemas: XmlSchemaSet, typeQName: XmlQualifiedName): void;
    static readNodes(xmlReader: XmlReader): XmlNode[];
    static writeNodes(xmlWriter: XmlWriter, nodes: XmlNode[]): void;
}


export type XmlSerializableServices = XmlSerializableServices$instance;

export abstract class XPathQueryGenerator$instance {
    static createFromDataContractSerializer(type_: Type, pathToMember: MemberInfo[], rootElementXpath: StringBuilder, namespaces: { value: ref<XmlNamespaceManager> }): string;
    static createFromDataContractSerializer(type_: Type, pathToMember: MemberInfo[], namespaces: { value: ref<XmlNamespaceManager> }): string;
}


export type XPathQueryGenerator = XPathQueryGenerator$instance;

