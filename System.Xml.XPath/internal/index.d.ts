// Generated by tsbindgen - Architecture
// Namespace: System.Xml.XPath
// Assembly: System.Private.Xml, System.Private.Xml.Linq, System.Xml.XPath.XDocument

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary_2, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IComparer, IDictionary, IEnumerable, IEnumerator, IEqualityComparer } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { XElement, XNode } from "../../System.Xml.Linq/internal/index.js";
import type { IXmlSchemaInfo, ValidationEventHandler, XmlSchemaSet, XmlSchemaType } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { IXmlNamespaceResolver, XmlNamespaceManager, XmlNamespaceScope, XmlNameTable, XmlNodeOrder, XmlReader, XmlSpace, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, DateTime, Double, Enum, Exception, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum XmlCaseOrder {
    none = 0,
    upperFirst = 1,
    lowerFirst = 2
}


export enum XmlDataType {
    text = 1,
    number_ = 2
}


export enum XmlSortOrder {
    ascending = 1,
    descending = 2
}


export enum XPathNamespaceScope {
    all = 0,
    excludeXml = 1,
    local = 2
}


export enum XPathNodeType {
    root = 0,
    element = 1,
    attribute = 2,
    namespace_ = 3,
    text = 4,
    significantWhitespace = 5,
    whitespace = 6,
    processingInstruction = 7,
    comment = 8,
    all = 9
}


export enum XPathResultType {
    number_ = 0,
    string_ = 1,
    boolean_ = 2,
    nodeSet = 3,
    navigator = 1,
    any_ = 5,
    error = 6
}


export interface IXPathNavigable$instance {
    CreateNavigator(): XPathNavigator;
}


export type IXPathNavigable = IXPathNavigable$instance;

export class XPathDocument$instance {
    constructor(reader: XmlReader);
    constructor(reader: XmlReader, space: XmlSpace);
    constructor(textReader: TextReader);
    constructor(stream: Stream);
    constructor(uri: string);
    constructor(uri: string, space: XmlSpace);
    createNavigator(): XPathNavigator;
}


export interface __XPathDocument$views {
    As_IXPathNavigable(): IXPathNavigable$instance;
}

export type XPathDocument = XPathDocument$instance & __XPathDocument$views;


export class XPathException$instance extends System_Internal.SystemException$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __XPathException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XPathException = XPathException$instance & __XPathException$views;


export abstract class XPathExpression$instance {
    readonly expression: string;
    readonly returnType: XPathResultType;
    abstract addSort(expr: unknown, comparer: IComparer): void;
    abstract addSort(expr: unknown, order: XmlSortOrder, caseOrder: XmlCaseOrder, lang: string, dataType: XmlDataType): void;
    abstract clone(): XPathExpression;
    abstract setContext(nsManager: XmlNamespaceManager): void;
    abstract setContext(nsResolver: IXmlNamespaceResolver): void;
    static Compile(xpath: string, nsResolver: IXmlNamespaceResolver): XPathExpression;
    static Compile(xpath: string): XPathExpression;
}


export type XPathExpression = XPathExpression$instance;

export abstract class XPathItem$instance {
    readonly isNode: boolean;
    readonly typedValue: unknown;
    readonly value: string;
    readonly valueAsBoolean: boolean;
    readonly valueAsDateTime: DateTime;
    readonly valueAsDouble: double;
    readonly valueAsInt: int;
    readonly valueAsLong: long;
    readonly valueType: Type;
    readonly xmlType: XmlSchemaType;
    valueAs(returnType: Type): unknown;
    valueAs(returnType: Type, nsResolver: IXmlNamespaceResolver): unknown;
}


export type XPathItem = XPathItem$instance;

export abstract class XPathNavigator$instance extends XPathItem$instance {
    readonly baseURI: string;
    readonly canEdit: boolean;
    readonly hasAttributes: boolean;
    readonly hasChildren: boolean;
    innerXml: string;
    readonly isEmptyElement: boolean;
    readonly isNode: boolean;
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string;
    readonly nameTable: XmlNameTable;
    readonly nodeType: XPathNodeType;
    outerXml: string;
    readonly prefix: string;
    readonly schemaInfo: IXmlSchemaInfo;
    readonly typedValue: unknown;
    readonly underlyingObject: unknown;
    readonly valueAsBoolean: boolean;
    readonly valueAsDateTime: DateTime;
    readonly valueAsDouble: double;
    readonly valueAsInt: int;
    readonly valueAsLong: long;
    readonly valueType: Type;
    readonly xmlLang: string;
    readonly xmlType: XmlSchemaType;
    appendChild(): XmlWriter;
    appendChild(newChild: string): void;
    appendChild(newChild: XmlReader): void;
    appendChild(newChild: XPathNavigator): void;
    appendChildElement(prefix: string, localName: string, namespaceURI: string, value: string): void;
    checkValidity(schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): boolean;
    abstract clone(): XPathNavigator;
    comparePosition(nav: XPathNavigator): XmlNodeOrder;
    compile(xpath: string): XPathExpression;
    createAttribute(prefix: string, localName: string, namespaceURI: string, value: string): void;
    createAttributes(): XmlWriter;
    createNavigator(): XPathNavigator;
    deleteRange(lastSiblingToDelete: XPathNavigator): void;
    deleteSelf(): void;
    evaluate(xpath: string): unknown;
    evaluate(xpath: string, resolver: IXmlNamespaceResolver): unknown;
    evaluate(expr: XPathExpression): unknown;
    evaluate(expr: XPathExpression, context: XPathNodeIterator): unknown;
    getAttribute(localName: string, namespaceURI: string): string;
    getNamespace(name: string): string;
    getNamespacesInScope(scope: XmlNamespaceScope): IDictionary_2<CLROf<string>, CLROf<string>>;
    insertAfter(): XmlWriter;
    insertAfter(newSibling: string): void;
    insertAfter(newSibling: XmlReader): void;
    insertAfter(newSibling: XPathNavigator): void;
    insertBefore(): XmlWriter;
    insertBefore(newSibling: string): void;
    insertBefore(newSibling: XmlReader): void;
    insertBefore(newSibling: XPathNavigator): void;
    insertElementAfter(prefix: string, localName: string, namespaceURI: string, value: string): void;
    insertElementBefore(prefix: string, localName: string, namespaceURI: string, value: string): void;
    isDescendant(nav: XPathNavigator): boolean;
    abstract isSamePosition(other: XPathNavigator): boolean;
    lookupNamespace(prefix: string): string;
    lookupPrefix(namespaceURI: string): string;
    matches(expr: XPathExpression): boolean;
    matches(xpath: string): boolean;
    abstract moveTo(other: XPathNavigator): boolean;
    moveToAttribute(localName: string, namespaceURI: string): boolean;
    moveToChild(localName: string, namespaceURI: string): boolean;
    moveToChild(type_: XPathNodeType): boolean;
    moveToFirst(): boolean;
    abstract moveToFirstAttribute(): boolean;
    abstract moveToFirstChild(): boolean;
    moveToFirstNamespace(namespaceScope: XPathNamespaceScope): boolean;
    moveToFirstNamespace(): boolean;
    moveToFollowing(localName: string, namespaceURI: string): boolean;
    moveToFollowing(localName: string, namespaceURI: string, end: XPathNavigator): boolean;
    moveToFollowing(type_: XPathNodeType): boolean;
    moveToFollowing(type_: XPathNodeType, end: XPathNavigator): boolean;
    abstract moveToId(id: string): boolean;
    moveToNamespace(name: string): boolean;
    moveToNext(): boolean;
    moveToNext(localName: string, namespaceURI: string): boolean;
    moveToNext(type_: XPathNodeType): boolean;
    abstract moveToNextAttribute(): boolean;
    moveToNextNamespace(namespaceScope: XPathNamespaceScope): boolean;
    moveToNextNamespace(): boolean;
    abstract moveToParent(): boolean;
    abstract moveToPrevious(): boolean;
    moveToRoot(): void;
    prependChild(): XmlWriter;
    prependChild(newChild: string): void;
    prependChild(newChild: XmlReader): void;
    prependChild(newChild: XPathNavigator): void;
    prependChildElement(prefix: string, localName: string, namespaceURI: string, value: string): void;
    readSubtree(): XmlReader;
    replaceRange(lastSiblingToReplace: XPathNavigator): XmlWriter;
    replaceSelf(newNode: string): void;
    replaceSelf(newNode: XmlReader): void;
    replaceSelf(newNode: XPathNavigator): void;
    select(xpath: string): XPathNodeIterator;
    select(xpath: string, resolver: IXmlNamespaceResolver): XPathNodeIterator;
    select(expr: XPathExpression): XPathNodeIterator;
    selectAncestors(type_: XPathNodeType, matchSelf: boolean): XPathNodeIterator;
    selectAncestors(name: string, namespaceURI: string, matchSelf: boolean): XPathNodeIterator;
    selectChildren(type_: XPathNodeType): XPathNodeIterator;
    selectChildren(name: string, namespaceURI: string): XPathNodeIterator;
    selectDescendants(type_: XPathNodeType, matchSelf: boolean): XPathNodeIterator;
    selectDescendants(name: string, namespaceURI: string, matchSelf: boolean): XPathNodeIterator;
    selectSingleNode(xpath: string): XPathNavigator;
    selectSingleNode(xpath: string, resolver: IXmlNamespaceResolver): XPathNavigator;
    selectSingleNode(expression: XPathExpression): XPathNavigator;
    setTypedValue(typedValue: unknown): void;
    setValue(value: string): void;
    toString(): string;
    valueAs(returnType: Type, nsResolver: IXmlNamespaceResolver): unknown;
    valueAs(returnType: Type): unknown;
    writeSubtree(writer: XmlWriter): void;
    static readonly NavigatorComparer: IEqualityComparer;
}


export interface __XPathNavigator$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IXmlNamespaceResolver(): System_Xml_Internal.IXmlNamespaceResolver$instance;
    As_IXPathNavigable(): IXPathNavigable$instance;
}

export type XPathNavigator = XPathNavigator$instance & __XPathNavigator$views;


export abstract class XPathNodeIterator$instance {
    readonly count: int;
    readonly current: XPathNavigator;
    readonly currentPosition: int;
    abstract clone(): XPathNodeIterator;
    getEnumerator(): IEnumerator;
    abstract moveNext(): boolean;
}


export interface __XPathNodeIterator$views {
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type XPathNodeIterator = XPathNodeIterator$instance & __XPathNodeIterator$views;


export abstract class Extensions$instance {
    static CreateNavigator(node: XNode, nameTable: XmlNameTable): XPathNavigator;
    static CreateNavigator(node: XNode): XPathNavigator;
    static XPathEvaluate(node: XNode, expression: string, resolver: IXmlNamespaceResolver): unknown;
    static XPathEvaluate(node: XNode, expression: string): unknown;
    static XPathSelectElement(node: XNode, expression: string, resolver: IXmlNamespaceResolver): XElement;
    static XPathSelectElement(node: XNode, expression: string): XElement;
    static XPathSelectElements(node: XNode, expression: string, resolver: IXmlNamespaceResolver): IEnumerable_1<XElement>;
    static XPathSelectElements(node: XNode, expression: string): IEnumerable_1<XElement>;
}


export type Extensions = Extensions$instance;

export abstract class XDocumentExtensions$instance {
    static ToXPathNavigable(node: XNode): IXPathNavigable;
}


export type XDocumentExtensions = XDocumentExtensions$instance;

