// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics
// Assembly: System.Diagnostics.DiagnosticSource, System.Diagnostics.FileVersionInfo, System.Diagnostics.Process, System.Diagnostics.TextWriterTraceListener, System.Diagnostics.TraceSource, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeProcessHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase, Stack } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, DescriptionAttribute, IComponent, IContainer, ISite, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { Stream, StreamReader, StreamWriter, TextWriter } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Delegate, Enum, EventArgs, EventHandler, EventHandler_1, Exception, Func_1, Func_2, Func_4, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, IObservable_1, IObserver_1, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ActivityIdFormat {
    Unknown = 0,
    Hierarchical = 1,
    W3C = 2
}


export enum ActivityKind {
    Internal = 0,
    Server = 1,
    Client = 2,
    Producer = 3,
    Consumer = 4
}


export enum ActivitySamplingResult {
    None = 0,
    PropagationData = 1,
    AllData = 2,
    AllDataAndRecorded = 3
}


export enum ActivityStatusCode {
    Unset = 0,
    Ok = 1,
    Error = 2
}


export enum ActivityTraceFlags {
    None = 0,
    Recorded = 1
}


export enum DebuggableAttribute_DebuggingModes {
    None = 0,
    Default = 1,
    DisableOptimizations = 256,
    IgnoreSymbolStoreSequencePoints = 2,
    EnableEditAndContinue = 4
}


export enum DebuggerBrowsableState {
    Never = 0,
    Collapsed = 2,
    RootHidden = 3
}


export enum ProcessPriorityClass {
    Normal = 32,
    Idle = 64,
    High = 128,
    RealTime = 256,
    BelowNormal = 16384,
    AboveNormal = 32768
}


export enum ProcessWindowStyle {
    Normal = 0,
    Hidden = 1,
    Minimized = 2,
    Maximized = 3
}


export enum SourceLevels {
    Off = 0,
    Critical = 1,
    Error = 3,
    Warning = 7,
    Information = 15,
    Verbose = 31,
    ActivityTracing = 65280,
    All = -1
}


export enum ThreadPriorityLevel {
    Idle = -15,
    Lowest = -2,
    BelowNormal = -1,
    Normal = 0,
    AboveNormal = 1,
    Highest = 2,
    TimeCritical = 15
}


export enum ThreadState {
    Initialized = 0,
    Ready = 1,
    Running = 2,
    Standby = 3,
    Terminated = 4,
    Wait = 5,
    Transition = 6,
    Unknown = 7
}


export enum ThreadWaitReason {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    SystemAllocation = 3,
    ExecutionDelay = 4,
    Suspended = 5,
    UserRequest = 6,
    EventPairHigh = 7,
    EventPairLow = 8,
    LpcReceive = 9,
    LpcReply = 10,
    VirtualMemory = 11,
    PageOut = 12,
    Unknown = 13
}


export enum TraceEventType {
    Critical = 1,
    Error = 2,
    Warning = 4,
    Information = 8,
    Verbose = 16,
    Start = 256,
    Stop = 512,
    Suspend = 1024,
    Resume = 2048,
    Transfer = 4096
}


export enum TraceLevel {
    Off = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
    Verbose = 4
}


export enum TraceOptions {
    None = 0,
    LogicalOperationStack = 1,
    DateTime = 2,
    Timestamp = 4,
    ProcessId = 8,
    ThreadId = 16,
    Callstack = 32
}


export class Activity_Enumerator_1$instance<T> {
    readonly Current: ref<T>;
    GetEnumerator(): Activity_Enumerator_1<T>;
    MoveNext(): boolean;
}


export type Activity_Enumerator_1<T> = Activity_Enumerator_1$instance<T>;

export class ActivityChangedEventArgs$instance {
    Current: Activity;
    Previous: Activity;
}


export type ActivityChangedEventArgs = ActivityChangedEventArgs$instance;

export class ActivityContext$instance {
    constructor(traceId: ActivityTraceId, spanId: ActivitySpanId, traceFlags: ActivityTraceFlags, traceState: string, isRemote: boolean);
    readonly IsRemote: boolean;
    readonly SpanId: ActivitySpanId;
    readonly TraceFlags: ActivityTraceFlags;
    readonly TraceId: ActivityTraceId;
    readonly TraceState: string;
    Equals(value: ActivityContext): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    static Parse(traceParent: string, traceState: string): ActivityContext;
    static TryParse(traceParent: string, traceState: string, isRemote: boolean, context: { value: ref<ActivityContext> }): boolean;
    static TryParse(traceParent: string, traceState: string, context: { value: ref<ActivityContext> }): boolean;
}


export interface __ActivityContext$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivityContext>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityContext): boolean;
}

export type ActivityContext = ActivityContext$instance & __ActivityContext$views;


export class ActivityCreationOptions_1$instance<T> {
    readonly Kind: ActivityKind;
    readonly Links: IEnumerable_1<ActivityLink>;
    readonly Name: string;
    readonly Parent: T;
    readonly SamplingTags: ActivityTagsCollection;
    readonly Source: ActivitySource;
    readonly Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly TraceId: ActivityTraceId;
    TraceState: string;
}


export type ActivityCreationOptions_1<T> = ActivityCreationOptions_1$instance<T>;

export class ActivityEvent$instance {
    constructor(name: string);
    constructor(name: string, timestamp: DateTimeOffset, tags: ActivityTagsCollection);
    readonly Name: string;
    readonly Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly Timestamp: DateTimeOffset;
    EnumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, any>>;
}


export type ActivityEvent = ActivityEvent$instance;

export class ActivityLink$instance {
    constructor(context: ActivityContext, tags: ActivityTagsCollection);
    readonly Context: ActivityContext;
    readonly Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    EnumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, any>>;
    Equals(obj: any): boolean;
    Equals(value: ActivityLink): boolean;
    GetHashCode(): int;
}


export interface __ActivityLink$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivityLink>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityLink): boolean;
}

export type ActivityLink = ActivityLink$instance & __ActivityLink$views;


export class ActivitySpanId$instance {
    CopyTo(destination: Span_1<CLROf<byte>>): void;
    Equals(spanId: ActivitySpanId): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToHexString(): string;
    ToString(): string;
    static CreateFromBytes(idData: ReadOnlySpan_1<CLROf<byte>>): ActivitySpanId;
    static CreateFromString(idData: ReadOnlySpan_1<CLROf<string>>): ActivitySpanId;
    static CreateFromUtf8String(idData: ReadOnlySpan_1<CLROf<byte>>): ActivitySpanId;
    static CreateRandom(): ActivitySpanId;
}


export interface __ActivitySpanId$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivitySpanId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivitySpanId): boolean;
}

export type ActivitySpanId = ActivitySpanId$instance & __ActivitySpanId$views;


export class ActivityTagsCollection_Enumerator$instance {
    readonly Current: KeyValuePair_2<CLROf<string>, any>;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __ActivityTagsCollection_Enumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type ActivityTagsCollection_Enumerator = ActivityTagsCollection_Enumerator$instance & __ActivityTagsCollection_Enumerator$views;


export class ActivityTraceId$instance {
    CopyTo(destination: Span_1<CLROf<byte>>): void;
    Equals(traceId: ActivityTraceId): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    ToHexString(): string;
    ToString(): string;
    static CreateFromBytes(idData: ReadOnlySpan_1<CLROf<byte>>): ActivityTraceId;
    static CreateFromString(idData: ReadOnlySpan_1<CLROf<string>>): ActivityTraceId;
    static CreateFromUtf8String(idData: ReadOnlySpan_1<CLROf<byte>>): ActivityTraceId;
    static CreateRandom(): ActivityTraceId;
}


export interface __ActivityTraceId$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivityTraceId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityTraceId): boolean;
}

export type ActivityTraceId = ActivityTraceId$instance & __ActivityTraceId$views;


export class Debug_AssertInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: ref<boolean>);
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<string>>): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<string>>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: any, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
}


export type Debug_AssertInterpolatedStringHandler = Debug_AssertInterpolatedStringHandler$instance;

export class Debug_WriteIfInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: ref<boolean>);
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<string>>): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<string>>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: any, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
}


export type Debug_WriteIfInterpolatedStringHandler = Debug_WriteIfInterpolatedStringHandler$instance;

export class TagList$instance {
    constructor(tagList: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>);
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: KeyValuePair_2<CLROf<string>, any>;
    Add(key: string, value: any): void;
    Add(tag: KeyValuePair_2<CLROf<string>, any>): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    CopyTo(tags: Span_1<KeyValuePair_2<CLROf<string>, any>>): void;
    CopyTo(array: KeyValuePair_2<CLROf<string>, any>[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, any>>;
    IndexOf(item: KeyValuePair_2<CLROf<string>, any>): int;
    Insert(index: int, item: KeyValuePair_2<CLROf<string>, any>): void;
    Remove(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    RemoveAt(index: int): void;
}


export interface __TagList$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type TagList = TagList$instance & __TagList$views;


export class TagList_Enumerator$instance {
    readonly Current: KeyValuePair_2<CLROf<string>, any>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __TagList_Enumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type TagList_Enumerator = TagList_Enumerator$instance & __TagList_Enumerator$views;


export class Activity$instance {
    constructor(operationName: string);
    ActivityTraceFlags: ActivityTraceFlags;
    readonly Baggage: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    readonly Context: ActivityContext;
    DisplayName: string;
    readonly Duration: TimeSpan;
    readonly Events: IEnumerable_1<ActivityEvent>;
    readonly HasRemoteParent: boolean;
    readonly Id: string;
    readonly IdFormat: ActivityIdFormat;
    IsAllDataRequested: boolean;
    readonly IsStopped: boolean;
    readonly Kind: ActivityKind;
    readonly Links: IEnumerable_1<ActivityLink>;
    readonly OperationName: string;
    readonly Parent: Activity;
    readonly ParentId: string;
    readonly ParentSpanId: ActivitySpanId;
    readonly Recorded: boolean;
    readonly RootId: string;
    readonly Source: ActivitySource;
    readonly SpanId: ActivitySpanId;
    readonly StartTimeUtc: DateTime;
    readonly Status: ActivityStatusCode;
    readonly StatusDescription: string;
    readonly TagObjects: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    readonly TraceId: ActivityTraceId;
    TraceStateString: string;
    AddBaggage(key: string, value: string): Activity;
    AddEvent(e: ActivityEvent): Activity;
    AddException(exception: Exception, tags?: { value: ref<TagList> }, timestamp?: DateTimeOffset): Activity;
    AddLink(link: ActivityLink): Activity;
    AddTag(key: string, value: string): Activity;
    AddTag(key: string, value: any): Activity;
    Dispose(): void;
    EnumerateEvents(): Activity_Enumerator_1<ActivityEvent>;
    EnumerateLinks(): Activity_Enumerator_1<ActivityLink>;
    EnumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, any>>;
    GetBaggageItem(key: string): string;
    GetCustomProperty(propertyName: string): any;
    GetTagItem(key: string): any;
    SetBaggage(key: string, value: string): Activity;
    SetCustomProperty(propertyName: string, propertyValue: any): void;
    SetEndTime(endTimeUtc: DateTime): Activity;
    SetIdFormat(format: ActivityIdFormat): Activity;
    SetParentId(parentId: string): Activity;
    SetParentId(traceId: ActivityTraceId, spanId: ActivitySpanId, activityTraceFlags?: ActivityTraceFlags): Activity;
    SetStartTime(startTimeUtc: DateTime): Activity;
    SetStatus(code: ActivityStatusCode, description?: string): Activity;
    SetTag(key: string, value: any): Activity;
    Start(): Activity;
    Stop(): void;
    static ForceDefaultIdFormat: boolean;
    static Current: Activity;
    static TraceIdGenerator: Func_1<ActivityTraceId>;
    static DefaultIdFormat: ActivityIdFormat;
}


export interface __Activity$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Activity = Activity$instance & __Activity$views;


export class ActivityListener$instance {
    constructor();
    ActivityStarted: Action_1<Activity>;
    ActivityStopped: Action_1<Activity>;
    ExceptionRecorder: ExceptionRecorder;
    Sample: SampleActivity_1<ActivityContext>;
    SampleUsingParentId: SampleActivity_1<CLROf<string>>;
    ShouldListenTo: Func_2<ActivitySource, CLROf<boolean>>;
    Dispose(): void;
}


export interface __ActivityListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ActivityListener = ActivityListener$instance & __ActivityListener$views;


export class ActivitySource$instance {
    constructor(name: string);
    constructor(name: string, version: string);
    constructor(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>);
    constructor(options: ActivitySourceOptions);
    readonly Name: string;
    readonly Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly TelemetrySchemaUrl: string;
    readonly Version: string;
    CreateActivity(name: string, kind: ActivityKind): Activity;
    CreateActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    CreateActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    Dispose(): void;
    HasListeners(): boolean;
    StartActivity(name?: string, kind?: ActivityKind): Activity;
    StartActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    StartActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    StartActivity(kind: ActivityKind, parentContext?: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset, name?: string): Activity;
    static AddActivityListener(listener: ActivityListener): void;
}


export interface __ActivitySource$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ActivitySource = ActivitySource$instance & __ActivitySource$views;


export class ActivitySourceOptions$instance {
    constructor(name: string);
    Name: string;
    Tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    TelemetrySchemaUrl: string;
    Version: string;
}


export type ActivitySourceOptions = ActivitySourceOptions$instance;

export class ActivityTagsCollection$instance {
    constructor();
    constructor(list: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>);
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: any;
    readonly Keys: ICollection_1<CLROf<string>>;
    readonly Values: ICollection_1<any>;
    Add(key: string, value: any): void;
    Add(item: KeyValuePair_2<CLROf<string>, any>): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    ContainsKey(key: string): boolean;
    CopyTo(array: KeyValuePair_2<CLROf<string>, any>[], arrayIndex: int): void;
    GetEnumerator(): ActivityTagsCollection_Enumerator;
    Remove(key: string): boolean;
    Remove(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    TryGetValue(key: string, value: { value: ref<any> }): boolean;
}


export interface __ActivityTagsCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, any>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ActivityTagsCollection = ActivityTagsCollection$instance & __ActivityTagsCollection$views;


export class BooleanSwitch$instance extends Switch$instance {
    constructor(displayName: string, description: string);
    constructor(displayName: string, description: string, defaultSwitchValue: string);
    Enabled: boolean;
}


export type BooleanSwitch = BooleanSwitch$instance;

export class ConditionalAttribute$instance extends System_Internal.Attribute$instance {
    constructor(conditionString: string);
    readonly ConditionString: string;
}


export type ConditionalAttribute = ConditionalAttribute$instance;

export class ConsoleTraceListener$instance extends TextWriterTraceListener$instance {
    constructor();
    constructor(useErrorStream: boolean);
    Close(): void;
    Dispose(): void;
}


export interface __ConsoleTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ConsoleTraceListener = ConsoleTraceListener$instance & __ConsoleTraceListener$views;


export class CorrelationManager$instance {
    ActivityId: Guid;
    readonly LogicalOperationStack: Stack;
    StartLogicalOperation(): void;
    StartLogicalOperation(operationId: any): void;
    StopLogicalOperation(): void;
}


export type CorrelationManager = CorrelationManager$instance;

export class DataReceivedEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly Data: string;
}


export type DataReceivedEventArgs = DataReceivedEventArgs$instance;

export class DataReceivedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(sender: any, e: DataReceivedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: any, e: DataReceivedEventArgs): void;
}


export interface __DataReceivedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataReceivedEventHandler = DataReceivedEventHandler$instance & __DataReceivedEventHandler$views;


export class DebuggableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isJITTrackingEnabled: boolean, isJITOptimizerDisabled: boolean);
    constructor(modes: DebuggableAttribute_DebuggingModes);
    readonly DebuggingFlags: DebuggableAttribute_DebuggingModes;
    readonly IsJITOptimizerDisabled: boolean;
    readonly IsJITTrackingEnabled: boolean;
}


export type DebuggableAttribute = DebuggableAttribute$instance;

export class DebuggerBrowsableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(state: DebuggerBrowsableState);
    readonly State: DebuggerBrowsableState;
}


export type DebuggerBrowsableAttribute = DebuggerBrowsableAttribute$instance;

export class DebuggerDisableUserUnhandledExceptionsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerDisableUserUnhandledExceptionsAttribute = DebuggerDisableUserUnhandledExceptionsAttribute$instance;

export class DebuggerDisplayAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: string);
    Name: string;
    Target: Type;
    TargetTypeName: string;
    Type: string;
    readonly Value: string;
}


export type DebuggerDisplayAttribute = DebuggerDisplayAttribute$instance;

export class DebuggerHiddenAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerHiddenAttribute = DebuggerHiddenAttribute$instance;

export class DebuggerNonUserCodeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerNonUserCodeAttribute = DebuggerNonUserCodeAttribute$instance;

export class DebuggerStepperBoundaryAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerStepperBoundaryAttribute = DebuggerStepperBoundaryAttribute$instance;

export class DebuggerStepThroughAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerStepThroughAttribute = DebuggerStepThroughAttribute$instance;

export class DebuggerTypeProxyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type);
    constructor(typeName: string);
    readonly ProxyTypeName: string;
    Target: Type;
    TargetTypeName: string;
}


export type DebuggerTypeProxyAttribute = DebuggerTypeProxyAttribute$instance;

export class DebuggerVisualizerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visualizerTypeName: string);
    constructor(visualizerTypeName: string, visualizerObjectSourceTypeName: string);
    constructor(visualizerTypeName: string, visualizerObjectSource: Type);
    constructor(visualizer: Type);
    constructor(visualizer: Type, visualizerObjectSource: Type);
    constructor(visualizer: Type, visualizerObjectSourceTypeName: string);
    Description: string;
    Target: Type;
    TargetTypeName: string;
    readonly VisualizerObjectSourceTypeName: string;
    readonly VisualizerTypeName: string;
}


export type DebuggerVisualizerAttribute = DebuggerVisualizerAttribute$instance;

export class DebugProvider$instance {
    constructor();
    Fail(message: string, detailMessage: string): void;
    OnIndentLevelChanged(indentLevel: int): void;
    OnIndentSizeChanged(indentSize: int): void;
    Write(message: string): void;
    WriteLine(message: string): void;
    static FailCore(stackTrace: string, message: string, detailMessage: string, errorSource: string): void;
    static WriteCore(message: string): void;
}


export type DebugProvider = DebugProvider$instance;

export class DefaultTraceListener$instance extends TraceListener$instance {
    constructor();
    AssertUiEnabled: boolean;
    LogFileName: string;
    Dispose(): void;
    Fail(message: string): void;
    Fail(message: string, detailMessage: string): void;
    Write(message: string): void;
    Write(o: any): void;
    Write(message: string, category: string): void;
    Write(o: any, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: any): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: any, category: string): void;
}


export interface __DefaultTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DefaultTraceListener = DefaultTraceListener$instance & __DefaultTraceListener$views;


export class DelimitedListTraceListener$instance extends TextWriterTraceListener$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, name: string);
    constructor(writer: TextWriter);
    constructor(writer: TextWriter, name: string);
    constructor(fileName: string);
    constructor(fileName: string, name: string);
    Delimiter: string;
    Dispose(): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: any[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
}


export interface __DelimitedListTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DelimitedListTraceListener = DelimitedListTraceListener$instance & __DelimitedListTraceListener$views;


export class DiagnosticListener$instance extends DiagnosticSource$instance {
    constructor(name: string);
    readonly Name: string;
    Dispose(): void;
    IsEnabled(name: string): boolean;
    IsEnabled(name: string, arg1: any, arg2?: any): boolean;
    OnActivityExport(activity: Activity, payload: any): void;
    OnActivityImport(activity: Activity, payload: any): void;
    Subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>, isEnabled: Func_4<CLROf<string>, any, any, CLROf<boolean>>, onActivityImport?: Action_2<Activity, any>, onActivityExport?: Action_2<Activity, any>): IDisposable;
    Subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>, isEnabled: Predicate_1<CLROf<string>>): IDisposable;
    Subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>, isEnabled: Func_4<CLROf<string>, any, any, CLROf<boolean>>): IDisposable;
    Subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>): IDisposable;
    ToString(): string;
    Write(name: string, value: any): void;
    Write<T>(name: string, value: T): void;
    static readonly AllListeners: IObservable_1<DiagnosticListener>;
}


export interface __DiagnosticListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IObservable_1_of_KeyValuePair_2: System_Internal.IObservable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
}

export type DiagnosticListener = DiagnosticListener$instance & __DiagnosticListener$views;


export class DiagnosticMethodInfo$instance {
    readonly DeclaringAssemblyName: string;
    readonly DeclaringTypeName: string;
    readonly Name: string;
    static Create(delegate: Function): DiagnosticMethodInfo;
    static Create(frame: StackFrame): DiagnosticMethodInfo;
}


export type DiagnosticMethodInfo = DiagnosticMethodInfo$instance;

export abstract class DiagnosticSource$instance {
    IsEnabled(name: string): boolean;
    IsEnabled(name: string, arg1: any, arg2?: any): boolean;
    OnActivityExport(activity: Activity, payload: any): void;
    OnActivityImport(activity: Activity, payload: any): void;
    StartActivity(activity: Activity, args: any): Activity;
    StartActivity<T>(activity: Activity, args: T): Activity;
    StopActivity(activity: Activity, args: any): void;
    StopActivity<T>(activity: Activity, args: T): void;
    Write(name: string, value: any): void;
    Write<T>(name: string, value: T): void;
}


export type DiagnosticSource = DiagnosticSource$instance;

export abstract class DistributedContextPropagator$instance {
    readonly Fields: IReadOnlyCollection_1<CLROf<string>>;
    abstract ExtractBaggage(carrier: any, getter: DistributedContextPropagator_PropagatorGetterCallback): IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    abstract ExtractTraceIdAndState(carrier: any, getter: DistributedContextPropagator_PropagatorGetterCallback, traceId: { value: ref<string> }, traceState: { value: ref<string> }): void;
    abstract Inject(activity: Activity, carrier: any, setter: DistributedContextPropagator_PropagatorSetterCallback): void;
    static Current: DistributedContextPropagator;
    static CreateDefaultPropagator(): DistributedContextPropagator;
    static CreateNoOutputPropagator(): DistributedContextPropagator;
    static CreatePassThroughPropagator(): DistributedContextPropagator;
    static CreatePreW3CPropagator(): DistributedContextPropagator;
    static CreateW3CPropagator(): DistributedContextPropagator;
}


export type DistributedContextPropagator = DistributedContextPropagator$instance;

export class DistributedContextPropagator_PropagatorGetterCallback$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(carrier: any, fieldName: string, fieldValue: { value: ref<string> }, fieldValues: { value: ref<IEnumerable_1<CLROf<string>>> }, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(fieldValue: { value: ref<string> }, fieldValues: { value: ref<IEnumerable_1<CLROf<string>>> }, result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(carrier: any, fieldName: string, fieldValue: { value: ref<string> }, fieldValues: { value: ref<IEnumerable_1<CLROf<string>>> }): void;
}


export interface __DistributedContextPropagator_PropagatorGetterCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DistributedContextPropagator_PropagatorGetterCallback = DistributedContextPropagator_PropagatorGetterCallback$instance & __DistributedContextPropagator_PropagatorGetterCallback$views;


export class DistributedContextPropagator_PropagatorSetterCallback$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(carrier: any, fieldName: string, fieldValue: string, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(carrier: any, fieldName: string, fieldValue: string): void;
}


export interface __DistributedContextPropagator_PropagatorSetterCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DistributedContextPropagator_PropagatorSetterCallback = DistributedContextPropagator_PropagatorSetterCallback$instance & __DistributedContextPropagator_PropagatorSetterCallback$views;


export class EventTypeFilter$instance extends TraceFilter$instance {
    constructor(level: SourceLevels);
    EventType: SourceLevels;
    ShouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
}


export type EventTypeFilter = EventTypeFilter$instance;

export class ExceptionRecorder$instance extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(activity: Activity, exception: Exception, tags: { value: ref<TagList> }, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(tags: { value: ref<TagList> }, result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(activity: Activity, exception: Exception, tags: { value: ref<TagList> }): void;
}


export interface __ExceptionRecorder$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExceptionRecorder = ExceptionRecorder$instance & __ExceptionRecorder$views;


export class FileVersionInfo$instance {
    readonly Comments: string;
    readonly CompanyName: string;
    readonly FileBuildPart: int;
    readonly FileDescription: string;
    readonly FileMajorPart: int;
    readonly FileMinorPart: int;
    readonly FileName: string;
    readonly FilePrivatePart: int;
    readonly FileVersion: string;
    readonly InternalName: string;
    readonly IsDebug: boolean;
    readonly IsPatched: boolean;
    readonly IsPreRelease: boolean;
    readonly IsPrivateBuild: boolean;
    readonly IsSpecialBuild: boolean;
    readonly Language: string;
    readonly LegalCopyright: string;
    readonly LegalTrademarks: string;
    readonly OriginalFilename: string;
    readonly PrivateBuild: string;
    readonly ProductBuildPart: int;
    readonly ProductMajorPart: int;
    readonly ProductMinorPart: int;
    readonly ProductName: string;
    readonly ProductPrivatePart: int;
    readonly ProductVersion: string;
    readonly SpecialBuild: string;
    ToString(): string;
    static GetVersionInfo(fileName: string): FileVersionInfo;
}


export type FileVersionInfo = FileVersionInfo$instance;

export class InitializingSwitchEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(switch_: Switch);
    readonly Switch: Switch;
}


export type InitializingSwitchEventArgs = InitializingSwitchEventArgs$instance;

export class InitializingTraceSourceEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(traceSource: TraceSource);
    readonly TraceSource: TraceSource;
    WasInitialized: boolean;
}


export type InitializingTraceSourceEventArgs = InitializingTraceSourceEventArgs$instance;

export class MonitoringDescriptionAttribute$instance extends System_ComponentModel_Internal.DescriptionAttribute$instance {
    constructor(description: string);
    readonly Description: string;
}


export type MonitoringDescriptionAttribute = MonitoringDescriptionAttribute$instance;

export class Process$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    readonly BasePriority: int;
    EnableRaisingEvents: boolean;
    readonly ExitCode: int;
    readonly ExitTime: DateTime;
    readonly Handle: nint;
    readonly HandleCount: int;
    readonly HasExited: boolean;
    readonly Id: int;
    readonly MachineName: string;
    readonly MainModule: ProcessModule;
    readonly MainWindowHandle: nint;
    readonly MainWindowTitle: string;
    MaxWorkingSet: nint;
    MinWorkingSet: nint;
    readonly Modules: ProcessModuleCollection;
    readonly NonpagedSystemMemorySize: int;
    readonly NonpagedSystemMemorySize64: long;
    readonly PagedMemorySize: int;
    readonly PagedMemorySize64: long;
    readonly PagedSystemMemorySize: int;
    readonly PagedSystemMemorySize64: long;
    readonly PeakPagedMemorySize: int;
    readonly PeakPagedMemorySize64: long;
    readonly PeakVirtualMemorySize: int;
    readonly PeakVirtualMemorySize64: long;
    readonly PeakWorkingSet: int;
    readonly PeakWorkingSet64: long;
    PriorityBoostEnabled: boolean;
    PriorityClass: ProcessPriorityClass;
    readonly PrivateMemorySize: int;
    readonly PrivateMemorySize64: long;
    readonly PrivilegedProcessorTime: TimeSpan;
    readonly ProcessName: string;
    ProcessorAffinity: nint;
    readonly Responding: boolean;
    readonly SafeHandle: SafeProcessHandle;
    readonly SessionId: int;
    readonly StandardError: StreamReader;
    readonly StandardInput: StreamWriter;
    readonly StandardOutput: StreamReader;
    StartInfo: ProcessStartInfo;
    readonly StartTime: DateTime;
    SynchronizingObject: ISynchronizeInvoke;
    readonly Threads: ProcessThreadCollection;
    readonly TotalProcessorTime: TimeSpan;
    readonly UserProcessorTime: TimeSpan;
    readonly VirtualMemorySize: int;
    readonly VirtualMemorySize64: long;
    readonly WorkingSet: int;
    readonly WorkingSet64: long;
    BeginErrorReadLine(): void;
    BeginOutputReadLine(): void;
    CancelErrorRead(): void;
    CancelOutputRead(): void;
    Close(): void;
    CloseMainWindow(): boolean;
    Dispose(): void;
    Kill(): void;
    Kill(entireProcessTree: boolean): void;
    Refresh(): void;
    Start(): boolean;
    ToString(): string;
    WaitForExit(): void;
    WaitForExit(milliseconds: int): boolean;
    WaitForExit(timeout: TimeSpan): boolean;
    WaitForExitAsync(cancellationToken?: CancellationToken): Task;
    WaitForInputIdle(): boolean;
    WaitForInputIdle(milliseconds: int): boolean;
    WaitForInputIdle(timeout: TimeSpan): boolean;
    static EnterDebugMode(): void;
    static GetCurrentProcess(): Process;
    static GetProcessById(processId: int, machineName: string): Process;
    static GetProcessById(processId: int): Process;
    static GetProcesses(): Process[];
    static GetProcesses(machineName: string): Process[];
    static GetProcessesByName(processName: string, machineName: string): Process[];
    static GetProcessesByName(processName: string): Process[];
    static LeaveDebugMode(): void;
    static Start(startInfo: ProcessStartInfo): Process;
    static Start(fileName: string, arguments: IEnumerable_1<CLROf<string>>): Process;
    static Start(fileName: string, userName: string, password: SecureString, domain: string): Process;
    static Start(fileName: string, arguments: string, userName: string, password: SecureString, domain: string): Process;
    static Start(fileName: string, arguments: string): Process;
    static Start(fileName: string): Process;
}


export interface __Process$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Process = Process$instance & __Process$views;


export class ProcessModule$instance extends System_ComponentModel_Internal.Component$instance {
    readonly BaseAddress: nint;
    readonly EntryPointAddress: nint;
    readonly FileName: string;
    readonly FileVersionInfo: FileVersionInfo;
    readonly ModuleMemorySize: int;
    readonly ModuleName: string;
    Dispose(): void;
    ToString(): string;
}


export interface __ProcessModule$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ProcessModule = ProcessModule$instance & __ProcessModule$views;


export class ProcessModuleCollection$instance extends System_Collections_Internal.ReadOnlyCollectionBase$instance {
    constructor(processModules: ProcessModule[]);
    readonly Item: ProcessModule;
    Contains(module_: ProcessModule): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(module_: ProcessModule): int;
}


export interface __ProcessModuleCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ProcessModuleCollection = ProcessModuleCollection$instance & __ProcessModuleCollection$views;


export class ProcessStartInfo$instance {
    constructor();
    constructor(fileName: string);
    constructor(fileName: string, arguments: string);
    constructor(fileName: string, arguments: IEnumerable_1<CLROf<string>>);
    readonly ArgumentList: Collection_1<CLROf<string>>;
    Arguments: string;
    CreateNewProcessGroup: boolean;
    CreateNoWindow: boolean;
    Domain: string;
    readonly Environment: IDictionary_2<CLROf<string>, CLROf<string>>;
    readonly EnvironmentVariables: StringDictionary;
    ErrorDialog: boolean;
    ErrorDialogParentHandle: nint;
    FileName: string;
    LoadUserProfile: boolean;
    Password: SecureString;
    PasswordInClearText: string;
    RedirectStandardError: boolean;
    RedirectStandardInput: boolean;
    RedirectStandardOutput: boolean;
    StandardErrorEncoding: Encoding;
    StandardInputEncoding: Encoding;
    StandardOutputEncoding: Encoding;
    UseCredentialsForNetworkingOnly: boolean;
    UserName: string;
    UseShellExecute: boolean;
    Verb: string;
    readonly Verbs: string[];
    WindowStyle: ProcessWindowStyle;
    WorkingDirectory: string;
}


export type ProcessStartInfo = ProcessStartInfo$instance;

export class ProcessThread$instance extends System_ComponentModel_Internal.Component$instance {
    readonly BasePriority: int;
    readonly CurrentPriority: int;
    readonly Id: int;
    IdealProcessor: int;
    PriorityBoostEnabled: boolean;
    PriorityLevel: ThreadPriorityLevel;
    readonly PrivilegedProcessorTime: TimeSpan;
    ProcessorAffinity: nint;
    readonly StartAddress: nint;
    readonly StartTime: DateTime;
    readonly ThreadState: ThreadState;
    readonly TotalProcessorTime: TimeSpan;
    readonly UserProcessorTime: TimeSpan;
    readonly WaitReason: ThreadWaitReason;
    Dispose(): void;
    ResetIdealProcessor(): void;
}


export interface __ProcessThread$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ProcessThread = ProcessThread$instance & __ProcessThread$views;


export class ProcessThreadCollection$instance extends System_Collections_Internal.ReadOnlyCollectionBase$instance {
    constructor(processThreads: ProcessThread[]);
    readonly Item: ProcessThread;
    Add(thread: ProcessThread): int;
    Contains(thread: ProcessThread): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(thread: ProcessThread): int;
    Insert(index: int, thread: ProcessThread): void;
    Remove(thread: ProcessThread): void;
}


export interface __ProcessThreadCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ProcessThreadCollection = ProcessThreadCollection$instance & __ProcessThreadCollection$views;


export class SampleActivity_1$instance<T> extends Function {
    constructor(object_: any, method: nint);
    BeginInvoke(options: { value: ref<ActivityCreationOptions_1<T>> }, callback: AsyncCallback, object_: any): IAsyncResult;
    Clone(): any;
    EndInvoke(options: { value: ref<ActivityCreationOptions_1<T>> }, result: IAsyncResult): ActivitySamplingResult;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(options: { value: ref<ActivityCreationOptions_1<T>> }): ActivitySamplingResult;
}


export interface __SampleActivity_1$views<T> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SampleActivity_1<T> = SampleActivity_1$instance<T> & __SampleActivity_1$views<T>;


export class SourceFilter$instance extends TraceFilter$instance {
    constructor(source: string);
    Source: string;
    ShouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
}


export type SourceFilter = SourceFilter$instance;

export class SourceSwitch$instance extends Switch$instance {
    constructor(name: string);
    constructor(displayName: string, defaultSwitchValue: string);
    Level: SourceLevels;
    ShouldTrace(eventType: TraceEventType): boolean;
}


export type SourceSwitch = SourceSwitch$instance;

export class StackFrame$instance {
    constructor();
    constructor(needFileInfo: boolean);
    constructor(skipFrames: int);
    constructor(skipFrames: int, needFileInfo: boolean);
    constructor(fileName: string, lineNumber: int);
    constructor(fileName: string, lineNumber: int, colNumber: int);
    GetFileColumnNumber(): int;
    GetFileLineNumber(): int;
    GetFileName(): string;
    GetILOffset(): int;
    GetMethod(): MethodBase;
    GetNativeOffset(): int;
    ToString(): string;
    static readonly OFFSET_UNKNOWN: int;
}


export type StackFrame = StackFrame$instance;

export class StackTrace$instance {
    constructor();
    constructor(fNeedFileInfo: boolean);
    constructor(skipFrames: int);
    constructor(skipFrames: int, fNeedFileInfo: boolean);
    constructor(e: Exception);
    constructor(e: Exception, fNeedFileInfo: boolean);
    constructor(e: Exception, skipFrames: int);
    constructor(e: Exception, skipFrames: int, fNeedFileInfo: boolean);
    constructor(frame: StackFrame);
    constructor(frames: IEnumerable_1<StackFrame>);
    readonly FrameCount: int;
    GetFrame(index: int): StackFrame;
    GetFrames(): StackFrame[];
    ToString(): string;
    static readonly METHODS_TO_SKIP: int;
}


export type StackTrace = StackTrace$instance;

export class StackTraceHiddenAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type StackTraceHiddenAttribute = StackTraceHiddenAttribute$instance;

export class Stopwatch$instance {
    constructor();
    readonly Elapsed: TimeSpan;
    readonly ElapsedMilliseconds: long;
    readonly ElapsedTicks: long;
    readonly IsRunning: boolean;
    Reset(): void;
    Restart(): void;
    Start(): void;
    Stop(): void;
    ToString(): string;
    static readonly Frequency: long;
    static readonly IsHighResolution: boolean;
    static GetElapsedTime(startingTimestamp: long, endingTimestamp: long): TimeSpan;
    static GetElapsedTime(startingTimestamp: long): TimeSpan;
    static GetTimestamp(): long;
    static StartNew(): Stopwatch;
}


export type Stopwatch = Stopwatch$instance;

export abstract class Switch$instance {
    readonly Attributes: StringDictionary;
    readonly DefaultValue: string;
    readonly Description: string;
    readonly DisplayName: string;
    Value: string;
    Refresh(): void;
}


export type Switch = Switch$instance;

export class SwitchAttribute$instance extends System_Internal.Attribute$instance {
    constructor(switchName: string, switchType: Type);
    SwitchDescription: string;
    SwitchName: string;
    SwitchType: Type;
    static GetAll(assembly: Assembly): SwitchAttribute[];
}


export type SwitchAttribute = SwitchAttribute$instance;

export class SwitchLevelAttribute$instance extends System_Internal.Attribute$instance {
    constructor(switchLevelType: Type);
    SwitchLevelType: Type;
}


export type SwitchLevelAttribute = SwitchLevelAttribute$instance;

export class TextWriterTraceListener$instance extends TraceListener$instance {
    constructor();
    constructor(stream: Stream);
    constructor(stream: Stream, name: string);
    constructor(writer: TextWriter);
    constructor(writer: TextWriter, name: string);
    constructor(fileName: string);
    constructor(fileName: string, name: string);
    Writer: TextWriter;
    Close(): void;
    Dispose(): void;
    Flush(): void;
    Write(message: string): void;
    Write(o: any): void;
    Write(message: string, category: string): void;
    Write(o: any, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: any): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: any, category: string): void;
}


export interface __TextWriterTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TextWriterTraceListener = TextWriterTraceListener$instance & __TextWriterTraceListener$views;


export class Trace$instance {
    static readonly CorrelationManager: CorrelationManager;
    static readonly Listeners: TraceListenerCollection;
    static AutoFlush: boolean;
    static UseGlobalLock: boolean;
    static IndentLevel: int;
    static IndentSize: int;
    static Assert(condition: boolean, message: string, detailMessage: string): void;
    static Assert(condition: boolean, message?: string): void;
    static Assert(condition: boolean): void;
    static Close(): void;
    static Fail(message: string, detailMessage: string): void;
    static Fail(message: string): void;
    static Flush(): void;
    static Indent(): void;
    static Refresh(): void;
    static TraceError(format: string, args: any[]): void;
    static TraceError(message: string): void;
    static TraceInformation(format: string, args: any[]): void;
    static TraceInformation(message: string): void;
    static TraceWarning(format: string, args: any[]): void;
    static TraceWarning(message: string): void;
    static Unindent(): void;
    static Write(value: any, category: string): void;
    static Write(value: any): void;
    static Write(message: string, category: string): void;
    static Write(message: string): void;
    static WriteIf(condition: boolean, value: any, category: string): void;
    static WriteIf(condition: boolean, value: any): void;
    static WriteIf(condition: boolean, message: string, category: string): void;
    static WriteIf(condition: boolean, message: string): void;
    static WriteLine(value: any, category: string): void;
    static WriteLine(value: any): void;
    static WriteLine(message: string, category: string): void;
    static WriteLine(message: string): void;
    static WriteLineIf(condition: boolean, value: any, category: string): void;
    static WriteLineIf(condition: boolean, value: any): void;
    static WriteLineIf(condition: boolean, message: string, category: string): void;
    static WriteLineIf(condition: boolean, message: string): void;
}


export type Trace = Trace$instance;

export class TraceEventCache$instance {
    constructor();
    readonly Callstack: string;
    readonly DateTime: DateTime;
    readonly LogicalOperationStack: Stack;
    readonly ProcessId: int;
    readonly ThreadId: string;
    readonly Timestamp: long;
}


export type TraceEventCache = TraceEventCache$instance;

export abstract class TraceFilter$instance {
    abstract ShouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
}


export type TraceFilter = TraceFilter$instance;

export abstract class TraceListener$instance extends System_Internal.MarshalByRefObject$instance {
    readonly Attributes: StringDictionary;
    Filter: TraceFilter;
    IndentLevel: int;
    IndentSize: int;
    readonly IsThreadSafe: boolean;
    Name: string;
    TraceOutputOptions: TraceOptions;
    Close(): void;
    Dispose(): void;
    Fail(message: string): void;
    Fail(message: string, detailMessage: string): void;
    Flush(): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: any[]): void;
    TraceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    Write(message: string): void;
    Write(o: any): void;
    Write(message: string, category: string): void;
    Write(o: any, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: any): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: any, category: string): void;
}


export interface __TraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TraceListener = TraceListener$instance & __TraceListener$views;


export class TraceListenerCollection$instance {
    readonly Count: int;
    Add(listener: TraceListener): int;
    AddRange(value: TraceListener[]): void;
    AddRange(value: TraceListenerCollection): void;
    Clear(): void;
    Contains(listener: TraceListener): boolean;
    CopyTo(listeners: TraceListener[], index: int): void;
    get_Item(i: int): TraceListener;
    get_Item(name: string): TraceListener;
    GetEnumerator(): IEnumerator;
    IndexOf(listener: TraceListener): int;
    Insert(index: int, listener: TraceListener): void;
    Remove(listener: TraceListener): void;
    Remove(name: string): void;
    RemoveAt(index: int): void;
    set_Item(i: int, value: TraceListener): void;
}


export interface __TraceListenerCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type TraceListenerCollection = TraceListenerCollection$instance & __TraceListenerCollection$views;


export class TraceSource$instance {
    constructor(name: string);
    constructor(name: string, defaultLevel: SourceLevels);
    readonly Attributes: StringDictionary;
    readonly DefaultLevel: SourceLevels;
    readonly Listeners: TraceListenerCollection;
    readonly Name: string;
    Switch: SourceSwitch;
    Close(): void;
    Flush(): void;
    TraceData(eventType: TraceEventType, id: int, data: any): void;
    TraceData(eventType: TraceEventType, id: int, data: any[]): void;
    TraceEvent(eventType: TraceEventType, id: int): void;
    TraceEvent(eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventType: TraceEventType, id: int, format: string, args: any[]): void;
    TraceInformation(message: string): void;
    TraceInformation(format: string, args: any[]): void;
    TraceTransfer(id: int, message: string, relatedActivityId: Guid): void;
}


export type TraceSource = TraceSource$instance;

export class TraceSwitch$instance extends Switch$instance {
    constructor(displayName: string, description: string);
    constructor(displayName: string, description: string, defaultSwitchValue: string);
    Level: TraceLevel;
    readonly TraceError: boolean;
    readonly TraceInfo: boolean;
    readonly TraceVerbose: boolean;
    readonly TraceWarning: boolean;
}


export type TraceSwitch = TraceSwitch$instance;

export class UnreachableException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __UnreachableException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnreachableException = UnreachableException$instance & __UnreachableException$views;


export class XmlWriterTraceListener$instance extends TextWriterTraceListener$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, name: string);
    constructor(writer: TextWriter);
    constructor(writer: TextWriter, name: string);
    constructor(filename: string);
    constructor(filename: string, name: string);
    Close(): void;
    Dispose(): void;
    Fail(message: string, detailMessage: string): void;
    Fail(message: string): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: any[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    TraceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    Write(message: string): void;
    Write(o: any): void;
    Write(message: string, category: string): void;
    Write(o: any, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: any): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: any, category: string): void;
}


export interface __XmlWriterTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlWriterTraceListener = XmlWriterTraceListener$instance & __XmlWriterTraceListener$views;


export abstract class Debug$instance {
    static AutoFlush: boolean;
    static IndentLevel: int;
    static IndentSize: int;
    static Assert(condition: boolean, message: { value: ref<Debug_AssertInterpolatedStringHandler> }, detailMessage: { value: ref<Debug_AssertInterpolatedStringHandler> }): void;
    static Assert(condition: boolean, message: { value: ref<Debug_AssertInterpolatedStringHandler> }): void;
    static Assert(condition: boolean, message: string, detailMessageFormat: string, args: any[]): void;
    static Assert(condition: boolean, message: string, detailMessage: string): void;
    static Assert(condition: boolean, message?: string): void;
    static Assert(condition: boolean): void;
    static Close(): void;
    static Fail(message: string, detailMessage: string): void;
    static Fail(message: string): void;
    static Flush(): void;
    static Indent(): void;
    static Print(format: string, args: any[]): void;
    static Print(message: string): void;
    static SetProvider(provider: DebugProvider): DebugProvider;
    static Unindent(): void;
    static Write(value: any, category: string): void;
    static Write(value: any): void;
    static Write(message: string, category: string): void;
    static Write(message: string): void;
    static WriteIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }, category: string): void;
    static WriteIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }): void;
    static WriteIf(condition: boolean, value: any, category: string): void;
    static WriteIf(condition: boolean, value: any): void;
    static WriteIf(condition: boolean, message: string, category: string): void;
    static WriteIf(condition: boolean, message: string): void;
    static WriteLine(value: any, category: string): void;
    static WriteLine(value: any): void;
    static WriteLine(format: string, args: any[]): void;
    static WriteLine(message: string, category: string): void;
    static WriteLine(message: string): void;
    static WriteLineIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }, category: string): void;
    static WriteLineIf(condition: boolean, message: { value: ref<Debug_WriteIfInterpolatedStringHandler> }): void;
    static WriteLineIf(condition: boolean, value: any, category: string): void;
    static WriteLineIf(condition: boolean, value: any): void;
    static WriteLineIf(condition: boolean, message: string, category: string): void;
    static WriteLineIf(condition: boolean, message: string): void;
}


export type Debug = Debug$instance;

export abstract class Debugger$instance {
    static readonly DefaultCategory: string;
    static readonly IsAttached: boolean;
    static Break(): void;
    static BreakForUserUnhandledException(exception: Exception): void;
    static IsLogging(): boolean;
    static Launch(): boolean;
    static Log(level: int, category: string, message: string): void;
    static NotifyOfCrossThreadDependency(): void;
}


export type Debugger = Debugger$instance;

export abstract class StackFrameExtensions$instance {
    static GetNativeImageBase(stackFrame: StackFrame): nint;
    static GetNativeIP(stackFrame: StackFrame): nint;
    static HasILOffset(stackFrame: StackFrame): boolean;
    static HasMethod(stackFrame: StackFrame): boolean;
    static HasNativeImage(stackFrame: StackFrame): boolean;
    static HasSource(stackFrame: StackFrame): boolean;
}


export type StackFrameExtensions = StackFrameExtensions$instance;

