// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics
// Assembly: System.Diagnostics.TraceSource, System.Diagnostics.Process, System.Private.CoreLib, System.Diagnostics.TextWriterTraceListener, System.Diagnostics.DiagnosticSource, System.Diagnostics.FileVersionInfo

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { SafeProcessHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase, Stack } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, DescriptionAttribute, IComponent, IContainer, ISite, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { Stream, StreamReader, StreamWriter, TextWriter } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Delegate, Enum, EventArgs, EventHandler, EventHandler_1, Exception, Func_1, Func_2, Func_4, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, IObservable_1, IObserver_1, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ActivityIdFormat {
    unknown_ = 0,
    hierarchical = 1,
    w3c = 2
}


export enum ActivityKind {
    internal = 0,
    server = 1,
    client = 2,
    producer = 3,
    consumer = 4
}


export enum ActivitySamplingResult {
    none = 0,
    propagationData = 1,
    allData = 2,
    allDataAndRecorded = 3
}


export enum ActivityStatusCode {
    unset = 0,
    ok = 1,
    error = 2
}


export enum ActivityTraceFlags {
    none = 0,
    recorded = 1
}


export enum DebuggableAttribute_DebuggingModes {
    none = 0,
    default_ = 1,
    disableOptimizations = 256,
    ignoreSymbolStoreSequencePoints = 2,
    enableEditAndContinue = 4
}


export enum DebuggerBrowsableState {
    never_ = 0,
    collapsed = 2,
    rootHidden = 3
}


export enum ProcessPriorityClass {
    normal = 32,
    idle = 64,
    high = 128,
    realTime = 256,
    belowNormal = 16384,
    aboveNormal = 32768
}


export enum ProcessWindowStyle {
    normal = 0,
    hidden = 1,
    minimized = 2,
    maximized = 3
}


export enum SourceLevels {
    off = 0,
    critical = 1,
    error = 3,
    warning = 7,
    information = 15,
    verbose = 31,
    activityTracing = 65280,
    all = -1
}


export enum ThreadPriorityLevel {
    idle = -15,
    lowest = -2,
    belowNormal = -1,
    normal = 0,
    aboveNormal = 1,
    highest = 2,
    timeCritical = 15
}


export enum ThreadState {
    initialized = 0,
    ready = 1,
    running = 2,
    standby = 3,
    terminated = 4,
    wait = 5,
    transition = 6,
    unknown_ = 7
}


export enum ThreadWaitReason {
    executive = 0,
    freePage = 1,
    pageIn = 2,
    systemAllocation = 3,
    executionDelay = 4,
    suspended = 5,
    userRequest = 6,
    eventPairHigh = 7,
    eventPairLow = 8,
    lpcReceive = 9,
    lpcReply = 10,
    virtualMemory = 11,
    pageOut = 12,
    unknown_ = 13
}


export enum TraceEventType {
    critical = 1,
    error = 2,
    warning = 4,
    information = 8,
    verbose = 16,
    start = 256,
    stop = 512,
    suspend = 1024,
    resume = 2048,
    transfer = 4096
}


export enum TraceLevel {
    off = 0,
    error = 1,
    warning = 2,
    info = 3,
    verbose = 4
}


export enum TraceOptions {
    none = 0,
    logicalOperationStack = 1,
    dateTime = 2,
    timestamp = 4,
    processId = 8,
    threadId = 16,
    callstack = 32
}


export class Activity_Enumerator_1$instance<T> {
    readonly current: TSByRef<T>;
    getEnumerator(): Activity_Enumerator_1<T>;
    moveNext(): boolean;
}


export type Activity_Enumerator_1<T> = Activity_Enumerator_1$instance<T>;

export class ActivityChangedEventArgs$instance {
    current: Activity;
    previous: Activity;
}


export type ActivityChangedEventArgs = ActivityChangedEventArgs$instance;

export class ActivityContext$instance {
    constructor(traceId: ActivityTraceId, spanId: ActivitySpanId, traceFlags: ActivityTraceFlags, traceState: string, isRemote: boolean);
    readonly isRemote: boolean;
    readonly spanId: ActivitySpanId;
    readonly traceFlags: ActivityTraceFlags;
    readonly traceId: ActivityTraceId;
    readonly traceState: string;
    equals(value: ActivityContext): boolean;
    equals(obj: any): boolean;
    getHashCode(): int;
    static Parse(traceParent: string, traceState: string): ActivityContext;
    static TryParse(traceParent: string, traceState: string, isRemote: boolean, context: { value: TSByRef<ActivityContext> }): boolean;
    static TryParse(traceParent: string, traceState: string, context: { value: TSByRef<ActivityContext> }): boolean;
}


export interface __ActivityContext$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivityContext>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityContext): boolean;
}

export type ActivityContext = ActivityContext$instance & __ActivityContext$views;


export class ActivityCreationOptions_1$instance<T> {
    readonly kind: ActivityKind;
    readonly links: IEnumerable_1<ActivityLink>;
    readonly name: string;
    readonly parent: T;
    readonly samplingTags: ActivityTagsCollection;
    readonly source: ActivitySource;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly traceId: ActivityTraceId;
    traceState: string;
}


export type ActivityCreationOptions_1<T> = ActivityCreationOptions_1$instance<T>;

export class ActivityEvent$instance {
    constructor(name: string);
    constructor(name: string, timestamp: DateTimeOffset, tags: ActivityTagsCollection);
    readonly name: string;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly timestamp: DateTimeOffset;
    enumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, any>>;
}


export type ActivityEvent = ActivityEvent$instance;

export class ActivityLink$instance {
    constructor(context: ActivityContext, tags: ActivityTagsCollection);
    readonly context: ActivityContext;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    enumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, any>>;
    equals(obj: any): boolean;
    equals(value: ActivityLink): boolean;
    getHashCode(): int;
}


export interface __ActivityLink$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivityLink>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityLink): boolean;
}

export type ActivityLink = ActivityLink$instance & __ActivityLink$views;


export class ActivitySpanId$instance {
    copyTo(destination: Span_1<CLROf<byte>>): void;
    equals(spanId: ActivitySpanId): boolean;
    equals(obj: any): boolean;
    getHashCode(): int;
    toHexString(): string;
    toString(): string;
    static CreateFromBytes(idData: ReadOnlySpan_1<CLROf<byte>>): ActivitySpanId;
    static CreateFromString(idData: ReadOnlySpan_1<CLROf<string>>): ActivitySpanId;
    static CreateFromUtf8String(idData: ReadOnlySpan_1<CLROf<byte>>): ActivitySpanId;
    static CreateRandom(): ActivitySpanId;
}


export interface __ActivitySpanId$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivitySpanId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivitySpanId): boolean;
}

export type ActivitySpanId = ActivitySpanId$instance & __ActivitySpanId$views;


export class ActivityTagsCollection_Enumerator$instance {
    readonly current: KeyValuePair_2<CLROf<string>, any>;
    dispose(): void;
    moveNext(): boolean;
}


export interface __ActivityTagsCollection_Enumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type ActivityTagsCollection_Enumerator = ActivityTagsCollection_Enumerator$instance & __ActivityTagsCollection_Enumerator$views;


export class ActivityTraceId$instance {
    copyTo(destination: Span_1<CLROf<byte>>): void;
    equals(traceId: ActivityTraceId): boolean;
    equals(obj: any): boolean;
    getHashCode(): int;
    toHexString(): string;
    toString(): string;
    static CreateFromBytes(idData: ReadOnlySpan_1<CLROf<byte>>): ActivityTraceId;
    static CreateFromString(idData: ReadOnlySpan_1<CLROf<string>>): ActivityTraceId;
    static CreateFromUtf8String(idData: ReadOnlySpan_1<CLROf<byte>>): ActivityTraceId;
    static CreateRandom(): ActivityTraceId;
}


export interface __ActivityTraceId$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<ActivityTraceId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityTraceId): boolean;
}

export type ActivityTraceId = ActivityTraceId$instance & __ActivityTraceId$views;


export class Debug_AssertInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: TSByRef<boolean>);
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<string>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<string>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: any, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
}


export type Debug_AssertInterpolatedStringHandler = Debug_AssertInterpolatedStringHandler$instance;

export class Debug_WriteIfInterpolatedStringHandler$instance {
    constructor(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: TSByRef<boolean>);
    appendFormatted<T>(value: T): void;
    appendFormatted<T>(value: T, format: string): void;
    appendFormatted<T>(value: T, alignment: int): void;
    appendFormatted<T>(value: T, alignment: int, format: string): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<string>>): void;
    appendFormatted(value: ReadOnlySpan_1<CLROf<string>>, alignment?: int, format?: string): void;
    appendFormatted(value: string): void;
    appendFormatted(value: string, alignment?: int, format?: string): void;
    appendFormatted(value: any, alignment?: int, format?: string): void;
    appendLiteral(value: string): void;
}


export type Debug_WriteIfInterpolatedStringHandler = Debug_WriteIfInterpolatedStringHandler$instance;

export class TagList$instance {
    constructor(tagList: ReadOnlySpan_1<KeyValuePair_2<CLROf<string>, any>>);
    readonly count: int;
    readonly isReadOnly: boolean;
    item: KeyValuePair_2<CLROf<string>, any>;
    add(key: string, value: any): void;
    add(tag: KeyValuePair_2<CLROf<string>, any>): void;
    clear(): void;
    contains(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    copyTo(tags: Span_1<KeyValuePair_2<CLROf<string>, any>>): void;
    copyTo(array: KeyValuePair_2<CLROf<string>, any>[], arrayIndex: int): void;
    getEnumerator(): IEnumerator_1<KeyValuePair_2<CLROf<string>, any>>;
    indexOf(item: KeyValuePair_2<CLROf<string>, any>): int;
    insert(index: int, item: KeyValuePair_2<CLROf<string>, any>): void;
    remove(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    removeAt(index: int): void;
}


export interface __TagList$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IList_1: System_Collections_Generic_Internal.IList_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IReadOnlyCollection_1: System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type TagList = TagList$instance & __TagList$views;


export class TagList_Enumerator$instance {
    readonly current: KeyValuePair_2<CLROf<string>, any>;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export interface __TagList_Enumerator$views {
    readonly As_IEnumerator_1: System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerator: System_Collections_Internal.IEnumerator$instance;
}

export type TagList_Enumerator = TagList_Enumerator$instance & __TagList_Enumerator$views;


export class Activity$instance {
    constructor(operationName: string);
    activityTraceFlags: ActivityTraceFlags;
    readonly baggage: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    readonly context: ActivityContext;
    displayName: string;
    readonly duration: TimeSpan;
    readonly events: IEnumerable_1<ActivityEvent>;
    readonly hasRemoteParent: boolean;
    readonly id: string;
    readonly idFormat: ActivityIdFormat;
    isAllDataRequested: boolean;
    readonly isStopped: boolean;
    readonly kind: ActivityKind;
    readonly links: IEnumerable_1<ActivityLink>;
    readonly operationName: string;
    readonly parent: Activity;
    readonly parentId: string;
    readonly parentSpanId: ActivitySpanId;
    readonly recorded: boolean;
    readonly rootId: string;
    readonly source: ActivitySource;
    readonly spanId: ActivitySpanId;
    readonly startTimeUtc: DateTime;
    readonly status: ActivityStatusCode;
    readonly statusDescription: string;
    readonly tagObjects: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    readonly traceId: ActivityTraceId;
    traceStateString: string;
    addBaggage(key: string, value: string): Activity;
    addEvent(e: ActivityEvent): Activity;
    addException(exception: Exception, tags?: { value: TSByRef<TagList> }, timestamp?: DateTimeOffset): Activity;
    addLink(link: ActivityLink): Activity;
    addTag(key: string, value: string): Activity;
    addTag(key: string, value: any): Activity;
    dispose(): void;
    enumerateEvents(): Activity_Enumerator_1<ActivityEvent>;
    enumerateLinks(): Activity_Enumerator_1<ActivityLink>;
    enumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<CLROf<string>, any>>;
    getBaggageItem(key: string): string;
    getCustomProperty(propertyName: string): any;
    getTagItem(key: string): any;
    setBaggage(key: string, value: string): Activity;
    setCustomProperty(propertyName: string, propertyValue: any): void;
    setEndTime(endTimeUtc: DateTime): Activity;
    setIdFormat(format: ActivityIdFormat): Activity;
    setParentId(parentId: string): Activity;
    setParentId(traceId: ActivityTraceId, spanId: ActivitySpanId, activityTraceFlags?: ActivityTraceFlags): Activity;
    setStartTime(startTimeUtc: DateTime): Activity;
    setStatus(code: ActivityStatusCode, description?: string): Activity;
    setTag(key: string, value: any): Activity;
    start(): Activity;
    stop(): void;
    static ForceDefaultIdFormat: boolean;
    static Current: Activity;
    static TraceIdGenerator: Func_1<ActivityTraceId>;
    static DefaultIdFormat: ActivityIdFormat;
}


export interface __Activity$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Activity = Activity$instance & __Activity$views;


export class ActivityListener$instance {
    constructor();
    activityStarted: Action_1<Activity>;
    activityStopped: Action_1<Activity>;
    exceptionRecorder: ExceptionRecorder;
    sample: SampleActivity_1<ActivityContext>;
    sampleUsingParentId: SampleActivity_1<CLROf<string>>;
    shouldListenTo: Func_2<ActivitySource, CLROf<boolean>>;
    dispose(): void;
}


export interface __ActivityListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ActivityListener = ActivityListener$instance & __ActivityListener$views;


export class ActivitySource$instance {
    constructor(name: string);
    constructor(name: string, version: string);
    constructor(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>);
    constructor(options: ActivitySourceOptions);
    readonly name: string;
    readonly tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    readonly telemetrySchemaUrl: string;
    readonly version: string;
    createActivity(name: string, kind: ActivityKind): Activity;
    createActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    createActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    dispose(): void;
    hasListeners(): boolean;
    startActivity(name?: string, kind?: ActivityKind): Activity;
    startActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    startActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    startActivity(kind: ActivityKind, parentContext?: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset, name?: string): Activity;
    static AddActivityListener(listener: ActivityListener): void;
}


export interface __ActivitySource$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ActivitySource = ActivitySource$instance & __ActivitySource$views;


export class ActivitySourceOptions$instance {
    constructor(name: string);
    name: string;
    tags: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>;
    telemetrySchemaUrl: string;
    version: string;
}


export type ActivitySourceOptions = ActivitySourceOptions$instance;

export class ActivityTagsCollection$instance {
    constructor();
    constructor(list: IEnumerable_1<KeyValuePair_2<CLROf<string>, any>>);
    readonly count: int;
    readonly isReadOnly: boolean;
    item: any;
    readonly keys: ICollection_1<CLROf<string>>;
    readonly values: ICollection_1<any>;
    add(key: string, value: any): void;
    add(item: KeyValuePair_2<CLROf<string>, any>): void;
    clear(): void;
    contains(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    containsKey(key: string): boolean;
    copyTo(array: KeyValuePair_2<CLROf<string>, any>[], arrayIndex: int): void;
    getEnumerator(): ActivityTagsCollection_Enumerator;
    remove(key: string): boolean;
    remove(item: KeyValuePair_2<CLROf<string>, any>): boolean;
    tryGetValue(key: string, value: { value: TSByRef<any> }): boolean;
}


export interface __ActivityTagsCollection$views {
    readonly As_ICollection_1: System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IDictionary_2: System_Collections_Generic_Internal.IDictionary_2$instance<CLROf<string>, any>;
    readonly As_IEnumerable_1_of_Char: System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ActivityTagsCollection = ActivityTagsCollection$instance & __ActivityTagsCollection$views;


export class BooleanSwitch$instance extends Switch$instance {
    constructor(displayName: string, description: string);
    constructor(displayName: string, description: string, defaultSwitchValue: string);
    enabled: boolean;
}


export type BooleanSwitch = BooleanSwitch$instance;

export class ConditionalAttribute$instance extends System_Internal.Attribute$instance {
    constructor(conditionString: string);
    readonly conditionString: string;
}


export type ConditionalAttribute = ConditionalAttribute$instance;

export class ConsoleTraceListener$instance extends TextWriterTraceListener$instance {
    constructor();
    constructor(useErrorStream: boolean);
    close(): void;
    dispose(): void;
}


export interface __ConsoleTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ConsoleTraceListener = ConsoleTraceListener$instance & __ConsoleTraceListener$views;


export class CorrelationManager$instance {
    activityId: Guid;
    readonly logicalOperationStack: Stack;
    startLogicalOperation(): void;
    startLogicalOperation(operationId: any): void;
    stopLogicalOperation(): void;
}


export type CorrelationManager = CorrelationManager$instance;

export class DataReceivedEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly data: string;
}


export type DataReceivedEventArgs = DataReceivedEventArgs$instance;

export class DataReceivedEventHandler$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(sender: any, e: DataReceivedEventArgs, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(sender: any, e: DataReceivedEventArgs): void;
}


export interface __DataReceivedEventHandler$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataReceivedEventHandler = DataReceivedEventHandler$instance & __DataReceivedEventHandler$views;


export class DebuggableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isJITTrackingEnabled: boolean, isJITOptimizerDisabled: boolean);
    constructor(modes: DebuggableAttribute_DebuggingModes);
    readonly debuggingFlags: DebuggableAttribute_DebuggingModes;
    readonly isJITOptimizerDisabled: boolean;
    readonly isJITTrackingEnabled: boolean;
}


export type DebuggableAttribute = DebuggableAttribute$instance;

export class DebuggerBrowsableAttribute$instance extends System_Internal.Attribute$instance {
    constructor(state: DebuggerBrowsableState);
    readonly state: DebuggerBrowsableState;
}


export type DebuggerBrowsableAttribute = DebuggerBrowsableAttribute$instance;

export class DebuggerDisableUserUnhandledExceptionsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerDisableUserUnhandledExceptionsAttribute = DebuggerDisableUserUnhandledExceptionsAttribute$instance;

export class DebuggerDisplayAttribute$instance extends System_Internal.Attribute$instance {
    constructor(value: string);
    name: string;
    target: Type;
    targetTypeName: string;
    type_: string;
    readonly value: string;
}


export type DebuggerDisplayAttribute = DebuggerDisplayAttribute$instance;

export class DebuggerHiddenAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerHiddenAttribute = DebuggerHiddenAttribute$instance;

export class DebuggerNonUserCodeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerNonUserCodeAttribute = DebuggerNonUserCodeAttribute$instance;

export class DebuggerStepperBoundaryAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerStepperBoundaryAttribute = DebuggerStepperBoundaryAttribute$instance;

export class DebuggerStepThroughAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type DebuggerStepThroughAttribute = DebuggerStepThroughAttribute$instance;

export class DebuggerTypeProxyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type);
    constructor(typeName: string);
    readonly proxyTypeName: string;
    target: Type;
    targetTypeName: string;
}


export type DebuggerTypeProxyAttribute = DebuggerTypeProxyAttribute$instance;

export class DebuggerVisualizerAttribute$instance extends System_Internal.Attribute$instance {
    constructor(visualizerTypeName: string);
    constructor(visualizerTypeName: string, visualizerObjectSourceTypeName: string);
    constructor(visualizerTypeName: string, visualizerObjectSource: Type);
    constructor(visualizer: Type);
    constructor(visualizer: Type, visualizerObjectSource: Type);
    constructor(visualizer: Type, visualizerObjectSourceTypeName: string);
    description: string;
    target: Type;
    targetTypeName: string;
    readonly visualizerObjectSourceTypeName: string;
    readonly visualizerTypeName: string;
}


export type DebuggerVisualizerAttribute = DebuggerVisualizerAttribute$instance;

export class DebugProvider$instance {
    constructor();
    fail(message: string, detailMessage: string): void;
    onIndentLevelChanged(indentLevel: int): void;
    onIndentSizeChanged(indentSize: int): void;
    write(message: string): void;
    writeLine(message: string): void;
    static FailCore(stackTrace: string, message: string, detailMessage: string, errorSource: string): void;
    static WriteCore(message: string): void;
}


export type DebugProvider = DebugProvider$instance;

export class DefaultTraceListener$instance extends TraceListener$instance {
    constructor();
    assertUiEnabled: boolean;
    logFileName: string;
    dispose(): void;
    fail(message: string): void;
    fail(message: string, detailMessage: string): void;
    write(message: string): void;
    write(o: any): void;
    write(message: string, category: string): void;
    write(o: any, category: string): void;
    writeLine(message: string): void;
    writeLine(o: any): void;
    writeLine(message: string, category: string): void;
    writeLine(o: any, category: string): void;
}


export interface __DefaultTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DefaultTraceListener = DefaultTraceListener$instance & __DefaultTraceListener$views;


export class DelimitedListTraceListener$instance extends TextWriterTraceListener$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, name: string);
    constructor(writer: TextWriter);
    constructor(writer: TextWriter, name: string);
    constructor(fileName: string);
    constructor(fileName: string, name: string);
    delimiter: string;
    dispose(): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: any[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
}


export interface __DelimitedListTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type DelimitedListTraceListener = DelimitedListTraceListener$instance & __DelimitedListTraceListener$views;


export class DiagnosticListener$instance extends DiagnosticSource$instance {
    constructor(name: string);
    readonly name: string;
    dispose(): void;
    isEnabled(name: string): boolean;
    isEnabled(name: string, arg1: any, arg2?: any): boolean;
    onActivityExport(activity: Activity, payload: any): void;
    onActivityImport(activity: Activity, payload: any): void;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>, isEnabled: Func_4<CLROf<string>, any, any, CLROf<boolean>>, onActivityImport?: Action_2<Activity, any>, onActivityExport?: Action_2<Activity, any>): IDisposable;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>, isEnabled: Predicate_1<CLROf<string>>): IDisposable;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>, isEnabled: Func_4<CLROf<string>, any, any, CLROf<boolean>>): IDisposable;
    subscribe(observer: IObserver_1<KeyValuePair_2<CLROf<string>, any>>): IDisposable;
    toString(): string;
    write(name: string, value: any): void;
    write<T>(name: string, value: T): void;
    static readonly AllListeners: IObservable_1<DiagnosticListener>;
}


export interface __DiagnosticListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
    readonly As_IObservable_1_of_KeyValuePair_2: System_Internal.IObservable_1$instance<KeyValuePair_2<CLROf<string>, any>>;
}

export type DiagnosticListener = DiagnosticListener$instance & __DiagnosticListener$views;


export class DiagnosticMethodInfo$instance {
    readonly declaringAssemblyName: string;
    readonly declaringTypeName: string;
    readonly name: string;
    static Create(delegate: Function): DiagnosticMethodInfo;
    static Create(frame: StackFrame): DiagnosticMethodInfo;
}


export type DiagnosticMethodInfo = DiagnosticMethodInfo$instance;

export abstract class DiagnosticSource$instance {
    isEnabled(name: string): boolean;
    isEnabled(name: string, arg1: any, arg2?: any): boolean;
    onActivityExport(activity: Activity, payload: any): void;
    onActivityImport(activity: Activity, payload: any): void;
    startActivity(activity: Activity, args: any): Activity;
    startActivity<T>(activity: Activity, args: T): Activity;
    stopActivity(activity: Activity, args: any): void;
    stopActivity<T>(activity: Activity, args: T): void;
    write(name: string, value: any): void;
    write<T>(name: string, value: T): void;
}


export type DiagnosticSource = DiagnosticSource$instance;

export abstract class DistributedContextPropagator$instance {
    readonly fields: IReadOnlyCollection_1<CLROf<string>>;
    abstract extractBaggage(carrier: any, getter: DistributedContextPropagator_PropagatorGetterCallback): IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>;
    abstract extractTraceIdAndState(carrier: any, getter: DistributedContextPropagator_PropagatorGetterCallback, traceId: { value: TSByRef<string> }, traceState: { value: TSByRef<string> }): void;
    abstract inject(activity: Activity, carrier: any, setter: DistributedContextPropagator_PropagatorSetterCallback): void;
    static Current: DistributedContextPropagator;
    static CreateDefaultPropagator(): DistributedContextPropagator;
    static CreateNoOutputPropagator(): DistributedContextPropagator;
    static CreatePassThroughPropagator(): DistributedContextPropagator;
    static CreatePreW3CPropagator(): DistributedContextPropagator;
    static CreateW3CPropagator(): DistributedContextPropagator;
}


export type DistributedContextPropagator = DistributedContextPropagator$instance;

export class DistributedContextPropagator_PropagatorGetterCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(carrier: any, fieldName: string, fieldValue: { value: TSByRef<string> }, fieldValues: { value: TSByRef<IEnumerable_1<CLROf<string>>> }, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(fieldValue: { value: TSByRef<string> }, fieldValues: { value: TSByRef<IEnumerable_1<CLROf<string>>> }, result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(carrier: any, fieldName: string, fieldValue: { value: TSByRef<string> }, fieldValues: { value: TSByRef<IEnumerable_1<CLROf<string>>> }): void;
}


export interface __DistributedContextPropagator_PropagatorGetterCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DistributedContextPropagator_PropagatorGetterCallback = DistributedContextPropagator_PropagatorGetterCallback$instance & __DistributedContextPropagator_PropagatorGetterCallback$views;


export class DistributedContextPropagator_PropagatorSetterCallback$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(carrier: any, fieldName: string, fieldValue: string, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(carrier: any, fieldName: string, fieldValue: string): void;
}


export interface __DistributedContextPropagator_PropagatorSetterCallback$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DistributedContextPropagator_PropagatorSetterCallback = DistributedContextPropagator_PropagatorSetterCallback$instance & __DistributedContextPropagator_PropagatorSetterCallback$views;


export class EventTypeFilter$instance extends TraceFilter$instance {
    constructor(level: SourceLevels);
    eventType: SourceLevels;
    shouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
}


export type EventTypeFilter = EventTypeFilter$instance;

export class ExceptionRecorder$instance extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(activity: Activity, exception: Exception, tags: { value: TSByRef<TagList> }, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(tags: { value: TSByRef<TagList> }, result: IAsyncResult): void;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(activity: Activity, exception: Exception, tags: { value: TSByRef<TagList> }): void;
}


export interface __ExceptionRecorder$views {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExceptionRecorder = ExceptionRecorder$instance & __ExceptionRecorder$views;


export class FileVersionInfo$instance {
    readonly comments: string;
    readonly companyName: string;
    readonly fileBuildPart: int;
    readonly fileDescription: string;
    readonly fileMajorPart: int;
    readonly fileMinorPart: int;
    readonly fileName: string;
    readonly filePrivatePart: int;
    readonly fileVersion: string;
    readonly internalName: string;
    readonly isDebug: boolean;
    readonly isPatched: boolean;
    readonly isPreRelease: boolean;
    readonly isPrivateBuild: boolean;
    readonly isSpecialBuild: boolean;
    readonly language: string;
    readonly legalCopyright: string;
    readonly legalTrademarks: string;
    readonly originalFilename: string;
    readonly privateBuild: string;
    readonly productBuildPart: int;
    readonly productMajorPart: int;
    readonly productMinorPart: int;
    readonly productName: string;
    readonly productPrivatePart: int;
    readonly productVersion: string;
    readonly specialBuild: string;
    toString(): string;
    static GetVersionInfo(fileName: string): FileVersionInfo;
}


export type FileVersionInfo = FileVersionInfo$instance;

export class InitializingSwitchEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(switch_: Switch);
    readonly switch_: Switch;
}


export type InitializingSwitchEventArgs = InitializingSwitchEventArgs$instance;

export class InitializingTraceSourceEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(traceSource: TraceSource);
    readonly traceSource: TraceSource;
    wasInitialized: boolean;
}


export type InitializingTraceSourceEventArgs = InitializingTraceSourceEventArgs$instance;

export class MonitoringDescriptionAttribute$instance extends System_ComponentModel_Internal.DescriptionAttribute$instance {
    constructor(description: string);
    readonly description: string;
}


export type MonitoringDescriptionAttribute = MonitoringDescriptionAttribute$instance;

export class Process$instance extends System_ComponentModel_Internal.Component$instance {
    constructor();
    readonly basePriority: int;
    enableRaisingEvents: boolean;
    readonly exitCode: int;
    readonly exitTime: DateTime;
    readonly handle: nint;
    readonly handleCount: int;
    readonly hasExited: boolean;
    readonly id: int;
    readonly machineName: string;
    readonly mainModule: ProcessModule;
    readonly mainWindowHandle: nint;
    readonly mainWindowTitle: string;
    maxWorkingSet: nint;
    minWorkingSet: nint;
    readonly modules: ProcessModuleCollection;
    readonly nonpagedSystemMemorySize: int;
    readonly nonpagedSystemMemorySize64: long;
    readonly pagedMemorySize: int;
    readonly pagedMemorySize64: long;
    readonly pagedSystemMemorySize: int;
    readonly pagedSystemMemorySize64: long;
    readonly peakPagedMemorySize: int;
    readonly peakPagedMemorySize64: long;
    readonly peakVirtualMemorySize: int;
    readonly peakVirtualMemorySize64: long;
    readonly peakWorkingSet: int;
    readonly peakWorkingSet64: long;
    priorityBoostEnabled: boolean;
    priorityClass: ProcessPriorityClass;
    readonly privateMemorySize: int;
    readonly privateMemorySize64: long;
    readonly privilegedProcessorTime: TimeSpan;
    readonly processName: string;
    processorAffinity: nint;
    readonly responding: boolean;
    readonly safeHandle: SafeProcessHandle;
    readonly sessionId: int;
    readonly standardError: StreamReader;
    readonly standardInput: StreamWriter;
    readonly standardOutput: StreamReader;
    startInfo: ProcessStartInfo;
    readonly startTime: DateTime;
    synchronizingObject: ISynchronizeInvoke;
    readonly threads: ProcessThreadCollection;
    readonly totalProcessorTime: TimeSpan;
    readonly userProcessorTime: TimeSpan;
    readonly virtualMemorySize: int;
    readonly virtualMemorySize64: long;
    readonly workingSet: int;
    readonly workingSet64: long;
    beginErrorReadLine(): void;
    beginOutputReadLine(): void;
    cancelErrorRead(): void;
    cancelOutputRead(): void;
    close(): void;
    closeMainWindow(): boolean;
    dispose(): void;
    kill(): void;
    kill(entireProcessTree: boolean): void;
    refresh(): void;
    start(): boolean;
    toString(): string;
    waitForExit(): void;
    waitForExit(milliseconds: int): boolean;
    waitForExit(timeout: TimeSpan): boolean;
    waitForExitAsync(cancellationToken?: CancellationToken): Task;
    waitForInputIdle(): boolean;
    waitForInputIdle(milliseconds: int): boolean;
    waitForInputIdle(timeout: TimeSpan): boolean;
    static EnterDebugMode(): void;
    static GetCurrentProcess(): Process;
    static GetProcessById(processId: int, machineName: string): Process;
    static GetProcessById(processId: int): Process;
    static GetProcesses(): Process[];
    static GetProcesses(machineName: string): Process[];
    static GetProcessesByName(processName: string, machineName: string): Process[];
    static GetProcessesByName(processName: string): Process[];
    static LeaveDebugMode(): void;
    static Start(startInfo: ProcessStartInfo): Process;
    static Start(fileName: string, arguments: IEnumerable_1<CLROf<string>>): Process;
    static Start(fileName: string, userName: string, password: SecureString, domain: string): Process;
    static Start(fileName: string, arguments: string, userName: string, password: SecureString, domain: string): Process;
    static Start(fileName: string, arguments: string): Process;
    static Start(fileName: string): Process;
}


export interface __Process$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type Process = Process$instance & __Process$views;


export class ProcessModule$instance extends System_ComponentModel_Internal.Component$instance {
    readonly baseAddress: nint;
    readonly entryPointAddress: nint;
    readonly fileName: string;
    readonly fileVersionInfo: FileVersionInfo;
    readonly moduleMemorySize: int;
    readonly moduleName: string;
    dispose(): void;
    toString(): string;
}


export interface __ProcessModule$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ProcessModule = ProcessModule$instance & __ProcessModule$views;


export class ProcessModuleCollection$instance extends System_Collections_Internal.ReadOnlyCollectionBase$instance {
    constructor(processModules: ProcessModule[]);
    readonly item: ProcessModule;
    contains(module_: ProcessModule): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(module_: ProcessModule): int;
}


export interface __ProcessModuleCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ProcessModuleCollection = ProcessModuleCollection$instance & __ProcessModuleCollection$views;


export class ProcessStartInfo$instance {
    constructor();
    constructor(fileName: string);
    constructor(fileName: string, arguments: string);
    constructor(fileName: string, arguments: IEnumerable_1<CLROf<string>>);
    readonly argumentList: Collection_1<CLROf<string>>;
    arguments: string;
    createNewProcessGroup: boolean;
    createNoWindow: boolean;
    domain: string;
    readonly environment: IDictionary_2<CLROf<string>, CLROf<string>>;
    readonly environmentVariables: StringDictionary;
    errorDialog: boolean;
    errorDialogParentHandle: nint;
    fileName: string;
    loadUserProfile: boolean;
    password: SecureString;
    passwordInClearText: string;
    redirectStandardError: boolean;
    redirectStandardInput: boolean;
    redirectStandardOutput: boolean;
    standardErrorEncoding: Encoding;
    standardInputEncoding: Encoding;
    standardOutputEncoding: Encoding;
    useCredentialsForNetworkingOnly: boolean;
    userName: string;
    useShellExecute: boolean;
    verb: string;
    readonly verbs: string[];
    windowStyle: ProcessWindowStyle;
    workingDirectory: string;
}


export type ProcessStartInfo = ProcessStartInfo$instance;

export class ProcessThread$instance extends System_ComponentModel_Internal.Component$instance {
    readonly basePriority: int;
    readonly currentPriority: int;
    readonly id: int;
    idealProcessor: int;
    priorityBoostEnabled: boolean;
    priorityLevel: ThreadPriorityLevel;
    readonly privilegedProcessorTime: TimeSpan;
    processorAffinity: nint;
    readonly startAddress: nint;
    readonly startTime: DateTime;
    readonly threadState: ThreadState;
    readonly totalProcessorTime: TimeSpan;
    readonly userProcessorTime: TimeSpan;
    readonly waitReason: ThreadWaitReason;
    dispose(): void;
    resetIdealProcessor(): void;
}


export interface __ProcessThread$views {
    readonly As_IComponent: System_ComponentModel_Internal.IComponent$instance;
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type ProcessThread = ProcessThread$instance & __ProcessThread$views;


export class ProcessThreadCollection$instance extends System_Collections_Internal.ReadOnlyCollectionBase$instance {
    constructor(processThreads: ProcessThread[]);
    readonly item: ProcessThread;
    add(thread: ProcessThread): int;
    contains(thread: ProcessThread): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(thread: ProcessThread): int;
    insert(index: int, thread: ProcessThread): void;
    remove(thread: ProcessThread): void;
}


export interface __ProcessThreadCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
}

export type ProcessThreadCollection = ProcessThreadCollection$instance & __ProcessThreadCollection$views;


export class SampleActivity_1$instance<T> extends Function {
    constructor(object_: any, method: nint);
    beginInvoke(options: { value: TSByRef<ActivityCreationOptions_1<T>> }, callback: AsyncCallback, object_: any): IAsyncResult;
    clone(): any;
    endInvoke(options: { value: TSByRef<ActivityCreationOptions_1<T>> }, result: IAsyncResult): ActivitySamplingResult;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    invoke(options: { value: TSByRef<ActivityCreationOptions_1<T>> }): ActivitySamplingResult;
}


export interface __SampleActivity_1$views<T> {
    readonly As_ICloneable: System_Internal.ICloneable$instance;
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SampleActivity_1<T> = SampleActivity_1$instance<T> & __SampleActivity_1$views<T>;


export class SourceFilter$instance extends TraceFilter$instance {
    constructor(source: string);
    source: string;
    shouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
}


export type SourceFilter = SourceFilter$instance;

export class SourceSwitch$instance extends Switch$instance {
    constructor(name: string);
    constructor(displayName: string, defaultSwitchValue: string);
    level: SourceLevels;
    shouldTrace(eventType: TraceEventType): boolean;
}


export type SourceSwitch = SourceSwitch$instance;

export class StackFrame$instance {
    constructor();
    constructor(needFileInfo: boolean);
    constructor(skipFrames: int);
    constructor(skipFrames: int, needFileInfo: boolean);
    constructor(fileName: string, lineNumber: int);
    constructor(fileName: string, lineNumber: int, colNumber: int);
    getFileColumnNumber(): int;
    getFileLineNumber(): int;
    getFileName(): string;
    getILOffset(): int;
    getMethod(): MethodBase;
    getNativeOffset(): int;
    toString(): string;
    static readonly OFFSET_UNKNOWN: int;
}


export type StackFrame = StackFrame$instance;

export class StackTrace$instance {
    constructor();
    constructor(fNeedFileInfo: boolean);
    constructor(skipFrames: int);
    constructor(skipFrames: int, fNeedFileInfo: boolean);
    constructor(e: Exception);
    constructor(e: Exception, fNeedFileInfo: boolean);
    constructor(e: Exception, skipFrames: int);
    constructor(e: Exception, skipFrames: int, fNeedFileInfo: boolean);
    constructor(frame: StackFrame);
    constructor(frames: IEnumerable_1<StackFrame>);
    readonly frameCount: int;
    getFrame(index: int): StackFrame;
    getFrames(): StackFrame[];
    toString(): string;
    static readonly METHODS_TO_SKIP: int;
}


export type StackTrace = StackTrace$instance;

export class StackTraceHiddenAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type StackTraceHiddenAttribute = StackTraceHiddenAttribute$instance;

export class Stopwatch$instance {
    constructor();
    readonly elapsed: TimeSpan;
    readonly elapsedMilliseconds: long;
    readonly elapsedTicks: long;
    readonly isRunning: boolean;
    reset(): void;
    restart(): void;
    start(): void;
    stop(): void;
    toString(): string;
    static readonly frequency: long;
    static readonly isHighResolution: boolean;
    static GetElapsedTime(startingTimestamp: long, endingTimestamp: long): TimeSpan;
    static GetElapsedTime(startingTimestamp: long): TimeSpan;
    static GetTimestamp(): long;
    static StartNew(): Stopwatch;
}


export type Stopwatch = Stopwatch$instance;

export abstract class Switch$instance {
    readonly attributes: StringDictionary;
    readonly defaultValue: string;
    readonly description: string;
    readonly displayName: string;
    value: string;
    refresh(): void;
}


export type Switch = Switch$instance;

export class SwitchAttribute$instance extends System_Internal.Attribute$instance {
    constructor(switchName: string, switchType: Type);
    switchDescription: string;
    switchName: string;
    switchType: Type;
    static GetAll(assembly: Assembly): SwitchAttribute[];
}


export type SwitchAttribute = SwitchAttribute$instance;

export class SwitchLevelAttribute$instance extends System_Internal.Attribute$instance {
    constructor(switchLevelType: Type);
    switchLevelType: Type;
}


export type SwitchLevelAttribute = SwitchLevelAttribute$instance;

export class TextWriterTraceListener$instance extends TraceListener$instance {
    constructor();
    constructor(stream: Stream);
    constructor(stream: Stream, name: string);
    constructor(writer: TextWriter);
    constructor(writer: TextWriter, name: string);
    constructor(fileName: string);
    constructor(fileName: string, name: string);
    writer: TextWriter;
    close(): void;
    dispose(): void;
    flush(): void;
    write(message: string): void;
    write(o: any): void;
    write(message: string, category: string): void;
    write(o: any, category: string): void;
    writeLine(message: string): void;
    writeLine(o: any): void;
    writeLine(message: string, category: string): void;
    writeLine(o: any, category: string): void;
}


export interface __TextWriterTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TextWriterTraceListener = TextWriterTraceListener$instance & __TextWriterTraceListener$views;


export class Trace$instance {
    static readonly CorrelationManager: CorrelationManager;
    static readonly Listeners: TraceListenerCollection;
    static AutoFlush: boolean;
    static UseGlobalLock: boolean;
    static IndentLevel: int;
    static IndentSize: int;
    static Assert(condition: boolean, message: string, detailMessage: string): void;
    static Assert(condition: boolean, message?: string): void;
    static Assert(condition: boolean): void;
    static Close(): void;
    static Fail(message: string, detailMessage: string): void;
    static Fail(message: string): void;
    static Flush(): void;
    static Indent(): void;
    static Refresh(): void;
    static TraceError(format: string, args: any[]): void;
    static TraceError(message: string): void;
    static TraceInformation(format: string, args: any[]): void;
    static TraceInformation(message: string): void;
    static TraceWarning(format: string, args: any[]): void;
    static TraceWarning(message: string): void;
    static Unindent(): void;
    static Write(value: any, category: string): void;
    static Write(value: any): void;
    static Write(message: string, category: string): void;
    static Write(message: string): void;
    static WriteIf(condition: boolean, value: any, category: string): void;
    static WriteIf(condition: boolean, value: any): void;
    static WriteIf(condition: boolean, message: string, category: string): void;
    static WriteIf(condition: boolean, message: string): void;
    static WriteLine(value: any, category: string): void;
    static WriteLine(value: any): void;
    static WriteLine(message: string, category: string): void;
    static WriteLine(message: string): void;
    static WriteLineIf(condition: boolean, value: any, category: string): void;
    static WriteLineIf(condition: boolean, value: any): void;
    static WriteLineIf(condition: boolean, message: string, category: string): void;
    static WriteLineIf(condition: boolean, message: string): void;
}


export type Trace = Trace$instance;

export class TraceEventCache$instance {
    constructor();
    readonly callstack: string;
    readonly dateTime: DateTime;
    readonly logicalOperationStack: Stack;
    readonly processId: int;
    readonly threadId: string;
    readonly timestamp: long;
}


export type TraceEventCache = TraceEventCache$instance;

export abstract class TraceFilter$instance {
    abstract shouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: any[], data1: any, data: any[]): boolean;
}


export type TraceFilter = TraceFilter$instance;

export abstract class TraceListener$instance extends System_Internal.MarshalByRefObject$instance {
    readonly attributes: StringDictionary;
    filter: TraceFilter;
    indentLevel: int;
    indentSize: int;
    readonly isThreadSafe: boolean;
    name: string;
    traceOutputOptions: TraceOptions;
    close(): void;
    dispose(): void;
    fail(message: string): void;
    fail(message: string, detailMessage: string): void;
    flush(): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: any[]): void;
    traceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    write(message: string): void;
    write(o: any): void;
    write(message: string, category: string): void;
    write(o: any, category: string): void;
    writeLine(message: string): void;
    writeLine(o: any): void;
    writeLine(message: string, category: string): void;
    writeLine(o: any, category: string): void;
}


export interface __TraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type TraceListener = TraceListener$instance & __TraceListener$views;


export class TraceListenerCollection$instance {
    readonly count: int;
    add(listener: TraceListener): int;
    addRange(value: TraceListener[]): void;
    addRange(value: TraceListenerCollection): void;
    clear(): void;
    contains(listener: TraceListener): boolean;
    copyTo(listeners: TraceListener[], index: int): void;
    get_Item(i: int): TraceListener;
    get_Item(name: string): TraceListener;
    getEnumerator(): IEnumerator;
    indexOf(listener: TraceListener): int;
    insert(index: int, listener: TraceListener): void;
    remove(listener: TraceListener): void;
    remove(name: string): void;
    removeAt(index: int): void;
    set_Item(i: int, value: TraceListener): void;
}


export interface __TraceListenerCollection$views {
    readonly As_ICollection: System_Collections_Internal.ICollection$instance;
    readonly As_IEnumerable: System_Collections_Internal.IEnumerable$instance;
    readonly As_IList: System_Collections_Internal.IList$instance;
}

export type TraceListenerCollection = TraceListenerCollection$instance & __TraceListenerCollection$views;


export class TraceSource$instance {
    constructor(name: string);
    constructor(name: string, defaultLevel: SourceLevels);
    readonly attributes: StringDictionary;
    readonly defaultLevel: SourceLevels;
    readonly listeners: TraceListenerCollection;
    readonly name: string;
    switch_: SourceSwitch;
    close(): void;
    flush(): void;
    traceData(eventType: TraceEventType, id: int, data: any): void;
    traceData(eventType: TraceEventType, id: int, data: any[]): void;
    traceEvent(eventType: TraceEventType, id: int): void;
    traceEvent(eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventType: TraceEventType, id: int, format: string, args: any[]): void;
    traceInformation(message: string): void;
    traceInformation(format: string, args: any[]): void;
    traceTransfer(id: int, message: string, relatedActivityId: Guid): void;
}


export type TraceSource = TraceSource$instance;

export class TraceSwitch$instance extends Switch$instance {
    constructor(displayName: string, description: string);
    constructor(displayName: string, description: string, defaultSwitchValue: string);
    level: TraceLevel;
    readonly traceError: boolean;
    readonly traceInfo: boolean;
    readonly traceVerbose: boolean;
    readonly traceWarning: boolean;
}


export type TraceSwitch = TraceSwitch$instance;

export class UnreachableException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: Exception);
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __UnreachableException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnreachableException = UnreachableException$instance & __UnreachableException$views;


export class XmlWriterTraceListener$instance extends TextWriterTraceListener$instance {
    constructor(stream: Stream);
    constructor(stream: Stream, name: string);
    constructor(writer: TextWriter);
    constructor(writer: TextWriter, name: string);
    constructor(filename: string);
    constructor(filename: string, name: string);
    close(): void;
    dispose(): void;
    fail(message: string, detailMessage: string): void;
    fail(message: string): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any): void;
    traceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: any[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, args: any[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    traceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    traceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    write(message: string): void;
    write(o: any): void;
    write(message: string, category: string): void;
    write(o: any, category: string): void;
    writeLine(message: string): void;
    writeLine(o: any): void;
    writeLine(message: string, category: string): void;
    writeLine(o: any, category: string): void;
}


export interface __XmlWriterTraceListener$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type XmlWriterTraceListener = XmlWriterTraceListener$instance & __XmlWriterTraceListener$views;


export abstract class Debug$instance {
    static AutoFlush: boolean;
    static IndentLevel: int;
    static IndentSize: int;
    static Assert(condition: boolean, message: { value: TSByRef<Debug_AssertInterpolatedStringHandler> }, detailMessage: { value: TSByRef<Debug_AssertInterpolatedStringHandler> }): void;
    static Assert(condition: boolean, message: { value: TSByRef<Debug_AssertInterpolatedStringHandler> }): void;
    static Assert(condition: boolean, message: string, detailMessageFormat: string, args: any[]): void;
    static Assert(condition: boolean, message: string, detailMessage: string): void;
    static Assert(condition: boolean, message?: string): void;
    static Assert(condition: boolean): void;
    static Close(): void;
    static Fail(message: string, detailMessage: string): void;
    static Fail(message: string): void;
    static Flush(): void;
    static Indent(): void;
    static Print(format: string, args: any[]): void;
    static Print(message: string): void;
    static SetProvider(provider: DebugProvider): DebugProvider;
    static Unindent(): void;
    static Write(value: any, category: string): void;
    static Write(value: any): void;
    static Write(message: string, category: string): void;
    static Write(message: string): void;
    static WriteIf(condition: boolean, message: { value: TSByRef<Debug_WriteIfInterpolatedStringHandler> }, category: string): void;
    static WriteIf(condition: boolean, message: { value: TSByRef<Debug_WriteIfInterpolatedStringHandler> }): void;
    static WriteIf(condition: boolean, value: any, category: string): void;
    static WriteIf(condition: boolean, value: any): void;
    static WriteIf(condition: boolean, message: string, category: string): void;
    static WriteIf(condition: boolean, message: string): void;
    static WriteLine(value: any, category: string): void;
    static WriteLine(value: any): void;
    static WriteLine(format: string, args: any[]): void;
    static WriteLine(message: string, category: string): void;
    static WriteLine(message: string): void;
    static WriteLineIf(condition: boolean, message: { value: TSByRef<Debug_WriteIfInterpolatedStringHandler> }, category: string): void;
    static WriteLineIf(condition: boolean, message: { value: TSByRef<Debug_WriteIfInterpolatedStringHandler> }): void;
    static WriteLineIf(condition: boolean, value: any, category: string): void;
    static WriteLineIf(condition: boolean, value: any): void;
    static WriteLineIf(condition: boolean, message: string, category: string): void;
    static WriteLineIf(condition: boolean, message: string): void;
}


export type Debug = Debug$instance;

export abstract class Debugger$instance {
    static readonly defaultCategory: string;
    static readonly IsAttached: boolean;
    static Break(): void;
    static BreakForUserUnhandledException(exception: Exception): void;
    static IsLogging(): boolean;
    static Launch(): boolean;
    static Log(level: int, category: string, message: string): void;
    static NotifyOfCrossThreadDependency(): void;
}


export type Debugger = Debugger$instance;

export abstract class StackFrameExtensions$instance {
    static GetNativeImageBase(stackFrame: StackFrame): nint;
    static GetNativeIP(stackFrame: StackFrame): nint;
    static HasILOffset(stackFrame: StackFrame): boolean;
    static HasMethod(stackFrame: StackFrame): boolean;
    static HasNativeImage(stackFrame: StackFrame): boolean;
    static HasSource(stackFrame: StackFrame): boolean;
}


export type StackFrameExtensions = StackFrameExtensions$instance;

