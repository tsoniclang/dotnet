// Generated by tsbindgen - Architecture
// Namespace: System.Data.Common
// Assembly: System.Data.Common

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AttributeCollection, Component, EventDescriptor, EventDescriptorCollection, IComponent, IContainer, ICustomTypeDescriptor, ISite, PropertyDescriptor, PropertyDescriptorCollection, TypeConverter } from "../../System.ComponentModel/internal/index.js";
import * as System_Data_Internal from "../../System.Data/internal/index.js";
import type { CommandBehavior, CommandType, ConflictOption, ConnectionState, DataColumn, DataRow, DataRowVersion, DataSet, DataTable, DbType, FillErrorEventHandler, IColumnMapping, IColumnMappingCollection, IDataAdapter, IDataParameter, IDataParameterCollection, IDataReader, IDataRecord, IDbCommand, IDbConnection, IDbDataAdapter, IDbDataParameter, IDbTransaction, IsolationLevel, ITableMapping, ITableMappingCollection, LoadOption, MissingMappingAction, MissingSchemaAction, ParameterDirection, SchemaType, StateChangeEventHandler, StatementType, UpdateRowSource, UpdateStatus } from "../../System.Data/internal/index.js";
import type { Stream, TextReader } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ExternalException } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { Transaction } from "../../System.Transactions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Enum, EventArgs, Exception, Guid, IAsyncDisposable, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, MarshalByRefObject, Nullable_1, Object as ClrObject, Single, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CatalogLocation {
    start = 1,
    end = 2
}


export enum GroupByBehavior {
    unknown_ = 0,
    notSupported = 1,
    unrelated = 2,
    mustContainAll = 3,
    exactMatch = 4
}


export enum IdentifierCase {
    unknown_ = 0,
    insensitive = 1,
    sensitive = 2
}


export enum SupportedJoinOperators {
    none = 0,
    inner = 1,
    leftOuter = 2,
    rightOuter = 4,
    fullOuter = 8
}


export interface IDbColumnSchemaGenerator$instance {
    getColumnSchema(): ReadOnlyCollection_1<DbColumn>;
}


export type IDbColumnSchemaGenerator = IDbColumnSchemaGenerator$instance;

export class DataAdapter$instance extends System_ComponentModel_Internal.Component$instance {
    acceptChangesDuringFill: boolean;
    acceptChangesDuringUpdate: boolean;
    continueUpdateOnError: boolean;
    fillLoadOption: LoadOption;
    missingMappingAction: MissingMappingAction;
    missingSchemaAction: MissingSchemaAction;
    returnProviderSpecificTypes: boolean;
    readonly tableMappings: DataTableMappingCollection | ITableMappingCollection;
    dispose(): void;
    fill(dataSet: DataSet): int;
    fillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    getFillParameters(): IDataParameter[];
    resetFillLoadOption(): void;
    shouldSerializeAcceptChangesDuringFill(): boolean;
    shouldSerializeFillLoadOption(): boolean;
    update(dataSet: DataSet): int;
}


export interface __DataAdapter$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDataAdapter(): System_Data_Internal.IDataAdapter$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DataAdapter$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type DataAdapter = DataAdapter$instance & __DataAdapter$views;


export class DataColumnMapping$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    constructor(sourceColumn: string, dataSetColumn: string);
    dataSetColumn: string;
    sourceColumn: string;
    getDataColumnBySchemaAction(dataTable: DataTable, dataType: Type, schemaAction: MissingSchemaAction): DataColumn;
    toString(): string;
    static getDataColumnBySchemaAction(sourceColumn: string, dataSetColumn: string, dataTable: DataTable, dataType: Type, schemaAction: MissingSchemaAction): DataColumn;
}


export interface __DataColumnMapping$views {
    As_IColumnMapping(): System_Data_Internal.IColumnMapping$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface DataColumnMapping$instance extends System_Data_Internal.IColumnMapping$instance, System_Internal.ICloneable$instance {}

export type DataColumnMapping = DataColumnMapping$instance & __DataColumnMapping$views;


export class DataColumnMappingCollection$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    readonly count: int;
    add(value: unknown): int;
    add(sourceColumn: string, dataSetColumn: string): DataColumnMapping;
    addRange(values: DataColumnMapping[]): void;
    addRange(values: ClrArray): void;
    clear(): void;
    contains(value: string): boolean;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: DataColumnMapping[], index: int): void;
    get_Item(index: int): DataColumnMapping;
    get_Item(sourceColumn: string): DataColumnMapping;
    getByDataSetColumn(value: string): DataColumnMapping;
    getEnumerator(): IEnumerator;
    indexOf(value: unknown): int;
    indexOf(sourceColumn: string): int;
    indexOfDataSetColumn(dataSetColumn: string): int;
    insert(index: int, value: unknown): void;
    insert(index: int, value: DataColumnMapping): void;
    remove(value: unknown): void;
    remove(value: DataColumnMapping): void;
    removeAt(index: int): void;
    removeAt(sourceColumn: string): void;
    set_Item(index: int, value: DataColumnMapping): void;
    set_Item(sourceColumn: string, value: DataColumnMapping): void;
    static getColumnMappingBySchemaAction(columnMappings: DataColumnMappingCollection, sourceColumn: string, mappingAction: MissingMappingAction): DataColumnMapping;
    static getDataColumn(columnMappings: DataColumnMappingCollection, sourceColumn: string, dataType: Type, dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction): DataColumn;
}


export interface __DataColumnMappingCollection$views {
    As_IColumnMappingCollection(): System_Data_Internal.IColumnMappingCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DataColumnMappingCollection = DataColumnMappingCollection$instance & __DataColumnMappingCollection$views;


export class DataTableMapping$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    constructor(sourceTable: string, dataSetTable: string);
    constructor(sourceTable: string, dataSetTable: string, columnMappings: DataColumnMapping[]);
    readonly columnMappings: DataColumnMappingCollection | IColumnMappingCollection;
    dataSetTable: string;
    sourceTable: string;
    getColumnMappingBySchemaAction(sourceColumn: string, mappingAction: MissingMappingAction): DataColumnMapping;
    getDataColumn(sourceColumn: string, dataType: Type, dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction): DataColumn;
    getDataTableBySchemaAction(dataSet: DataSet, schemaAction: MissingSchemaAction): DataTable;
    toString(): string;
}


export interface __DataTableMapping$views {
    As_ITableMapping(): System_Data_Internal.ITableMapping$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface DataTableMapping$instance extends System_Internal.ICloneable$instance {}

export type DataTableMapping = DataTableMapping$instance & __DataTableMapping$views;


export class DataTableMappingCollection$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    readonly count: int;
    add(value: unknown): int;
    add(sourceTable: string, dataSetTable: string): DataTableMapping;
    addRange(values: DataTableMapping[]): void;
    addRange(values: ClrArray): void;
    clear(): void;
    contains(value: string): boolean;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: DataTableMapping[], index: int): void;
    get_Item(index: int): DataTableMapping;
    get_Item(sourceTable: string): DataTableMapping;
    getByDataSetTable(dataSetTable: string): DataTableMapping;
    getEnumerator(): IEnumerator;
    indexOf(value: unknown): int;
    indexOf(sourceTable: string): int;
    indexOfDataSetTable(dataSetTable: string): int;
    insert(index: int, value: unknown): void;
    insert(index: int, value: DataTableMapping): void;
    remove(value: unknown): void;
    remove(value: DataTableMapping): void;
    removeAt(index: int): void;
    removeAt(sourceTable: string): void;
    set_Item(index: int, value: DataTableMapping): void;
    set_Item(sourceTable: string, value: DataTableMapping): void;
    static getTableMappingBySchemaAction(tableMappings: DataTableMappingCollection, sourceTable: string, dataSetTable: string, mappingAction: MissingMappingAction): DataTableMapping;
}


export interface __DataTableMappingCollection$views {
    As_ITableMappingCollection(): System_Data_Internal.ITableMappingCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DataTableMappingCollection = DataTableMappingCollection$instance & __DataTableMappingCollection$views;


export abstract class DbBatch$instance {
    readonly batchCommands: DbBatchCommandCollection;
    connection: DbConnection;
    timeout: int;
    transaction: DbTransaction;
    abstract cancel(): void;
    createBatchCommand(): DbBatchCommand;
    dispose(): void;
    disposeAsync(): ValueTask;
    abstract executeNonQuery(): int;
    abstract executeNonQueryAsync(cancellationToken?: CancellationToken): Task_1<CLROf<int>>;
    executeReader(behavior?: CommandBehavior): DbDataReader;
    executeReaderAsync(cancellationToken?: CancellationToken): Task_1<DbDataReader>;
    executeReaderAsync(behavior: CommandBehavior, cancellationToken?: CancellationToken): Task_1<DbDataReader>;
    abstract executeScalar(): unknown;
    abstract executeScalarAsync(cancellationToken?: CancellationToken): Task_1<unknown>;
    abstract prepare(): void;
    abstract prepareAsync(cancellationToken?: CancellationToken): Task;
}


export interface __DbBatch$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbBatch$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type DbBatch = DbBatch$instance & __DbBatch$views;


export abstract class DbBatchCommand$instance {
    readonly canCreateParameter: boolean;
    commandText: string;
    commandType: CommandType;
    readonly parameters: DbParameterCollection;
    readonly recordsAffected: int;
    createParameter(): DbParameter;
}


export type DbBatchCommand = DbBatchCommand$instance;

export abstract class DbBatchCommandCollection$instance {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: DbBatchCommand;
    abstract add(item: DbBatchCommand): void;
    abstract clear(): void;
    abstract contains(item: DbBatchCommand): boolean;
    abstract copyTo(array: DbBatchCommand[], arrayIndex: int): void;
    abstract getEnumerator(): IEnumerator_1<DbBatchCommand>;
    abstract indexOf(item: DbBatchCommand): int;
    abstract insert(index: int, item: DbBatchCommand): void;
    abstract remove(item: DbBatchCommand): boolean;
    abstract removeAt(index: int): void;
}


export interface __DbBatchCommandCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<DbBatchCommand>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<DbBatchCommand>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<DbBatchCommand>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DbBatchCommandCollection = DbBatchCommandCollection$instance & __DbBatchCommandCollection$views;


export abstract class DbColumn$instance {
    readonly allowDBNull: Nullable_1<CLROf<boolean>>;
    readonly baseCatalogName: string;
    readonly baseColumnName: string;
    readonly baseSchemaName: string;
    readonly baseServerName: string;
    readonly baseTableName: string;
    readonly columnName: string;
    readonly columnOrdinal: Nullable_1<CLROf<int>>;
    readonly columnSize: Nullable_1<CLROf<int>>;
    readonly dataType: Type;
    readonly dataTypeName: string;
    readonly isAliased: Nullable_1<CLROf<boolean>>;
    readonly isAutoIncrement: Nullable_1<CLROf<boolean>>;
    readonly isExpression: Nullable_1<CLROf<boolean>>;
    readonly isHidden: Nullable_1<CLROf<boolean>>;
    readonly isIdentity: Nullable_1<CLROf<boolean>>;
    readonly isKey: Nullable_1<CLROf<boolean>>;
    readonly isLong: Nullable_1<CLROf<boolean>>;
    readonly isReadOnly: Nullable_1<CLROf<boolean>>;
    readonly isUnique: Nullable_1<CLROf<boolean>>;
    readonly item: unknown;
    readonly numericPrecision: Nullable_1<CLROf<int>>;
    readonly numericScale: Nullable_1<CLROf<int>>;
    readonly udtAssemblyQualifiedName: string;
}


export type DbColumn = DbColumn$instance;

export abstract class DbCommand$instance extends System_ComponentModel_Internal.Component$instance {
    commandText: string;
    commandTimeout: int;
    commandType: CommandType;
    connection: DbConnection | IDbConnection;
    designTimeVisible: boolean;
    readonly parameters: DbParameterCollection | IDataParameterCollection;
    transaction: DbTransaction | IDbTransaction;
    updatedRowSource: UpdateRowSource;
    abstract cancel(): void;
    createParameter(): DbParameter;
    dispose(): void;
    disposeAsync(): ValueTask;
    abstract executeNonQuery(): int;
    executeNonQueryAsync(): Task_1<CLROf<int>>;
    executeNonQueryAsync(cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    executeReader(): DbDataReader;
    executeReader(behavior: CommandBehavior): DbDataReader;
    executeReaderAsync(): Task_1<DbDataReader>;
    executeReaderAsync(cancellationToken: CancellationToken): Task_1<DbDataReader>;
    executeReaderAsync(behavior: CommandBehavior): Task_1<DbDataReader>;
    executeReaderAsync(behavior: CommandBehavior, cancellationToken: CancellationToken): Task_1<DbDataReader>;
    abstract executeScalar(): unknown;
    executeScalarAsync(): Task_1<unknown>;
    executeScalarAsync(cancellationToken: CancellationToken): Task_1<unknown>;
    abstract prepare(): void;
    prepareAsync(cancellationToken?: CancellationToken): Task;
}


export interface __DbCommand$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDbCommand(): System_Data_Internal.IDbCommand$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbCommand$instance extends System_ComponentModel_Internal.IComponent$instance, System_Internal.IAsyncDisposable$instance {}

export type DbCommand = DbCommand$instance & __DbCommand$views;


export abstract class DbCommandBuilder$instance extends System_ComponentModel_Internal.Component$instance {
    catalogLocation: CatalogLocation;
    catalogSeparator: string;
    conflictOption: ConflictOption;
    dataAdapter: DbDataAdapter;
    quotePrefix: string;
    quoteSuffix: string;
    schemaSeparator: string;
    setAllValues: boolean;
    dispose(): void;
    getDeleteCommand(): DbCommand;
    getDeleteCommand(useColumnsForParameterNames: boolean): DbCommand;
    getInsertCommand(): DbCommand;
    getInsertCommand(useColumnsForParameterNames: boolean): DbCommand;
    getUpdateCommand(): DbCommand;
    getUpdateCommand(useColumnsForParameterNames: boolean): DbCommand;
    quoteIdentifier(unquotedIdentifier: string): string;
    refreshSchema(): void;
    unquoteIdentifier(quotedIdentifier: string): string;
}


export interface __DbCommandBuilder$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbCommandBuilder$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type DbCommandBuilder = DbCommandBuilder$instance & __DbCommandBuilder$views;


export abstract class DbConnection$instance extends System_ComponentModel_Internal.Component$instance {
    readonly canCreateBatch: boolean;
    connectionString: string;
    readonly connectionTimeout: int;
    readonly database: string;
    readonly dataSource: string;
    readonly serverVersion: string;
    readonly state: ConnectionState;
    beginTransaction(): DbTransaction;
    beginTransaction(isolationLevel: IsolationLevel): DbTransaction;
    beginTransactionAsync(cancellationToken?: CancellationToken): ValueTask_1<DbTransaction>;
    beginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): ValueTask_1<DbTransaction>;
    abstract changeDatabase(databaseName: string): void;
    changeDatabaseAsync(databaseName: string, cancellationToken?: CancellationToken): Task;
    abstract close(): void;
    closeAsync(): Task;
    createBatch(): DbBatch;
    createCommand(): DbCommand;
    dispose(): void;
    disposeAsync(): ValueTask;
    enlistTransaction(transaction: Transaction): void;
    getSchema(): DataTable;
    getSchema(collectionName: string): DataTable;
    getSchema(collectionName: string, restrictionValues: string[]): DataTable;
    getSchemaAsync(cancellationToken?: CancellationToken): Task_1<DataTable>;
    getSchemaAsync(collectionName: string, cancellationToken?: CancellationToken): Task_1<DataTable>;
    getSchemaAsync(collectionName: string, restrictionValues: string[], cancellationToken?: CancellationToken): Task_1<DataTable>;
    abstract open(): void;
    openAsync(): Task;
    openAsync(cancellationToken: CancellationToken): Task;
}


export interface __DbConnection$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDbConnection(): System_Data_Internal.IDbConnection$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbConnection$instance extends System_ComponentModel_Internal.IComponent$instance, System_Internal.IAsyncDisposable$instance {}

export type DbConnection = DbConnection$instance & __DbConnection$views;


export class DbConnectionStringBuilder$instance {
    constructor();
    constructor(useOdbcRules: boolean);
    browsableConnectionString: boolean;
    connectionString: string;
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    item: unknown;
    readonly keys: ICollection;
    readonly values: ICollection;
    add(keyword: string, value: unknown): void;
    clear(): void;
    containsKey(keyword: string): boolean;
    equivalentTo(connectionStringBuilder: DbConnectionStringBuilder): boolean;
    remove(keyword: string): boolean;
    shouldSerialize(keyword: string): boolean;
    toString(): string;
    tryGetValue(keyword: string, value: { value: ref<unknown> }): boolean;
    static appendKeyValuePair(builder: StringBuilder, keyword: string, value: string, useOdbcRules: boolean): void;
    static appendKeyValuePair(builder: StringBuilder, keyword: string, value: string): void;
}


export interface __DbConnectionStringBuilder$views {
    As_ICustomTypeDescriptor(): System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface DbConnectionStringBuilder$instance extends System_ComponentModel_Internal.ICustomTypeDescriptor$instance {}

export type DbConnectionStringBuilder = DbConnectionStringBuilder$instance & __DbConnectionStringBuilder$views;


export abstract class DbDataAdapter$instance extends DataAdapter$instance {
    deleteCommand: DbCommand | IDbCommand;
    insertCommand: DbCommand | IDbCommand;
    selectCommand: DbCommand | IDbCommand;
    updateBatchSize: int;
    updateCommand: DbCommand | IDbCommand;
    dispose(): void;
    fill(dataSet: DataSet): int;
    fill(dataTable: DataTable): int;
    fillSchema(dataTable: DataTable, schemaType: SchemaType): DataTable;
    fillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    getFillParameters(): IDataParameter[];
    update(dataSet: DataSet): int;
    update(dataTable: DataTable): int;
    static readonly defaultSourceTableName: string;
}


export interface __DbDataAdapter$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDataAdapter(): System_Data_Internal.IDataAdapter$instance;
    As_IDbDataAdapter(): System_Data_Internal.IDbDataAdapter$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbDataAdapter$instance extends System_Internal.ICloneable$instance {}

export type DbDataAdapter = DbDataAdapter$instance & __DbDataAdapter$views;


export abstract class DbDataReader$instance extends System_Internal.MarshalByRefObject$instance {
    readonly depth: int;
    readonly fieldCount: int;
    readonly hasRows: boolean;
    readonly isClosed: boolean;
    readonly recordsAffected: int;
    readonly visibleFieldCount: int;
    close(): void;
    closeAsync(): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    get_Item(ordinal: int): unknown;
    get_Item(name: string): unknown;
    abstract getBoolean(ordinal: int): boolean;
    abstract getByte(ordinal: int): byte;
    abstract getBytes(ordinal: int, dataOffset: long, buffer: byte[], bufferOffset: int, length: int): long;
    abstract getChar(ordinal: int): char;
    abstract getChars(ordinal: int, dataOffset: long, buffer: char[], bufferOffset: int, length: int): long;
    getColumnSchemaAsync(cancellationToken?: CancellationToken): Task_1<ReadOnlyCollection_1<DbColumn>>;
    getData(ordinal: int): DbDataReader;
    abstract getDataTypeName(ordinal: int): string;
    abstract getDateTime(ordinal: int): DateTime;
    abstract getDecimal(ordinal: int): decimal;
    abstract getDouble(ordinal: int): double;
    abstract getEnumerator(): IEnumerator;
    abstract getFieldType(ordinal: int): Type;
    getFieldValue<T>(ordinal: int): T;
    getFieldValueAsync<T>(ordinal: int): Task_1<T>;
    getFieldValueAsync<T>(ordinal: int, cancellationToken: CancellationToken): Task_1<T>;
    abstract getFloat(ordinal: int): float;
    abstract getGuid(ordinal: int): Guid;
    abstract getInt16(ordinal: int): short;
    abstract getInt32(ordinal: int): int;
    abstract getInt64(ordinal: int): long;
    abstract getName(ordinal: int): string;
    abstract getOrdinal(name: string): int;
    getProviderSpecificFieldType(ordinal: int): Type;
    getProviderSpecificValue(ordinal: int): unknown;
    getProviderSpecificValues(values: unknown[]): int;
    getSchemaTable(): DataTable;
    getSchemaTableAsync(cancellationToken?: CancellationToken): Task_1<DataTable>;
    getStream(ordinal: int): Stream;
    abstract getString(ordinal: int): string;
    getTextReader(ordinal: int): TextReader;
    abstract getValue(ordinal: int): unknown;
    abstract getValues(values: unknown[]): int;
    abstract isDBNull(ordinal: int): boolean;
    isDBNullAsync(ordinal: int): Task_1<CLROf<boolean>>;
    isDBNullAsync(ordinal: int, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    abstract nextResult(): boolean;
    nextResultAsync(): Task_1<CLROf<boolean>>;
    nextResultAsync(cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    abstract read(): boolean;
    readAsync(): Task_1<CLROf<boolean>>;
    readAsync(cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
}


export interface __DbDataReader$views {
    As_IDataReader(): System_Data_Internal.IDataReader$instance;
    As_IDataRecord(): System_Data_Internal.IDataRecord$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbDataReader$instance extends System_Collections_Internal.IEnumerable$instance, System_Internal.IAsyncDisposable$instance {}

export type DbDataReader = DbDataReader$instance & __DbDataReader$views;


export abstract class DbDataRecord$instance {
    readonly fieldCount: int;
    get_Item(i: int): unknown;
    get_Item(name: string): unknown;
    abstract getBoolean(i: int): boolean;
    abstract getByte(i: int): byte;
    abstract getBytes(i: int, dataIndex: long, buffer: byte[], bufferIndex: int, length: int): long;
    abstract getChar(i: int): char;
    abstract getChars(i: int, dataIndex: long, buffer: char[], bufferIndex: int, length: int): long;
    getData(i: int): IDataReader;
    abstract getDataTypeName(i: int): string;
    abstract getDateTime(i: int): DateTime;
    abstract getDecimal(i: int): decimal;
    abstract getDouble(i: int): double;
    abstract getFieldType(i: int): Type;
    abstract getFloat(i: int): float;
    abstract getGuid(i: int): Guid;
    abstract getInt16(i: int): short;
    abstract getInt32(i: int): int;
    abstract getInt64(i: int): long;
    abstract getName(i: int): string;
    abstract getOrdinal(name: string): int;
    abstract getString(i: int): string;
    abstract getValue(i: int): unknown;
    abstract getValues(values: unknown[]): int;
    abstract isDBNull(i: int): boolean;
}


export interface __DbDataRecord$views {
    As_ICustomTypeDescriptor(): System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    As_IDataRecord(): System_Data_Internal.IDataRecord$instance;
}

export interface DbDataRecord$instance extends System_ComponentModel_Internal.ICustomTypeDescriptor$instance, System_Data_Internal.IDataRecord$instance {}

export type DbDataRecord = DbDataRecord$instance & __DbDataRecord$views;


export abstract class DbDataSource$instance {
    readonly connectionString: string;
    createBatch(): DbBatch;
    createCommand(commandText?: string): DbCommand;
    createConnection(): DbConnection;
    dispose(): void;
    disposeAsync(): ValueTask;
    openConnection(): DbConnection;
    openConnectionAsync(cancellationToken?: CancellationToken): ValueTask_1<DbConnection>;
}


export interface __DbDataSource$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbDataSource$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type DbDataSource = DbDataSource$instance & __DbDataSource$views;


export abstract class DbDataSourceEnumerator$instance {
    abstract getDataSources(): DataTable;
}


export type DbDataSourceEnumerator = DbDataSourceEnumerator$instance;

export class DbEnumerator$instance {
    constructor(reader: IDataReader);
    constructor(reader: IDataReader, closeReader: boolean);
    constructor(reader: DbDataReader);
    constructor(reader: DbDataReader, closeReader: boolean);
    readonly current: unknown;
    moveNext(): boolean;
    reset(): void;
}


export interface __DbEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export interface DbEnumerator$instance extends System_Collections_Internal.IEnumerator$instance {}

export type DbEnumerator = DbEnumerator$instance & __DbEnumerator$views;


export abstract class DbException$instance extends System_Runtime_InteropServices_Internal.ExternalException$instance {
    readonly batchCommand: DbBatchCommand;
    readonly isTransient: boolean;
    readonly sqlState: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DbException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DbException = DbException$instance & __DbException$views;


export abstract class DbParameter$instance extends System_Internal.MarshalByRefObject$instance {
    dbType: DbType;
    direction: ParameterDirection;
    isNullable: boolean;
    parameterName: string;
    precision: byte;
    scale: byte;
    size: int;
    sourceColumn: string;
    sourceColumnNullMapping: boolean;
    sourceVersion: DataRowVersion;
    value: unknown;
    abstract resetDbType(): void;
}


export interface __DbParameter$views {
    As_IDataParameter(): System_Data_Internal.IDataParameter$instance;
    As_IDbDataParameter(): System_Data_Internal.IDbDataParameter$instance;
}

export type DbParameter = DbParameter$instance & __DbParameter$views;


export abstract class DbParameterCollection$instance extends System_Internal.MarshalByRefObject$instance {
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    abstract add(value: unknown): int;
    abstract addRange(values: ClrArray): void;
    abstract clear(): void;
    abstract contains(value: unknown): boolean;
    abstract contains(value: string): boolean;
    abstract copyTo(array: ClrArray, index: int): void;
    get_Item(index: int): DbParameter;
    get_Item(parameterName: string): DbParameter;
    abstract getEnumerator(): IEnumerator;
    abstract indexOf(value: unknown): int;
    abstract indexOf(parameterName: string): int;
    abstract insert(index: int, value: unknown): void;
    abstract remove(value: unknown): void;
    abstract removeAt(index: int): void;
    abstract removeAt(parameterName: string): void;
    set_Item(index: int, value: DbParameter): void;
    set_Item(parameterName: string, value: DbParameter): void;
}


export interface __DbParameterCollection$views {
    As_IDataParameterCollection(): System_Data_Internal.IDataParameterCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DbParameterCollection = DbParameterCollection$instance & __DbParameterCollection$views;


export abstract class DbProviderFactory$instance {
    readonly canCreateBatch: boolean;
    readonly canCreateCommandBuilder: boolean;
    readonly canCreateDataAdapter: boolean;
    readonly canCreateDataSourceEnumerator: boolean;
    createBatch(): DbBatch;
    createBatchCommand(): DbBatchCommand;
    createCommand(): DbCommand;
    createCommandBuilder(): DbCommandBuilder;
    createConnection(): DbConnection;
    createConnectionStringBuilder(): DbConnectionStringBuilder;
    createDataAdapter(): DbDataAdapter;
    createDataSource(connectionString: string): DbDataSource;
    createDataSourceEnumerator(): DbDataSourceEnumerator;
    createParameter(): DbParameter;
}


export type DbProviderFactory = DbProviderFactory$instance;

export class DbProviderSpecificTypePropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isProviderSpecificTypeProperty: boolean);
    readonly isProviderSpecificTypeProperty: boolean;
}


export type DbProviderSpecificTypePropertyAttribute = DbProviderSpecificTypePropertyAttribute$instance;

export abstract class DbTransaction$instance extends System_Internal.MarshalByRefObject$instance {
    readonly connection: DbConnection | IDbConnection;
    readonly isolationLevel: IsolationLevel;
    readonly supportsSavepoints: boolean;
    abstract commit(): void;
    commitAsync(cancellationToken?: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    release(savepointName: string): void;
    releaseAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
    rollback(): void;
    rollback(savepointName: string): void;
    rollbackAsync(cancellationToken?: CancellationToken): Task;
    rollbackAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
    save(savepointName: string): void;
    saveAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
}


export interface __DbTransaction$views {
    As_IDbTransaction(): System_Data_Internal.IDbTransaction$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbTransaction$instance extends System_Internal.IAsyncDisposable$instance {}

export type DbTransaction = DbTransaction$instance & __DbTransaction$views;


export class RowUpdatedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping);
    readonly command: IDbCommand;
    errors: Exception;
    readonly recordsAffected: int;
    readonly row: DataRow;
    readonly rowCount: int;
    readonly statementType: StatementType;
    status: UpdateStatus;
    readonly tableMapping: DataTableMapping;
    copyToRows(array: DataRow[]): void;
    copyToRows(array: DataRow[], arrayIndex: int): void;
}


export type RowUpdatedEventArgs = RowUpdatedEventArgs$instance;

export class RowUpdatingEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping);
    command: IDbCommand;
    errors: Exception;
    readonly row: DataRow;
    readonly statementType: StatementType;
    status: UpdateStatus;
    readonly tableMapping: DataTableMapping;
}


export type RowUpdatingEventArgs = RowUpdatingEventArgs$instance;

export abstract class DbDataReaderExtensions$instance {
    static canGetColumnSchema(reader: DbDataReader): boolean;
    static getColumnSchema(reader: DbDataReader): ReadOnlyCollection_1<DbColumn>;
}


export type DbDataReaderExtensions = DbDataReaderExtensions$instance;

export abstract class DbMetaDataCollectionNames$instance {
    static readonly metaDataCollections: string;
    static readonly dataSourceInformation: string;
    static readonly dataTypes: string;
    static readonly restrictions: string;
    static readonly reservedWords: string;
}


export type DbMetaDataCollectionNames = DbMetaDataCollectionNames$instance;

export abstract class DbMetaDataColumnNames$instance {
    static readonly collectionName: string;
    static readonly columnSize: string;
    static readonly compositeIdentifierSeparatorPattern: string;
    static readonly createFormat: string;
    static readonly createParameters: string;
    static readonly dataSourceProductName: string;
    static readonly dataSourceProductVersion: string;
    static readonly dataType: string;
    static readonly dataSourceProductVersionNormalized: string;
    static readonly groupByBehavior: string;
    static readonly identifierCase: string;
    static readonly identifierPattern: string;
    static readonly isAutoIncrementable: string;
    static readonly isBestMatch: string;
    static readonly isCaseSensitive: string;
    static readonly isConcurrencyType: string;
    static readonly isFixedLength: string;
    static readonly isFixedPrecisionScale: string;
    static readonly isLiteralSupported: string;
    static readonly isLong: string;
    static readonly isNullable: string;
    static readonly isSearchable: string;
    static readonly isSearchableWithLike: string;
    static readonly isUnsigned: string;
    static readonly literalPrefix: string;
    static readonly literalSuffix: string;
    static readonly maximumScale: string;
    static readonly minimumScale: string;
    static readonly numberOfIdentifierParts: string;
    static readonly numberOfRestrictions: string;
    static readonly orderByColumnsInSelect: string;
    static readonly parameterMarkerFormat: string;
    static readonly parameterMarkerPattern: string;
    static readonly parameterNameMaxLength: string;
    static readonly parameterNamePattern: string;
    static readonly providerDbType: string;
    static readonly quotedIdentifierCase: string;
    static readonly quotedIdentifierPattern: string;
    static readonly reservedWord: string;
    static readonly statementSeparatorPattern: string;
    static readonly stringLiteralPattern: string;
    static readonly supportedJoinOperators: string;
    static readonly typeName: string;
}


export type DbMetaDataColumnNames = DbMetaDataColumnNames$instance;

export abstract class DbProviderFactories$instance {
    static getFactory(connection: DbConnection): DbProviderFactory;
    static getFactory(providerRow: DataRow): DbProviderFactory;
    static getFactory(providerInvariantName: string): DbProviderFactory;
    static getFactoryClasses(): DataTable;
    static getProviderInvariantNames(): IEnumerable_1<CLROf<string>>;
    static registerFactory(providerInvariantName: string, factory: DbProviderFactory): void;
    static registerFactory(providerInvariantName: string, factoryTypeAssemblyQualifiedName: string): void;
    static registerFactory(providerInvariantName: string, providerFactoryClass: Type): void;
    static tryGetFactory(providerInvariantName: string, factory: { value: ref<DbProviderFactory> }): boolean;
    static unregisterFactory(providerInvariantName: string): boolean;
}


export type DbProviderFactories = DbProviderFactories$instance;

export abstract class SchemaTableColumn$instance {
    static readonly columnName: string;
    static readonly columnOrdinal: string;
    static readonly columnSize: string;
    static readonly numericPrecision: string;
    static readonly numericScale: string;
    static readonly dataType: string;
    static readonly providerType: string;
    static readonly nonVersionedProviderType: string;
    static readonly isLong: string;
    static readonly allowDBNull: string;
    static readonly isAliased: string;
    static readonly isExpression: string;
    static readonly isKey: string;
    static readonly isUnique: string;
    static readonly baseSchemaName: string;
    static readonly baseTableName: string;
    static readonly baseColumnName: string;
}


export type SchemaTableColumn = SchemaTableColumn$instance;

export abstract class SchemaTableOptionalColumn$instance {
    static readonly providerSpecificDataType: string;
    static readonly isAutoIncrement: string;
    static readonly isHidden: string;
    static readonly isReadOnly: string;
    static readonly isRowVersion: string;
    static readonly baseServerName: string;
    static readonly baseCatalogName: string;
    static readonly autoIncrementSeed: string;
    static readonly autoIncrementStep: string;
    static readonly defaultValue: string;
    static readonly expression: string;
    static readonly baseTableNamespace: string;
    static readonly baseColumnNamespace: string;
    static readonly columnMapping: string;
}


export type SchemaTableOptionalColumn = SchemaTableOptionalColumn$instance;

