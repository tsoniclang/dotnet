// Generated by tsbindgen - Architecture
// Namespace: System.Data.Common
// Assembly: System.Data.Common

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AttributeCollection, Component, EventDescriptor, EventDescriptorCollection, IComponent, IContainer, ICustomTypeDescriptor, ISite, PropertyDescriptor, PropertyDescriptorCollection, TypeConverter } from "../../System.ComponentModel/internal/index.js";
import * as System_Data_Internal from "../../System.Data/internal/index.js";
import type { CommandBehavior, CommandType, ConflictOption, ConnectionState, DataColumn, DataRow, DataRowVersion, DataSet, DataTable, DbType, FillErrorEventHandler, IColumnMapping, IColumnMappingCollection, IDataAdapter, IDataParameter, IDataParameterCollection, IDataReader, IDataRecord, IDbCommand, IDbConnection, IDbDataAdapter, IDbDataParameter, IDbTransaction, IsolationLevel, ITableMapping, ITableMappingCollection, LoadOption, MissingMappingAction, MissingSchemaAction, ParameterDirection, SchemaType, StateChangeEventHandler, StatementType, UpdateRowSource, UpdateStatus } from "../../System.Data/internal/index.js";
import type { Stream, TextReader } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ExternalException } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { Transaction } from "../../System.Transactions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Enum, EventArgs, Exception, Guid, IAsyncDisposable, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, MarshalByRefObject, Nullable_1, Object as ClrObject, Single, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CatalogLocation {
    Start = 1,
    End = 2
}


export enum GroupByBehavior {
    Unknown = 0,
    NotSupported = 1,
    Unrelated = 2,
    MustContainAll = 3,
    ExactMatch = 4
}


export enum IdentifierCase {
    Unknown = 0,
    Insensitive = 1,
    Sensitive = 2
}


export enum SupportedJoinOperators {
    None = 0,
    Inner = 1,
    LeftOuter = 2,
    RightOuter = 4,
    FullOuter = 8
}


export interface IDbColumnSchemaGenerator$instance {
    GetColumnSchema(): ReadOnlyCollection_1<DbColumn>;
}


export type IDbColumnSchemaGenerator = IDbColumnSchemaGenerator$instance;

export class DataAdapter$instance extends System_ComponentModel_Internal.Component$instance {
    AcceptChangesDuringFill: boolean;
    AcceptChangesDuringUpdate: boolean;
    ContinueUpdateOnError: boolean;
    FillLoadOption: LoadOption;
    MissingMappingAction: MissingMappingAction;
    MissingSchemaAction: MissingSchemaAction;
    ReturnProviderSpecificTypes: boolean;
    readonly TableMappings: DataTableMappingCollection | ITableMappingCollection;
    Dispose(): void;
    Fill(dataSet: DataSet): int;
    FillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    GetFillParameters(): IDataParameter[];
    ResetFillLoadOption(): void;
    ShouldSerializeAcceptChangesDuringFill(): boolean;
    ShouldSerializeFillLoadOption(): boolean;
    Update(dataSet: DataSet): int;
}


export interface __DataAdapter$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDataAdapter(): System_Data_Internal.IDataAdapter$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DataAdapter = DataAdapter$instance & __DataAdapter$views;


export class DataColumnMapping$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    constructor(sourceColumn: string, dataSetColumn: string);
    DataSetColumn: string;
    SourceColumn: string;
    GetDataColumnBySchemaAction(dataTable: DataTable, dataType: Type, schemaAction: MissingSchemaAction): DataColumn;
    ToString(): string;
    static GetDataColumnBySchemaAction(sourceColumn: string, dataSetColumn: string, dataTable: DataTable, dataType: Type, schemaAction: MissingSchemaAction): DataColumn;
}


export interface __DataColumnMapping$views {
    As_IColumnMapping(): System_Data_Internal.IColumnMapping$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type DataColumnMapping = DataColumnMapping$instance & __DataColumnMapping$views;


export class DataColumnMappingCollection$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    readonly Count: int;
    Add(value: unknown): int;
    Add(sourceColumn: string, dataSetColumn: string): DataColumnMapping;
    AddRange(values: DataColumnMapping[]): void;
    AddRange(values: ClrArray): void;
    Clear(): void;
    Contains(value: string): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: DataColumnMapping[], index: int): void;
    get_Item(index: int): DataColumnMapping;
    get_Item(sourceColumn: string): DataColumnMapping;
    GetByDataSetColumn(value: string): DataColumnMapping;
    GetEnumerator(): IEnumerator;
    IndexOf(value: unknown): int;
    IndexOf(sourceColumn: string): int;
    IndexOfDataSetColumn(dataSetColumn: string): int;
    Insert(index: int, value: unknown): void;
    Insert(index: int, value: DataColumnMapping): void;
    Remove(value: unknown): void;
    Remove(value: DataColumnMapping): void;
    RemoveAt(index: int): void;
    RemoveAt(sourceColumn: string): void;
    set_Item(index: int, value: DataColumnMapping): void;
    set_Item(sourceColumn: string, value: DataColumnMapping): void;
    static GetColumnMappingBySchemaAction(columnMappings: DataColumnMappingCollection, sourceColumn: string, mappingAction: MissingMappingAction): DataColumnMapping;
    static GetDataColumn(columnMappings: DataColumnMappingCollection, sourceColumn: string, dataType: Type, dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction): DataColumn;
}


export interface __DataColumnMappingCollection$views {
    As_IColumnMappingCollection(): System_Data_Internal.IColumnMappingCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DataColumnMappingCollection = DataColumnMappingCollection$instance & __DataColumnMappingCollection$views;


export class DataTableMapping$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    constructor(sourceTable: string, dataSetTable: string);
    constructor(sourceTable: string, dataSetTable: string, columnMappings: DataColumnMapping[]);
    readonly ColumnMappings: DataColumnMappingCollection | IColumnMappingCollection;
    DataSetTable: string;
    SourceTable: string;
    GetColumnMappingBySchemaAction(sourceColumn: string, mappingAction: MissingMappingAction): DataColumnMapping;
    GetDataColumn(sourceColumn: string, dataType: Type, dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction): DataColumn;
    GetDataTableBySchemaAction(dataSet: DataSet, schemaAction: MissingSchemaAction): DataTable;
    ToString(): string;
}


export interface __DataTableMapping$views {
    As_ITableMapping(): System_Data_Internal.ITableMapping$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type DataTableMapping = DataTableMapping$instance & __DataTableMapping$views;


export class DataTableMappingCollection$instance extends System_Internal.MarshalByRefObject$instance {
    constructor();
    readonly Count: int;
    Add(value: unknown): int;
    Add(sourceTable: string, dataSetTable: string): DataTableMapping;
    AddRange(values: DataTableMapping[]): void;
    AddRange(values: ClrArray): void;
    Clear(): void;
    Contains(value: string): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: DataTableMapping[], index: int): void;
    get_Item(index: int): DataTableMapping;
    get_Item(sourceTable: string): DataTableMapping;
    GetByDataSetTable(dataSetTable: string): DataTableMapping;
    GetEnumerator(): IEnumerator;
    IndexOf(value: unknown): int;
    IndexOf(sourceTable: string): int;
    IndexOfDataSetTable(dataSetTable: string): int;
    Insert(index: int, value: unknown): void;
    Insert(index: int, value: DataTableMapping): void;
    Remove(value: unknown): void;
    Remove(value: DataTableMapping): void;
    RemoveAt(index: int): void;
    RemoveAt(sourceTable: string): void;
    set_Item(index: int, value: DataTableMapping): void;
    set_Item(sourceTable: string, value: DataTableMapping): void;
    static GetTableMappingBySchemaAction(tableMappings: DataTableMappingCollection, sourceTable: string, dataSetTable: string, mappingAction: MissingMappingAction): DataTableMapping;
}


export interface __DataTableMappingCollection$views {
    As_ITableMappingCollection(): System_Data_Internal.ITableMappingCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DataTableMappingCollection = DataTableMappingCollection$instance & __DataTableMappingCollection$views;


export abstract class DbBatch$instance {
    readonly BatchCommands: DbBatchCommandCollection;
    Connection: DbConnection;
    Timeout: int;
    Transaction: DbTransaction;
    abstract Cancel(): void;
    CreateBatchCommand(): DbBatchCommand;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    abstract ExecuteNonQuery(): int;
    abstract ExecuteNonQueryAsync(cancellationToken?: CancellationToken): Task_1<CLROf<int>>;
    ExecuteReader(behavior?: CommandBehavior): DbDataReader;
    ExecuteReaderAsync(cancellationToken?: CancellationToken): Task_1<DbDataReader>;
    ExecuteReaderAsync(behavior: CommandBehavior, cancellationToken?: CancellationToken): Task_1<DbDataReader>;
    abstract ExecuteScalar(): unknown;
    abstract ExecuteScalarAsync(cancellationToken?: CancellationToken): Task_1<unknown>;
    abstract Prepare(): void;
    abstract PrepareAsync(cancellationToken?: CancellationToken): Task;
}


export interface __DbBatch$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbBatch = DbBatch$instance & __DbBatch$views;


export abstract class DbBatchCommand$instance {
    readonly CanCreateParameter: boolean;
    CommandText: string;
    CommandType: CommandType;
    readonly Parameters: DbParameterCollection;
    readonly RecordsAffected: int;
    CreateParameter(): DbParameter;
}


export type DbBatchCommand = DbBatchCommand$instance;

export abstract class DbBatchCommandCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: DbBatchCommand;
    abstract Add(item: DbBatchCommand): void;
    abstract Clear(): void;
    abstract Contains(item: DbBatchCommand): boolean;
    abstract CopyTo(array: DbBatchCommand[], arrayIndex: int): void;
    abstract GetEnumerator(): IEnumerator_1<DbBatchCommand>;
    abstract IndexOf(item: DbBatchCommand): int;
    abstract Insert(index: int, item: DbBatchCommand): void;
    abstract Remove(item: DbBatchCommand): boolean;
    abstract RemoveAt(index: int): void;
}


export interface __DbBatchCommandCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<DbBatchCommand>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<DbBatchCommand>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<DbBatchCommand>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DbBatchCommandCollection = DbBatchCommandCollection$instance & __DbBatchCommandCollection$views;


export abstract class DbColumn$instance {
    readonly AllowDBNull: Nullable_1<CLROf<boolean>>;
    readonly BaseCatalogName: string;
    readonly BaseColumnName: string;
    readonly BaseSchemaName: string;
    readonly BaseServerName: string;
    readonly BaseTableName: string;
    readonly ColumnName: string;
    readonly ColumnOrdinal: Nullable_1<CLROf<int>>;
    readonly ColumnSize: Nullable_1<CLROf<int>>;
    readonly DataType: Type;
    readonly DataTypeName: string;
    readonly IsAliased: Nullable_1<CLROf<boolean>>;
    readonly IsAutoIncrement: Nullable_1<CLROf<boolean>>;
    readonly IsExpression: Nullable_1<CLROf<boolean>>;
    readonly IsHidden: Nullable_1<CLROf<boolean>>;
    readonly IsIdentity: Nullable_1<CLROf<boolean>>;
    readonly IsKey: Nullable_1<CLROf<boolean>>;
    readonly IsLong: Nullable_1<CLROf<boolean>>;
    readonly IsReadOnly: Nullable_1<CLROf<boolean>>;
    readonly IsUnique: Nullable_1<CLROf<boolean>>;
    readonly Item: unknown;
    readonly NumericPrecision: Nullable_1<CLROf<int>>;
    readonly NumericScale: Nullable_1<CLROf<int>>;
    readonly UdtAssemblyQualifiedName: string;
}


export type DbColumn = DbColumn$instance;

export abstract class DbCommand$instance extends System_ComponentModel_Internal.Component$instance {
    CommandText: string;
    CommandTimeout: int;
    CommandType: CommandType;
    Connection: DbConnection | IDbConnection;
    DesignTimeVisible: boolean;
    readonly Parameters: DbParameterCollection | IDataParameterCollection;
    Transaction: DbTransaction | IDbTransaction;
    UpdatedRowSource: UpdateRowSource;
    abstract Cancel(): void;
    CreateParameter(): DbParameter;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    abstract ExecuteNonQuery(): int;
    ExecuteNonQueryAsync(): Task_1<CLROf<int>>;
    ExecuteNonQueryAsync(cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ExecuteReader(): DbDataReader;
    ExecuteReader(behavior: CommandBehavior): DbDataReader;
    ExecuteReaderAsync(): Task_1<DbDataReader>;
    ExecuteReaderAsync(cancellationToken: CancellationToken): Task_1<DbDataReader>;
    ExecuteReaderAsync(behavior: CommandBehavior): Task_1<DbDataReader>;
    ExecuteReaderAsync(behavior: CommandBehavior, cancellationToken: CancellationToken): Task_1<DbDataReader>;
    abstract ExecuteScalar(): unknown;
    ExecuteScalarAsync(): Task_1<unknown>;
    ExecuteScalarAsync(cancellationToken: CancellationToken): Task_1<unknown>;
    abstract Prepare(): void;
    PrepareAsync(cancellationToken?: CancellationToken): Task;
}


export interface __DbCommand$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDbCommand(): System_Data_Internal.IDbCommand$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbCommand = DbCommand$instance & __DbCommand$views;


export abstract class DbCommandBuilder$instance extends System_ComponentModel_Internal.Component$instance {
    CatalogLocation: CatalogLocation;
    CatalogSeparator: string;
    ConflictOption: ConflictOption;
    DataAdapter: DbDataAdapter;
    QuotePrefix: string;
    QuoteSuffix: string;
    SchemaSeparator: string;
    SetAllValues: boolean;
    Dispose(): void;
    GetDeleteCommand(): DbCommand;
    GetDeleteCommand(useColumnsForParameterNames: boolean): DbCommand;
    GetInsertCommand(): DbCommand;
    GetInsertCommand(useColumnsForParameterNames: boolean): DbCommand;
    GetUpdateCommand(): DbCommand;
    GetUpdateCommand(useColumnsForParameterNames: boolean): DbCommand;
    QuoteIdentifier(unquotedIdentifier: string): string;
    RefreshSchema(): void;
    UnquoteIdentifier(quotedIdentifier: string): string;
}


export interface __DbCommandBuilder$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbCommandBuilder = DbCommandBuilder$instance & __DbCommandBuilder$views;


export abstract class DbConnection$instance extends System_ComponentModel_Internal.Component$instance {
    readonly CanCreateBatch: boolean;
    ConnectionString: string;
    readonly ConnectionTimeout: int;
    readonly Database: string;
    readonly DataSource: string;
    readonly ServerVersion: string;
    readonly State: ConnectionState;
    BeginTransaction(): DbTransaction;
    BeginTransaction(isolationLevel: IsolationLevel): DbTransaction;
    BeginTransactionAsync(cancellationToken?: CancellationToken): ValueTask_1<DbTransaction>;
    BeginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): ValueTask_1<DbTransaction>;
    abstract ChangeDatabase(databaseName: string): void;
    ChangeDatabaseAsync(databaseName: string, cancellationToken?: CancellationToken): Task;
    abstract Close(): void;
    CloseAsync(): Task;
    CreateBatch(): DbBatch;
    CreateCommand(): DbCommand;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EnlistTransaction(transaction: Transaction): void;
    GetSchema(): DataTable;
    GetSchema(collectionName: string): DataTable;
    GetSchema(collectionName: string, restrictionValues: string[]): DataTable;
    GetSchemaAsync(cancellationToken?: CancellationToken): Task_1<DataTable>;
    GetSchemaAsync(collectionName: string, cancellationToken?: CancellationToken): Task_1<DataTable>;
    GetSchemaAsync(collectionName: string, restrictionValues: string[], cancellationToken?: CancellationToken): Task_1<DataTable>;
    abstract Open(): void;
    OpenAsync(): Task;
    OpenAsync(cancellationToken: CancellationToken): Task;
}


export interface __DbConnection$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDbConnection(): System_Data_Internal.IDbConnection$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbConnection = DbConnection$instance & __DbConnection$views;


export class DbConnectionStringBuilder$instance {
    constructor();
    constructor(useOdbcRules: boolean);
    BrowsableConnectionString: boolean;
    ConnectionString: string;
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    Item: unknown;
    readonly Keys: ICollection;
    readonly Values: ICollection;
    Add(keyword: string, value: unknown): void;
    Clear(): void;
    ContainsKey(keyword: string): boolean;
    EquivalentTo(connectionStringBuilder: DbConnectionStringBuilder): boolean;
    Remove(keyword: string): boolean;
    ShouldSerialize(keyword: string): boolean;
    ToString(): string;
    TryGetValue(keyword: string, value: { value: ref<unknown> }): boolean;
    static AppendKeyValuePair(builder: StringBuilder, keyword: string, value: string, useOdbcRules: boolean): void;
    static AppendKeyValuePair(builder: StringBuilder, keyword: string, value: string): void;
}


export interface __DbConnectionStringBuilder$views {
    As_ICustomTypeDescriptor(): System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DbConnectionStringBuilder = DbConnectionStringBuilder$instance & __DbConnectionStringBuilder$views;


export abstract class DbDataAdapter$instance extends DataAdapter$instance {
    DeleteCommand: DbCommand | IDbCommand;
    InsertCommand: DbCommand | IDbCommand;
    SelectCommand: DbCommand | IDbCommand;
    UpdateBatchSize: int;
    UpdateCommand: DbCommand | IDbCommand;
    Dispose(): void;
    Fill(dataSet: DataSet): int;
    FillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    GetFillParameters(): IDataParameter[];
    Update(dataSet: DataSet): int;
    static readonly DefaultSourceTableName: string;
}


export interface __DbDataAdapter$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDataAdapter(): System_Data_Internal.IDataAdapter$instance;
    As_IDbDataAdapter(): System_Data_Internal.IDbDataAdapter$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbDataAdapter = DbDataAdapter$instance & __DbDataAdapter$views;


export abstract class DbDataReader$instance extends System_Internal.MarshalByRefObject$instance {
    readonly Depth: int;
    readonly FieldCount: int;
    readonly HasRows: boolean;
    readonly IsClosed: boolean;
    readonly RecordsAffected: int;
    readonly VisibleFieldCount: int;
    Close(): void;
    CloseAsync(): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    get_Item(ordinal: int): unknown;
    get_Item(name: string): unknown;
    abstract GetBoolean(ordinal: int): boolean;
    abstract GetByte(ordinal: int): byte;
    abstract GetBytes(ordinal: int, dataOffset: long, buffer: byte[], bufferOffset: int, length: int): long;
    abstract GetChar(ordinal: int): char;
    abstract GetChars(ordinal: int, dataOffset: long, buffer: char[], bufferOffset: int, length: int): long;
    GetColumnSchemaAsync(cancellationToken?: CancellationToken): Task_1<ReadOnlyCollection_1<DbColumn>>;
    GetData(ordinal: int): DbDataReader;
    abstract GetDataTypeName(ordinal: int): string;
    abstract GetDateTime(ordinal: int): DateTime;
    abstract GetDecimal(ordinal: int): decimal;
    abstract GetDouble(ordinal: int): double;
    abstract GetEnumerator(): IEnumerator;
    abstract GetFieldType(ordinal: int): Type;
    GetFieldValue<T>(ordinal: int): T;
    GetFieldValueAsync<T>(ordinal: int): Task_1<T>;
    GetFieldValueAsync<T>(ordinal: int, cancellationToken: CancellationToken): Task_1<T>;
    abstract GetFloat(ordinal: int): float;
    abstract GetGuid(ordinal: int): Guid;
    abstract GetInt16(ordinal: int): short;
    abstract GetInt32(ordinal: int): int;
    abstract GetInt64(ordinal: int): long;
    abstract GetName(ordinal: int): string;
    abstract GetOrdinal(name: string): int;
    GetProviderSpecificFieldType(ordinal: int): Type;
    GetProviderSpecificValue(ordinal: int): unknown;
    GetProviderSpecificValues(values: unknown[]): int;
    GetSchemaTable(): DataTable;
    GetSchemaTableAsync(cancellationToken?: CancellationToken): Task_1<DataTable>;
    GetStream(ordinal: int): Stream;
    abstract GetString(ordinal: int): string;
    GetTextReader(ordinal: int): TextReader;
    abstract GetValue(ordinal: int): unknown;
    abstract GetValues(values: unknown[]): int;
    abstract IsDBNull(ordinal: int): boolean;
    IsDBNullAsync(ordinal: int): Task_1<CLROf<boolean>>;
    IsDBNullAsync(ordinal: int, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    abstract NextResult(): boolean;
    NextResultAsync(): Task_1<CLROf<boolean>>;
    NextResultAsync(cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    abstract Read(): boolean;
    ReadAsync(): Task_1<CLROf<boolean>>;
    ReadAsync(cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
}


export interface __DbDataReader$views {
    As_IDataReader(): System_Data_Internal.IDataReader$instance;
    As_IDataRecord(): System_Data_Internal.IDataRecord$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbDataReader = DbDataReader$instance & __DbDataReader$views;


export abstract class DbDataRecord$instance {
    readonly FieldCount: int;
    get_Item(i: int): unknown;
    get_Item(name: string): unknown;
    abstract GetBoolean(i: int): boolean;
    abstract GetByte(i: int): byte;
    abstract GetBytes(i: int, dataIndex: long, buffer: byte[], bufferIndex: int, length: int): long;
    abstract GetChar(i: int): char;
    abstract GetChars(i: int, dataIndex: long, buffer: char[], bufferIndex: int, length: int): long;
    GetData(i: int): IDataReader;
    abstract GetDataTypeName(i: int): string;
    abstract GetDateTime(i: int): DateTime;
    abstract GetDecimal(i: int): decimal;
    abstract GetDouble(i: int): double;
    abstract GetFieldType(i: int): Type;
    abstract GetFloat(i: int): float;
    abstract GetGuid(i: int): Guid;
    abstract GetInt16(i: int): short;
    abstract GetInt32(i: int): int;
    abstract GetInt64(i: int): long;
    abstract GetName(i: int): string;
    abstract GetOrdinal(name: string): int;
    abstract GetString(i: int): string;
    abstract GetValue(i: int): unknown;
    abstract GetValues(values: unknown[]): int;
    abstract IsDBNull(i: int): boolean;
}


export interface __DbDataRecord$views {
    As_ICustomTypeDescriptor(): System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    As_IDataRecord(): System_Data_Internal.IDataRecord$instance;
}

export type DbDataRecord = DbDataRecord$instance & __DbDataRecord$views;


export abstract class DbDataSource$instance {
    readonly ConnectionString: string;
    CreateBatch(): DbBatch;
    CreateCommand(commandText?: string): DbCommand;
    CreateConnection(): DbConnection;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    OpenConnection(): DbConnection;
    OpenConnectionAsync(cancellationToken?: CancellationToken): ValueTask_1<DbConnection>;
}


export interface __DbDataSource$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbDataSource = DbDataSource$instance & __DbDataSource$views;


export abstract class DbDataSourceEnumerator$instance {
    abstract GetDataSources(): DataTable;
}


export type DbDataSourceEnumerator = DbDataSourceEnumerator$instance;

export class DbEnumerator$instance {
    constructor(reader: IDataReader);
    constructor(reader: IDataReader, closeReader: boolean);
    constructor(reader: DbDataReader);
    constructor(reader: DbDataReader, closeReader: boolean);
    readonly Current: unknown;
    MoveNext(): boolean;
    Reset(): void;
}


export interface __DbEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type DbEnumerator = DbEnumerator$instance & __DbEnumerator$views;


export abstract class DbException$instance extends System_Runtime_InteropServices_Internal.ExternalException$instance {
    readonly BatchCommand: DbBatchCommand;
    readonly IsTransient: boolean;
    readonly SqlState: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __DbException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DbException = DbException$instance & __DbException$views;


export abstract class DbParameter$instance extends System_Internal.MarshalByRefObject$instance {
    DbType: DbType;
    Direction: ParameterDirection;
    IsNullable: boolean;
    ParameterName: string;
    Precision: byte;
    Scale: byte;
    Size: int;
    SourceColumn: string;
    SourceColumnNullMapping: boolean;
    SourceVersion: DataRowVersion;
    Value: unknown;
    abstract ResetDbType(): void;
}


export interface __DbParameter$views {
    As_IDataParameter(): System_Data_Internal.IDataParameter$instance;
    As_IDbDataParameter(): System_Data_Internal.IDbDataParameter$instance;
}

export type DbParameter = DbParameter$instance & __DbParameter$views;


export abstract class DbParameterCollection$instance extends System_Internal.MarshalByRefObject$instance {
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    abstract Add(value: unknown): int;
    abstract AddRange(values: ClrArray): void;
    abstract Clear(): void;
    abstract Contains(value: unknown): boolean;
    abstract Contains(value: string): boolean;
    abstract CopyTo(array: ClrArray, index: int): void;
    get_Item(index: int): DbParameter;
    get_Item(parameterName: string): DbParameter;
    abstract GetEnumerator(): IEnumerator;
    abstract IndexOf(value: unknown): int;
    abstract IndexOf(parameterName: string): int;
    abstract Insert(index: int, value: unknown): void;
    abstract Remove(value: unknown): void;
    abstract RemoveAt(index: int): void;
    abstract RemoveAt(parameterName: string): void;
    set_Item(index: int, value: DbParameter): void;
    set_Item(parameterName: string, value: DbParameter): void;
}


export interface __DbParameterCollection$views {
    As_IDataParameterCollection(): System_Data_Internal.IDataParameterCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DbParameterCollection = DbParameterCollection$instance & __DbParameterCollection$views;


export abstract class DbProviderFactory$instance {
    readonly CanCreateBatch: boolean;
    readonly CanCreateCommandBuilder: boolean;
    readonly CanCreateDataAdapter: boolean;
    readonly CanCreateDataSourceEnumerator: boolean;
    CreateBatch(): DbBatch;
    CreateBatchCommand(): DbBatchCommand;
    CreateCommand(): DbCommand;
    CreateCommandBuilder(): DbCommandBuilder;
    CreateConnection(): DbConnection;
    CreateConnectionStringBuilder(): DbConnectionStringBuilder;
    CreateDataAdapter(): DbDataAdapter;
    CreateDataSource(connectionString: string): DbDataSource;
    CreateDataSourceEnumerator(): DbDataSourceEnumerator;
    CreateParameter(): DbParameter;
}


export type DbProviderFactory = DbProviderFactory$instance;

export class DbProviderSpecificTypePropertyAttribute$instance extends System_Internal.Attribute$instance {
    constructor(isProviderSpecificTypeProperty: boolean);
    readonly IsProviderSpecificTypeProperty: boolean;
}


export type DbProviderSpecificTypePropertyAttribute = DbProviderSpecificTypePropertyAttribute$instance;

export abstract class DbTransaction$instance extends System_Internal.MarshalByRefObject$instance {
    readonly Connection: DbConnection | IDbConnection;
    readonly IsolationLevel: IsolationLevel;
    readonly SupportsSavepoints: boolean;
    abstract Commit(): void;
    CommitAsync(cancellationToken?: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Release(savepointName: string): void;
    ReleaseAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
    Rollback(): void;
    Rollback(savepointName: string): void;
    RollbackAsync(cancellationToken?: CancellationToken): Task;
    RollbackAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
    Save(savepointName: string): void;
    SaveAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
}


export interface __DbTransaction$views {
    As_IDbTransaction(): System_Data_Internal.IDbTransaction$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DbTransaction = DbTransaction$instance & __DbTransaction$views;


export class RowUpdatedEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping);
    readonly Command: IDbCommand;
    Errors: Exception;
    readonly RecordsAffected: int;
    readonly Row: DataRow;
    readonly RowCount: int;
    readonly StatementType: StatementType;
    Status: UpdateStatus;
    readonly TableMapping: DataTableMapping;
    CopyToRows(array: DataRow[]): void;
    CopyToRows(array: DataRow[], arrayIndex: int): void;
}


export type RowUpdatedEventArgs = RowUpdatedEventArgs$instance;

export class RowUpdatingEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping);
    Command: IDbCommand;
    Errors: Exception;
    readonly Row: DataRow;
    readonly StatementType: StatementType;
    Status: UpdateStatus;
    readonly TableMapping: DataTableMapping;
}


export type RowUpdatingEventArgs = RowUpdatingEventArgs$instance;

export abstract class DbDataReaderExtensions$instance {
    static CanGetColumnSchema(reader: DbDataReader): boolean;
    static GetColumnSchema(reader: DbDataReader): ReadOnlyCollection_1<DbColumn>;
}


export type DbDataReaderExtensions = DbDataReaderExtensions$instance;

export abstract class DbMetaDataCollectionNames$instance {
    static readonly MetaDataCollections: string;
    static readonly DataSourceInformation: string;
    static readonly DataTypes: string;
    static readonly Restrictions: string;
    static readonly ReservedWords: string;
}


export type DbMetaDataCollectionNames = DbMetaDataCollectionNames$instance;

export abstract class DbMetaDataColumnNames$instance {
    static readonly CollectionName: string;
    static readonly ColumnSize: string;
    static readonly CompositeIdentifierSeparatorPattern: string;
    static readonly CreateFormat: string;
    static readonly CreateParameters: string;
    static readonly DataSourceProductName: string;
    static readonly DataSourceProductVersion: string;
    static readonly DataType: string;
    static readonly DataSourceProductVersionNormalized: string;
    static readonly GroupByBehavior: string;
    static readonly IdentifierCase: string;
    static readonly IdentifierPattern: string;
    static readonly IsAutoIncrementable: string;
    static readonly IsBestMatch: string;
    static readonly IsCaseSensitive: string;
    static readonly IsConcurrencyType: string;
    static readonly IsFixedLength: string;
    static readonly IsFixedPrecisionScale: string;
    static readonly IsLiteralSupported: string;
    static readonly IsLong: string;
    static readonly IsNullable: string;
    static readonly IsSearchable: string;
    static readonly IsSearchableWithLike: string;
    static readonly IsUnsigned: string;
    static readonly LiteralPrefix: string;
    static readonly LiteralSuffix: string;
    static readonly MaximumScale: string;
    static readonly MinimumScale: string;
    static readonly NumberOfIdentifierParts: string;
    static readonly NumberOfRestrictions: string;
    static readonly OrderByColumnsInSelect: string;
    static readonly ParameterMarkerFormat: string;
    static readonly ParameterMarkerPattern: string;
    static readonly ParameterNameMaxLength: string;
    static readonly ParameterNamePattern: string;
    static readonly ProviderDbType: string;
    static readonly QuotedIdentifierCase: string;
    static readonly QuotedIdentifierPattern: string;
    static readonly ReservedWord: string;
    static readonly StatementSeparatorPattern: string;
    static readonly StringLiteralPattern: string;
    static readonly SupportedJoinOperators: string;
    static readonly TypeName: string;
}


export type DbMetaDataColumnNames = DbMetaDataColumnNames$instance;

export abstract class DbProviderFactories$instance {
    static GetFactory(connection: DbConnection): DbProviderFactory;
    static GetFactory(providerRow: DataRow): DbProviderFactory;
    static GetFactory(providerInvariantName: string): DbProviderFactory;
    static GetFactoryClasses(): DataTable;
    static GetProviderInvariantNames(): IEnumerable_1<CLROf<string>>;
    static RegisterFactory(providerInvariantName: string, factory: DbProviderFactory): void;
    static RegisterFactory(providerInvariantName: string, factoryTypeAssemblyQualifiedName: string): void;
    static RegisterFactory(providerInvariantName: string, providerFactoryClass: Type): void;
    static TryGetFactory(providerInvariantName: string, factory: { value: ref<DbProviderFactory> }): boolean;
    static UnregisterFactory(providerInvariantName: string): boolean;
}


export type DbProviderFactories = DbProviderFactories$instance;

export abstract class SchemaTableColumn$instance {
    static readonly ColumnName: string;
    static readonly ColumnOrdinal: string;
    static readonly ColumnSize: string;
    static readonly NumericPrecision: string;
    static readonly NumericScale: string;
    static readonly DataType: string;
    static readonly ProviderType: string;
    static readonly NonVersionedProviderType: string;
    static readonly IsLong: string;
    static readonly AllowDBNull: string;
    static readonly IsAliased: string;
    static readonly IsExpression: string;
    static readonly IsKey: string;
    static readonly IsUnique: string;
    static readonly BaseSchemaName: string;
    static readonly BaseTableName: string;
    static readonly BaseColumnName: string;
}


export type SchemaTableColumn = SchemaTableColumn$instance;

export abstract class SchemaTableOptionalColumn$instance {
    static readonly ProviderSpecificDataType: string;
    static readonly IsAutoIncrement: string;
    static readonly IsHidden: string;
    static readonly IsReadOnly: string;
    static readonly IsRowVersion: string;
    static readonly BaseServerName: string;
    static readonly BaseCatalogName: string;
    static readonly AutoIncrementSeed: string;
    static readonly AutoIncrementStep: string;
    static readonly DefaultValue: string;
    static readonly Expression: string;
    static readonly BaseTableNamespace: string;
    static readonly BaseColumnNamespace: string;
    static readonly ColumnMapping: string;
}


export type SchemaTableOptionalColumn = SchemaTableOptionalColumn$instance;

