// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Serialization
// Assembly: System.Private.Xml

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import type { StringCollection } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { CollectionBase, Hashtable, ICollection, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { ICustomAttributeProvider, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Xml_Schema_Internal from "../../System.Xml.Schema/internal/index.js";
import type { ValidationEventHandler, XmlSchema, XmlSchemaForm } from "../../System.Xml.Schema/internal/index.js";
import type { WhitespaceHandling, XmlAttribute, XmlElement, XmlNodeType, XmlQualifiedName, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Delegate, Enum, EventArgs, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, Type, TypeCode, Uri, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CodeGenerationOptions {
    None = 0,
    GenerateProperties = 1,
    GenerateNewAsync = 2,
    GenerateOldAsync = 4,
    GenerateOrder = 8,
    EnableDataBinding = 16
}


export enum XmlMappingAccess {
    None = 0,
    Read = 1,
    Write = 2
}


export interface IXmlSerializable$instance {
    GetSchema(): XmlSchema;
    ReadXml(reader: XmlReader): void;
    WriteXml(writer: XmlWriter): void;
}


export type IXmlSerializable = IXmlSerializable$instance;

export interface IXmlTextParser$instance {
    Normalized: boolean;
    WhitespaceHandling: WhitespaceHandling;
}


export type IXmlTextParser = IXmlTextParser$instance;

export class XmlDeserializationEvents$instance {
    OnUnknownAttribute: XmlAttributeEventHandler;
    OnUnknownElement: XmlElementEventHandler;
    OnUnknownNode: XmlNodeEventHandler;
    OnUnreferencedObject: UnreferencedObjectEventHandler;
}


export type XmlDeserializationEvents = XmlDeserializationEvents$instance;

export class CodeIdentifier$instance {
    constructor();
    static MakeCamel(identifier: string): string;
    static MakePascal(identifier: string): string;
    static MakeValid(identifier: string): string;
}


export type CodeIdentifier = CodeIdentifier$instance;

export class CodeIdentifiers$instance {
    constructor();
    constructor(caseSensitive: boolean);
    UseCamelCasing: boolean;
    Add(identifier: string, value: unknown): void;
    AddReserved(identifier: string): void;
    AddUnique(identifier: string, value: unknown): string;
    Clear(): void;
    IsInUse(identifier: string): boolean;
    MakeRightCase(identifier: string): string;
    MakeUnique(identifier: string): string;
    Remove(identifier: string): void;
    RemoveReserved(identifier: string): void;
    ToArray(type_: Type): unknown;
}


export type CodeIdentifiers = CodeIdentifiers$instance;

export class ImportContext$instance {
    constructor(identifiers: CodeIdentifiers, shareTypes: boolean);
    readonly ShareTypes: boolean;
    readonly TypeIdentifiers: CodeIdentifiers;
    readonly Warnings: StringCollection;
}


export type ImportContext = ImportContext$instance;

export abstract class SchemaImporter$instance {
}


export type SchemaImporter = SchemaImporter$instance;

export class SoapAttributeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(attributeName: string);
    AttributeName: string;
    DataType: string;
    Namespace: string;
}


export type SoapAttributeAttribute = SoapAttributeAttribute$instance;

export class SoapAttributeOverrides$instance {
    constructor();
    Add(type_: Type, attributes: SoapAttributes): void;
    Add(type_: Type, member: string, attributes: SoapAttributes): void;
    get_Item(type_: Type): SoapAttributes;
    get_Item(type_: Type, member: string): SoapAttributes;
}


export type SoapAttributeOverrides = SoapAttributeOverrides$instance;

export class SoapAttributes$instance {
    constructor();
    constructor(provider: ICustomAttributeProvider);
    SoapAttribute: SoapAttributeAttribute;
    SoapDefaultValue: unknown;
    SoapElement: SoapElementAttribute;
    SoapEnum: SoapEnumAttribute;
    SoapIgnore: boolean;
    SoapType: SoapTypeAttribute;
}


export type SoapAttributes = SoapAttributes$instance;

export class SoapElementAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(elementName: string);
    DataType: string;
    ElementName: string;
    IsNullable: boolean;
}


export type SoapElementAttribute = SoapElementAttribute$instance;

export class SoapEnumAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(name: string);
    Name: string;
}


export type SoapEnumAttribute = SoapEnumAttribute$instance;

export class SoapIgnoreAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type SoapIgnoreAttribute = SoapIgnoreAttribute$instance;

export class SoapIncludeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type);
    Type: Type;
}


export type SoapIncludeAttribute = SoapIncludeAttribute$instance;

export class SoapReflectionImporter$instance {
    constructor();
    constructor(defaultNamespace: string);
    constructor(attributeOverrides: SoapAttributeOverrides);
    constructor(attributeOverrides: SoapAttributeOverrides, defaultNamespace: string);
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[]): XmlMembersMapping;
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, writeAccessors: boolean): XmlMembersMapping;
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, writeAccessors: boolean, validate: boolean): XmlMembersMapping;
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, writeAccessors: boolean, validate: boolean, access: XmlMappingAccess): XmlMembersMapping;
    ImportTypeMapping(type_: Type): XmlTypeMapping;
    ImportTypeMapping(type_: Type, defaultNamespace: string): XmlTypeMapping;
    IncludeType(type_: Type): void;
    IncludeTypes(provider: ICustomAttributeProvider): void;
}


export type SoapReflectionImporter = SoapReflectionImporter$instance;

export class SoapSchemaMember$instance {
    constructor();
    MemberName: string;
    MemberType: XmlQualifiedName;
}


export type SoapSchemaMember = SoapSchemaMember$instance;

export class SoapTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(typeName: string);
    constructor(typeName: string, ns: string);
    IncludeInSchema: boolean;
    Namespace: string;
    TypeName: string;
}


export type SoapTypeAttribute = SoapTypeAttribute$instance;

export class UnreferencedObjectEventArgs$instance extends System_Internal.EventArgs$instance {
    constructor(o: unknown, id: string);
    readonly UnreferencedId: string;
    readonly UnreferencedObject: unknown;
}


export type UnreferencedObjectEventArgs = UnreferencedObjectEventArgs$instance;

export class UnreferencedObjectEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(sender: unknown, e: UnreferencedObjectEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: unknown, e: UnreferencedObjectEventArgs): void;
}


export interface __UnreferencedObjectEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnreferencedObjectEventHandler = UnreferencedObjectEventHandler$instance & __UnreferencedObjectEventHandler$views;


export class XmlAnyAttributeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type XmlAnyAttributeAttribute = XmlAnyAttributeAttribute$instance;

export class XmlAnyElementAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(name: string);
    constructor(name: string, ns: string);
    Name: string;
    Namespace: string;
    Order: int;
}


export type XmlAnyElementAttribute = XmlAnyElementAttribute$instance;

export class XmlAnyElementAttributes$instance extends System_Collections_Internal.CollectionBase$instance {
    constructor();
    Item: XmlAnyElementAttribute;
    Add(value: unknown): int;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(attribute: XmlAnyElementAttribute): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export interface __XmlAnyElementAttributes$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlAnyElementAttributes = XmlAnyElementAttributes$instance & __XmlAnyElementAttributes$views;


export class XmlArrayAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(elementName: string);
    ElementName: string;
    Form: XmlSchemaForm;
    IsNullable: boolean;
    Namespace: string;
    Order: int;
}


export type XmlArrayAttribute = XmlArrayAttribute$instance;

export class XmlArrayItemAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(elementName: string);
    constructor(type_: Type);
    constructor(elementName: string, type_: Type);
    DataType: string;
    ElementName: string;
    Form: XmlSchemaForm;
    IsNullable: boolean;
    Namespace: string;
    NestingLevel: int;
    Type: Type;
}


export type XmlArrayItemAttribute = XmlArrayItemAttribute$instance;

export class XmlArrayItemAttributes$instance extends System_Collections_Internal.CollectionBase$instance {
    constructor();
    Item: XmlArrayItemAttribute;
    Add(value: unknown): int;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(attribute: XmlArrayItemAttribute): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export interface __XmlArrayItemAttributes$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlArrayItemAttributes = XmlArrayItemAttributes$instance & __XmlArrayItemAttributes$views;


export class XmlAttributeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(attributeName: string);
    constructor(type_: Type);
    constructor(attributeName: string, type_: Type);
    AttributeName: string;
    DataType: string;
    Form: XmlSchemaForm;
    Namespace: string;
    Type: Type;
}


export type XmlAttributeAttribute = XmlAttributeAttribute$instance;

export class XmlAttributeEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly Attr: XmlAttribute;
    readonly ExpectedAttributes: string;
    readonly LineNumber: int;
    readonly LinePosition: int;
    readonly ObjectBeingDeserialized: unknown;
}


export type XmlAttributeEventArgs = XmlAttributeEventArgs$instance;

export class XmlAttributeEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(sender: unknown, e: XmlAttributeEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: unknown, e: XmlAttributeEventArgs): void;
}


export interface __XmlAttributeEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlAttributeEventHandler = XmlAttributeEventHandler$instance & __XmlAttributeEventHandler$views;


export class XmlAttributeOverrides$instance {
    constructor();
    Add(type_: Type, attributes: XmlAttributes): void;
    Add(type_: Type, member: string, attributes: XmlAttributes): void;
    get_Item(type_: Type): XmlAttributes;
    get_Item(type_: Type, member: string): XmlAttributes;
}


export type XmlAttributeOverrides = XmlAttributeOverrides$instance;

export class XmlAttributes$instance {
    constructor();
    constructor(provider: ICustomAttributeProvider);
    XmlAnyAttribute: XmlAnyAttributeAttribute;
    readonly XmlAnyElements: XmlAnyElementAttributes;
    XmlArray: XmlArrayAttribute;
    readonly XmlArrayItems: XmlArrayItemAttributes;
    XmlAttribute: XmlAttributeAttribute;
    readonly XmlChoiceIdentifier: XmlChoiceIdentifierAttribute;
    XmlDefaultValue: unknown;
    readonly XmlElements: XmlElementAttributes;
    XmlEnum: XmlEnumAttribute;
    XmlIgnore: boolean;
    Xmlns: boolean;
    XmlRoot: XmlRootAttribute;
    XmlText: XmlTextAttribute;
    XmlType: XmlTypeAttribute;
}


export type XmlAttributes = XmlAttributes$instance;

export class XmlChoiceIdentifierAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(name: string);
    MemberName: string;
}


export type XmlChoiceIdentifierAttribute = XmlChoiceIdentifierAttribute$instance;

export class XmlElementAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(elementName: string);
    constructor(type_: Type);
    constructor(elementName: string, type_: Type);
    DataType: string;
    ElementName: string;
    Form: XmlSchemaForm;
    IsNullable: boolean;
    Namespace: string;
    Order: int;
    Type: Type;
}


export type XmlElementAttribute = XmlElementAttribute$instance;

export class XmlElementAttributes$instance extends System_Collections_Internal.CollectionBase$instance {
    constructor();
    Item: XmlElementAttribute;
    Add(value: unknown): int;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(attribute: XmlElementAttribute): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export interface __XmlElementAttributes$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlElementAttributes = XmlElementAttributes$instance & __XmlElementAttributes$views;


export class XmlElementEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly Element: XmlElement;
    readonly ExpectedElements: string;
    readonly LineNumber: int;
    readonly LinePosition: int;
    readonly ObjectBeingDeserialized: unknown;
}


export type XmlElementEventArgs = XmlElementEventArgs$instance;

export class XmlElementEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(sender: unknown, e: XmlElementEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: unknown, e: XmlElementEventArgs): void;
}


export interface __XmlElementEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlElementEventHandler = XmlElementEventHandler$instance & __XmlElementEventHandler$views;


export class XmlEnumAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(name: string);
    Name: string;
}


export type XmlEnumAttribute = XmlEnumAttribute$instance;

export class XmlIgnoreAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type XmlIgnoreAttribute = XmlIgnoreAttribute$instance;

export class XmlIncludeAttribute$instance extends System_Internal.Attribute$instance {
    constructor(type_: Type);
    Type: Type;
}


export type XmlIncludeAttribute = XmlIncludeAttribute$instance;

export abstract class XmlMapping$instance {
    readonly ElementName: string;
    readonly Namespace: string;
    readonly XsdElementName: string;
    SetKey(key: string): void;
}


export type XmlMapping = XmlMapping$instance;

export class XmlMemberMapping$instance {
    readonly Any: boolean;
    readonly CheckSpecified: boolean;
    readonly ElementName: string;
    readonly MemberName: string;
    readonly Namespace: string;
    readonly TypeFullName: string;
    readonly TypeName: string;
    readonly TypeNamespace: string;
    readonly XsdElementName: string;
}


export type XmlMemberMapping = XmlMemberMapping$instance;

export class XmlMembersMapping$instance extends XmlMapping$instance {
    readonly Count: int;
    readonly Item: XmlMemberMapping;
    readonly TypeName: string;
    readonly TypeNamespace: string;
}


export type XmlMembersMapping = XmlMembersMapping$instance;

export class XmlNamespaceDeclarationsAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
}


export type XmlNamespaceDeclarationsAttribute = XmlNamespaceDeclarationsAttribute$instance;

export class XmlNodeEventArgs$instance extends System_Internal.EventArgs$instance {
    readonly LineNumber: int;
    readonly LinePosition: int;
    readonly LocalName: string;
    readonly Name: string;
    readonly NamespaceURI: string;
    readonly NodeType: XmlNodeType;
    readonly ObjectBeingDeserialized: unknown;
    readonly Text: string;
}


export type XmlNodeEventArgs = XmlNodeEventArgs$instance;

export class XmlNodeEventHandler$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(sender: unknown, e: XmlNodeEventArgs, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(sender: unknown, e: XmlNodeEventArgs): void;
}


export interface __XmlNodeEventHandler$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlNodeEventHandler = XmlNodeEventHandler$instance & __XmlNodeEventHandler$views;


export class XmlReflectionImporter$instance {
    constructor();
    constructor(defaultNamespace: string);
    constructor(attributeOverrides: XmlAttributeOverrides);
    constructor(attributeOverrides: XmlAttributeOverrides, defaultNamespace: string);
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean): XmlMembersMapping;
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, rpc: boolean): XmlMembersMapping;
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, rpc: boolean, openModel: boolean): XmlMembersMapping;
    ImportMembersMapping(elementName: string, ns: string, members: XmlReflectionMember[], hasWrapperElement: boolean, rpc: boolean, openModel: boolean, access: XmlMappingAccess): XmlMembersMapping;
    ImportTypeMapping(type_: Type): XmlTypeMapping;
    ImportTypeMapping(type_: Type, defaultNamespace: string): XmlTypeMapping;
    ImportTypeMapping(type_: Type, root: XmlRootAttribute): XmlTypeMapping;
    ImportTypeMapping(type_: Type, root: XmlRootAttribute, defaultNamespace: string): XmlTypeMapping;
    IncludeType(type_: Type): void;
    IncludeTypes(provider: ICustomAttributeProvider): void;
}


export type XmlReflectionImporter = XmlReflectionImporter$instance;

export class XmlReflectionMember$instance {
    constructor();
    IsReturnValue: boolean;
    MemberName: string;
    MemberType: Type;
    OverrideIsNullable: boolean;
    SoapAttributes: SoapAttributes;
    XmlAttributes: XmlAttributes;
}


export type XmlReflectionMember = XmlReflectionMember$instance;

export class XmlRootAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(elementName: string);
    DataType: string;
    ElementName: string;
    IsNullable: boolean;
    Namespace: string;
}


export type XmlRootAttribute = XmlRootAttribute$instance;

export class XmlSchemaEnumerator$instance implements System_Internal.IDisposable$instance {
    constructor(list: XmlSchemas);
    readonly Current: XmlSchema;
    Dispose(): void;
    MoveNext(): boolean;
}


export interface __XmlSchemaEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<XmlSchema>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaEnumerator = XmlSchemaEnumerator$instance & __XmlSchemaEnumerator$views;


export class XmlSchemaExporter$instance {
    constructor(schemas: XmlSchemas);
    ExportAnyType(ns: string): string;
    ExportAnyType(members: XmlMembersMapping): string;
    ExportMembersMapping(xmlMembersMapping: XmlMembersMapping): void;
    ExportMembersMapping(xmlMembersMapping: XmlMembersMapping, exportEnclosingType: boolean): void;
    ExportTypeMapping(xmlTypeMapping: XmlTypeMapping): void;
    ExportTypeMapping(xmlMembersMapping: XmlMembersMapping): XmlQualifiedName;
}


export type XmlSchemaExporter = XmlSchemaExporter$instance;

export class XmlSchemaImporter$instance extends SchemaImporter$instance {
    constructor(schemas: XmlSchemas);
    constructor(schemas: XmlSchemas, typeIdentifiers: CodeIdentifiers);
    ImportAnyType(typeName: XmlQualifiedName, elementName: string): XmlMembersMapping;
    ImportDerivedTypeMapping(name: XmlQualifiedName, baseType: Type): XmlTypeMapping;
    ImportDerivedTypeMapping(name: XmlQualifiedName, baseType: Type, baseTypeCanBeIndirect: boolean): XmlTypeMapping;
    ImportMembersMapping(name: XmlQualifiedName): XmlMembersMapping;
    ImportMembersMapping(names: XmlQualifiedName[]): XmlMembersMapping;
    ImportMembersMapping(names: XmlQualifiedName[], baseType: Type, baseTypeCanBeIndirect: boolean): XmlMembersMapping;
    ImportMembersMapping(name: string, ns: string, members: SoapSchemaMember[]): XmlMembersMapping;
    ImportSchemaType(typeName: XmlQualifiedName): XmlTypeMapping;
    ImportSchemaType(typeName: XmlQualifiedName, baseType: Type): XmlTypeMapping;
    ImportSchemaType(typeName: XmlQualifiedName, baseType: Type, baseTypeCanBeIndirect: boolean): XmlTypeMapping;
    ImportTypeMapping(name: XmlQualifiedName): XmlTypeMapping;
}


export type XmlSchemaImporter = XmlSchemaImporter$instance;

export class XmlSchemaProviderAttribute$instance extends System_Internal.Attribute$instance {
    constructor(methodName: string);
    IsAny: boolean;
    readonly MethodName: string;
}


export type XmlSchemaProviderAttribute = XmlSchemaProviderAttribute$instance;

export class XmlSchemas$instance extends System_Collections_Internal.CollectionBase$instance {
    constructor();
    readonly IsCompiled: boolean;
    Add(value: unknown): int;
    AddReference(schema: XmlSchema): void;
    Clear(): void;
    Compile(handler: ValidationEventHandler, fullCompile: boolean): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Find(name: XmlQualifiedName, type_: Type): unknown;
    get_Item(index: int): XmlSchema;
    get_Item(ns: string): XmlSchema;
    GetEnumerator(): IEnumerator;
    GetSchemas(ns: string): IList;
    IndexOf(schema: XmlSchema): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
    set_Item(index: int, value: XmlSchema): void;
    static IsDataSet(schema: XmlSchema): boolean;
}


export interface __XmlSchemas$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<XmlSchema>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlSchemas = XmlSchemas$instance & __XmlSchemas$views;


export class XmlSerializationCollectionFixupCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(collection: unknown, collectionItems: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(collection: unknown, collectionItems: unknown): void;
}


export interface __XmlSerializationCollectionFixupCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSerializationCollectionFixupCallback = XmlSerializationCollectionFixupCallback$instance & __XmlSerializationCollectionFixupCallback$views;


export class XmlSerializationFixupCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(fixup: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(fixup: unknown): void;
}


export interface __XmlSerializationFixupCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSerializationFixupCallback = XmlSerializationFixupCallback$instance & __XmlSerializationFixupCallback$views;


export abstract class XmlSerializationGeneratedCode$instance {
}


export type XmlSerializationGeneratedCode = XmlSerializationGeneratedCode$instance;

export class XmlSerializationReadCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(): unknown;
}


export interface __XmlSerializationReadCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSerializationReadCallback = XmlSerializationReadCallback$instance & __XmlSerializationReadCallback$views;


export abstract class XmlSerializationReader$instance extends XmlSerializationGeneratedCode$instance {
}


export type XmlSerializationReader = XmlSerializationReader$instance;

export class XmlSerializationWriteCallback$instance extends Function {
    constructor(object_: unknown, method: nint);
    BeginInvoke(o: unknown, callback: AsyncCallback, object_: unknown): IAsyncResult;
    Clone(): unknown;
    EndInvoke(result: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Invoke(o: unknown): void;
}


export interface __XmlSerializationWriteCallback$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSerializationWriteCallback = XmlSerializationWriteCallback$instance & __XmlSerializationWriteCallback$views;


export abstract class XmlSerializationWriter$instance extends XmlSerializationGeneratedCode$instance {
}


export type XmlSerializationWriter = XmlSerializationWriter$instance;

export class XmlSerializer$instance {
    constructor(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string);
    constructor(type_: Type, root: XmlRootAttribute);
    constructor(type_: Type, extraTypes: Type[]);
    constructor(type_: Type, overrides: XmlAttributeOverrides);
    constructor(xmlTypeMapping: XmlTypeMapping);
    constructor(type_: Type);
    constructor(type_: Type, defaultNamespace: string);
    constructor(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string, location: string);
    CanDeserialize(xmlReader: XmlReader): boolean;
    Deserialize(stream: Stream): unknown;
    Deserialize(textReader: TextReader): unknown;
    Deserialize(xmlReader: XmlReader): unknown;
    Deserialize(xmlReader: XmlReader, events: XmlDeserializationEvents): unknown;
    Deserialize(xmlReader: XmlReader, encodingStyle: string): unknown;
    Deserialize(xmlReader: XmlReader, encodingStyle: string, events: XmlDeserializationEvents): unknown;
    Serialize(textWriter: TextWriter, o: unknown): void;
    Serialize(textWriter: TextWriter, o: unknown, namespaces: XmlSerializerNamespaces): void;
    Serialize(stream: Stream, o: unknown): void;
    Serialize(stream: Stream, o: unknown, namespaces: XmlSerializerNamespaces): void;
    Serialize(xmlWriter: XmlWriter, o: unknown): void;
    Serialize(xmlWriter: XmlWriter, o: unknown, namespaces: XmlSerializerNamespaces): void;
    Serialize(xmlWriter: XmlWriter, o: unknown, namespaces: XmlSerializerNamespaces, encodingStyle: string): void;
    Serialize(xmlWriter: XmlWriter, o: unknown, namespaces: XmlSerializerNamespaces, encodingStyle: string, id: string): void;
    static FromMappings(mappings: XmlMapping[], type_: Type): XmlSerializer[];
    static FromMappings(mappings: XmlMapping[]): XmlSerializer[];
    static FromTypes(types: Type[]): XmlSerializer[];
    static GetXmlSerializerAssemblyName(type_: Type, defaultNamespace: string): string;
    static GetXmlSerializerAssemblyName(type_: Type): string;
}


export type XmlSerializer = XmlSerializer$instance;

export class XmlSerializerAssemblyAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(assemblyName: string);
    constructor(assemblyName: string, codeBase: string);
    AssemblyName: string;
    CodeBase: string;
}


export type XmlSerializerAssemblyAttribute = XmlSerializerAssemblyAttribute$instance;

export class XmlSerializerFactory$instance {
    constructor();
    CreateSerializer(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string): XmlSerializer;
    CreateSerializer(type_: Type, root: XmlRootAttribute): XmlSerializer;
    CreateSerializer(type_: Type, extraTypes: Type[]): XmlSerializer;
    CreateSerializer(type_: Type, overrides: XmlAttributeOverrides): XmlSerializer;
    CreateSerializer(xmlTypeMapping: XmlTypeMapping): XmlSerializer;
    CreateSerializer(type_: Type): XmlSerializer;
    CreateSerializer(type_: Type, defaultNamespace: string): XmlSerializer;
    CreateSerializer(type_: Type, overrides: XmlAttributeOverrides, extraTypes: Type[], root: XmlRootAttribute, defaultNamespace: string, location: string): XmlSerializer;
}


export type XmlSerializerFactory = XmlSerializerFactory$instance;

export abstract class XmlSerializerImplementation$instance {
    readonly Reader: XmlSerializationReader;
    readonly ReadMethods: Hashtable;
    readonly TypedSerializers: Hashtable;
    readonly WriteMethods: Hashtable;
    readonly Writer: XmlSerializationWriter;
    CanSerialize(type_: Type): boolean;
    GetSerializer(type_: Type): XmlSerializer;
}


export type XmlSerializerImplementation = XmlSerializerImplementation$instance;

export class XmlSerializerNamespaces$instance {
    constructor();
    constructor(namespaces: XmlSerializerNamespaces);
    constructor(namespaces: XmlQualifiedName[]);
    readonly Count: int;
    Add(prefix: string, ns: string): void;
    ToArray(): XmlQualifiedName[];
}


export type XmlSerializerNamespaces = XmlSerializerNamespaces$instance;

export class XmlSerializerVersionAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(type_: Type);
    Namespace: string;
    ParentAssemblyId: string;
    Type: Type;
    Version: string;
}


export type XmlSerializerVersionAttribute = XmlSerializerVersionAttribute$instance;

export class XmlTextAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(type_: Type);
    DataType: string;
    Type: Type;
}


export type XmlTextAttribute = XmlTextAttribute$instance;

export class XmlTypeAttribute$instance extends System_Internal.Attribute$instance {
    constructor();
    constructor(typeName: string);
    AnonymousType: boolean;
    IncludeInSchema: boolean;
    Namespace: string;
    TypeName: string;
}


export type XmlTypeAttribute = XmlTypeAttribute$instance;

export class XmlTypeMapping$instance extends XmlMapping$instance {
    readonly TypeFullName: string;
    readonly TypeName: string;
    readonly XsdTypeName: string;
    readonly XsdTypeNamespace: string;
}


export type XmlTypeMapping = XmlTypeMapping$instance;

