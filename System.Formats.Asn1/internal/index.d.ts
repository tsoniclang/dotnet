// Generated by tsbindgen - Architecture
// Namespace: System.Formats.Asn1
// Assembly: System.Formats.Asn1

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { BigInteger } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, Boolean as ClrBoolean, Byte, Char, DateTimeOffset, Enum, Exception, Func_2, Func_3, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, TypeCode, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

export enum AsnEncodingRules {
    BER = 0,
    CER = 1,
    DER = 2
}


export enum TagClass {
    universal = 0,
    application = 64,
    contextSpecific = 128,
    private_ = 192
}


export enum UniversalTagNumber {
    endOfContents = 0,
    boolean_ = 1,
    integer = 2,
    bitString = 3,
    octetString = 4,
    null_ = 5,
    objectIdentifier = 6,
    objectDescriptor = 7,
    external = 8,
    instanceOf = 8,
    real = 9,
    enumerated = 10,
    embedded = 11,
    utF8String = 12,
    relativeObjectIdentifier = 13,
    time = 14,
    sequence = 16,
    sequenceOf = 16,
    set_ = 17,
    setOf = 17,
    numericString = 18,
    printableString = 19,
    teletexString = 20,
    t61String = 20,
    videotexString = 21,
    iA5String = 22,
    utcTime = 23,
    generalizedTime = 24,
    graphicString = 25,
    visibleString = 26,
    isO646String = 26,
    generalString = 27,
    universalString = 28,
    unrestrictedCharacterString = 29,
    bmpString = 30,
    date = 31,
    timeOfDay = 32,
    dateTime = 33,
    duration = 34,
    objectIdentifierIRI = 35,
    relativeObjectIdentifierIRI = 36
}


export interface Asn1Tag$instance {
    readonly isConstructed: boolean;
    readonly tagClass: TagClass;
    readonly tagValue: int;
    asConstructed(): Asn1Tag;
    asPrimitive(): Asn1Tag;
    calculateEncodedSize(): int;
    encode(destination: Span_1<System_Internal.Byte>): int;
    equals(other: Asn1Tag): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    hasSameClassAndValue(other: Asn1Tag): boolean;
    toString(): string;
    tryEncode(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Asn1Tag: {
    new(universalTagNumber: UniversalTagNumber, isConstructed: boolean): Asn1Tag$instance;
    new(tagClass: TagClass, tagValue: int, isConstructed: boolean): Asn1Tag$instance;
    readonly boolean_: Asn1Tag;
    readonly integer: Asn1Tag;
    readonly primitiveBitString: Asn1Tag;
    readonly constructedBitString: Asn1Tag;
    readonly primitiveOctetString: Asn1Tag;
    readonly constructedOctetString: Asn1Tag;
    readonly null_: Asn1Tag;
    readonly objectIdentifier: Asn1Tag;
    readonly enumerated: Asn1Tag;
    readonly sequence: Asn1Tag;
    readonly setOf: Asn1Tag;
    readonly utcTime: Asn1Tag;
    readonly generalizedTime: Asn1Tag;
    decode(source: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int): Asn1Tag;
    tryDecode(source: ReadOnlySpan_1<System_Internal.Byte>, tag: Asn1Tag, bytesConsumed: int): boolean;
};


export interface __Asn1Tag$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Asn1Tag>;

    // Structural method bridges for numeric interface constraints
    equals(other: Asn1Tag): boolean;
}

export type Asn1Tag = Asn1Tag$instance & __Asn1Tag$views;


export interface AsnReaderOptions$instance {
    skipSetSortOrderVerification: boolean;
    utcTimeTwoDigitYearMax: int;
}


export const AsnReaderOptions: {
    new(): AsnReaderOptions$instance;
};


export type AsnReaderOptions = AsnReaderOptions$instance;

export interface AsnWriter_Scope$instance {
    dispose(): void;
}


export const AsnWriter_Scope: {
    new(): AsnWriter_Scope$instance;
};


export interface __AsnWriter_Scope$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AsnWriter_Scope$instance extends System_Internal.IDisposable$instance {}

export type AsnWriter_Scope = AsnWriter_Scope$instance & __AsnWriter_Scope$views;


export interface AsnContentException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AsnContentException: {
    new(): AsnContentException$instance;
    new(message: string): AsnContentException$instance;
    new(message: string, inner: Exception): AsnContentException$instance;
};


export interface __AsnContentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AsnContentException = AsnContentException$instance & __AsnContentException$views;


export interface AsnReader$instance {
    readonly hasData: boolean;
    readonly ruleSet: AsnEncodingRules;
    clone(): AsnReader;
    peekContentBytes(): ReadOnlyMemory_1<System_Internal.Byte>;
    peekEncodedValue(): ReadOnlyMemory_1<System_Internal.Byte>;
    peekTag(): Asn1Tag;
    readBitString(unusedBitCount: int, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    readBoolean(expectedTag?: Nullable_1<Asn1Tag>): boolean;
    readCharacterString(encodingType: UniversalTagNumber, expectedTag?: Nullable_1<Asn1Tag>): string;
    readEncodedValue(): ReadOnlyMemory_1<System_Internal.Byte>;
    readEnumeratedBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<System_Internal.Byte>;
    readEnumeratedValue<TEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    readEnumeratedValue(enumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    readGeneralizedTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    readInteger(expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    readIntegerBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<System_Internal.Byte>;
    readNamedBitList(expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    readNamedBitListValue<TFlagsEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    readNamedBitListValue(flagsEnumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    readNull(expectedTag?: Nullable_1<Asn1Tag>): void;
    readObjectIdentifier(expectedTag?: Nullable_1<Asn1Tag>): string;
    readOctetString(expectedTag?: Nullable_1<Asn1Tag>): byte[];
    readSequence(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    readSetOf(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    readSetOf(skipSortOrderValidation: boolean, expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    readUtcTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    readUtcTime(twoDigitYearMax: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    throwIfNotEmpty(): void;
    tryReadBitString(destination: Span_1<System_Internal.Byte>, unusedBitCount: int, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadCharacterString(destination: Span_1<System_Internal.Char>, encodingType: UniversalTagNumber, charsWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadCharacterStringBytes(destination: Span_1<System_Internal.Byte>, expectedTag: Asn1Tag, bytesWritten: int): boolean;
    tryReadInt32(value: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadInt64(value: long, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadOctetString(destination: Span_1<System_Internal.Byte>, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadPrimitiveBitString(unusedBitCount: int, value: ReadOnlyMemory_1<System_Internal.Byte>, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadPrimitiveCharacterStringBytes(expectedTag: Asn1Tag, contents: ReadOnlyMemory_1<System_Internal.Byte>): boolean;
    tryReadPrimitiveOctetString(contents: ReadOnlyMemory_1<System_Internal.Byte>, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadUInt32(value: uint, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    tryReadUInt64(value: ulong, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export const AsnReader: {
    new(data: ReadOnlyMemory_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, options: AsnReaderOptions): AsnReader$instance;
};


export type AsnReader = AsnReader$instance;

export interface AsnWriter$instance {
    readonly ruleSet: AsnEncodingRules;
    copyTo(destination: AsnWriter): void;
    encode(destination: Span_1<System_Internal.Byte>): int;
    encode(): byte[];
    encode<TReturn>(encodeCallback: Func_2<ReadOnlySpan_1<System_Internal.Byte>, TReturn>): TReturn;
    encode<TState, TReturn>(state: TState, encodeCallback: Func_3<TState, ReadOnlySpan_1<System_Internal.Byte>, TReturn>): TReturn;
    encode<TState>(state: TState, encodeCallback: Action_2<TState, ReadOnlySpan_1<System_Internal.Byte>>): void;
    encodedValueEquals(other: ReadOnlySpan_1<System_Internal.Byte>): boolean;
    encodedValueEquals(other: AsnWriter): boolean;
    getEncodedLength(): int;
    popOctetString(tag?: Nullable_1<Asn1Tag>): void;
    popSequence(tag?: Nullable_1<Asn1Tag>): void;
    popSetOf(tag?: Nullable_1<Asn1Tag>): void;
    pushOctetString(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    pushSequence(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    pushSetOf(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    reset(): void;
    tryEncode(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
    writeBitString(value: ReadOnlySpan_1<System_Internal.Byte>, unusedBitCount?: int, tag?: Nullable_1<Asn1Tag>): void;
    writeBoolean(value: boolean, tag?: Nullable_1<Asn1Tag>): void;
    writeCharacterString(encodingType: UniversalTagNumber, value: string, tag?: Nullable_1<Asn1Tag>): void;
    writeCharacterString(encodingType: UniversalTagNumber, str: ReadOnlySpan_1<System_Internal.Char>, tag?: Nullable_1<Asn1Tag>): void;
    writeEncodedValue(value: ReadOnlySpan_1<System_Internal.Byte>): void;
    writeEnumeratedValue(value: number, tag?: Nullable_1<Asn1Tag>): void;
    writeEnumeratedValue<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    writeGeneralizedTime(value: DateTimeOffset, omitFractionalSeconds?: boolean, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: long, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: ulong, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: BigInteger, tag?: Nullable_1<Asn1Tag>): void;
    writeInteger(value: ReadOnlySpan_1<System_Internal.Byte>, tag?: Nullable_1<Asn1Tag>): void;
    writeIntegerUnsigned(value: ReadOnlySpan_1<System_Internal.Byte>, tag?: Nullable_1<Asn1Tag>): void;
    writeNamedBitList(value: number, tag?: Nullable_1<Asn1Tag>): void;
    writeNamedBitList<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    writeNamedBitList(value: BitArray, tag?: Nullable_1<Asn1Tag>): void;
    writeNull(tag?: Nullable_1<Asn1Tag>): void;
    writeObjectIdentifier(oidValue: string, tag?: Nullable_1<Asn1Tag>): void;
    writeObjectIdentifier(oidValue: ReadOnlySpan_1<System_Internal.Char>, tag?: Nullable_1<Asn1Tag>): void;
    writeOctetString(value: ReadOnlySpan_1<System_Internal.Byte>, tag?: Nullable_1<Asn1Tag>): void;
    writeUtcTime(value: DateTimeOffset, tag?: Nullable_1<Asn1Tag>): void;
    writeUtcTime(value: DateTimeOffset, twoDigitYearMax: int, tag?: Nullable_1<Asn1Tag>): void;
}


export const AsnWriter: {
    new(ruleSet: AsnEncodingRules): AsnWriter$instance;
    new(ruleSet: AsnEncodingRules, initialCapacity: int): AsnWriter$instance;
};


export type AsnWriter = AsnWriter$instance;

export abstract class AsnDecoder$instance {
    static decodeLength(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int): Nullable_1<System_Internal.Int32>;
    static readBitString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, unusedBitCount: int, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static readBoolean(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static readCharacterString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): string;
    static readEncodedValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, contentOffset: int, contentLength: int, bytesConsumed: int): Asn1Tag;
    static readEnumeratedBytes(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<System_Internal.Byte>;
    static readEnumeratedValue<TEnum extends number>(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    static readEnumeratedValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, enumType: Type, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): number;
    static readGeneralizedTime(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static readInteger(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    static readIntegerBytes(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<System_Internal.Byte>;
    static readNamedBitList(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    static readNamedBitListValue<TFlagsEnum extends number>(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    static readNamedBitListValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, flagsEnumType: Type, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): number;
    static readNull(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): void;
    static readObjectIdentifier(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): string;
    static readOctetString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static readSequence(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, contentOffset: int, contentLength: int, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): void;
    static readSetOf(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, contentOffset: int, contentLength: int, bytesConsumed: int, skipSortOrderValidation?: boolean, expectedTag?: Nullable_1<Asn1Tag>): void;
    static readUtcTime(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, twoDigitYearMax?: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static tryDecodeLength(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, decodedLength: Nullable_1<System_Internal.Int32>, bytesConsumed: int): boolean;
    static tryReadBitString(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, unusedBitCount: int, bytesConsumed: int, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadCharacterString(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Char>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: int, charsWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadCharacterStringBytes(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, bytesConsumed: int, bytesWritten: int): boolean;
    static tryReadEncodedValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, tag: Asn1Tag, contentOffset: int, contentLength: int, bytesConsumed: int): boolean;
    static tryReadInt32(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: int, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadInt64(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: long, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadOctetString(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadPrimitiveBitString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, unusedBitCount: int, value: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadPrimitiveCharacterStringBytes(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, value: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int): boolean;
    static tryReadPrimitiveOctetString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadUInt32(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: uint, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static tryReadUInt64(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: ulong, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export type AsnDecoder = AsnDecoder$instance;

