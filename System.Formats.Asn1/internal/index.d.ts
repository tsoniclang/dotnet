// Generated by tsbindgen - Architecture
// Namespace: System.Formats.Asn1
// Assembly: System.Formats.Asn1

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../../_support/types.js";

// Import types from other namespaces
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { BigInteger } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, Boolean as ClrBoolean, Byte, Char, DateTimeOffset, Enum, Exception, Func_2, Func_3, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, TypeCode, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AsnEncodingRules {
    BER = 0,
    CER = 1,
    DER = 2
}


export enum TagClass {
    Universal = 0,
    Application = 64,
    ContextSpecific = 128,
    Private = 192
}


export enum UniversalTagNumber {
    EndOfContents = 0,
    Boolean = 1,
    Integer = 2,
    BitString = 3,
    OctetString = 4,
    Null = 5,
    ObjectIdentifier = 6,
    ObjectDescriptor = 7,
    External = 8,
    InstanceOf = 8,
    Real = 9,
    Enumerated = 10,
    Embedded = 11,
    UTF8String = 12,
    RelativeObjectIdentifier = 13,
    Time = 14,
    Sequence = 16,
    SequenceOf = 16,
    Set = 17,
    SetOf = 17,
    NumericString = 18,
    PrintableString = 19,
    TeletexString = 20,
    T61String = 20,
    VideotexString = 21,
    IA5String = 22,
    UtcTime = 23,
    GeneralizedTime = 24,
    GraphicString = 25,
    VisibleString = 26,
    ISO646String = 26,
    GeneralString = 27,
    UniversalString = 28,
    UnrestrictedCharacterString = 29,
    BMPString = 30,
    Date = 31,
    TimeOfDay = 32,
    DateTime = 33,
    Duration = 34,
    ObjectIdentifierIRI = 35,
    RelativeObjectIdentifierIRI = 36
}


export class Asn1Tag$instance {
    constructor(universalTagNumber: UniversalTagNumber, isConstructed: boolean);
    constructor(tagClass: TagClass, tagValue: int, isConstructed: boolean);
    readonly IsConstructed: boolean;
    readonly TagClass: TagClass;
    readonly TagValue: int;
    AsConstructed(): Asn1Tag;
    AsPrimitive(): Asn1Tag;
    CalculateEncodedSize(): int;
    Encode(destination: Span_1<CLROf<byte>>): int;
    Equals(other: Asn1Tag): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): int;
    HasSameClassAndValue(other: Asn1Tag): boolean;
    ToString(): string;
    TryEncode(destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    static readonly Boolean: Asn1Tag;
    static readonly Integer: Asn1Tag;
    static readonly PrimitiveBitString: Asn1Tag;
    static readonly ConstructedBitString: Asn1Tag;
    static readonly PrimitiveOctetString: Asn1Tag;
    static readonly ConstructedOctetString: Asn1Tag;
    static readonly Null: Asn1Tag;
    static readonly ObjectIdentifier: Asn1Tag;
    static readonly Enumerated: Asn1Tag;
    static readonly Sequence: Asn1Tag;
    static readonly SetOf: Asn1Tag;
    static readonly UtcTime: Asn1Tag;
    static readonly GeneralizedTime: Asn1Tag;
    static Decode(source: ReadOnlySpan_1<CLROf<byte>>, bytesConsumed: { value: TSByRef<int> }): Asn1Tag;
    static TryDecode(source: ReadOnlySpan_1<CLROf<byte>>, tag: { value: TSByRef<Asn1Tag> }, bytesConsumed: { value: TSByRef<int> }): boolean;
}


export interface __Asn1Tag$views {
    readonly As_IEquatable_1_of_ConsoleKeyInfo: System_Internal.IEquatable_1$instance<Asn1Tag>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Asn1Tag): boolean;
}

export type Asn1Tag = Asn1Tag$instance & __Asn1Tag$views;


export class AsnReaderOptions$instance {
    SkipSetSortOrderVerification: boolean;
    UtcTimeTwoDigitYearMax: int;
}


export type AsnReaderOptions = AsnReaderOptions$instance;

export class AsnWriter_Scope$instance {
    Dispose(): void;
}


export interface __AsnWriter_Scope$views {
    readonly As_IDisposable: System_Internal.IDisposable$instance;
}

export type AsnWriter_Scope = AsnWriter_Scope$instance & __AsnWriter_Scope$views;


export class AsnContentException$instance extends System_Internal.Exception$instance {
    constructor();
    constructor(message: string);
    constructor(message: string, inner: Exception);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export interface __AsnContentException$views {
    readonly As_ISerializable: System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AsnContentException = AsnContentException$instance & __AsnContentException$views;


export class AsnReader$instance {
    constructor(data: ReadOnlyMemory_1<CLROf<byte>>, ruleSet: AsnEncodingRules, options: AsnReaderOptions);
    readonly HasData: boolean;
    readonly RuleSet: AsnEncodingRules;
    Clone(): AsnReader;
    PeekContentBytes(): ReadOnlyMemory_1<CLROf<byte>>;
    PeekEncodedValue(): ReadOnlyMemory_1<CLROf<byte>>;
    PeekTag(): Asn1Tag;
    ReadBitString(unusedBitCount: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    ReadBoolean(expectedTag?: Nullable_1<Asn1Tag>): boolean;
    ReadCharacterString(encodingType: UniversalTagNumber, expectedTag?: Nullable_1<Asn1Tag>): string;
    ReadEncodedValue(): ReadOnlyMemory_1<CLROf<byte>>;
    ReadEnumeratedBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<CLROf<byte>>;
    ReadEnumeratedValue<TEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    ReadEnumeratedValue(enumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    ReadGeneralizedTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    ReadInteger(expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    ReadIntegerBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<CLROf<byte>>;
    ReadNamedBitList(expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    ReadNamedBitListValue<TFlagsEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    ReadNamedBitListValue(flagsEnumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    ReadNull(expectedTag?: Nullable_1<Asn1Tag>): void;
    ReadObjectIdentifier(expectedTag?: Nullable_1<Asn1Tag>): string;
    ReadOctetString(expectedTag?: Nullable_1<Asn1Tag>): byte[];
    ReadSequence(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    ReadSetOf(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    ReadSetOf(skipSortOrderValidation: boolean, expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    ReadUtcTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    ReadUtcTime(twoDigitYearMax: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    ThrowIfNotEmpty(): void;
    TryReadBitString(destination: Span_1<CLROf<byte>>, unusedBitCount: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadCharacterString(destination: Span_1<CLROf<string>>, encodingType: UniversalTagNumber, charsWritten: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadCharacterStringBytes(destination: Span_1<CLROf<byte>>, expectedTag: Asn1Tag, bytesWritten: { value: TSByRef<int> }): boolean;
    TryReadInt32(value: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadInt64(value: { value: TSByRef<long> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadOctetString(destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadPrimitiveBitString(unusedBitCount: { value: TSByRef<int> }, value: { value: TSByRef<ReadOnlyMemory_1<CLROf<byte>>> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadPrimitiveCharacterStringBytes(expectedTag: Asn1Tag, contents: { value: TSByRef<ReadOnlyMemory_1<CLROf<byte>>> }): boolean;
    TryReadPrimitiveOctetString(contents: { value: TSByRef<ReadOnlyMemory_1<CLROf<byte>>> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadUInt32(value: { value: TSByRef<uint> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadUInt64(value: { value: TSByRef<ulong> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export type AsnReader = AsnReader$instance;

export class AsnWriter$instance {
    constructor(ruleSet: AsnEncodingRules);
    constructor(ruleSet: AsnEncodingRules, initialCapacity: int);
    readonly RuleSet: AsnEncodingRules;
    CopyTo(destination: AsnWriter): void;
    Encode(destination: Span_1<CLROf<byte>>): int;
    Encode(): byte[];
    Encode<TReturn>(encodeCallback: Func_2<ReadOnlySpan_1<CLROf<byte>>, TReturn>): TReturn;
    Encode<TState, TReturn>(state: TState, encodeCallback: Func_3<TState, ReadOnlySpan_1<CLROf<byte>>, TReturn>): TReturn;
    Encode<TState>(state: TState, encodeCallback: Action_2<TState, ReadOnlySpan_1<CLROf<byte>>>): void;
    EncodedValueEquals(other: ReadOnlySpan_1<CLROf<byte>>): boolean;
    EncodedValueEquals(other: AsnWriter): boolean;
    GetEncodedLength(): int;
    PopOctetString(tag?: Nullable_1<Asn1Tag>): void;
    PopSequence(tag?: Nullable_1<Asn1Tag>): void;
    PopSetOf(tag?: Nullable_1<Asn1Tag>): void;
    PushOctetString(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    PushSequence(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    PushSetOf(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    Reset(): void;
    TryEncode(destination: Span_1<CLROf<byte>>, bytesWritten: { value: TSByRef<int> }): boolean;
    WriteBitString(value: ReadOnlySpan_1<CLROf<byte>>, unusedBitCount?: int, tag?: Nullable_1<Asn1Tag>): void;
    WriteBoolean(value: boolean, tag?: Nullable_1<Asn1Tag>): void;
    WriteCharacterString(encodingType: UniversalTagNumber, value: string, tag?: Nullable_1<Asn1Tag>): void;
    WriteCharacterString(encodingType: UniversalTagNumber, str: ReadOnlySpan_1<CLROf<string>>, tag?: Nullable_1<Asn1Tag>): void;
    WriteEncodedValue(value: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteEnumeratedValue(value: number, tag?: Nullable_1<Asn1Tag>): void;
    WriteEnumeratedValue<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    WriteGeneralizedTime(value: DateTimeOffset, omitFractionalSeconds?: boolean, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: long, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: ulong, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: BigInteger, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: ReadOnlySpan_1<CLROf<byte>>, tag?: Nullable_1<Asn1Tag>): void;
    WriteIntegerUnsigned(value: ReadOnlySpan_1<CLROf<byte>>, tag?: Nullable_1<Asn1Tag>): void;
    WriteNamedBitList(value: number, tag?: Nullable_1<Asn1Tag>): void;
    WriteNamedBitList<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    WriteNamedBitList(value: BitArray, tag?: Nullable_1<Asn1Tag>): void;
    WriteNull(tag?: Nullable_1<Asn1Tag>): void;
    WriteObjectIdentifier(oidValue: string, tag?: Nullable_1<Asn1Tag>): void;
    WriteObjectIdentifier(oidValue: ReadOnlySpan_1<CLROf<string>>, tag?: Nullable_1<Asn1Tag>): void;
    WriteOctetString(value: ReadOnlySpan_1<CLROf<byte>>, tag?: Nullable_1<Asn1Tag>): void;
    WriteUtcTime(value: DateTimeOffset, tag?: Nullable_1<Asn1Tag>): void;
    WriteUtcTime(value: DateTimeOffset, twoDigitYearMax: int, tag?: Nullable_1<Asn1Tag>): void;
}


export type AsnWriter = AsnWriter$instance;

export abstract class AsnDecoder$instance {
    static DecodeLength(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }): Nullable_1<CLROf<int>>;
    static ReadBitString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, unusedBitCount: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static ReadBoolean(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static ReadCharacterString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): string;
    static ReadEncodedValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, contentOffset: { value: TSByRef<int> }, contentLength: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }): Asn1Tag;
    static ReadEnumeratedBytes(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<CLROf<byte>>;
    static ReadEnumeratedValue<TEnum extends number>(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    static ReadEnumeratedValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, enumType: Type, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): number;
    static ReadGeneralizedTime(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static ReadInteger(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    static ReadIntegerBytes(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<CLROf<byte>>;
    static ReadNamedBitList(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    static ReadNamedBitListValue<TFlagsEnum extends number>(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    static ReadNamedBitListValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, flagsEnumType: Type, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): number;
    static ReadNull(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): void;
    static ReadObjectIdentifier(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): string;
    static ReadOctetString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static ReadSequence(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, contentOffset: { value: TSByRef<int> }, contentLength: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): void;
    static ReadSetOf(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, contentOffset: { value: TSByRef<int> }, contentLength: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }, skipSortOrderValidation?: boolean, expectedTag?: Nullable_1<Asn1Tag>): void;
    static ReadUtcTime(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, twoDigitYearMax?: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static TryDecodeLength(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, decodedLength: { value: TSByRef<Nullable_1<CLROf<int>>> }, bytesConsumed: { value: TSByRef<int> }): boolean;
    static TryReadBitString(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, ruleSet: AsnEncodingRules, unusedBitCount: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadCharacterString(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<string>>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: { value: TSByRef<int> }, charsWritten: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadCharacterStringBytes(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, bytesConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }): boolean;
    static TryReadEncodedValue(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, tag: { value: TSByRef<Asn1Tag> }, contentOffset: { value: TSByRef<int> }, contentLength: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }): boolean;
    static TryReadInt32(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: TSByRef<int> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadInt64(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: TSByRef<long> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadOctetString(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, ruleSet: AsnEncodingRules, bytesConsumed: { value: TSByRef<int> }, bytesWritten: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadPrimitiveBitString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, unusedBitCount: { value: TSByRef<int> }, value: { value: TSByRef<ReadOnlySpan_1<CLROf<byte>>> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadPrimitiveCharacterStringBytes(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, value: { value: TSByRef<ReadOnlySpan_1<CLROf<byte>>> }, bytesConsumed: { value: TSByRef<int> }): boolean;
    static TryReadPrimitiveOctetString(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: TSByRef<ReadOnlySpan_1<CLROf<byte>>> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadUInt32(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: TSByRef<uint> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadUInt64(source: ReadOnlySpan_1<CLROf<byte>>, ruleSet: AsnEncodingRules, value: { value: TSByRef<ulong> }, bytesConsumed: { value: TSByRef<int> }, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export type AsnDecoder = AsnDecoder$instance;

